diff --git a/configure b/configure
index 7fb356797e..9fafab4d65 100755
--- a/configure
+++ b/configure
@@ -19680,32 +19680,6 @@ _ACEOF
 fi
 
 
-ac_fn_c_check_member "$LINENO" "struct sysinfo" "totalram" "ac_cv_member_struct_sysinfo_totalram" "#ifdef HAVE_SYS_SYSINFO_H
-# include <sys/sysinfo.h>
-#endif
-"
-if test "x$ac_cv_member_struct_sysinfo_totalram" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SYSINFO_TOTALRAM 1
-_ACEOF
-
-
-fi
-ac_fn_c_check_member "$LINENO" "struct sysinfo" "mem_unit" "ac_cv_member_struct_sysinfo_mem_unit" "#ifdef HAVE_SYS_SYSINFO_H
-# include <sys/sysinfo.h>
-#endif
-"
-if test "x$ac_cv_member_struct_sysinfo_mem_unit" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SYSINFO_MEM_UNIT 1
-_ACEOF
-
-
-fi
-
-
 ac_save_LIBS="$LIBS"
 LIBS="$LIBS -lm"
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for isfinite" >&5
diff --git a/configure.ac b/configure.ac
index 13adf2da7e..cb6aa45723 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2672,12 +2672,6 @@ AC_CHECK_MEMBERS([struct ifreq.ifr_hwaddr],,,
 # include <net/if.h>
 #endif])
 
-dnl Check for struct sysinfo members totalram and mem_unit
-AC_CHECK_MEMBERS([struct sysinfo.totalram, struct sysinfo.mem_unit],,,
-[#ifdef HAVE_SYS_SYSINFO_H
-# include <sys/sysinfo.h>
-#endif])
-
 dnl Check for isfinite
 ac_save_LIBS="$LIBS"
 LIBS="$LIBS -lm"
diff --git a/dlls/dbgeng/dbgeng.c b/dlls/dbgeng/dbgeng.c
index f24b04d086..35796dd8a7 100644
--- a/dlls/dbgeng/dbgeng.c
+++ b/dlls/dbgeng/dbgeng.c
@@ -36,6 +36,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dbgeng);
 
+extern NTSTATUS WINAPI NtSuspendProcess(HANDLE handle);
+extern NTSTATUS WINAPI NtResumeProcess(HANDLE handle);
+
 struct module_info
 {
     DEBUG_MODULE_PARAMETERS params;
diff --git a/dlls/dinput/device_private.h b/dlls/dinput/device_private.h
index 2fac4f0e61..fe5644f21c 100644
--- a/dlls/dinput/device_private.h
+++ b/dlls/dinput/device_private.h
@@ -69,9 +69,6 @@ struct IDirectInputDeviceImpl
     HWND                        win;
     int                         acquired;
 
-    BOOL                        use_raw_input; /* use raw input instead of low-level messages */
-    RAWINPUTDEVICE              raw_device;    /* raw device to (un)register */
-
     LPDIDEVICEOBJECTDATA        data_queue;  /* buffer for 'GetDeviceData'.                 */
     int                         queue_len;   /* valid size of the queue                     */
     int                         queue_head;  /* position to write new event into queue      */
diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
index 45023fc104..2e56150240 100644
--- a/dlls/dinput/dinput_main.c
+++ b/dlls/dinput/dinput_main.c
@@ -97,14 +97,10 @@ static const struct dinput_device *dinput_devices[] =
 
 HINSTANCE DINPUT_instance;
 
-static const WCHAR di_em_win_w[] = {'D','I','E','m','W','i','n',0};
-static HWND di_em_win;
-
 static BOOL check_hook_thread(void);
 static CRITICAL_SECTION dinput_hook_crit;
 static struct list direct_input_list = LIST_INIT( direct_input_list );
 static struct list acquired_mouse_list = LIST_INIT( acquired_mouse_list );
-static struct list acquired_rawmouse_list = LIST_INIT( acquired_rawmouse_list );
 static struct list acquired_keyboard_list = LIST_INIT( acquired_keyboard_list );
 static struct list acquired_device_list = LIST_INIT( acquired_device_list );
 
@@ -117,7 +113,7 @@ void dinput_hooks_acquire_device(LPDIRECTINPUTDEVICE8W iface)
 
     EnterCriticalSection( &dinput_hook_crit );
     if (IsEqualGUID( &dev->guid, &GUID_SysMouse ))
-        list_add_tail( dev->use_raw_input ? &acquired_rawmouse_list : &acquired_mouse_list, &dev->entry );
+        list_add_tail( &acquired_mouse_list, &dev->entry );
     else if (IsEqualGUID( &dev->guid, &GUID_SysKeyboard ))
         list_add_tail( &acquired_keyboard_list, &dev->entry );
     else
@@ -641,52 +637,6 @@ static HRESULT WINAPI IDirectInputWImpl_QueryInterface(LPDIRECTINPUT7W iface, RE
     return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
 }
 
-static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
-{
-    IDirectInputDeviceImpl *dev;
-    RAWINPUT ri;
-    UINT size = sizeof(ri);
-    int rim = GET_RAWINPUT_CODE_WPARAM( wparam );
-
-    TRACE( "%p %d %lx %lx\n", hwnd, msg, wparam, lparam );
-
-    if (msg == WM_INPUT && (rim == RIM_INPUT || rim == RIM_INPUTSINK))
-    {
-        size = GetRawInputData( (HRAWINPUT)lparam, RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER) );
-        if (size == (UINT)-1 || size < sizeof(RAWINPUTHEADER))
-            WARN( "Unable to read raw input data\n" );
-        else if (ri.header.dwType == RIM_TYPEMOUSE)
-        {
-            EnterCriticalSection( &dinput_hook_crit );
-            LIST_FOR_EACH_ENTRY( dev, &acquired_rawmouse_list, IDirectInputDeviceImpl, entry )
-                dinput_mouse_rawinput_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam, &ri );
-            LeaveCriticalSection( &dinput_hook_crit );
-        }
-    }
-
-    return DefWindowProcW( hwnd, msg, wparam, lparam );
-}
-
-static void register_di_em_win_class(void)
-{
-    WNDCLASSEXW class;
-
-    memset(&class, 0, sizeof(class));
-    class.cbSize = sizeof(class);
-    class.lpfnWndProc = di_em_win_wndproc;
-    class.hInstance = DINPUT_instance;
-    class.lpszClassName = di_em_win_w;
-
-    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
-        WARN( "Unable to register message window class\n" );
-}
-
-static void unregister_di_em_win_class(void)
-{
-    if (!UnregisterClassW( di_em_win_w, NULL ) && GetLastError() != ERROR_CLASS_DOES_NOT_EXIST)
-        WARN( "Unable to unregister message window class\n" );
-}
-
 static HRESULT initialize_directinput_instance(IDirectInputImpl *This, DWORD dwVersion)
 {
     if (!This->initialized)
@@ -1723,7 +1673,6 @@ static LRESULT CALLBACK LL_hook_proc( int code, WPARAM wparam, LPARAM lparam )
     }
     LIST_FOR_EACH_ENTRY( dev, &acquired_keyboard_list, IDirectInputDeviceImpl, entry )
     {
-        if (dev->use_raw_input) continue;
         TRACE("calling dinput_keyboard_hook (%p %lx %lx)\n", dev, wparam, lparam);
         skip |= dinput_keyboard_hook( &dev->IDirectInputDevice8A_iface, wparam, lparam );
     }
@@ -1761,14 +1710,6 @@ static LRESULT CALLBACK callwndproc_proc( int code, WPARAM wparam, LPARAM lparam
             IDirectInputDevice_Unacquire( &dev->IDirectInputDevice8A_iface );
         }
     }
-    LIST_FOR_EACH_ENTRY_SAFE( dev, next, &acquired_rawmouse_list, IDirectInputDeviceImpl, entry )
-    {
-        if (msg->hwnd == dev->win && msg->hwnd != foreground)
-        {
-            TRACE( "%p window is not foreground - unacquiring %p\n", dev->win, dev );
-            IDirectInputDevice_Unacquire( &dev->IDirectInputDevice8A_iface );
-        }
-    }
     LIST_FOR_EACH_ENTRY_SAFE( dev, next, &acquired_keyboard_list, IDirectInputDeviceImpl, entry )
     {
         if (msg->hwnd == dev->win && msg->hwnd != foreground)
@@ -1787,9 +1728,6 @@ static DWORD WINAPI hook_thread_proc(void *param)
     static HHOOK kbd_hook, mouse_hook;
     MSG msg;
 
-    di_em_win = CreateWindowW( di_em_win_w, di_em_win_w, 0, 0, 0, 0, 0,
-                               HWND_MESSAGE, 0, DINPUT_instance, NULL );
-
     /* Force creation of the message queue */
     PeekMessageW( &msg, 0, 0, 0, PM_NOREMOVE );
     SetEvent(param);
@@ -1840,9 +1778,6 @@ static DWORD WINAPI hook_thread_proc(void *param)
         DispatchMessageW(&msg);
     }
 
-    DestroyWindow( di_em_win );
-    di_em_win = NULL;
-
     FreeLibraryAndExitThread(DINPUT_instance, 0);
 }
 
@@ -1925,31 +1860,6 @@ void check_dinput_hooks(LPDIRECTINPUTDEVICE8W iface, BOOL acquired)
         hook_thread_event = NULL;
     }
 
-    if (dev->use_raw_input)
-    {
-        if (acquired)
-        {
-            dev->raw_device.dwFlags = 0;
-            if (dev->dwCoopLevel & DISCL_BACKGROUND)
-                dev->raw_device.dwFlags |= RIDEV_INPUTSINK;
-            if (dev->dwCoopLevel & DISCL_EXCLUSIVE)
-                dev->raw_device.dwFlags |= RIDEV_NOLEGACY;
-            if ((dev->dwCoopLevel & DISCL_EXCLUSIVE) && dev->raw_device.usUsage == 2)
-                dev->raw_device.dwFlags |= RIDEV_CAPTUREMOUSE;
-            if ((dev->dwCoopLevel & DISCL_EXCLUSIVE) && dev->raw_device.usUsage == 6)
-                dev->raw_device.dwFlags |= RIDEV_NOHOTKEYS;
-            dev->raw_device.hwndTarget = di_em_win;
-        }
-        else
-        {
-            dev->raw_device.dwFlags = RIDEV_REMOVE;
-            dev->raw_device.hwndTarget = NULL;
-        }
-
-        if (!RegisterRawInputDevices( &dev->raw_device, 1, sizeof(RAWINPUTDEVICE) ))
-            WARN( "Unable to (un)register raw device %x:%x\n", dev->raw_device.usUsagePage, dev->raw_device.usUsage );
-    }
-
     if (acquired)
         hook_change_finished_event = CreateEventW( NULL, FALSE, FALSE, NULL );
     PostThreadMessageW( hook_thread_id, WM_USER+0x10, 1, (LPARAM)hook_change_finished_event );
@@ -1984,11 +1894,9 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
       case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls(inst);
         DINPUT_instance = inst;
-        register_di_em_win_class();
         break;
       case DLL_PROCESS_DETACH:
         if (reserved) break;
-        unregister_di_em_win_class();
         DeleteCriticalSection(&dinput_hook_crit);
         break;
     }
diff --git a/dlls/dinput/dinput_private.h b/dlls/dinput/dinput_private.h
index c0c88da967..06a439d6a4 100644
--- a/dlls/dinput/dinput_private.h
+++ b/dlls/dinput/dinput_private.h
@@ -73,7 +73,6 @@ extern void dinput_hooks_acquire_device(LPDIRECTINPUTDEVICE8W iface);
 extern void dinput_hooks_unacquire_device(LPDIRECTINPUTDEVICE8W iface);
 extern int dinput_mouse_hook(LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam);
 extern int dinput_keyboard_hook(LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam);
-extern void dinput_mouse_rawinput_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam, RAWINPUT *raw );
 
 extern void check_dinput_hooks(LPDIRECTINPUTDEVICE8W, BOOL) DECLSPEC_HIDDEN;
 extern void check_dinput_events(void) DECLSPEC_HIDDEN;
diff --git a/dlls/dinput/mouse.c b/dlls/dinput/mouse.c
index e50731fda4..5e6f34f0ec 100644
--- a/dlls/dinput/mouse.c
+++ b/dlls/dinput/mouse.c
@@ -239,13 +239,6 @@ static SysMouseImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput)
     newDevice->base.data_format.wine_df = df;
     IDirectInput_AddRef(&newDevice->base.dinput->IDirectInput7A_iface);
 
-    if (dinput->dwVersion >= 0x0800)
-    {
-        newDevice->base.use_raw_input = TRUE;
-        newDevice->base.raw_device.usUsagePage = 1; /* HID generic device page */
-        newDevice->base.raw_device.usUsage = 2; /* HID generic mouse */
-    }
-
     return newDevice;
 
 failed:
@@ -313,89 +306,6 @@ const struct dinput_device mouse_device = {
  *	SysMouseA (DInput Mouse support)
  */
 
-void dinput_mouse_rawinput_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam, RAWINPUT *ri )
-{
-    SysMouseImpl* This = impl_from_IDirectInputDevice8A( iface );
-    POINT rel, pt;
-    DWORD seq;
-    int i, wdata = 0;
-
-    static const USHORT mouse_button_flags[] =
-    {
-        RI_MOUSE_BUTTON_1_DOWN, RI_MOUSE_BUTTON_1_UP,
-        RI_MOUSE_BUTTON_2_DOWN, RI_MOUSE_BUTTON_2_UP,
-        RI_MOUSE_BUTTON_3_DOWN, RI_MOUSE_BUTTON_3_UP,
-        RI_MOUSE_BUTTON_4_DOWN, RI_MOUSE_BUTTON_4_UP,
-        RI_MOUSE_BUTTON_5_DOWN, RI_MOUSE_BUTTON_5_UP
-    };
-
-    TRACE( "(%p) wp %08lx, lp %08lx\n", iface, wparam, lparam );
-
-    if (ri->data.mouse.usFlags & MOUSE_VIRTUAL_DESKTOP)
-        FIXME( "Unimplemented MOUSE_VIRTUAL_DESKTOP flag\n" );
-    if (ri->data.mouse.usFlags & MOUSE_ATTRIBUTES_CHANGED)
-        FIXME( "Unimplemented MOUSE_ATTRIBUTES_CHANGED flag\n" );
-
-    EnterCriticalSection( &This->base.crit );
-    seq = This->base.dinput->evsequence++;
-
-    rel.x = ri->data.mouse.lLastX;
-    rel.y = ri->data.mouse.lLastY;
-    if (ri->data.mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
-    {
-        GetCursorPos( &pt );
-        rel.x -= pt.x;
-        rel.y -= pt.y;
-    }
-
-    This->m_state.lX += rel.x;
-    This->m_state.lY += rel.y;
-
-    if (This->base.data_format.user_df->dwFlags & DIDF_ABSAXIS)
-    {
-        pt.x = This->m_state.lX;
-        pt.y = This->m_state.lY;
-    }
-    else
-    {
-        pt = rel;
-    }
-
-    if (rel.x)
-        queue_event( iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_X_AXIS_INSTANCE) | DIDFT_RELAXIS,
-                     pt.x, GetCurrentTime(), seq );
-
-    if (rel.y)
-        queue_event( iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Y_AXIS_INSTANCE) | DIDFT_RELAXIS,
-                     pt.y, GetCurrentTime(), seq );
-
-    if (rel.x || rel.y)
-    {
-        if ((This->warp_override == WARP_FORCE_ON) ||
-            (This->warp_override != WARP_DISABLE && (This->base.dwCoopLevel & DISCL_EXCLUSIVE)))
-            This->need_warp = TRUE;
-    }
-
-    if (ri->data.mouse.usButtonFlags & RI_MOUSE_WHEEL)
-    {
-        This->m_state.lZ += (wdata = (SHORT)ri->data.mouse.usButtonData);
-        queue_event( iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_Z_AXIS_INSTANCE) | DIDFT_RELAXIS,
-                     wdata, GetCurrentTime(), seq );
-    }
-
-    for (i = 0; i < ARRAY_SIZE(mouse_button_flags); ++i)
-    {
-        if (ri->data.mouse.usButtonFlags & mouse_button_flags[i])
-        {
-            This->m_state.rgbButtons[i / 2] = 0x80 - (i % 2) * 0x80;
-            queue_event( iface, DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE +(i / 2) ) | DIDFT_PSHBUTTON,
-                         This->m_state.rgbButtons[i / 2], GetCurrentTime(), seq );
-        }
-    }
-
-    LeaveCriticalSection( &This->base.crit );
-}
-
 /* low-level mouse hook */
 int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam )
 {
diff --git a/dlls/dinput8/tests/device.c b/dlls/dinput8/tests/device.c
index 80a7fe26c3..88ccf6c2e1 100644
--- a/dlls/dinput8/tests/device.c
+++ b/dlls/dinput8/tests/device.c
@@ -602,6 +602,7 @@ static void test_mouse_keyboard(void)
 
     raw_devices_count = ARRAY_SIZE(raw_devices);
     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+    todo_wine
     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
 
     hr = IDirectInputDevice8_Acquire(di_keyboard);
@@ -623,6 +624,7 @@ static void test_mouse_keyboard(void)
     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
     raw_devices_count = ARRAY_SIZE(raw_devices);
     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+    todo_wine
     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
 
     if (raw_devices[0].hwndTarget != NULL)
@@ -646,9 +648,13 @@ static void test_mouse_keyboard(void)
     raw_devices_count = ARRAY_SIZE(raw_devices);
     memset(raw_devices, 0, sizeof(raw_devices));
     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+    todo_wine
     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+    todo_wine
     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+    todo_wine
     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
+    todo_wine
     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
     todo_wine
     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
@@ -656,11 +662,9 @@ static void test_mouse_keyboard(void)
     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %08x\n", hr);
     raw_devices_count = ARRAY_SIZE(raw_devices);
     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+    todo_wine
     ok(raw_devices_count == 0, "Unexpected raw devices registered: %d\n", raw_devices_count);
 
-    if (raw_devices[0].hwndTarget != NULL)
-        di_hwnd = raw_devices[0].hwndTarget;
-
     /* expect dinput8 to take over any activated raw input devices */
     raw_devices[0].usUsagePage = 0x01;
     raw_devices[0].usUsage = 0x05;
@@ -685,16 +689,26 @@ static void test_mouse_keyboard(void)
     raw_devices_count = ARRAY_SIZE(raw_devices);
     memset(raw_devices, 0, sizeof(raw_devices));
     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+    todo_wine
     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+    todo_wine
     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+    todo_wine
     ok(raw_devices[0].usUsage == 2, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
+    todo_wine
     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+    todo_wine
     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
+    todo_wine
     ok(raw_devices[1].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
+    todo_wine
     ok(raw_devices[1].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
     ok(raw_devices[1].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
+    todo_wine
     ok(raw_devices[1].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[1].hwndTarget);
+    todo_wine
     ok(raw_devices[2].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[1].usUsagePage);
+    todo_wine
     ok(raw_devices[2].usUsage == 6, "Unexpected raw device usage: %x\n", raw_devices[1].usUsage);
     todo_wine
     ok(raw_devices[2].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
@@ -720,6 +734,7 @@ static void test_mouse_keyboard(void)
     memset(raw_devices, 0, sizeof(raw_devices));
     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
     ok(hr == 3, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+    todo_wine
     ok(raw_devices[0].dwFlags == (RIDEV_CAPTUREMOUSE|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
     todo_wine
     ok(raw_devices[2].dwFlags == (RIDEV_NOHOTKEYS|RIDEV_NOLEGACY), "Unexpected raw device flags: %x\n", raw_devices[1].dwFlags);
@@ -732,9 +747,12 @@ static void test_mouse_keyboard(void)
     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
     todo_wine
     ok(hr == 1, "GetRegisteredRawInputDevices returned %d, raw_devices_count: %d\n", hr, raw_devices_count);
+    todo_wine
     ok(raw_devices[0].usUsagePage == 1, "Unexpected raw device usage page: %x\n", raw_devices[0].usUsagePage);
+    todo_wine
     ok(raw_devices[0].usUsage == 5, "Unexpected raw device usage: %x\n", raw_devices[0].usUsage);
     ok(raw_devices[0].dwFlags == 0, "Unexpected raw device flags: %x\n", raw_devices[0].dwFlags);
+    todo_wine
     ok(raw_devices[0].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
 
     IDirectInputDevice8_Release(di_mouse);
diff --git a/dlls/kernel32/console.c b/dlls/kernel32/console.c
index 44df9463da..315a9186ab 100644
--- a/dlls/kernel32/console.c
+++ b/dlls/kernel32/console.c
@@ -54,7 +54,6 @@
 #include "winnls.h"
 #include "winerror.h"
 #include "wincon.h"
-#include "wine/condrv.h"
 #include "wine/server.h"
 #include "wine/exception.h"
 #include "wine/unicode.h"
@@ -176,7 +175,9 @@ static BOOL restore_console_mode(HANDLE hin)
         close(fd);
     }
 
-    TERM_Exit();
+    if (RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle == KERNEL32_CONSOLE_SHELL)
+        TERM_Exit();
+
     return ret;
 }
 
@@ -187,14 +188,18 @@ static BOOL restore_console_mode(HANDLE hin)
  *   Success: hwnd of the console window.
  *   Failure: NULL
  */
-HWND WINAPI GetConsoleWindow(void)
+HWND WINAPI GetConsoleWindow(VOID)
 {
-    struct condrv_input_info info;
-    BOOL ret;
+    HWND hWnd = NULL;
+
+    SERVER_START_REQ(get_console_input_info)
+    {
+        req->handle = 0;
+        if (!wine_server_call_err(req)) hWnd = wine_server_ptr_handle( reply->win );
+    }
+    SERVER_END_REQ;
 
-    ret = DeviceIoControl( RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle,
-                           IOCTL_CONDRV_GET_INPUT_INFO, NULL, 0, &info, sizeof(info), NULL, NULL );
-    return ret ? (HWND)info.win : NULL;
+    return hWnd;
 }
 
 
@@ -219,21 +224,39 @@ BOOL WINAPI Beep( DWORD dwFreq, DWORD dwDur )
  */
 HANDLE WINAPI OpenConsoleW(LPCWSTR name, DWORD access, BOOL inherit, DWORD creation)
 {
-    SECURITY_ATTRIBUTES sa;
+    HANDLE      output = INVALID_HANDLE_VALUE;
+    HANDLE      ret;
 
     TRACE("(%s, 0x%08x, %d, %u)\n", debugstr_w(name), access, inherit, creation);
 
-    if (!name || (strcmpiW( coninW, name ) && strcmpiW( conoutW, name )) || creation != OPEN_EXISTING)
+    if (name)
+    {
+        if (strcmpiW(coninW, name) == 0)
+            output = (HANDLE) FALSE;
+        else if (strcmpiW(conoutW, name) == 0)
+            output = (HANDLE) TRUE;
+    }
+
+    if (output == INVALID_HANDLE_VALUE || creation != OPEN_EXISTING)
     {
-        SetLastError( ERROR_INVALID_PARAMETER );
+        SetLastError(ERROR_INVALID_PARAMETER);
         return INVALID_HANDLE_VALUE;
     }
 
-    sa.nLength = sizeof(sa);
-    sa.lpSecurityDescriptor = NULL;
-    sa.bInheritHandle = inherit;
+    SERVER_START_REQ( open_console )
+    {
+        req->from       = wine_server_obj_handle( output );
+        req->access     = access;
+        req->attributes = inherit ? OBJ_INHERIT : 0;
+        req->share      = FILE_SHARE_READ | FILE_SHARE_WRITE;
+        wine_server_call_err( req );
+        ret = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    if (ret)
+        ret = console_handle_map(ret);
 
-    return CreateFileW( name, access, FILE_SHARE_READ | FILE_SHARE_WRITE, &sa, creation, 0, NULL );
+    return ret;
 }
 
 /******************************************************************
@@ -243,10 +266,16 @@ HANDLE WINAPI OpenConsoleW(LPCWSTR name, DWORD access, BOOL inherit, DWORD creat
  */
 BOOL WINAPI VerifyConsoleIoHandle(HANDLE handle)
 {
-    IO_STATUS_BLOCK io;
-    DWORD mode;
-    return !NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io, IOCTL_CONDRV_GET_MODE,
-                                   NULL, 0, &mode, sizeof(mode) );
+    BOOL ret;
+
+    if (!is_console_handle(handle)) return FALSE;
+    SERVER_START_REQ(get_console_mode)
+    {
+	req->handle = console_handle_unmap(handle);
+	ret = !wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 /******************************************************************
@@ -398,8 +427,6 @@ static enum read_console_input_return read_console_input(HANDLE handle, PINPUT_R
 {
     int fd;
     enum read_console_input_return      ret;
-    int blocking = timeout != 0;
-    DWORD read_bytes;
 
     if ((fd = get_console_bare_fd(handle)) != -1)
     {
@@ -412,10 +439,25 @@ static enum read_console_input_return read_console_input(HANDLE handle, PINPUT_R
         close(fd);
         if (ret != rci_gotone) return ret;
     }
+    else
+    {
+        if (!VerifyConsoleIoHandle(handle)) return rci_error;
+
+        if (WaitForSingleObject(handle, timeout) != WAIT_OBJECT_0)
+            return rci_timeout;
+    }
 
-    if (!DeviceIoControl( handle, IOCTL_CONDRV_READ_INPUT, &blocking, sizeof(blocking), ir, sizeof(*ir), &read_bytes, NULL ))
-        return rci_error;
-    return read_bytes ? rci_gotone : rci_timeout;
+    SERVER_START_REQ( read_console_input )
+    {
+        req->handle = console_handle_unmap(handle);
+        req->flush = TRUE;
+        wine_server_set_reply( req, ir, sizeof(INPUT_RECORD) );
+        if (wine_server_call_err( req ) || !reply->read) ret = rci_error;
+        else ret = rci_gotone;
+    }
+    SERVER_END_REQ;
+
+    return ret;
 }
 
 
@@ -644,30 +686,64 @@ BOOL WINAPI GetNumberOfConsoleMouseButtons(LPDWORD nrofbuttons)
     return TRUE;
 }
 
+/******************************************************************
+ *		CONSOLE_HandleCtrlC
+ *
+ * Check whether the shall manipulate CtrlC events
+ */
+LONG CALLBACK CONSOLE_HandleCtrlC( EXCEPTION_POINTERS *eptr )
+{
+    extern DWORD WINAPI CtrlRoutine( void *arg );
+    HANDLE thread;
+
+    if (eptr->ExceptionRecord->ExceptionCode != CONTROL_C_EXIT) return EXCEPTION_CONTINUE_SEARCH;
+
+    /* FIXME: better test whether a console is attached to this process ??? */
+    if (CONSOLE_GetNumHistoryEntries() == (unsigned)-1) return EXCEPTION_CONTINUE_SEARCH;
+
+    /* check if we have to ignore ctrl-C events */
+    if (!(NtCurrentTeb()->Peb->ProcessParameters->ConsoleFlags & 1))
+    {
+        /* Create a separate thread to signal all the events. 
+         * This is needed because:
+         *  - this function can be called in an Unix signal handler (hence on an
+         *    different stack than the thread that's running). This breaks the 
+         *    Win32 exception mechanisms (where the thread's stack is checked).
+         *  - since the current thread, while processing the signal, can hold the
+         *    console critical section, we need another execution environment where
+         *    we can wait on this critical section 
+         */
+        thread = CreateThread(NULL, 0, CtrlRoutine, (void*)CTRL_C_EVENT, 0, NULL);
+        if (thread) CloseHandle(thread);
+    }
+    return EXCEPTION_CONTINUE_EXECUTION;
+}
+
 /******************************************************************
  *		CONSOLE_WriteChars
  *
  * WriteConsoleOutput helper: hides server call semantics
  * writes a string at a given pos with standard attribute
  */
-static int CONSOLE_WriteChars(HANDLE handle, const WCHAR *str, size_t length, COORD *coord)
-{
-    struct condrv_output_params *params;
-    DWORD written = 0, size;
-
-    if (!length) return 0;
-
-    size = sizeof(*params) + length * sizeof(WCHAR);
-    if (!(params = HeapAlloc( GetProcessHeap(), 0, size ))) return FALSE;
-    params->mode   = CHAR_INFO_MODE_TEXTSTDATTR;
-    params->x      = coord->X;
-    params->y      = coord->Y;
-    params->width  = 0;
-    memcpy( params + 1, str, length * sizeof(*str) );
-    if (DeviceIoControl( handle, IOCTL_CONDRV_WRITE_OUTPUT, params, size,
-                         &written, sizeof(written), NULL, NULL ))
-        coord->X += written;
-    HeapFree( GetProcessHeap(), 0, params );
+static int CONSOLE_WriteChars(HANDLE hCon, LPCWSTR lpBuffer, int nc, COORD* pos)
+{
+    int written = -1;
+
+    if (!nc) return 0;
+
+    SERVER_START_REQ( write_console_output )
+    {
+        req->handle = console_handle_unmap(hCon);
+        req->x      = pos->X;
+        req->y      = pos->Y;
+        req->mode   = CHAR_INFO_MODE_TEXTSTDATTR;
+        req->wrap   = FALSE;
+        wine_server_add_data( req, lpBuffer, nc * sizeof(WCHAR) );
+        if (!wine_server_call_err( req )) written = reply->written;
+    }
+    SERVER_END_REQ;
+
+    if (written > 0) pos->X += written;
     return written;
 }
 
@@ -907,16 +983,19 @@ BOOL WINAPI WriteConsoleW(HANDLE hConsoleOutput, LPCVOID lpBuffer, DWORD nNumber
  */
 void CONSOLE_FillLineUniform(HANDLE hConsoleOutput, int i, int j, int len, LPCHAR_INFO lpFill)
 {
-    struct condrv_fill_output_params params;
-
-    params.mode  = CHAR_INFO_MODE_TEXTATTR;
-    params.x     = i;
-    params.y     = j;
-    params.count = len;
-    params.wrap  = FALSE;
-    params.ch    = lpFill->Char.UnicodeChar;
-    params.attr  = lpFill->Attributes;
-    DeviceIoControl( hConsoleOutput, IOCTL_CONDRV_FILL_OUTPUT, &params, sizeof(params), NULL, 0, NULL, NULL );
+    SERVER_START_REQ( fill_console_output )
+    {
+        req->handle    = console_handle_unmap(hConsoleOutput);
+        req->mode      = CHAR_INFO_MODE_TEXTATTR;
+        req->x         = i;
+        req->y         = j;
+        req->count     = len;
+        req->wrap      = FALSE;
+        req->data.ch   = lpFill->Char.UnicodeChar;
+        req->data.attr = lpFill->Attributes;
+        wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
 }
 
 /******************************************************************
@@ -1009,11 +1088,16 @@ BOOL	CONSOLE_AppendHistory(const WCHAR* ptr)
  *
  *
  */
-unsigned CONSOLE_GetNumHistoryEntries(HANDLE console)
+unsigned CONSOLE_GetNumHistoryEntries(void)
 {
-    struct condrv_input_info info;
-    BOOL ret = DeviceIoControl( console, IOCTL_CONDRV_GET_INPUT_INFO, NULL, 0, &info, sizeof(info), NULL, NULL );
-    return ret ? info.history_index : ~0;
+    unsigned ret = -1;
+    SERVER_START_REQ(get_console_input_info)
+    {
+        req->handle = 0;
+        if (!wine_server_call_err( req )) ret = reply->history_index;
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 /******************************************************************
@@ -1023,9 +1107,15 @@ unsigned CONSOLE_GetNumHistoryEntries(HANDLE console)
  */
 BOOL CONSOLE_GetEditionMode(HANDLE hConIn, int* mode)
 {
-    struct condrv_input_info info;
-    return DeviceIoControl( hConIn, IOCTL_CONDRV_GET_INPUT_INFO, NULL, 0, &info, sizeof(info), NULL, NULL )
-        ? info.edition_mode : 0;
+    unsigned ret = 0;
+    SERVER_START_REQ(get_console_input_info)
+    {
+        req->handle = console_handle_unmap(hConIn);
+        if ((ret = !wine_server_call_err( req )))
+            *mode = reply->edition_mode;
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 /******************************************************************
@@ -1065,7 +1155,7 @@ BOOL CONSOLE_Init(RTL_USER_PROCESS_PARAMETERS *params)
     memset(&S_termios, 0, sizeof(S_termios));
     if (params->ConsoleHandle == KERNEL32_CONSOLE_SHELL)
     {
-        HANDLE  conin, console;
+        HANDLE  conin;
 
         /* FIXME: to be done even if program is a GUI ? */
         /* This is wine specific: we have no parent (we're started from unix)
@@ -1118,8 +1208,6 @@ BOOL CONSOLE_Init(RTL_USER_PROCESS_PARAMETERS *params)
             }
             SERVER_END_REQ;
         }
-        console = CreateFileW( coninW, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, 0, NULL, OPEN_EXISTING, 0, 0 );
-        if (console != INVALID_HANDLE_VALUE) params->ConsoleHandle = console;
     }
 
     /* convert value from server:
@@ -1129,7 +1217,7 @@ BOOL CONSOLE_Init(RTL_USER_PROCESS_PARAMETERS *params)
      */
     if (!params->hStdInput || params->hStdInput == INVALID_HANDLE_VALUE)
         params->hStdInput = 0;
-    else if (VerifyConsoleIoHandle(params->hStdInput))
+    else if (VerifyConsoleIoHandle(console_handle_map(params->hStdInput)))
     {
         params->hStdInput = console_handle_map(params->hStdInput);
         save_console_mode(params->hStdInput);
@@ -1137,12 +1225,12 @@ BOOL CONSOLE_Init(RTL_USER_PROCESS_PARAMETERS *params)
 
     if (!params->hStdOutput || params->hStdOutput == INVALID_HANDLE_VALUE)
         params->hStdOutput = 0;
-    else if (VerifyConsoleIoHandle(params->hStdOutput))
+    else if (VerifyConsoleIoHandle(console_handle_map(params->hStdOutput)))
         params->hStdOutput = console_handle_map(params->hStdOutput);
 
     if (!params->hStdError || params->hStdError == INVALID_HANDLE_VALUE)
         params->hStdError = 0;
-    else if (VerifyConsoleIoHandle(params->hStdError))
+    else if (VerifyConsoleIoHandle(console_handle_map(params->hStdError)))
         params->hStdError = console_handle_map(params->hStdError);
 
     return TRUE;
@@ -1274,11 +1362,11 @@ BOOL WINAPI SetConsoleKeyShortcuts(BOOL set, BYTE keys, VOID *a, DWORD b)
 
 BOOL WINAPI GetCurrentConsoleFontEx(HANDLE hConsole, BOOL maxwindow, CONSOLE_FONT_INFOEX *fontinfo)
 {
-    DWORD size;
+    BOOL ret;
     struct
     {
-        struct condrv_output_info info;
-        WCHAR face_name[LF_FACESIZE - 1];
+        unsigned int color_map[16];
+        WCHAR face_name[LF_FACESIZE];
     } data;
 
     if (fontinfo->cbSize != sizeof(CONSOLE_FONT_INFOEX))
@@ -1287,30 +1375,37 @@ BOOL WINAPI GetCurrentConsoleFontEx(HANDLE hConsole, BOOL maxwindow, CONSOLE_FON
         return FALSE;
     }
 
-    if (!DeviceIoControl( hConsole, IOCTL_CONDRV_GET_OUTPUT_INFO, NULL, 0,
-                          &data, sizeof(data), &size, NULL ))
-    {
-        SetLastError( ERROR_INVALID_HANDLE );
-        return FALSE;
-    }
-
-    fontinfo->nFont = 0;
-    if (maxwindow)
-    {
-        fontinfo->dwFontSize.X = min( data.info.width, data.info.max_width );
-        fontinfo->dwFontSize.Y = min( data.info.height, data.info.max_height );
-    }
-    else
+    SERVER_START_REQ(get_console_output_info)
     {
-        fontinfo->dwFontSize.X = data.info.win_right - data.info.win_left + 1;
-        fontinfo->dwFontSize.Y = data.info.win_bottom - data.info.win_top + 1;
+        req->handle = console_handle_unmap(hConsole);
+        wine_server_set_reply( req, &data, sizeof(data) - sizeof(WCHAR) );
+        if ((ret = !wine_server_call_err(req)))
+        {
+            fontinfo->nFont = 0;
+            if (maxwindow)
+            {
+                fontinfo->dwFontSize.X = min(reply->width, reply->max_width);
+                fontinfo->dwFontSize.Y = min(reply->height, reply->max_height);
+            }
+            else
+            {
+                fontinfo->dwFontSize.X = reply->win_right - reply->win_left + 1;
+                fontinfo->dwFontSize.Y = reply->win_bottom - reply->win_top + 1;
+            }
+            if (wine_server_reply_size( reply ) > sizeof(data.color_map))
+            {
+                data_size_t len = wine_server_reply_size( reply ) - sizeof(data.color_map);
+                memcpy( fontinfo->FaceName, data.face_name, len );
+                fontinfo->FaceName[len / sizeof(WCHAR)] = 0;
+            }
+            else
+                fontinfo->FaceName[0] = 0;
+            fontinfo->FontFamily = reply->font_pitch_family;
+            fontinfo->FontWeight = reply->font_weight;
+        }
     }
-    size -= sizeof(data.info);
-    if (size) memcpy( fontinfo->FaceName, data.face_name, size );
-    fontinfo->FaceName[size / sizeof(WCHAR)] = 0;
-    fontinfo->FontFamily = data.info.font_pitch_family;
-    fontinfo->FontWeight = data.info.font_weight;
-    return TRUE;
+    SERVER_END_REQ;
+    return ret;
 }
 
 BOOL WINAPI GetCurrentConsoleFont(HANDLE hConsole, BOOL maxwindow, CONSOLE_FONT_INFO *fontinfo)
@@ -1332,7 +1427,6 @@ BOOL WINAPI GetCurrentConsoleFont(HANDLE hConsole, BOOL maxwindow, CONSOLE_FONT_
 
 static COORD get_console_font_size(HANDLE hConsole, DWORD index)
 {
-    struct condrv_output_info info;
     COORD c = {0,0};
 
     if (index >= GetNumberOfConsoleFonts())
@@ -1341,12 +1435,16 @@ static COORD get_console_font_size(HANDLE hConsole, DWORD index)
         return c;
     }
 
-    if (DeviceIoControl( hConsole, IOCTL_CONDRV_GET_OUTPUT_INFO, NULL, 0, &info, sizeof(info), NULL, NULL ))
+    SERVER_START_REQ(get_console_output_info)
     {
-        c.X = info.font_width;
-        c.Y = info.font_height;
+        req->handle = console_handle_unmap(hConsole);
+        if (!wine_server_call_err(req))
+        {
+            c.X = reply->font_width;
+            c.Y = reply->font_height;
+        }
     }
-    else SetLastError( ERROR_INVALID_HANDLE );
+    SERVER_END_REQ;
     return c;
 }
 
diff --git a/dlls/kernel32/console_private.h b/dlls/kernel32/console_private.h
index b0fd2acd92..2943d48a60 100644
--- a/dlls/kernel32/console_private.h
+++ b/dlls/kernel32/console_private.h
@@ -22,9 +22,10 @@
 #define __WINE_CONSOLE_PRIVATE_H
 
 /* console.c */
+extern LONG CALLBACK CONSOLE_HandleCtrlC( EXCEPTION_POINTERS *eptr ) DECLSPEC_HIDDEN;
 extern int      CONSOLE_GetHistory(int idx, WCHAR* buf, int buf_len) DECLSPEC_HIDDEN;
 extern BOOL     CONSOLE_AppendHistory(const WCHAR *p) DECLSPEC_HIDDEN;
-extern unsigned CONSOLE_GetNumHistoryEntries(HANDLE) DECLSPEC_HIDDEN;
+extern unsigned CONSOLE_GetNumHistoryEntries(void) DECLSPEC_HIDDEN;
 extern void     CONSOLE_FillLineUniform(HANDLE hConsoleOutput, int i, int j, int len, LPCHAR_INFO lpFill) DECLSPEC_HIDDEN;
 extern BOOL     CONSOLE_GetEditionMode(HANDLE, int*) DECLSPEC_HIDDEN;
 
diff --git a/dlls/kernel32/editline.c b/dlls/kernel32/editline.c
index 38bc475754..489960aba6 100644
--- a/dlls/kernel32/editline.c
+++ b/dlls/kernel32/editline.c
@@ -408,7 +408,7 @@ static WCHAR* WCEL_GetHistory(WCEL_Context* ctx, int idx)
 
 static void	WCEL_HistoryInit(WCEL_Context* ctx)
 {
-    ctx->histPos  = CONSOLE_GetNumHistoryEntries(ctx->hConIn);
+    ctx->histPos  = CONSOLE_GetNumHistoryEntries();
     ctx->histSize = ctx->histPos + 1;
     ctx->histCurr = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WCHAR));
 }
diff --git a/dlls/kernel32/file.c b/dlls/kernel32/file.c
index 949be6c303..29dd5791af 100644
--- a/dlls/kernel32/file.c
+++ b/dlls/kernel32/file.c
@@ -92,6 +92,73 @@ static HANDLE create_file_OF( LPCSTR path, INT mode )
 }
 
 
+/***********************************************************************
+ *           FILE_SetDosError
+ *
+ * Set the DOS error code from errno.
+ */
+void FILE_SetDosError(void)
+{
+    int save_errno = errno; /* errno gets overwritten by printf */
+
+    TRACE("errno = %d %s\n", errno, strerror(errno));
+    switch (save_errno)
+    {
+    case EAGAIN:
+        SetLastError( ERROR_SHARING_VIOLATION );
+        break;
+    case EBADF:
+        SetLastError( ERROR_INVALID_HANDLE );
+        break;
+    case ENOSPC:
+        SetLastError( ERROR_HANDLE_DISK_FULL );
+        break;
+    case EACCES:
+    case EPERM:
+    case EROFS:
+        SetLastError( ERROR_ACCESS_DENIED );
+        break;
+    case EBUSY:
+        SetLastError( ERROR_LOCK_VIOLATION );
+        break;
+    case ENOENT:
+        SetLastError( ERROR_FILE_NOT_FOUND );
+        break;
+    case EISDIR:
+        SetLastError( ERROR_CANNOT_MAKE );
+        break;
+    case ENFILE:
+    case EMFILE:
+        SetLastError( ERROR_TOO_MANY_OPEN_FILES );
+        break;
+    case EEXIST:
+        SetLastError( ERROR_FILE_EXISTS );
+        break;
+    case EINVAL:
+    case ESPIPE:
+        SetLastError( ERROR_SEEK );
+        break;
+    case ENOTEMPTY:
+        SetLastError( ERROR_DIR_NOT_EMPTY );
+        break;
+    case ENOEXEC:
+        SetLastError( ERROR_BAD_FORMAT );
+        break;
+    case ENOTDIR:
+        SetLastError( ERROR_PATH_NOT_FOUND );
+        break;
+    case EXDEV:
+        SetLastError( ERROR_NOT_SAME_DEVICE );
+        break;
+    default:
+        WARN("unknown file error: %s\n", strerror(save_errno) );
+        SetLastError( ERROR_GEN_FAILURE );
+        break;
+    }
+    errno = save_errno;
+}
+
+
 /***********************************************************************
  *           FILE_name_AtoW
  *
diff --git a/dlls/kernel32/heap.c b/dlls/kernel32/heap.c
index dc1a3cd72c..6c5219b624 100644
--- a/dlls/kernel32/heap.c
+++ b/dlls/kernel32/heap.c
@@ -333,10 +333,10 @@ SIZE_T WINAPI GlobalSize(HGLOBAL hmem)
    {
       retval=HeapSize(GetProcessHeap(), 0, hmem);
 
-      if (retval == ~(SIZE_T)0) /* It might be a GMEM_MOVEABLE data pointer */
+      if (retval == ~0ul) /* It might be a GMEM_MOVEABLE data pointer */
       {
           retval = HeapSize(GetProcessHeap(), 0, (char*)hmem - HGLOBAL_STORAGE);
-          if (retval != ~(SIZE_T)0) retval -= HGLOBAL_STORAGE;
+          if (retval != ~0ul) retval -= HGLOBAL_STORAGE;
       }
    }
    else
@@ -351,7 +351,7 @@ SIZE_T WINAPI GlobalSize(HGLOBAL hmem)
          else
          {
              retval = HeapSize(GetProcessHeap(), 0, (char *)pintern->Pointer - HGLOBAL_STORAGE );
-             if (retval != ~(SIZE_T)0) retval -= HGLOBAL_STORAGE;
+             if (retval != ~0ul) retval -= HGLOBAL_STORAGE;
          }
       }
       else
@@ -362,7 +362,7 @@ SIZE_T WINAPI GlobalSize(HGLOBAL hmem)
       }
       RtlUnlockHeap(GetProcessHeap());
    }
-   if (retval == ~(SIZE_T)0) retval = 0;
+   if (retval == ~0ul) retval = 0;
    return retval;
 }
 
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 8d4776c21e..41d2d1ff73 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -1270,8 +1270,8 @@
 @ stdcall ReleaseSemaphoreWhenCallbackReturns(ptr long long) ntdll.TpCallbackReleaseSemaphoreOnCompletion
 @ stdcall ReleaseSRWLockExclusive(ptr) ntdll.RtlReleaseSRWLockExclusive
 @ stdcall ReleaseSRWLockShared(ptr) ntdll.RtlReleaseSRWLockShared
-@ stdcall -import RemoveDirectoryA(str)
-@ stdcall -import RemoveDirectoryW(wstr)
+@ stdcall RemoveDirectoryA(str)
+@ stdcall RemoveDirectoryW(wstr)
 # @ stub RemoveLocalAlternateComputerNameA
 # @ stub RemoveLocalAlternateComputerNameW
 @ stdcall RemoveVectoredContinueHandler(ptr) ntdll.RtlRemoveVectoredContinueHandler
diff --git a/dlls/kernel32/kernel_main.c b/dlls/kernel32/kernel_main.c
index e856cc3af4..f7f87d2a70 100644
--- a/dlls/kernel32/kernel_main.c
+++ b/dlls/kernel32/kernel_main.c
@@ -147,10 +147,12 @@ static BOOL process_attach( HMODULE module )
             LoadLibraryA( "krnl386.exe16" );
     }
 
+    /* finish the process initialisation for console bits, if needed */
+    RtlAddVectoredExceptionHandler( FALSE, CONSOLE_HandleCtrlC );
+
     if (params->ConsoleHandle == KERNEL32_CONSOLE_ALLOC)
     {
         HMODULE mod = GetModuleHandleA(0);
-        params->ConsoleHandle = NULL;
         if (RtlImageNtHeader(mod)->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)
             AllocConsole();
     }
diff --git a/dlls/kernel32/kernel_private.h b/dlls/kernel32/kernel_private.h
index 2a0e524748..bcf2ee9a52 100644
--- a/dlls/kernel32/kernel_private.h
+++ b/dlls/kernel32/kernel_private.h
@@ -60,6 +60,7 @@ extern SYSTEM_BASIC_INFORMATION system_info DECLSPEC_HIDDEN;
 extern const WCHAR DIR_Windows[] DECLSPEC_HIDDEN;
 extern const WCHAR DIR_System[] DECLSPEC_HIDDEN;
 
+extern void FILE_SetDosError(void) DECLSPEC_HIDDEN;
 extern WCHAR *FILE_name_AtoW( LPCSTR name, BOOL alloc ) DECLSPEC_HIDDEN;
 extern DWORD FILE_name_WtoA( LPCWSTR src, INT srclen, LPSTR dest, INT destlen ) DECLSPEC_HIDDEN;
 
diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
index 5377c2302b..0f075d0af1 100644
--- a/dlls/kernel32/path.c
+++ b/dlls/kernel32/path.c
@@ -228,6 +228,68 @@ BOOL WINAPI CreateDirectoryExA( LPCSTR template, LPCSTR path, LPSECURITY_ATTRIBU
 }
 
 
+/***********************************************************************
+ *           RemoveDirectoryW   (KERNEL32.@)
+ */
+BOOL WINAPI RemoveDirectoryW( LPCWSTR path )
+{
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING nt_name;
+    ANSI_STRING unix_name;
+    IO_STATUS_BLOCK io;
+    NTSTATUS status;
+    HANDLE handle;
+    BOOL ret = FALSE;
+
+    TRACE( "%s\n", debugstr_w(path) );
+
+    if (!RtlDosPathNameToNtPathName_U( path, &nt_name, NULL, NULL ))
+    {
+        SetLastError( ERROR_PATH_NOT_FOUND );
+        return FALSE;
+    }
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.ObjectName = &nt_name;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if (!set_ntstatus( NtOpenFile( &handle, DELETE | SYNCHRONIZE, &attr, &io,
+                                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+                                   FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT )))
+    {
+        RtlFreeUnicodeString( &nt_name );
+        return FALSE;
+    }
+
+    status = wine_nt_to_unix_file_name( &nt_name, &unix_name, FILE_OPEN, FALSE );
+    RtlFreeUnicodeString( &nt_name );
+    if (!set_ntstatus( status ))
+    {
+        NtClose( handle );
+        return FALSE;
+    }
+
+    if (!(ret = (rmdir( unix_name.Buffer ) != -1))) FILE_SetDosError();
+    RtlFreeAnsiString( &unix_name );
+    NtClose( handle );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           RemoveDirectoryA   (KERNEL32.@)
+ */
+BOOL WINAPI RemoveDirectoryA( LPCSTR path )
+{
+    WCHAR *pathW;
+
+    if (!(pathW = FILE_name_AtoW( path, FALSE ))) return FALSE;
+    return RemoveDirectoryW( pathW );
+}
+
+
 /***********************************************************************
  *           GetSystemDirectoryW   (KERNEL32.@)
  *
@@ -276,30 +338,18 @@ DWORD /*BOOLEAN*/ WINAPI KERNEL32_Wow64EnableWow64FsRedirection( BOOLEAN enable
 char * CDECL wine_get_unix_file_name( LPCWSTR dosW )
 {
     UNICODE_STRING nt_name;
+    ANSI_STRING unix_name;
     NTSTATUS status;
-    SIZE_T size = 256;
-    char *buffer;
 
     if (!RtlDosPathNameToNtPathName_U( dosW, &nt_name, NULL, NULL )) return NULL;
-    for (;;)
-    {
-        if (!(buffer = HeapAlloc( GetProcessHeap(), 0, size )))
-        {
-            RtlFreeUnicodeString( &nt_name );
-            return NULL;
-        }
-        status = wine_nt_to_unix_file_name( &nt_name, buffer, &size, FILE_OPEN_IF );
-        if (status != STATUS_BUFFER_TOO_SMALL) break;
-        HeapFree( GetProcessHeap(), 0, buffer );
-    }
+    status = wine_nt_to_unix_file_name( &nt_name, &unix_name, FILE_OPEN_IF, FALSE );
     RtlFreeUnicodeString( &nt_name );
     if (status && status != STATUS_NO_SUCH_FILE)
     {
-        HeapFree( GetProcessHeap(), 0, buffer );
         SetLastError( RtlNtStatusToDosError( status ) );
         return NULL;
     }
-    return buffer;
+    return unix_name.Buffer;
 }
 
 
@@ -312,38 +362,22 @@ char * CDECL wine_get_unix_file_name( LPCWSTR dosW )
 WCHAR * CDECL wine_get_dos_file_name( LPCSTR str )
 {
     UNICODE_STRING nt_name;
-    NTSTATUS status;
-    WCHAR *buffer;
-    SIZE_T len = strlen(str) + 1;
+    ANSI_STRING unix_name;
+    DWORD len;
 
-    if (str[0] != '/')  /* relative path name */
-    {
-        if (!(buffer = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) ))) return NULL;
-        MultiByteToWideChar( CP_UNIXCP, 0, str, len, buffer, len );
-        status = RtlDosPathNameToNtPathName_U_WithStatus( buffer, &nt_name, NULL, NULL );
-        RtlFreeHeap( GetProcessHeap(), 0, buffer );
-        if (!set_ntstatus( status )) return NULL;
-        buffer = nt_name.Buffer;
-        len = nt_name.Length / sizeof(WCHAR) + 1;
-    }
-    else
-    {
-        len += 8;  /* \??\unix prefix */
-        if (!(buffer = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) ))) return NULL;
-        if (!set_ntstatus( wine_unix_to_nt_file_name( str, buffer, &len )))
-        {
-            HeapFree( GetProcessHeap(), 0, buffer );
-            return NULL;
-        }
-    }
-    if (buffer[5] == ':')
+    RtlInitAnsiString( &unix_name, str );
+    if (!set_ntstatus( wine_unix_to_nt_file_name( &unix_name, &nt_name ))) return NULL;
+    if (nt_name.Buffer[5] == ':')
     {
         /* get rid of the \??\ prefix */
         /* FIXME: should implement RtlNtPathNameToDosPathName and use that instead */
-        memmove( buffer, buffer + 4, (len - 4) * sizeof(WCHAR) );
+        len = nt_name.Length - 4 * sizeof(WCHAR);
+        memmove( nt_name.Buffer, nt_name.Buffer + 4, len );
+        nt_name.Buffer[len / sizeof(WCHAR)] = 0;
     }
-    else buffer[1] = '\\';
-    return buffer;
+    else
+        nt_name.Buffer[1] = '\\';
+    return nt_name.Buffer;
 }
 
 /*************************************************************************
diff --git a/dlls/kernel32/profile.c b/dlls/kernel32/profile.c
index bfaba6cdeb..2cf0819023 100644
--- a/dlls/kernel32/profile.c
+++ b/dlls/kernel32/profile.c
@@ -29,9 +29,7 @@
 #include "winbase.h"
 #include "winnls.h"
 #include "winerror.h"
-#include "winreg.h"
 #include "winternl.h"
-#include "shlwapi.h"
 #include "wine/unicode.h"
 #include "wine/library.h"
 #include "wine/debug.h"
@@ -1018,312 +1016,6 @@ static BOOL PROFILE_SetString( LPCWSTR section_name, LPCWSTR key_name,
     return TRUE;
 }
 
-static HKEY open_file_mapping_key( const WCHAR *filename )
-{
-    static const WCHAR mapping_pathW[] = {'S','o','f','t','w','a','r','e',
-            '\\','M','i','c','r','o','s','o','f','t',
-            '\\','W','i','n','d','o','w','s',' ','N','T',
-            '\\','C','u','r','r','e','n','t','V','e','r','s','i','o','n',
-            '\\','I','n','i','F','i','l','e','M','a','p','p','i','n','g',0};
-    static HKEY mapping_key;
-    HKEY key;
-
-    EnterCriticalSection( &PROFILE_CritSect );
-
-    if (!mapping_key && RegOpenKeyExW( HKEY_LOCAL_MACHINE, mapping_pathW, 0, KEY_WOW64_64KEY, &mapping_key ))
-        mapping_key = NULL;
-
-    LeaveCriticalSection( &PROFILE_CritSect );
-
-    if (mapping_key && !RegOpenKeyExW( mapping_key, PathFindFileNameW( filename ), 0, KEY_READ, &key ))
-        return key;
-    return NULL;
-}
-
-static WCHAR *enum_key( HKEY key, DWORD i )
-{
-    WCHAR *value, *new_value;
-    DWORD max = 256, len;
-    LSTATUS res;
-
-    if (!(value = HeapAlloc( GetProcessHeap(), 0, max * sizeof(WCHAR) ))) return NULL;
-    len = max;
-    while ((res = RegEnumValueW( key, i, value, &len, NULL, NULL, NULL, NULL )) == ERROR_MORE_DATA)
-    {
-        max *= 2;
-        if (!(new_value = HeapReAlloc( GetProcessHeap(), 0, value, max * sizeof(WCHAR) )))
-        {
-            HeapFree( GetProcessHeap(), 0, value );
-            return NULL;
-        }
-        value = new_value;
-        len = max;
-    }
-    if (!res) return value;
-    HeapFree( GetProcessHeap(), 0, value );
-    return NULL;
-}
-
-static WCHAR *get_key_value( HKEY key, const WCHAR *value )
-{
-    DWORD size = 0;
-    WCHAR *data;
-
-    if (RegGetValueW( key, NULL, value, RRF_RT_REG_SZ | RRF_NOEXPAND, NULL, NULL, &size )) return NULL;
-    if (!(data = HeapAlloc( GetProcessHeap(), 0, size ))) return NULL;
-    if (!RegGetValueW( key, NULL, value, RRF_RT_REG_SZ | RRF_NOEXPAND, NULL, (BYTE *)data, &size )) return data;
-    HeapFree( GetProcessHeap(), 0, data );
-    return NULL;
-}
-
-static HKEY open_mapped_key( const WCHAR *path, BOOL write )
-{
-    static const WCHAR softwareW[] = {'S','o','f','t','w','a','r','e','\\',0};
-    static const WCHAR usrW[] = {'U','S','R',':'};
-    static const WCHAR sysW[] = {'S','Y','S',':'};
-    WCHAR *combined_path;
-    const WCHAR *p;
-    LSTATUS res;
-    HKEY key;
-
-    TRACE("%s\n", debugstr_w( path ));
-
-    for (p = path; strchr("!#@", *p); p++)
-        FIXME("ignoring %c modifier\n", *p);
-
-    if (!strncmpW( p, usrW, ARRAY_SIZE( usrW ) ))
-    {
-        if (write)
-            res = RegCreateKeyExW( HKEY_CURRENT_USER, p + 4, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &key, NULL );
-        else
-            res = RegOpenKeyExW( HKEY_CURRENT_USER, p + 4, 0, KEY_READ, &key );
-        return res ? NULL : key;
-    }
-
-    if (!strncmpW( p, sysW, ARRAY_SIZE( sysW ) ))
-    {
-        p += 4;
-        if (!(combined_path = HeapAlloc( GetProcessHeap(), 0,
-                                         (ARRAY_SIZE( softwareW ) + strlenW( p )) * sizeof(WCHAR) )))
-            return NULL;
-        strcpyW( combined_path, softwareW );
-        strcatW( combined_path, p );
-        if (write)
-            res = RegCreateKeyExW( HKEY_LOCAL_MACHINE, combined_path, 0, NULL,
-                                   0, KEY_READ | KEY_WRITE, NULL, &key, NULL );
-        else
-            res = RegOpenKeyExW( HKEY_LOCAL_MACHINE, combined_path, 0, KEY_READ, &key );
-        HeapFree( GetProcessHeap(), 0, combined_path );
-        return res ? NULL : key;
-    }
-
-    FIXME("unhandled path syntax %s\n", debugstr_w( path ));
-    return NULL;
-}
-
-/* returns TRUE if the given section + name is mapped */
-static BOOL get_mapped_section_key( const WCHAR *filename, const WCHAR *section,
-                                    const WCHAR *name, BOOL write, HKEY *ret_key )
-{
-    static const WCHAR backslashW[] = {'\\',0};
-    WCHAR *path = NULL, *combined_path;
-    HKEY key, subkey = NULL;
-
-    if (!(key = open_file_mapping_key( filename )))
-        return FALSE;
-
-    if (!RegOpenKeyExW( key, section, 0, KEY_READ, &subkey ))
-    {
-        if (!(path = get_key_value( subkey, name )))
-            path = get_key_value( subkey, NULL );
-        RegCloseKey( subkey );
-        RegCloseKey( key );
-        if (!path) return FALSE;
-    }
-    else
-    {
-        if (!(path = get_key_value( key, section )))
-        {
-            if ((path = get_key_value( key, NULL )))
-            {
-                if ((combined_path = HeapAlloc( GetProcessHeap(), 0,
-                                                (strlenW( path ) + strlenW( section ) + 2) * sizeof(WCHAR) )))
-                {
-                    strcpyW( combined_path, path );
-                    strcatW( combined_path, backslashW );
-                    strcatW( combined_path, section );
-                }
-                HeapFree( GetProcessHeap(), 0, path );
-                path = combined_path;
-            }
-        }
-        RegCloseKey( key );
-        if (!path) return FALSE;
-    }
-
-    *ret_key = open_mapped_key( path, write );
-    HeapFree( GetProcessHeap(), 0, path );
-    return TRUE;
-}
-
-static DWORD get_mapped_section( HKEY key, WCHAR *buffer, DWORD size, BOOL return_values )
-{
-    WCHAR *entry, *value;
-    DWORD i, ret = 0;
-
-    for (i = 0; (entry = enum_key( key, i )); ++i)
-    {
-        lstrcpynW( buffer + ret, entry, size - ret - 1 );
-        ret = min( ret + strlenW( entry ) + 1, size - 1 );
-        if (return_values && ret < size - 1 && (value = get_key_value( key, entry )))
-        {
-            buffer[ret - 1] = '=';
-            lstrcpynW( buffer + ret, value, size - ret - 1 );
-            ret = min( ret + strlenW( value ) + 1, size - 1 );
-            HeapFree( GetProcessHeap(), 0, value );
-        }
-        HeapFree( GetProcessHeap(), 0, entry );
-    }
-
-    return ret;
-}
-
-static DWORD get_section( const WCHAR *filename, const WCHAR *section,
-                          WCHAR *buffer, DWORD size, BOOL return_values )
-{
-    HKEY key, subkey, section_key;
-    BOOL use_ini = TRUE;
-    DWORD ret = 0;
-    WCHAR *path;
-
-    if ((key = open_file_mapping_key( filename )))
-    {
-        if (!RegOpenKeyExW( key, section, 0, KEY_READ, &subkey ))
-        {
-            WCHAR *entry, *value;
-            HKEY entry_key;
-            DWORD i;
-
-            for (i = 0; (entry = enum_key( subkey, i )); ++i)
-            {
-                if (!(path = get_key_value( subkey, entry )))
-                {
-                    HeapFree( GetProcessHeap(), 0, entry );
-                    continue;
-                }
-
-                entry_key = open_mapped_key( path, FALSE );
-                HeapFree( GetProcessHeap(), 0, path );
-                if (!entry_key)
-                {
-                    HeapFree( GetProcessHeap(), 0, entry );
-                    continue;
-                }
-
-                if (entry[0])
-                {
-                    if ((value = get_key_value( entry_key, entry )))
-                    {
-                        lstrcpynW( buffer + ret, entry, size - ret - 1 );
-                        ret = min( ret + strlenW( entry ) + 1, size - 1 );
-                        if (return_values && ret < size - 1)
-                        {
-                            buffer[ret - 1] = '=';
-                            lstrcpynW( buffer + ret, value, size - ret - 1 );
-                            ret = min( ret + strlenW( value ) + 1, size - 1 );
-                        }
-                        HeapFree( GetProcessHeap(), 0, value );
-                    }
-                }
-                else
-                {
-                    ret = get_mapped_section( entry_key, buffer, size, return_values );
-                    use_ini = FALSE;
-                }
-
-                HeapFree( GetProcessHeap(), 0, entry );
-                RegCloseKey( entry_key );
-            }
-
-            RegCloseKey( subkey );
-        }
-        else if (get_mapped_section_key( filename, section, NULL, FALSE, &section_key ))
-        {
-            ret = get_mapped_section( section_key, buffer, size, return_values );
-            use_ini = FALSE;
-            RegCloseKey( section_key );
-        }
-
-        RegCloseKey( key );
-    }
-
-    if (use_ini)
-        ret += PROFILE_GetSection( filename, section, buffer + ret, size - ret, return_values );
-
-    return ret;
-}
-
-static void delete_key_values( HKEY key )
-{
-    WCHAR *entry;
-
-    while ((entry = enum_key( key, 0 )))
-    {
-        RegDeleteValueW( key, entry );
-        HeapFree( GetProcessHeap(), 0, entry );
-    }
-}
-
-static BOOL delete_section( const WCHAR *filename, const WCHAR *section )
-{
-    HKEY key, subkey, section_key;
-
-    if ((key = open_file_mapping_key( filename )))
-    {
-        if (!RegOpenKeyExW( key, section, 0, KEY_READ, &subkey ))
-        {
-            WCHAR *entry, *path;
-            HKEY entry_key;
-            DWORD i;
-
-            for (i = 0; (entry = enum_key( subkey, i )); ++i)
-            {
-                if (!(path = get_key_value( subkey, entry )))
-                {
-                    HeapFree( GetProcessHeap(), 0, path );
-                    continue;
-                }
-
-                entry_key = open_mapped_key( path, TRUE );
-                HeapFree( GetProcessHeap(), 0, path );
-                if (!entry_key)
-                {
-                    HeapFree( GetProcessHeap(), 0, entry );
-                    continue;
-                }
-
-                if (entry[0])
-                    RegDeleteValueW( entry_key, entry );
-                else
-                    delete_key_values( entry_key );
-
-                HeapFree( GetProcessHeap(), 0, entry );
-                RegCloseKey( entry_key );
-            }
-
-            RegCloseKey( subkey );
-        }
-        else if (get_mapped_section_key( filename, section, NULL, TRUE, &section_key ))
-        {
-            delete_key_values( section_key );
-            RegCloseKey( section_key );
-        }
-
-        RegCloseKey( key );
-    }
-
-    return PROFILE_DeleteSection( filename, section );
-}
 
 /********************* API functions **********************************/
 
@@ -1355,7 +1047,6 @@ INT WINAPI GetPrivateProfileStringW( LPCWSTR section, LPCWSTR entry,
     int		ret;
     LPWSTR	defval_tmp = NULL;
     const WCHAR *p;
-    HKEY key;
 
     TRACE("%s,%s,%s,%p,%u,%s\n", debugstr_w(section), debugstr_w(entry),
           debugstr_w(def_val), buffer, len, debugstr_w(filename));
@@ -1365,7 +1056,7 @@ INT WINAPI GetPrivateProfileStringW( LPCWSTR section, LPCWSTR entry,
     if (!section) return GetPrivateProfileSectionNamesW( buffer, len, filename );
     if (!entry)
     {
-        ret = get_section( filename, section, buffer, len, FALSE );
+        ret = PROFILE_GetSection( filename, section, buffer, len, FALSE );
         if (!buffer[0])
         {
             PROFILE_CopyEntry( buffer, def_val, len );
@@ -1389,47 +1080,23 @@ INT WINAPI GetPrivateProfileStringW( LPCWSTR section, LPCWSTR entry,
         def_val = defval_tmp;
     }
 
-    if (get_mapped_section_key( filename, section, entry, FALSE, &key ))
-    {
-        if (key)
-        {
-            WCHAR *value;
-
-            if ((value = get_key_value( key, entry )))
-            {
-                lstrcpynW( buffer, value, len );
-                HeapFree( GetProcessHeap(), 0, value );
-            }
-            else
-                lstrcpynW( buffer, def_val, len );
-
-            RegCloseKey( key );
-        }
-        else
-            lstrcpynW( buffer, def_val, len );
+    RtlEnterCriticalSection( &PROFILE_CritSect );
 
+    if (PROFILE_Open( filename, FALSE ))
+    {
+        PROFILEKEY *key = PROFILE_Find( &CurProfile->section, section, entry, FALSE, FALSE );
+        PROFILE_CopyEntry( buffer, (key && key->value) ? key->value : def_val, len );
+        TRACE("-> %s\n", debugstr_w( buffer ));
         ret = strlenW( buffer );
     }
     else
     {
-        EnterCriticalSection( &PROFILE_CritSect );
-
-        if (PROFILE_Open( filename, FALSE ))
-        {
-            PROFILEKEY *key = PROFILE_Find( &CurProfile->section, section, entry, FALSE, FALSE );
-            PROFILE_CopyEntry( buffer, (key && key->value) ? key->value : def_val, len );
-            TRACE("-> %s\n", debugstr_w( buffer ));
-            ret = strlenW( buffer );
-        }
-        else
-        {
-           lstrcpynW( buffer, def_val, len );
-           ret = strlenW( buffer );
-        }
-
-        LeaveCriticalSection( &PROFILE_CritSect );
+       lstrcpynW( buffer, def_val, len );
+       ret = strlenW( buffer );
     }
 
+    RtlLeaveCriticalSection( &PROFILE_CritSect );
+
     HeapFree(GetProcessHeap(), 0, defval_tmp);
 
     TRACE("returning %s, %d\n", debugstr_w(buffer), ret);
@@ -1583,7 +1250,7 @@ INT WINAPI GetPrivateProfileSectionW( LPCWSTR section, LPWSTR buffer,
 
     TRACE("(%s, %p, %d, %s)\n", debugstr_w(section), buffer, len, debugstr_w(filename));
 
-    return get_section( filename, section, buffer, len, TRUE );
+    return PROFILE_GetSection( filename, section, buffer, len, TRUE );
 }
 
 /***********************************************************************
@@ -1656,9 +1323,6 @@ BOOL WINAPI WritePrivateProfileStringW( LPCWSTR section, LPCWSTR entry,
 					LPCWSTR string, LPCWSTR filename )
 {
     BOOL ret = FALSE;
-    HKEY key;
-
-    TRACE("(%s, %s, %s, %s)\n", debugstr_w(section), debugstr_w(entry), debugstr_w(string), debugstr_w(filename));
 
     if (!section && !entry && !string) /* documented "file flush" case */
     {
@@ -1670,21 +1334,7 @@ BOOL WINAPI WritePrivateProfileStringW( LPCWSTR section, LPCWSTR entry,
         LeaveCriticalSection( &PROFILE_CritSect );
         return FALSE;
     }
-    if (!entry) return delete_section( filename, section );
-
-    if (get_mapped_section_key( filename, section, entry, TRUE, &key ))
-    {
-        LSTATUS res;
-
-        if (string)
-            res = RegSetValueExW( key, entry, 0, REG_SZ, (const BYTE *)string,
-                                  (strlenW( string ) + 1) * sizeof(WCHAR) );
-        else
-            res = RegDeleteValueW( key, entry );
-        RegCloseKey( key );
-        if (res) SetLastError( res );
-        return !res;
-    }
+    if (!entry) return PROFILE_DeleteSection( filename, section );
 
     EnterCriticalSection( &PROFILE_CritSect );
 
@@ -1736,7 +1386,6 @@ BOOL WINAPI WritePrivateProfileSectionW( LPCWSTR section,
 {
     BOOL ret = FALSE;
     LPWSTR p;
-    HKEY key, section_key;
 
     if (!section && !string)
     {
@@ -1748,45 +1397,7 @@ BOOL WINAPI WritePrivateProfileSectionW( LPCWSTR section,
         LeaveCriticalSection( &PROFILE_CritSect );
         return FALSE;
     }
-    if (!string) return delete_section( filename, section );
-
-    if ((key = open_file_mapping_key( filename )))
-    {
-        /* replace existing entries, but only if they are mapped, and do not
-         * delete any keys */
-
-        const WCHAR *entry, *p;
-
-        for (entry = string; *entry; entry += strlenW( entry ) + 1)
-        {
-            if ((p = strchrW( entry, '=' )))
-            {
-                WCHAR *entry_copy;
-                p++;
-                if (!(entry_copy = HeapAlloc( GetProcessHeap(), 0, (p - entry) * sizeof(WCHAR) )))
-                {
-                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-                    RegCloseKey( key );
-                    return FALSE;
-                }
-                lstrcpynW( entry_copy, entry, p - entry );
-                if (get_mapped_section_key( filename, section, entry_copy, TRUE, &section_key ))
-                {
-                    LSTATUS res = RegSetValueExW( section_key, entry_copy, 0, REG_SZ, (const BYTE *)p,
-                                                  (strlenW( p ) + 1) * sizeof(WCHAR) );
-                    RegCloseKey( section_key );
-                    if (res)
-                    {
-                        SetLastError( res );
-                        RegCloseKey( key );
-                        return FALSE;
-                    }
-                }
-            }
-        }
-        RegCloseKey( key );
-        return TRUE;
-    }
+    if (!string) return PROFILE_DeleteSection( filename, section );
 
     EnterCriticalSection( &PROFILE_CritSect );
 
@@ -1908,26 +1519,11 @@ DWORD WINAPI GetPrivateProfileSectionNamesW( LPWSTR buffer, DWORD size,
 					     LPCWSTR filename)
 {
     DWORD ret = 0;
-    HKEY key;
-
-    if ((key = open_file_mapping_key( filename )))
-    {
-        WCHAR *section;
-        DWORD i;
-
-        for (i = 0; (section = enum_key( key, i )); ++i)
-        {
-            lstrcpynW( buffer + ret, section, size - ret - 1 );
-            ret = min( ret + strlenW( section ) + 1, size - 1 );
-        }
-
-        RegCloseKey( key );
-    }
 
     RtlEnterCriticalSection( &PROFILE_CritSect );
 
     if (PROFILE_Open( filename, FALSE ))
-        ret += PROFILE_GetSectionNames( buffer + ret, size - ret );
+        ret = PROFILE_GetSectionNames(buffer, size);
 
     RtlLeaveCriticalSection( &PROFILE_CritSect );
 
diff --git a/dlls/kernel32/tests/console.c b/dlls/kernel32/tests/console.c
index 1702369d7a..79b4d7215e 100644
--- a/dlls/kernel32/tests/console.c
+++ b/dlls/kernel32/tests/console.c
@@ -301,8 +301,7 @@ static void testWriteNotWrappedProcessed(HANDLE hCon, COORD sbSize)
     int			p;
     WORD                attr;
 
-    ok(GetConsoleMode(hCon, &mode) && SetConsoleMode(hCon, (mode | ENABLE_PROCESSED_OUTPUT) &
-                                                     ~(ENABLE_WRAP_AT_EOL_OUTPUT | ENABLE_VIRTUAL_TERMINAL_PROCESSING)),
+    ok(GetConsoleMode(hCon, &mode) && SetConsoleMode(hCon, (mode | ENABLE_PROCESSED_OUTPUT) & ~ENABLE_WRAP_AT_EOL_OUTPUT),
        "clearing wrap at EOL & setting processed output\n");
 
     /* write line, wrapping disabled, buffer exceeds sb width */
@@ -824,7 +823,7 @@ static void testScreenBuffer(HANDLE hConOut)
     ret = WriteConsoleA(hFileOutWT, test_str1, lstrlenA(test_str1), &len, NULL);
     error = GetLastError();
     ok(!ret, "Shouldn't succeed\n");
-    ok(error == ERROR_INVALID_HANDLE || error == ERROR_INVALID_FUNCTION,
+    todo_wine ok(error == ERROR_INVALID_HANDLE || error == ERROR_INVALID_FUNCTION,
        "GetLastError: got %u\n", error);
 
     CloseHandle(hFileOutRW);
@@ -1321,6 +1320,7 @@ static void test_CreateFileW(void)
                           cf_table[index].creation, FILE_ATTRIBUTE_NORMAL, NULL);
         if (!index && ret == INVALID_HANDLE_VALUE)
         {
+            todo_wine
             win_skip("Skipping NT path tests, not supported on this Windows version\n");
             skip_nt = TRUE;
             continue;
@@ -2861,8 +2861,8 @@ static void test_ReadConsoleOutput(HANDLE console)
     coord.Y = 3;
     set_region(&region, 200, 7, 15, 211);
     ret = ReadConsoleOutputW(console, char_info_buf, size, coord, &region);
-    ok(!ret, "ReadConsoleOutputW returned: %x(%u)\n", ret, GetLastError());
-    check_region(&region, 200, 7, -15, -211);
+    ok(!ret && GetLastError() == ERROR_NOT_ENOUGH_MEMORY, "ReadConsoleOutputW returned: %x(%u)\n", ret, GetLastError());
+    check_region(&region, 200, 7, 15, 211);
 
     size.X = 23;
     size.Y = 17;
@@ -3589,69 +3589,36 @@ static void test_GetConsoleScreenBufferInfoEx(HANDLE std_output)
 
 static void test_FreeConsole(void)
 {
-    WCHAR title[16];
     HANDLE handle;
-    DWORD size;
-    HWND hwnd;
-    UINT cp;
     BOOL ret;
 
-    ok(RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle != NULL, "ConsoleHandle is NULL\n");
-
     ret = FreeConsole();
     ok(ret, "FreeConsole failed: %u\n", GetLastError());
 
-    ok(RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle == NULL, "ConsoleHandle = %p\n",
-       RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle);
-
     handle = CreateFileA("CONOUT$", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    todo_wine
     ok(handle == INVALID_HANDLE_VALUE &&
        (GetLastError() == ERROR_INVALID_HANDLE || broken(GetLastError() == ERROR_ACCESS_DENIED /* winxp */)),
        "CreateFileA failed: %u\n", GetLastError());
 
     handle = CreateFileA("CONIN$", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
+    todo_wine
     ok(handle == INVALID_HANDLE_VALUE &&
        (GetLastError() == ERROR_INVALID_HANDLE || broken(GetLastError() == ERROR_ACCESS_DENIED /* winxp */)),
        "CreateFileA failed: %u\n", GetLastError());
 
     handle = CreateFileA("CON", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
+    todo_wine
     ok(handle == INVALID_HANDLE_VALUE &&
        (GetLastError() == ERROR_INVALID_HANDLE || broken(GetLastError() == ERROR_ACCESS_DENIED /* winxp */)),
        "CreateFileA failed: %u\n", GetLastError());
 
     handle = CreateFileA("CON", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    todo_wine
     ok(handle == INVALID_HANDLE_VALUE &&
        (GetLastError() == ERROR_INVALID_HANDLE || broken(GetLastError() == ERROR_FILE_NOT_FOUND /* winxp */)),
        "CreateFileA failed: %u\n", GetLastError());
 
-    handle = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
-                                       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
-                                       CONSOLE_TEXTMODE_BUFFER, NULL);
-    ok(handle == INVALID_HANDLE_VALUE && GetLastError() == ERROR_INVALID_HANDLE,
-       "CreateConsoleScreenBuffer returned: %p (%u)\n", handle, GetLastError());
-
-    SetLastError(0xdeadbeef);
-    cp = GetConsoleCP();
-    ok(!cp, "cp = %x\n", cp);
-    ok(GetLastError() == ERROR_INVALID_HANDLE, "last error %u\n", GetLastError());
-
-    SetLastError(0xdeadbeef);
-    cp = GetConsoleOutputCP();
-    ok(!cp, "cp = %x\n", cp);
-    ok(GetLastError() == ERROR_INVALID_HANDLE, "last error %u\n", GetLastError());
-
-    SetLastError(0xdeadbeef);
-    memset( title, 0xc0, sizeof(title) );
-    size = GetConsoleTitleW( title, ARRAY_SIZE(title) );
-    ok(!size, "GetConsoleTitleW returned %u\n", size);
-    ok(title[0] == 0xc0c0, "title byffer changed\n");
-    ok(GetLastError() == ERROR_INVALID_HANDLE, "last error %u\n", GetLastError());
-
-    SetLastError(0xdeadbeef);
-    hwnd = GetConsoleWindow();
-    ok(!hwnd, "hwnd = %p\n", hwnd);
-    ok(GetLastError() == ERROR_INVALID_HANDLE, "last error %u\n", GetLastError());
-
     if (!skip_nt)
     {
         SetStdHandle( STD_INPUT_HANDLE, (HANDLE)0xdeadbeef );
@@ -3710,30 +3677,6 @@ static void test_SetConsoleScreenBufferInfoEx(HANDLE std_output)
     CloseHandle(std_input);
 }
 
-static void test_console_title(void)
-{
-    WCHAR buf[64];
-    BOOL ret;
-
-    ret = SetConsoleTitleW(L"test");
-    ok(ret, "SetConsoleTitleW failed: %u\n", GetLastError());
-
-    ret = GetConsoleTitleW(buf, ARRAY_SIZE(buf));
-    ok(ret, "GetConsoleTitleW failed: %u\n", GetLastError());
-    ok(!wcscmp(buf, L"test"), "title = %s\n", wine_dbgstr_w(buf));
-
-    if (!skip_nt)
-    {
-        ret = GetConsoleTitleW(buf, 2);
-        ok(ret, "GetConsoleTitleW failed: %u\n", GetLastError());
-        ok(!wcscmp(buf, L"t"), "title = %s\n", wine_dbgstr_w(buf));
-
-        ret = GetConsoleTitleW(buf, 4);
-        ok(ret, "GetConsoleTitleW failed: %u\n", GetLastError());
-        ok(!wcscmp(buf, L"tes"), "title = %s\n", wine_dbgstr_w(buf));
-    }
-}
-
 static void test_AttachConsole_child(DWORD console_pid)
 {
     HANDLE pipe_in, pipe_out;
@@ -3750,11 +3693,8 @@ static void test_AttachConsole_child(DWORD console_pid)
     ok(!res && GetLastError() == ERROR_ACCESS_DENIED,
        "AttachConsole returned: %x(%u)\n", res, GetLastError());
 
-    ok(RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle != NULL, "ConsoleHandle is NULL\n");
     res = FreeConsole();
     ok(res, "FreeConsole failed: %u\n", GetLastError());
-    ok(RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle == NULL, "ConsoleHandle = %p\n",
-       RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle);
 
     SetStdHandle(STD_ERROR_HANDLE, pipe_out);
 
@@ -3762,7 +3702,6 @@ static void test_AttachConsole_child(DWORD console_pid)
     ok(res, "AttachConsole failed: %u\n", GetLastError());
 
     ok(pipe_out != GetStdHandle(STD_ERROR_HANDLE), "std handle not set to console\n");
-    ok(RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle != NULL, "ConsoleHandle is NULL\n");
 
     console = CreateFileA("CONOUT$", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
     ok(console != INVALID_HANDLE_VALUE, "Could not open console\n");
@@ -3830,110 +3769,16 @@ static void test_AttachConsole(HANDLE console)
     ok(!memcmp(buf, "Child", 5), "Unexpected console output\n");
 }
 
-static void test_AllocConsole_child(void)
-{
-    HANDLE unbound_output;
-    HANDLE prev_output, prev_error;
-    STARTUPINFOW si;
-    DWORD mode;
-    BOOL res;
-
-    GetStartupInfoW(&si);
-
-    prev_output = GetStdHandle(STD_OUTPUT_HANDLE);
-    res = DuplicateHandle(GetCurrentProcess(), prev_output, GetCurrentProcess(), &unbound_output,
-                          0, FALSE, DUPLICATE_SAME_ACCESS);
-    ok(res, "DuplicateHandle failed: %u\n", GetLastError());
-
-    res = GetConsoleMode(unbound_output, &mode);
-    ok(res, "GetConsoleMode failed: %u\n", GetLastError());
-
-    prev_error = GetStdHandle(STD_ERROR_HANDLE);
-    if (si.dwFlags & STARTF_USESTDHANDLES)
-    {
-        res = GetConsoleMode(prev_error, &mode);
-        ok(!res && GetLastError() == ERROR_INVALID_HANDLE, "GetConsoleMode failed: %u\n", GetLastError());
-    }
-
-    FreeConsole();
-
-    ok(GetStdHandle(STD_OUTPUT_HANDLE) == prev_output, "GetStdHandle(STD_OUTPUT_HANDLE) = %p\n", GetStdHandle(STD_OUTPUT_HANDLE));
-    ok(GetStdHandle(STD_ERROR_HANDLE) == prev_error, "GetStdHandle(STD_ERROR_HANDLE) = %p\n", GetStdHandle(STD_ERROR_HANDLE));
-    res = GetConsoleMode(unbound_output, &mode);
-    todo_wine
-    ok(!res && GetLastError() == ERROR_INVALID_HANDLE, "GetConsoleMode failed: %u\n", GetLastError());
-
-    res = AllocConsole();
-    ok(res, "AllocConsole failed: %u\n", GetLastError());
-
-    if (si.dwFlags & STARTF_USESTDHANDLES)
-    {
-        ok(GetStdHandle(STD_OUTPUT_HANDLE) == prev_output, "GetStdHandle(STD_OUTPUT_HANDLE) = %p\n", GetStdHandle(STD_OUTPUT_HANDLE));
-        ok(GetStdHandle(STD_ERROR_HANDLE) == prev_error, "GetStdHandle(STD_ERROR_HANDLE) = %p\n", GetStdHandle(STD_ERROR_HANDLE));
-    }
-
-    res = GetConsoleMode(unbound_output, &mode);
-    ok(res, "GetConsoleMode failed: %u\n", GetLastError());
-
-    FreeConsole();
-    SetStdHandle(STD_OUTPUT_HANDLE, NULL);
-    SetStdHandle(STD_ERROR_HANDLE, NULL);
-    res = AllocConsole();
-    ok(res, "AllocConsole failed: %u\n", GetLastError());
-
-    ok(GetStdHandle(STD_OUTPUT_HANDLE) != NULL, "GetStdHandle(STD_OUTPUT_HANDLE) = %p\n", GetStdHandle(STD_OUTPUT_HANDLE));
-    ok(GetStdHandle(STD_ERROR_HANDLE) != NULL, "GetStdHandle(STD_ERROR_HANDLE) = %p\n", GetStdHandle(STD_ERROR_HANDLE));
-
-    res = GetConsoleMode(unbound_output, &mode);
-    ok(res, "GetConsoleMode failed: %u\n", GetLastError());
-    res = GetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), &mode);
-    ok(res, "GetConsoleMode failed: %u\n", GetLastError());
-    res = GetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), &mode);
-    ok(res, "GetConsoleMode failed: %u\n", GetLastError());
-
-    res = CloseHandle(unbound_output);
-    ok(res, "CloseHandle failed: %u\n", GetLastError());
-}
-
-static void test_AllocConsole(void)
-{
-    SECURITY_ATTRIBUTES inheritable_attr = { sizeof(inheritable_attr), NULL, TRUE };
-    STARTUPINFOA si = { sizeof(si) };
-    PROCESS_INFORMATION info;
-    char **argv, buf[MAX_PATH];
-    HANDLE pipe_read, pipe_write;
-    BOOL res;
-
-    if (skip_nt) return;
-
-    winetest_get_mainargs(&argv);
-    sprintf(buf, "\"%s\" console alloc_console", argv[0], GetCurrentProcessId());
-    res = CreateProcessA(NULL, buf, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &info);
-    ok(res, "CreateProcess failed: %u\n", GetLastError());
-    CloseHandle(info.hThread);
-    wait_child_process(info.hProcess);
-    CloseHandle(info.hProcess);
-
-    res = CreatePipe(&pipe_read, &pipe_write, &inheritable_attr, 0);
-    ok(res, "CreatePipe failed: %u\n", GetLastError());
-
-    si.dwFlags = STARTF_USESTDHANDLES;
-    si.hStdError = pipe_write;
-    res = CreateProcessA(NULL, buf, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &info);
-    ok(res, "CreateProcess failed: %u\n", GetLastError());
-    CloseHandle(info.hThread);
-    wait_child_process(info.hProcess);
-    CloseHandle(info.hProcess);
-
-    CloseHandle(pipe_read);
-    CloseHandle(pipe_write);
-}
-
 START_TEST(console)
 {
+    static const char font_name[] = "Lucida Console";
     HANDLE hConIn, hConOut;
-    BOOL ret, test_current;
+    BOOL ret;
     CONSOLE_SCREEN_BUFFER_INFO	sbi;
+    LONG err;
+    HKEY console_key;
+    char old_font[LF_FACESIZE];
+    BOOL delete = FALSE;
     DWORD size;
     char **argv;
     int argc;
@@ -3950,73 +3795,62 @@ START_TEST(console)
         return;
     }
 
-    if (argc == 3 && !strcmp(argv[2], "alloc_console"))
-    {
-        test_AllocConsole_child();
-        return;
-    }
-
-    test_current = argc >= 3 && !strcmp(argv[2], "--current");
+    /* be sure we have a clean console (and that's our own)
+     * FIXME: this will make the test fail (currently) if we don't run
+     * under X11
+     * Another solution would be to rerun the test under wineconsole with
+     * the curses backend
+     */
 
-    if (!test_current)
-    {
-        static const char font_name[] = "Lucida Console";
-        HKEY console_key;
-        char old_font[LF_FACESIZE];
-        BOOL delete = FALSE;
-        LONG err;
-
-        /* ReadConsoleOutputW doesn't retrieve characters from the output buffer
-         * correctly for characters that don't have a glyph in the console font. So,
-         * we first set the console font to Lucida Console (which has a wider
-         * selection of glyphs available than the default raster fonts). We want
-         * to be able to restore the original font afterwards, so don't change
-         * if we can't read the original font.
-         */
-        err = RegOpenKeyExA(HKEY_CURRENT_USER, "Console", 0,
-                            KEY_QUERY_VALUE | KEY_SET_VALUE, &console_key);
-        if (err == ERROR_SUCCESS)
+    /* ReadConsoleOutputW doesn't retrieve characters from the output buffer
+     * correctly for characters that don't have a glyph in the console font. So,
+     * we first set the console font to Lucida Console (which has a wider
+     * selection of glyphs available than the default raster fonts). We want
+     * to be able to restore the original font afterwards, so don't change
+     * if we can't read the original font.
+     */
+    err = RegOpenKeyExA(HKEY_CURRENT_USER, "Console", 0,
+                        KEY_QUERY_VALUE | KEY_SET_VALUE, &console_key);
+    if (err == ERROR_SUCCESS)
+    {
+        size = sizeof(old_font);
+        err = RegQueryValueExA(console_key, "FaceName", NULL, NULL,
+                               (LPBYTE) old_font, &size);
+        if (err == ERROR_SUCCESS || err == ERROR_FILE_NOT_FOUND)
         {
-            size = sizeof(old_font);
-            err = RegQueryValueExA(console_key, "FaceName", NULL, NULL,
-                                   (LPBYTE) old_font, &size);
-            if (err == ERROR_SUCCESS || err == ERROR_FILE_NOT_FOUND)
-            {
-                delete = (err == ERROR_FILE_NOT_FOUND);
-                err = RegSetValueExA(console_key, "FaceName", 0, REG_SZ,
-                                     (const BYTE *) font_name, sizeof(font_name));
-                if (err != ERROR_SUCCESS)
-                    trace("Unable to change default console font, error %d\n", err);
-            }
-            else
-            {
-                trace("Unable to query default console font, error %d\n", err);
-                RegCloseKey(console_key);
-                console_key = NULL;
-            }
+            delete = (err == ERROR_FILE_NOT_FOUND);
+            err = RegSetValueExA(console_key, "FaceName", 0, REG_SZ,
+                                 (const BYTE *) font_name, sizeof(font_name));
+            if (err != ERROR_SUCCESS)
+                trace("Unable to change default console font, error %d\n", err);
         }
         else
         {
-            trace("Unable to open HKCU\\Console, error %d\n", err);
+            trace("Unable to query default console font, error %d\n", err);
+            RegCloseKey(console_key);
             console_key = NULL;
         }
+    }
+    else
+    {
+        trace("Unable to open HKCU\\Console, error %d\n", err);
+        console_key = NULL;
+    }
 
-        /* Now detach and open a fresh console to play with */
-        FreeConsole();
-        ok(AllocConsole(), "Couldn't alloc console\n");
+    /* Now detach and open a fresh console to play with */
+    FreeConsole();
+    ok(AllocConsole(), "Couldn't alloc console\n");
 
-        /* Restore default console font if needed */
-        if (console_key != NULL)
-        {
-            if (delete)
-                err = RegDeleteValueA(console_key, "FaceName");
-            else
-                err = RegSetValueExA(console_key, "FaceName", 0, REG_SZ,
-                                     (const BYTE *) old_font, strlen(old_font) + 1);
-            ok(err == ERROR_SUCCESS, "Unable to restore default console font, error %d\n", err);
-        }
+    /* Restore default console font if needed */
+    if (console_key != NULL)
+    {
+        if (delete)
+            err = RegDeleteValueA(console_key, "FaceName");
+        else
+            err = RegSetValueExA(console_key, "FaceName", 0, REG_SZ,
+                                 (const BYTE *) old_font, strlen(old_font) + 1);
+        ok(err == ERROR_SUCCESS, "Unable to restore default console font, error %d\n", err);
     }
-
     hConIn = CreateFileA("CONIN$", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
     hConOut = CreateFileA("CONOUT$", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
 
@@ -4052,22 +3886,19 @@ START_TEST(console)
     /* will test all the scrolling operations */
     testScroll(hConOut, sbi.dwSize);
     /* will test sb creation / modification / codepage handling */
-    if (!test_current) testScreenBuffer(hConOut);
+    testScreenBuffer(hConOut);
     /* Test waiting for a console handle */
     testWaitForConsoleInput(hConIn);
 
-    if (!test_current)
-    {
-        /* clear duplicated console font table */
-        CloseHandle(hConIn);
-        CloseHandle(hConOut);
-        FreeConsole();
-        ok(AllocConsole(), "Couldn't alloc console\n");
-        hConIn = CreateFileA("CONIN$", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
-        hConOut = CreateFileA("CONOUT$", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
-        ok(hConIn != INVALID_HANDLE_VALUE, "Opening ConIn\n");
-        ok(hConOut != INVALID_HANDLE_VALUE, "Opening ConOut\n");
-    }
+    /* clear duplicated console font table */
+    CloseHandle(hConIn);
+    CloseHandle(hConOut);
+    FreeConsole();
+    ok(AllocConsole(), "Couldn't alloc console\n");
+    hConIn = CreateFileA("CONIN$", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    hConOut = CreateFileA("CONOUT$", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hConIn != INVALID_HANDLE_VALUE, "Opening ConIn\n");
+    ok(hConOut != INVALID_HANDLE_VALUE, "Opening ConOut\n");
 
     testCtrlHandler();
     /* still to be done: access rights & access on objects */
@@ -4105,11 +3936,6 @@ START_TEST(console)
     test_SetConsoleFont(hConOut);
     test_GetConsoleScreenBufferInfoEx(hConOut);
     test_SetConsoleScreenBufferInfoEx(hConOut);
-    test_console_title();
-    if (!test_current)
-    {
-        test_AttachConsole(hConOut);
-        test_AllocConsole();
-        test_FreeConsole();
-    }
+    test_AttachConsole(hConOut);
+    test_FreeConsole();
 }
diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
index 757a230ae1..59965984a6 100644
--- a/dlls/kernel32/tests/loader.c
+++ b/dlls/kernel32/tests/loader.c
@@ -3901,7 +3901,7 @@ static void test_wow64_redirection(void)
     ok(pWow64RevertWow64FsRedirection(OldValue), "Re-enabling FS redirection failed\n");
 }
 
-static void test_dll_file( const char *name, BOOL is_todo )
+static void test_dll_file( const char *name )
 {
     HMODULE module = GetModuleHandleA( name );
     IMAGE_NT_HEADERS *nt, *nt_file;
@@ -3926,29 +3926,27 @@ static void test_dll_file( const char *name, BOOL is_todo )
     nt_file = pRtlImageNtHeader( ptr );
     ok( nt_file != NULL, "%s: invalid header\n", path );
 #define OK_FIELD(x) ok( nt->x == nt_file->x, "%s:%u: wrong " #x " %x / %x\n", name, i, nt->x, nt_file->x )
-    todo_wine_if(is_todo)
+    todo_wine
     OK_FIELD( FileHeader.NumberOfSections );
-    todo_wine_if(is_todo)
+    todo_wine
     OK_FIELD( OptionalHeader.AddressOfEntryPoint );
     OK_FIELD( OptionalHeader.NumberOfRvaAndSizes );
     for (i = 0; i < nt->OptionalHeader.NumberOfRvaAndSizes; i++)
     {
-        todo_wine_if( is_todo &&
-                      (i == IMAGE_DIRECTORY_ENTRY_EXPORT ||
-                       (i == IMAGE_DIRECTORY_ENTRY_IMPORT && nt->OptionalHeader.DataDirectory[i].Size) ||
-                       i == IMAGE_DIRECTORY_ENTRY_RESOURCE ||
-                       i == IMAGE_DIRECTORY_ENTRY_BASERELOC ))
+        todo_wine_if( i == IMAGE_DIRECTORY_ENTRY_EXPORT ||
+                      (i == IMAGE_DIRECTORY_ENTRY_IMPORT && nt->OptionalHeader.DataDirectory[i].Size) ||
+                      i == IMAGE_DIRECTORY_ENTRY_RESOURCE ||
+                      i == IMAGE_DIRECTORY_ENTRY_BASERELOC )
         OK_FIELD( OptionalHeader.DataDirectory[i].VirtualAddress );
-        todo_wine_if( is_todo &&
-                      (i == IMAGE_DIRECTORY_ENTRY_EXPORT ||
-                       (i == IMAGE_DIRECTORY_ENTRY_IMPORT && nt->OptionalHeader.DataDirectory[i].Size) ||
-                       i == IMAGE_DIRECTORY_ENTRY_BASERELOC ))
+        todo_wine_if( i == IMAGE_DIRECTORY_ENTRY_EXPORT ||
+                      (i == IMAGE_DIRECTORY_ENTRY_IMPORT && nt->OptionalHeader.DataDirectory[i].Size) ||
+                      i == IMAGE_DIRECTORY_ENTRY_BASERELOC )
         OK_FIELD( OptionalHeader.DataDirectory[i].Size );
     }
     sec = (IMAGE_SECTION_HEADER *)((char *)&nt->OptionalHeader + nt->FileHeader.SizeOfOptionalHeader);
     sec_file = (IMAGE_SECTION_HEADER *)((char *)&nt_file->OptionalHeader + nt_file->FileHeader.SizeOfOptionalHeader);
     for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
-        todo_wine_if(is_todo)
+        todo_wine
         ok( !memcmp( sec + i, sec_file + i, sizeof(*sec) ), "%s: wrong section %d\n", name, i );
     UnmapViewOfFile( ptr );
 #undef OK_FIELD
@@ -4042,10 +4040,10 @@ START_TEST(loader)
     test_InMemoryOrderModuleList();
     test_LoadPackagedLibrary();
     test_wow64_redirection();
-    test_dll_file( "ntdll.dll", FALSE );
-    test_dll_file( "kernel32.dll", TRUE );
-    test_dll_file( "advapi32.dll", TRUE );
-    test_dll_file( "user32.dll", TRUE );
+    test_dll_file( "ntdll.dll" );
+    test_dll_file( "kernel32.dll" );
+    test_dll_file( "advapi32.dll" );
+    test_dll_file( "user32.dll" );
     /* loader test must be last, it can corrupt the internal loader state on Windows */
     test_Loader();
 }
diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index eaa5da2e95..2e20c9d8a3 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -2612,7 +2612,6 @@ static void test_QueryInformationJobObject(void)
     PJOBOBJECT_BASIC_PROCESS_ID_LIST pid_list = (JOBOBJECT_BASIC_PROCESS_ID_LIST *)buf;
     JOBOBJECT_EXTENDED_LIMIT_INFORMATION ext_limit_info;
     JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit_info = &ext_limit_info.BasicLimitInformation;
-    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION basic_accounting_info;
     DWORD ret_len;
     PROCESS_INFORMATION pi[2];
     char buffer[50];
@@ -2720,14 +2719,6 @@ static void test_QueryInformationJobObject(void)
     ok(ret_len == sizeof(ext_limit_info), "QueryInformationJobObject returned ret_len=%u\n", ret_len);
     expect_eq_d(0, basic_limit_info->LimitFlags);
 
-    /* test JobObjectBasicAccountingInformation */
-    ret = pQueryInformationJobObject(job, JobObjectBasicAccountingInformation, &basic_accounting_info,
-                                     sizeof(basic_accounting_info), &ret_len);
-    ok(ret, "QueryInformationJobObject error %u\n", GetLastError());
-    ok(ret_len == sizeof(basic_accounting_info), "QueryInformationJobObject returned ret_len=%u\n", ret_len);
-    expect_eq_d(3, basic_accounting_info.TotalProcesses);
-    expect_eq_d(2, basic_accounting_info.ActiveProcesses);
-
     TerminateProcess(pi[0].hProcess, 0);
     CloseHandle(pi[0].hProcess);
     CloseHandle(pi[0].hThread);
diff --git a/dlls/kernel32/tests/profile.c b/dlls/kernel32/tests/profile.c
index 2fba26542f..ce82a746e7 100644
--- a/dlls/kernel32/tests/profile.c
+++ b/dlls/kernel32/tests/profile.c
@@ -32,15 +32,6 @@
 #define TESTFILE ".\\testwine.ini"
 #define TESTFILE2 ".\\testwine2.ini"
 
-static void check_profile_string_(int line, const char *section, const char *name, const char *file, const char *expect)
-{
-    char value[200] = {0};
-    DWORD ret = GetPrivateProfileStringA(section, name, "default", value, sizeof(value), file);
-    ok_(__FILE__, line)(ret == strlen(expect), "expected len %u, got %u\n", strlen(expect), ret);
-    ok_(__FILE__, line)(!strcmp(value, expect), "expected %s, got %s\n", debugstr_a(expect), debugstr_a(value));
-}
-#define check_profile_string(a, b, c, d) check_profile_string_(__LINE__, a, b, c, d);
-
 struct _profileInt { 
     LPCSTR section;
     LPCSTR key;
@@ -1172,415 +1163,6 @@ static void test_profile_struct(void)
     ok(ret, "got error %u\n", GetLastError());
 }
 
-static void check_registry_value_(int line, HKEY key, const char *value, const char *expect)
-{
-    char buffer[30];
-    DWORD type, size = sizeof(buffer);
-    LSTATUS ret;
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = RegQueryValueExA(key, value, 0, &type, (BYTE *)buffer, &size);
-    ok_(__FILE__, line)(!ret, "got error %u\n", ret);
-    ok_(__FILE__, line)(!strcmp(buffer, expect), "expected %s, got %s\n", debugstr_a(expect), debugstr_a(buffer));
-    ok_(__FILE__, line)(type == REG_SZ, "got type %u\n", type);
-}
-#define check_registry_value(a, b, c) check_registry_value_(__LINE__, a, b, c)
-
-static void test_registry_mapping(void)
-{
-    static const DWORD ivalue = 0xabacab;
-    HKEY mapping_key, mapped_key, mapping_subkey;
-    char buffer[30];
-    LSTATUS ret;
-
-    /* impersonate ourselves to prevent registry virtualization */
-    ret = ImpersonateSelf(SecurityImpersonation);
-    ok(ret, "got error %u\n", GetLastError());
-
-    ret = RegCreateKeyExA(HKEY_LOCAL_MACHINE,
-            "Software\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\winetest.ini",
-            0, NULL, 0, KEY_READ | KEY_WRITE | KEY_WOW64_64KEY, NULL, &mapping_key, NULL);
-    if (ret == ERROR_ACCESS_DENIED)
-    {
-        skip("Not enough permissions to write to the IniFileMapping key.\n");
-        return;
-    }
-    ok(!ret, "got error %u\n", ret);
-
-    ret = RegSetValueExA(mapping_key, "section1", 0, REG_SZ, (BYTE *)"USR:winetest_map", sizeof("USR:winetest_map"));
-    ok(!ret, "got error %u\n", ret);
-    ret = WritePrivateProfileStringA(NULL, NULL, NULL, "winetest.ini");
-    todo_wine ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section1", "name1", "winetest.ini", "default");
-
-    ret = WritePrivateProfileStringA("section1", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section1", "name1", "winetest.ini", "value1");
-    check_profile_string("section1", "name1", "C:/fake/path/winetest.ini", "value1");
-
-    ret = RegOpenKeyExA(HKEY_CURRENT_USER, "winetest_map", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-    check_registry_value(mapped_key, "name1", "value1");
-
-    ret = RegSetValueExA(mapped_key, "name2", 0, REG_SZ, (BYTE *)"value2", sizeof("value2"));
-    ok(!ret, "got error %u\n", ret);
-
-    check_profile_string("section1", "name2", "winetest.ini", "value2");
-
-    ret = GetFileAttributesA("C:/windows/winetest.ini");
-    ok(ret == INVALID_FILE_ATTRIBUTES, "winetest.ini should not exist.\n");
-
-    ret = WritePrivateProfileStringA("section1", "name2", NULL, "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    ret = RegQueryValueExA(mapped_key, "name2", 0, NULL, NULL, NULL);
-    ok(ret == ERROR_FILE_NOT_FOUND, "got error %u\n", ret);
-
-    /* Test non-string types. */
-
-    ret = RegSetValueExA(mapped_key, "name3", 0, REG_DWORD, (BYTE *)&ivalue, sizeof(ivalue));
-    ok(!ret, "got error %u\n", ret);
-    check_profile_string("section1", "name3", "winetest.ini", "default");
-
-    ret = GetPrivateProfileIntA("section1", "name3", 0, "winetest.ini");
-    ok(ret == 0, "got %#x\n", ret);
-
-    ret = RegSetValueExA(mapped_key, "name3", 0, REG_BINARY, (BYTE *)"value3", sizeof("value3"));
-    ok(!ret, "got error %u\n", ret);
-    check_profile_string("section1", "name3", "winetest.ini", "default");
-
-    ret = RegSetValueExA(mapped_key, "name3", 0, REG_MULTI_SZ, (BYTE *)"one\0two\0", sizeof("one\0two\0"));
-    ok(!ret, "got error %u\n", ret);
-    check_profile_string("section1", "name3", "winetest.ini", "default");
-
-    ret = RegSetValueExA(mapped_key, "name3", 0, REG_EXPAND_SZ, (BYTE *)"x%SystemRoot%", sizeof("x%SystemRoot%"));
-    ok(!ret, "got error %u\n", ret);
-    check_profile_string("section1", "name3", "winetest.ini", "default");
-
-    /* Test WritePrivateProfileSection(). Unlike with .ini files, it doesn't
-     * remove existing entries. */
-
-    ret = WritePrivateProfileStringA("section1", "name4", "value4", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    ret = WritePrivateProfileStringA("section1", "name5", "value5", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    ret = WritePrivateProfileSectionA("section1", "name4=four\0name6=six\0", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section1", "name4", "winetest.ini", "four");
-    check_profile_string("section1", "name5", "winetest.ini", "value5");
-    check_profile_string("section1", "name6", "winetest.ini", "six");
-
-    /* Test deleting the section. */
-
-    RegCloseKey(mapped_key);
-
-    ret = RegCreateKeyExA(HKEY_CURRENT_USER, "winetest_map\\subkey", 0, NULL, 0, 0, NULL, &mapped_key, NULL);
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    ret = WritePrivateProfileStringA("section1", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    ret = WritePrivateProfileStringA("section1", NULL, NULL, "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section1", "name1", "winetest.ini", "default");
-
-    ret = WritePrivateProfileStringA("section1", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    ret = WritePrivateProfileSectionA("section1", NULL, "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section1", "name1", "winetest.ini", "default");
-
-    ret = RegDeleteKeyA(HKEY_CURRENT_USER, "winetest_map\\subkey");
-    ok(!ret, "got error %u\n", ret);
-    ret = RegDeleteKeyA(HKEY_CURRENT_USER, "winetest_map");
-    ok(!ret, "got error %u\n", ret);
-
-    /* Test GetPrivateProfileSectionNames(). */
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = GetPrivateProfileSectionNamesA(buffer, 5, "winetest.ini");
-    ok(ret == 3, "got %u\n", ret);
-    ok(!memcmp(buffer, "sec\0", 5), "got %s\n", debugstr_an(buffer, ret));
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = GetPrivateProfileSectionNamesA(buffer, sizeof(buffer), "winetest.ini");
-    ok(ret == 9, "got %u\n", ret);
-    ok(!memcmp(buffer, "section1\0", 10), "got %s\n", debugstr_an(buffer, ret));
-
-    ret = WritePrivateProfileStringA("file_section", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = GetPrivateProfileSectionNamesA(buffer, 5, "winetest.ini");
-    ok(ret == 3, "got %u\n", ret);
-    ok(!memcmp(buffer, "sec\0", 5), "got %s\n", debugstr_an(buffer, ret));
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = GetPrivateProfileSectionNamesA(buffer, sizeof(buffer), "winetest.ini");
-    ok(ret == 22, "got %u\n", ret);
-    ok(!memcmp(buffer, "section1\0file_section\0", 23), "got %s\n", debugstr_an(buffer, ret));
-
-    ret = DeleteFileA("C:/windows/winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    /* Test the SYS: prefix. */
-
-    ret = RegSetValueExA(mapping_key, "section2", 0, REG_SZ, (BYTE *)"SYS:winetest_map", sizeof("SYS:winetest_map"));
-    ok(!ret, "got error %u\n", ret);
-    ret = WritePrivateProfileStringA(NULL, NULL, NULL, "winetest.ini");
-    todo_wine ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section2", "name1", "winetest.ini", "default");
-
-    ret = WritePrivateProfileStringA("section2", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section2", "name1", "winetest.ini", "value1");
-
-    ret = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\winetest_map", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-    check_registry_value(mapped_key, "name1", "value1");
-
-    ret = RegSetValueExA(mapped_key, "name2", 0, REG_SZ, (BYTE *)"value2", sizeof("value2"));
-    ok(!ret, "got error %u\n", ret);
-
-    check_profile_string("section2", "name2", "winetest.ini", "value2");
-
-    ret = GetFileAttributesA("C:/windows/winetest.ini");
-    ok(ret == INVALID_FILE_ATTRIBUTES, "winetest.ini should not exist.\n");
-
-    ret = RegDeleteKeyA(mapped_key, "");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    /* Try writing directly to the .ini file on disk instead. */
-
-    ret = WritePrivateProfileStringA("section3", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section3", "name1", "winetest.ini", "value1");
-
-    ret = RegSetValueExA(mapping_key, "section3", 0, REG_SZ, (BYTE *)"USR:winetest_map", sizeof("USR:winetest_map"));
-    ok(!ret, "got error %u\n", ret);
-    ret = WritePrivateProfileStringA(NULL, NULL, NULL, "winetest.ini");
-    todo_wine ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section3", "name1", "winetest.ini", "default");
-
-    ret = RegOpenKeyExA(HKEY_CURRENT_USER, "winetest_section3", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(ret == ERROR_FILE_NOT_FOUND, "got error %u\n", ret);
-
-    ret = WritePrivateProfileStringA("section3", "name1", "value2", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section3", "name1", "winetest.ini", "value2");
-
-    ret = RegOpenKeyExA(HKEY_CURRENT_USER, "winetest_map", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-
-    ret = RegDeleteKeyA(mapped_key, "");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    ret = RegDeleteValueA(mapping_key, "section3");
-    ok(!ret, "got error %u\n", ret);
-    ret = WritePrivateProfileStringA(NULL, NULL, NULL, "winetest.ini");
-    todo_wine ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section3", "name1", "winetest.ini", "value1");
-
-    ret = DeleteFileA("C:/windows/winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    /* Test default keys. */
-
-    ret = WritePrivateProfileStringA("section4", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    check_profile_string("section4", "name1", "winetest.ini", "value1");
-
-    ret = DeleteFileA("C:/windows/winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    ret = RegSetValueExA(mapping_key, NULL, 0, REG_SZ, (BYTE *)"SYS:winetest_default", sizeof("SYS:winetest_default"));
-    ok(!ret, "got error %u\n", ret);
-    ret = WritePrivateProfileStringA(NULL, NULL, NULL, "winetest.ini");
-    todo_wine ok(ret, "got error %u\n", GetLastError());
-
-    ret = WritePrivateProfileStringA("section4", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    ret = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\winetest_default\\section4", 0, KEY_READ, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-    check_registry_value(mapped_key, "name1", "value1");
-    RegCloseKey(mapped_key);
-
-    ret = RegCreateKeyExA(HKEY_LOCAL_MACHINE, "Software\\winetest_default\\section5",
-            0, NULL, 0, KEY_WRITE, NULL, &mapped_key, NULL);
-    ok(!ret, "got error %u\n", ret);
-    ret = RegSetValueExA(mapped_key, "name2", 0, REG_SZ, (BYTE *)"value2", sizeof("value2"));
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    check_profile_string("section5", "name2", "winetest.ini", "value2");
-
-    ret = GetFileAttributesA("C:/windows/winetest.ini");
-    ok(ret == INVALID_FILE_ATTRIBUTES, "winetest.ini should not exist.\n");
-
-    ret = RegDeleteKeyA(HKEY_LOCAL_MACHINE, "Software\\winetest_default\\Section4");
-    ret = RegDeleteKeyA(HKEY_LOCAL_MACHINE, "Software\\winetest_default\\Section5");
-    ret = RegDeleteKeyA(HKEY_LOCAL_MACHINE, "Software\\winetest_default");
-    ok(!ret, "got error %u\n", ret);
-    ret = RegDeleteValueA(mapping_key, NULL);
-    ok(!ret, "got error %u\n", ret);
-
-    /* Test name-specific mapping. */
-
-    ret = RegCreateKeyExA(mapping_key, "section6", 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &mapping_subkey, NULL);
-    ok(!ret, "got error %u\n", ret);
-    ret = RegSetValueExA(mapping_subkey, "name1", 0, REG_SZ, (BYTE *)"USR:winetest_name1", sizeof("USR:winetest_name1"));
-    ok(!ret, "got error %u\n", ret);
-    ret = RegSetValueExA(mapping_subkey, "name2", 0, REG_SZ, (BYTE *)"SYS:winetest_name2", sizeof("SYS:winetest_name2"));
-    ok(!ret, "got error %u\n", ret);
-    ret = WritePrivateProfileStringA(NULL, NULL, NULL, "winetest.ini");
-    todo_wine ok(ret, "got error %u\n", GetLastError());
-
-    ret = WritePrivateProfileStringA("section6", "name1", "value1", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section6", "name1", "winetest.ini", "value1");
-
-    ret = RegOpenKeyExA(HKEY_CURRENT_USER, "winetest_name1", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-    check_registry_value(mapped_key, "name1", "value1");
-
-    ret = RegSetValueExA(mapped_key, "name1", 0, REG_SZ, (BYTE *)"one", sizeof("one"));
-    ok(!ret, "got error %u\n", ret);
-    check_profile_string("section6", "name1", "winetest.ini", "one");
-
-    ret = RegDeleteKeyA(mapped_key, "");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    ret = WritePrivateProfileStringA("section6", "name2", "value2", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    ret = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\winetest_name2", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-    check_registry_value(mapped_key, "name2", "value2");
-
-    ret = RegSetValueExA(mapped_key, "name2", 0, REG_SZ, (BYTE *)"two", sizeof("two"));
-    ok(!ret, "got error %u\n", ret);
-    check_profile_string("section6", "name2", "winetest.ini", "two");
-
-    ret = RegDeleteKeyA(mapped_key, "");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    ret = WritePrivateProfileStringA("section6", "name3", "value3", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section6", "name3", "winetest.ini", "value3");
-    ret = DeleteFileA("C:/windows/winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    /* Test name-specific mapping with Get/WritePrivateProfileSection(). */
-
-    ret = WritePrivateProfileStringA("section6", "name2", "value2", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    ret = WritePrivateProfileStringA("section6", "name3", "value3", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    ret = WritePrivateProfileSectionA("section6", "name1=one\0name3=three\0", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section6", "name1", "winetest.ini", "one");
-    check_profile_string("section6", "name2", "winetest.ini", "value2");
-    check_profile_string("section6", "name3", "winetest.ini", "value3");
-
-    ret = RegOpenKeyExA(HKEY_CURRENT_USER, "winetest_name1", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-    ret = RegDeleteValueA(mapped_key, "name1");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = GetPrivateProfileSectionA("section6", buffer, 5, "winetest.ini");
-    ok(ret == 3, "got %u\n", ret);
-    ok(!memcmp(buffer, "nam\0", 5), "got %s\n", debugstr_an(buffer, ret));
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = GetPrivateProfileSectionA("section6", buffer, sizeof(buffer), "winetest.ini");
-    ok(ret == 26, "got %u\n", ret);
-    ok(!memcmp(buffer, "name2=value2\0name3=value3\0", 27), "got %s\n", debugstr_an(buffer, ret));
-
-    ret = WritePrivateProfileStringA("section6", NULL, NULL, "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section6", "name1", "winetest.ini", "default");
-    check_profile_string("section6", "name2", "winetest.ini", "default");
-    check_profile_string("section6", "name3", "winetest.ini", "default");
-
-    ret = RegDeleteKeyA(HKEY_CURRENT_USER, "winetest_name1");
-    ok(!ret, "got error %u\n", ret);
-    ret = RegDeleteKeyA(HKEY_LOCAL_MACHINE, "Software\\winetest_name2");
-    ok(!ret, "got error %u\n", ret);
-    ret = DeleteFileA("C:/windows/winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    /* Test name-specific mapping with a default value. */
-
-    ret = RegSetValueExA(mapping_subkey, NULL, 0, REG_SZ, (BYTE *)"USR:winetest_default", sizeof("USR:winetest_default"));
-    ok(!ret, "got error %u\n", ret);
-    ret = WritePrivateProfileStringA(NULL, NULL, NULL, "winetest.ini");
-    todo_wine ok(ret, "got error %u\n", GetLastError());
-
-    ret = WritePrivateProfileStringA("section6", "name2", "value2", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    ret = WritePrivateProfileStringA("section6", "name3", "value3", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-
-    ret = RegOpenKeyExA(HKEY_CURRENT_USER, "winetest_default", 0, KEY_READ | KEY_WRITE, &mapped_key);
-    ok(!ret, "got error %u\n", ret);
-    check_registry_value(mapped_key, "name3", "value3");
-
-    ret = RegSetValueExA(mapped_key, "name3", 0, REG_SZ, (BYTE *)"three", sizeof("three"));
-    ok(!ret, "got error %u\n", ret);
-    check_profile_string("section6", "name3", "winetest.ini", "three");
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = GetPrivateProfileSectionA("section6", buffer, sizeof(buffer), "winetest.ini");
-    ok(ret == 25, "got %u\n", ret);
-    todo_wine ok(!memcmp(buffer, "name2=value2\0name3=three\0", 26), "got %s\n", debugstr_an(buffer, ret));
-
-    ret = WritePrivateProfileSectionA("section6", "name2=duo\0name3=treis\0", "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section6", "name2", "winetest.ini", "duo");
-    check_profile_string("section6", "name3", "winetest.ini", "treis");
-
-    ret = WritePrivateProfileStringA("section6", NULL, NULL, "winetest.ini");
-    ok(ret, "got error %u\n", GetLastError());
-    check_profile_string("section6", "name2", "winetest.ini", "default");
-    check_profile_string("section6", "name3", "winetest.ini", "default");
-
-    ret = RegDeleteKeyA(HKEY_LOCAL_MACHINE, "Software\\winetest_name2");
-    ok(!ret, "got error %u\n", ret);
-    ret = RegDeleteKeyA(mapped_key, "");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapped_key);
-
-    ret = RegDeleteKeyA(mapping_subkey, "");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapping_subkey);
-
-    ret = RegDeleteKeyA(mapping_key, "");
-    ok(!ret, "got error %u\n", ret);
-    RegCloseKey(mapping_key);
-
-    ret = DeleteFileA("C:/windows/winetest.ini");
-    ok(!ret, "expected failure\n");
-    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "got error %u\n", GetLastError());
-    ret = RevertToSelf();
-    ok(ret, "got error %u\n", GetLastError());
-}
-
 START_TEST(profile)
 {
     test_profile_int();
@@ -1609,5 +1191,4 @@ START_TEST(profile)
         "CR only");
     test_WritePrivateProfileString();
     test_profile_struct();
-    test_registry_mapping();
 }
diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index bd9fe7fece..fdb144d00c 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -2256,9 +2256,12 @@ static void test_thread_info(void)
 #endif
 
         case ThreadTimes:
+todo_wine
             ok(status == STATUS_SUCCESS, "for info %u expected STATUS_SUCCESS, got %08x (ret_len %u)\n", i, status, ret_len);
             break;
 
+        case ThreadAffinityMask:
+        case ThreadQuerySetWin32StartAddress:
         case ThreadIsIoPending:
 todo_wine
             ok(status == STATUS_ACCESS_DENIED, "for info %u expected STATUS_ACCESS_DENIED, got %08x (ret_len %u)\n", i, status, ret_len);
diff --git a/dlls/kernelbase/console.c b/dlls/kernelbase/console.c
index a3271712d9..9a58cd516c 100644
--- a/dlls/kernelbase/console.c
+++ b/dlls/kernelbase/console.c
@@ -36,7 +36,6 @@
 #include "winnls.h"
 #include "winerror.h"
 #include "wincon.h"
-#include "wine/condrv.h"
 #include "wine/server.h"
 #include "wine/exception.h"
 #include "wine/debug.h"
@@ -55,11 +54,6 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION console_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static HANDLE console_wait_event;
-static unsigned int console_flags;
-
-#define CONSOLE_INPUT_HANDLE    0x01
-#define CONSOLE_OUTPUT_HANDLE   0x02
-#define CONSOLE_ERROR_HANDLE    0x04
 
 static WCHAR input_exe[MAX_PATH + 1];
 
@@ -79,27 +73,10 @@ static BOOL WINAPI default_ctrl_handler( DWORD type )
 static struct ctrl_handler default_handler = { default_ctrl_handler, NULL };
 static struct ctrl_handler *ctrl_handlers = &default_handler;
 
-static BOOL console_ioctl( HANDLE handle, DWORD code, void *in_buff, DWORD in_count,
-                           void *out_buff, DWORD out_count, DWORD *read )
+/* map a kernel32 console handle onto a real wineserver handle */
+static inline obj_handle_t console_handle_unmap( HANDLE h )
 {
-    IO_STATUS_BLOCK io;
-    NTSTATUS status;
-
-    status = NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io, code, in_buff, in_count,
-                                    out_buff, out_count );
-    switch( status )
-    {
-    case STATUS_SUCCESS:
-        if (read) *read = io.Information;
-        return TRUE;
-    case STATUS_INVALID_PARAMETER:
-        break;
-    default:
-        status = STATUS_INVALID_HANDLE;
-        break;
-    }
-    if (read) *read = 0;
-    return set_ntstatus( status );
+    return wine_server_obj_handle( console_handle_map( h ) );
 }
 
 /* map input records to ASCII */
@@ -133,8 +110,9 @@ static void input_records_AtoW( INPUT_RECORD *buffer, int count )
 }
 
 /* map char infos to ASCII */
-static void char_info_WtoA( UINT cp, CHAR_INFO *buffer, int count )
+static void char_info_WtoA( CHAR_INFO *buffer, int count )
 {
+    UINT cp = GetConsoleOutputCP();
     char ch;
 
     while (count-- > 0)
@@ -159,79 +137,69 @@ static void char_info_AtoW( CHAR_INFO *buffer, int count )
     }
 }
 
+/* helper function for ScrollConsoleScreenBufferW */
+static void fill_console_output( HANDLE handle, int i, int j, int len, CHAR_INFO *fill )
+{
+    SERVER_START_REQ( fill_console_output )
+    {
+        req->handle    = console_handle_unmap( handle );
+        req->mode      = CHAR_INFO_MODE_TEXTATTR;
+        req->x         = i;
+        req->y         = j;
+        req->count     = len;
+        req->wrap      = FALSE;
+        req->data.ch   = fill->Char.UnicodeChar;
+        req->data.attr = fill->Attributes;
+        wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+}
+
 /* helper function for GetLargestConsoleWindowSize */
 static COORD get_largest_console_window_size( HANDLE handle )
 {
-    struct condrv_output_info info;
     COORD c = { 0, 0 };
 
-    if (!console_ioctl( handle, IOCTL_CONDRV_GET_OUTPUT_INFO, NULL, 0, &info, sizeof(info), NULL ))
-        return c;
-
-    c.X = info.max_width;
-    c.Y = info.max_height;
+    SERVER_START_REQ( get_console_output_info )
+    {
+        req->handle = console_handle_unmap( handle );
+        if (!wine_server_call_err( req ))
+        {
+            c.X = reply->max_width;
+            c.Y = reply->max_height;
+        }
+    }
+    SERVER_END_REQ;
     TRACE( "(%p), returning %dx%d\n", handle, c.X, c.Y );
     return c;
 }
 
-static BOOL init_console_std_handles(void)
+/* helper function to replace OpenConsoleW */
+HANDLE open_console( BOOL output, DWORD access, SECURITY_ATTRIBUTES *sa, DWORD creation )
 {
-    HANDLE std_out = NULL, std_err = NULL, handle;
-    OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    IO_STATUS_BLOCK iosb;
-    UNICODE_STRING name;
-    STARTUPINFOW si;
-    NTSTATUS status;
-
-    GetStartupInfoW( &si );
-    attr.ObjectName = &name;
-    attr.Attributes = OBJ_INHERIT;
+    HANDLE ret;
 
-    if (!(si.dwFlags & STARTF_USESTDHANDLES) || !GetStdHandle( STD_INPUT_HANDLE ))
+    if (creation != OPEN_EXISTING)
     {
-        /* FIXME: Use unbound console handle */
-        RtlInitUnicodeString( &name, L"\\Device\\ConDrv\\CurrentIn" );
-        status = NtCreateFile( &handle, FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE | FILE_READ_ATTRIBUTES |
-                               FILE_WRITE_ATTRIBUTES, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL,
-                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_CREATE,
-                               FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0 );
-        if (!set_ntstatus( status )) return FALSE;
-        console_flags |= CONSOLE_INPUT_HANDLE;
-        SetStdHandle( STD_INPUT_HANDLE, console_handle_map( handle ));
-    }
-
-    if (si.dwFlags & STARTF_USESTDHANDLES)
-    {
-        std_out = GetStdHandle( STD_OUTPUT_HANDLE );
-        std_err = GetStdHandle( STD_ERROR_HANDLE );
-        if (std_out && std_err) return TRUE;
-    }
-
-    /* FIXME: Use unbound console handle */
-    RtlInitUnicodeString( &name, L"\\Device\\ConDrv\\CurrentOut" );
-    status = NtCreateFile( &handle, FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE | FILE_READ_ATTRIBUTES |
-                           FILE_WRITE_ATTRIBUTES, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL,
-                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_CREATE,
-                           FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0 );
-    if (!set_ntstatus( status )) return FALSE;
-    if (!std_out)
-    {
-        console_flags |= CONSOLE_OUTPUT_HANDLE;
-        SetStdHandle( STD_OUTPUT_HANDLE, console_handle_map( handle ));
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return INVALID_HANDLE_VALUE;
     }
 
-    if (!std_err)
+    SERVER_START_REQ( open_console )
     {
-        if (!std_out && !DuplicateHandle( GetCurrentProcess(), handle, GetCurrentProcess(),
-                                          &handle, 0, TRUE, DUPLICATE_SAME_ACCESS ))
-            return FALSE;
-        console_flags |= CONSOLE_ERROR_HANDLE;
-        SetStdHandle( STD_ERROR_HANDLE, console_handle_map( handle ));
+        req->from       = wine_server_obj_handle( ULongToHandle( output ));
+        req->access     = access;
+        req->attributes = sa && sa->bInheritHandle ? OBJ_INHERIT : 0;
+        req->share      = FILE_SHARE_READ | FILE_SHARE_WRITE;
+        wine_server_call_err( req );
+        ret = wine_server_ptr_handle( reply->handle );
     }
-
-    return TRUE;
+    SERVER_END_REQ;
+    if (ret) ret = console_handle_map( ret );
+    return ret;
 }
 
+
 /******************************************************************
  *	AttachConsole   (kernelbase.@)
  */
@@ -241,27 +209,17 @@ BOOL WINAPI DECLSPEC_HOTPATCH AttachConsole( DWORD pid )
 
     TRACE( "(%x)\n", pid );
 
-    RtlEnterCriticalSection( &console_section );
-
     SERVER_START_REQ( attach_console )
     {
         req->pid = pid;
-        ret = !wine_server_call_err( req );
-    }
-    SERVER_END_REQ;
-
-    if (ret)
-    {
-        if ((ret = init_console_std_handles()))
+        if ((ret = !wine_server_call_err( req )))
         {
-            HANDLE console = CreateFileW( L"CONIN$", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, 0, NULL, OPEN_EXISTING, 0, 0 );
-            if (console != INVALID_HANDLE_VALUE) RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle = console;
-            else ret = FALSE;
+            SetStdHandle( STD_INPUT_HANDLE,  wine_server_ptr_handle( reply->std_in ));
+            SetStdHandle( STD_OUTPUT_HANDLE, wine_server_ptr_handle( reply->std_out ));
+            SetStdHandle( STD_ERROR_HANDLE,  wine_server_ptr_handle( reply->std_err ));
         }
-        if (!ret) FreeConsole();
     }
-
-    RtlLeaveCriticalSection( &console_section );
+    SERVER_END_REQ;
     return ret;
 }
 
@@ -272,21 +230,23 @@ BOOL WINAPI DECLSPEC_HOTPATCH AttachConsole( DWORD pid )
 BOOL WINAPI AllocConsole(void)
 {
     SECURITY_ATTRIBUTES inheritable_attr = { sizeof(inheritable_attr), NULL, TRUE };
+    HANDLE std_in  = INVALID_HANDLE_VALUE;
+    HANDLE std_out = INVALID_HANDLE_VALUE;
+    HANDLE std_err = INVALID_HANDLE_VALUE;
     STARTUPINFOW app_si, console_si;
     WCHAR buffer[1024], cmd[256];
     PROCESS_INFORMATION pi;
-    HANDLE event, console;
+    HANDLE event;
+    DWORD mode;
     BOOL ret;
 
     TRACE("()\n");
 
-    RtlEnterCriticalSection( &console_section );
-
-    if (RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle)
+    std_in = CreateFileW( L"CONIN$", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, 0, NULL, OPEN_EXISTING, 0, 0 );
+    if (GetConsoleMode( std_in, &mode ))
     {
         /* we already have a console opened on this process, don't create a new one */
-        RtlLeaveCriticalSection( &console_section );
-        SetLastError( ERROR_ACCESS_DENIED );
+        CloseHandle( std_in );
         return FALSE;
     }
 
@@ -319,7 +279,7 @@ BOOL WINAPI AllocConsole(void)
         console_si.lpTitle = buffer;
     }
 
-    if (!(event = CreateEventW( &inheritable_attr, TRUE, FALSE, NULL ))) goto error;
+    if (!(event = CreateEventW( &inheritable_attr, TRUE, FALSE, NULL ))) return FALSE;
 
     swprintf( cmd, ARRAY_SIZE(cmd),  L"wineconsole --use-event=%ld", (DWORD_PTR)event );
     if ((ret = CreateProcessW( NULL, cmd, NULL, NULL, TRUE, DETACHED_PROCESS, NULL, NULL, &console_si, &pi )))
@@ -330,21 +290,42 @@ BOOL WINAPI AllocConsole(void)
         CloseHandle( pi.hProcess );
     }
     CloseHandle( event );
-    if (!ret || !init_console_std_handles()) goto error;
-    console = CreateFileW( L"CONIN$", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, 0, NULL, OPEN_EXISTING, 0, 0 );
-    if (console == INVALID_HANDLE_VALUE) goto error;
-    RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle = console;
-
+    if (!ret) goto error;
     TRACE( "Started wineconsole pid=%08x tid=%08x\n", pi.dwProcessId, pi.dwThreadId );
 
-    RtlLeaveCriticalSection( &console_section );
+    if (!(app_si.dwFlags & STARTF_USESTDHANDLES))
+    {
+
+        std_in = CreateFileW( L"CONIN$", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, 0, &inheritable_attr,
+                              OPEN_EXISTING, 0, 0);
+        if (std_in == INVALID_HANDLE_VALUE) goto error;
+
+        std_out = CreateFileW( L"CONOUT$", GENERIC_READ | GENERIC_WRITE, 0, &inheritable_attr, OPEN_EXISTING, 0, 0);
+        if (std_out == INVALID_HANDLE_VALUE) goto error;
+
+        if (!DuplicateHandle( GetCurrentProcess(), std_out, GetCurrentProcess(),
+                              &std_err, 0, TRUE, DUPLICATE_SAME_ACCESS) )
+            goto error;
+    }
+    else
+    {
+        std_in  = app_si.hStdInput;
+        std_out = app_si.hStdOutput;
+        std_err = app_si.hStdError;
+    }
+
+    SetStdHandle( STD_INPUT_HANDLE,  std_in );
+    SetStdHandle( STD_OUTPUT_HANDLE, std_out );
+    SetStdHandle( STD_ERROR_HANDLE,  std_err );
     SetLastError( ERROR_SUCCESS );
     return TRUE;
 
 error:
     ERR("Can't allocate console\n");
+    if (std_in != INVALID_HANDLE_VALUE)  CloseHandle(std_in);
+    if (std_out != INVALID_HANDLE_VALUE) CloseHandle(std_out);
+    if (std_err != INVALID_HANDLE_VALUE) CloseHandle(std_err);
     FreeConsole();
-    RtlLeaveCriticalSection( &console_section );
     return FALSE;
 }
 
@@ -356,11 +337,7 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateConsoleScreenBuffer( DWORD access, DWORD s
                                                            SECURITY_ATTRIBUTES *sa, DWORD flags,
                                                            void *data )
 {
-    OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    IO_STATUS_BLOCK iosb;
-    UNICODE_STRING name;
-    HANDLE handle;
-    NTSTATUS status;
+    HANDLE ret = INVALID_HANDLE_VALUE;
 
     TRACE( "(%x,%x,%p,%x,%p)\n", access, share, sa, flags, data );
 
@@ -370,13 +347,18 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateConsoleScreenBuffer( DWORD access, DWORD s
 	return INVALID_HANDLE_VALUE;
     }
 
-    RtlInitUnicodeString( &name, L"\\Device\\ConDrv\\ScreenBuffer" );
-    attr.ObjectName = &name;
-    attr.SecurityDescriptor = sa ? sa->lpSecurityDescriptor : NULL;
-    if (sa && sa->bInheritHandle) attr.Attributes |= OBJ_INHERIT;
-    status = NtCreateFile( &handle, access, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
-                           FILE_NON_DIRECTORY_FILE, NULL, 0 );
-    return set_ntstatus( status ) ? handle : INVALID_HANDLE_VALUE;
+    SERVER_START_REQ( create_console_output )
+    {
+        req->handle_in  = 0;
+        req->access     = access;
+        req->attributes = (sa && sa->bInheritHandle) ? OBJ_INHERIT : 0;
+        req->share      = share;
+        req->fd         = -1;
+        if (!wine_server_call_err( req ))
+            ret = console_handle_map( wine_server_ptr_handle( reply->handle_out ));
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -419,27 +401,13 @@ DWORD WINAPI CtrlRoutine( void *arg )
 }
 
 
-static LONG WINAPI handle_ctrl_c( EXCEPTION_POINTERS *eptr )
-{
-    if (eptr->ExceptionRecord->ExceptionCode != CONTROL_C_EXIT) return EXCEPTION_CONTINUE_SEARCH;
-    if (!RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle)  return EXCEPTION_CONTINUE_SEARCH;
-
-    if (!(NtCurrentTeb()->Peb->ProcessParameters->ConsoleFlags & 1))
-    {
-        HANDLE thread = CreateThread( NULL, 0, CtrlRoutine, (void*)CTRL_C_EVENT, 0, NULL );
-        if (thread) CloseHandle( thread );
-    }
-    return EXCEPTION_CONTINUE_EXECUTION;
-}
-
-
 /******************************************************************************
  *	FillConsoleOutputAttribute   (kernelbase.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH FillConsoleOutputAttribute( HANDLE handle, WORD attr, DWORD length,
                                                            COORD coord, DWORD *written )
 {
-    struct condrv_fill_output_params params;
+    BOOL ret;
 
     TRACE( "(%p,%d,%d,(%dx%d),%p)\n", handle, attr, length, coord.X, coord.Y, written );
 
@@ -450,16 +418,19 @@ BOOL WINAPI DECLSPEC_HOTPATCH FillConsoleOutputAttribute( HANDLE handle, WORD at
     }
 
     *written = 0;
-
-    params.mode  = CHAR_INFO_MODE_ATTR;
-    params.x     = coord.X;
-    params.y     = coord.Y;
-    params.count = length;
-    params.wrap  = TRUE;
-    params.ch    = 0;
-    params.attr  = attr;
-    return console_ioctl( handle, IOCTL_CONDRV_FILL_OUTPUT, &params, sizeof(params),
-                          written, sizeof(*written), NULL );
+    SERVER_START_REQ( fill_console_output )
+    {
+        req->handle    = console_handle_unmap( handle );
+        req->x         = coord.X;
+        req->y         = coord.Y;
+        req->mode      = CHAR_INFO_MODE_ATTR;
+        req->wrap      = TRUE;
+        req->data.attr = attr;
+        req->count     = length;
+        if ((ret = !wine_server_call_err( req ))) *written = reply->written;
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -482,7 +453,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH FillConsoleOutputCharacterA( HANDLE handle, CHAR c
 BOOL WINAPI DECLSPEC_HOTPATCH FillConsoleOutputCharacterW( HANDLE handle, WCHAR ch, DWORD length,
                                                            COORD coord, DWORD *written )
 {
-    struct condrv_fill_output_params params;
+    BOOL ret;
 
     TRACE( "(%p,%s,%d,(%dx%d),%p)\n", handle, debugstr_wn(&ch, 1), length, coord.X, coord.Y, written );
 
@@ -493,16 +464,19 @@ BOOL WINAPI DECLSPEC_HOTPATCH FillConsoleOutputCharacterW( HANDLE handle, WCHAR
     }
 
     *written = 0;
-
-    params.mode  = CHAR_INFO_MODE_TEXT;
-    params.x     = coord.X;
-    params.y     = coord.Y;
-    params.count = length;
-    params.wrap  = TRUE;
-    params.ch    = ch;
-    params.attr  = 0;
-    return console_ioctl( handle, IOCTL_CONDRV_FILL_OUTPUT, &params, sizeof(params),
-                          written, sizeof(*written), NULL );
+    SERVER_START_REQ( fill_console_output )
+    {
+        req->handle  = console_handle_unmap( handle );
+        req->x       = coord.X;
+        req->y       = coord.Y;
+        req->mode    = CHAR_INFO_MODE_TEXT;
+        req->wrap    = TRUE;
+        req->data.ch = ch;
+        req->count   = length;
+        if ((ret = !wine_server_call_err( req ))) *written = reply->written;
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 HANDLE get_console_wait_handle( HANDLE handle )
@@ -532,24 +506,12 @@ BOOL WINAPI DECLSPEC_HOTPATCH FreeConsole(void)
     HANDLE event;
     BOOL ret;
 
-    RtlEnterCriticalSection( &console_section );
-
-    NtClose( RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle );
-    RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle = NULL;
-
-    if (console_flags & CONSOLE_INPUT_HANDLE)  NtClose( GetStdHandle( STD_INPUT_HANDLE ));
-    if (console_flags & CONSOLE_OUTPUT_HANDLE) NtClose( GetStdHandle( STD_OUTPUT_HANDLE ));
-    if (console_flags & CONSOLE_ERROR_HANDLE)  NtClose( GetStdHandle( STD_ERROR_HANDLE ));
-    console_flags = 0;
-
     SERVER_START_REQ( free_console )
     {
         ret = !wine_server_call_err( req );
     }
     SERVER_END_REQ;
     if ((event = InterlockedExchangePointer( &console_wait_event, NULL ))) NtClose( event );
-
-    RtlLeaveCriticalSection( &console_section );
     return ret;
 }
 
@@ -585,12 +547,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH GenerateConsoleCtrlEvent( DWORD event, DWORD group
  */
 UINT WINAPI DECLSPEC_HOTPATCH GetConsoleCP(void)
 {
-    struct condrv_input_info info;
+    UINT codepage = GetOEMCP(); /* default value */
 
-    if (!console_ioctl( RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle,
-                         IOCTL_CONDRV_GET_INPUT_INFO, NULL, 0, &info, sizeof(info), NULL ))
-        return 0;
-    return info.input_cp ? info.input_cp : GetOEMCP();
+    SERVER_START_REQ( get_console_input_info )
+    {
+        req->handle = 0;
+        if (!wine_server_call_err( req ))
+        {
+            if (reply->input_cp) codepage = reply->input_cp;
+        }
+    }
+    SERVER_END_REQ;
+    return codepage;
 }
 
 
@@ -599,19 +567,26 @@ UINT WINAPI DECLSPEC_HOTPATCH GetConsoleCP(void)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleCursorInfo( HANDLE handle, CONSOLE_CURSOR_INFO *info )
 {
-    struct condrv_output_info condrv_info;
+    BOOL ret;
 
-    if (!console_ioctl( handle, IOCTL_CONDRV_GET_OUTPUT_INFO, NULL, 0, &condrv_info, sizeof(condrv_info), NULL ))
-        return FALSE;
+    SERVER_START_REQ( get_console_output_info )
+    {
+        req->handle = console_handle_unmap( handle );
+        ret = !wine_server_call_err( req );
+        if (ret && info)
+        {
+            info->dwSize = reply->cursor_size;
+            info->bVisible = reply->cursor_visible;
+        }
+    }
+    SERVER_END_REQ;
 
+    if (!ret) return FALSE;
     if (!info)
     {
         SetLastError( ERROR_INVALID_ACCESS );
         return FALSE;
     }
-
-    info->dwSize   = condrv_info.cursor_size;
-    info->bVisible = condrv_info.cursor_visible;
     TRACE("(%p) returning (%d,%d)\n", handle, info->dwSize, info->bVisible);
     return TRUE;
 }
@@ -649,7 +624,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleInputExeNameW( DWORD len, LPWSTR buffer
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleMode( HANDLE handle, DWORD *mode )
 {
-    return console_ioctl( handle, IOCTL_CONDRV_GET_MODE, NULL, 0, mode, sizeof(*mode), NULL );
+    BOOL ret;
+
+    SERVER_START_REQ( get_console_mode )
+    {
+        req->handle = console_handle_unmap( handle );
+        if ((ret = !wine_server_call_err( req )))
+        {
+            if (mode) *mode = reply->mode;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -658,12 +644,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleMode( HANDLE handle, DWORD *mode )
  */
 UINT WINAPI DECLSPEC_HOTPATCH GetConsoleOutputCP(void)
 {
-    struct condrv_input_info info;
+    UINT codepage = GetOEMCP(); /* default value */
 
-    if (!console_ioctl( RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle,
-                         IOCTL_CONDRV_GET_INPUT_INFO, NULL, 0, &info, sizeof(info), NULL ))
-        return 0;
-    return info.output_cp ? info.output_cp : GetOEMCP();
+    SERVER_START_REQ( get_console_input_info )
+    {
+        req->handle = 0;
+        if (!wine_server_call_err( req ))
+        {
+            if (reply->output_cp) codepage = reply->output_cp;
+        }
+    }
+    SERVER_END_REQ;
+    return codepage;
 }
 
 
@@ -672,29 +664,33 @@ UINT WINAPI DECLSPEC_HOTPATCH GetConsoleOutputCP(void)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleScreenBufferInfo( HANDLE handle, CONSOLE_SCREEN_BUFFER_INFO *info )
 {
-    struct condrv_output_info condrv_info;
-
-    if (!console_ioctl( handle , IOCTL_CONDRV_GET_OUTPUT_INFO, NULL, 0,
-                        &condrv_info, sizeof(condrv_info), NULL ))
-        return FALSE;
+    BOOL ret;
 
-    info->dwSize.X              = condrv_info.width;
-    info->dwSize.Y              = condrv_info.height;
-    info->dwCursorPosition.X    = condrv_info.cursor_x;
-    info->dwCursorPosition.Y    = condrv_info.cursor_y;
-    info->wAttributes           = condrv_info.attr;
-    info->srWindow.Left         = condrv_info.win_left;
-    info->srWindow.Right        = condrv_info.win_right;
-    info->srWindow.Top          = condrv_info.win_top;
-    info->srWindow.Bottom       = condrv_info.win_bottom;
-    info->dwMaximumWindowSize.X = min(condrv_info.width, condrv_info.max_width);
-    info->dwMaximumWindowSize.Y = min(condrv_info.height, condrv_info.max_height);
+    SERVER_START_REQ( get_console_output_info )
+    {
+        req->handle = console_handle_unmap( handle );
+        if ((ret = !wine_server_call_err( req )))
+        {
+            info->dwSize.X              = reply->width;
+            info->dwSize.Y              = reply->height;
+            info->dwCursorPosition.X    = reply->cursor_x;
+            info->dwCursorPosition.Y    = reply->cursor_y;
+            info->wAttributes           = reply->attr;
+            info->srWindow.Left         = reply->win_left;
+            info->srWindow.Right        = reply->win_right;
+            info->srWindow.Top          = reply->win_top;
+            info->srWindow.Bottom       = reply->win_bottom;
+            info->dwMaximumWindowSize.X = min(reply->width, reply->max_width);
+            info->dwMaximumWindowSize.Y = min(reply->height, reply->max_height);
+        }
+    }
+    SERVER_END_REQ;
 
     TRACE( "(%p,(%d,%d) (%d,%d) %d (%d,%d-%d,%d) (%d,%d)\n", handle,
            info->dwSize.X, info->dwSize.Y, info->dwCursorPosition.X, info->dwCursorPosition.Y,
-           info->wAttributes, info->srWindow.Left, info->srWindow.Top, info->srWindow.Right,
+	  info->wAttributes, info->srWindow.Left, info->srWindow.Top, info->srWindow.Right,
            info->srWindow.Bottom, info->dwMaximumWindowSize.X, info->dwMaximumWindowSize.Y );
-    return TRUE;
+    return ret;
 }
 
 
@@ -704,7 +700,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleScreenBufferInfo( HANDLE handle, CONSOLE
 BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleScreenBufferInfoEx( HANDLE handle,
                                                             CONSOLE_SCREEN_BUFFER_INFOEX *info )
 {
-    struct condrv_output_info condrv_info;
+    BOOL ret;
 
     if (info->cbSize != sizeof(CONSOLE_SCREEN_BUFFER_INFOEX))
     {
@@ -712,25 +708,29 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleScreenBufferInfoEx( HANDLE handle,
         return FALSE;
     }
 
-    if (!console_ioctl( handle, IOCTL_CONDRV_GET_OUTPUT_INFO, NULL, 0, &condrv_info,
-                        sizeof(condrv_info), NULL ))
-        return FALSE;
-
-    info->dwSize.X              = condrv_info.width;
-    info->dwSize.Y              = condrv_info.height;
-    info->dwCursorPosition.X    = condrv_info.cursor_x;
-    info->dwCursorPosition.Y    = condrv_info.cursor_y;
-    info->wAttributes           = condrv_info.attr;
-    info->srWindow.Left         = condrv_info.win_left;
-    info->srWindow.Top          = condrv_info.win_top;
-    info->srWindow.Right        = condrv_info.win_right;
-    info->srWindow.Bottom       = condrv_info.win_bottom;
-    info->dwMaximumWindowSize.X = min( condrv_info.width, condrv_info.max_width );
-    info->dwMaximumWindowSize.Y = min( condrv_info.height, condrv_info.max_height );
-    info->wPopupAttributes      = condrv_info.popup_attr;
-    info->bFullscreenSupported  = FALSE;
-    memcpy( info->ColorTable, condrv_info.color_map, sizeof(info->ColorTable) );
-    return TRUE;
+    SERVER_START_REQ( get_console_output_info )
+    {
+        req->handle = console_handle_unmap( handle );
+        wine_server_set_reply( req, info->ColorTable, sizeof(info->ColorTable) );
+        if ((ret = !wine_server_call_err( req )))
+        {
+            info->dwSize.X              = reply->width;
+            info->dwSize.Y              = reply->height;
+            info->dwCursorPosition.X    = reply->cursor_x;
+            info->dwCursorPosition.Y    = reply->cursor_y;
+            info->wAttributes           = reply->attr;
+            info->srWindow.Left         = reply->win_left;
+            info->srWindow.Top          = reply->win_top;
+            info->srWindow.Right        = reply->win_right;
+            info->srWindow.Bottom       = reply->win_bottom;
+            info->dwMaximumWindowSize.X = min( reply->width, reply->max_width );
+            info->dwMaximumWindowSize.Y = min( reply->height, reply->max_height );
+            info->wPopupAttributes      = reply->popup_attr;
+            info->bFullscreenSupported  = FALSE;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -739,15 +739,20 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleScreenBufferInfoEx( HANDLE handle,
  */
 DWORD WINAPI DECLSPEC_HOTPATCH GetConsoleTitleW( LPWSTR title, DWORD size )
 {
-    if (!size) return 0;
-
-    if (!console_ioctl( RtlGetCurrentPeb()->ProcessParameters->ConsoleHandle, IOCTL_CONDRV_GET_TITLE,
-                        NULL, 0, title, (size - 1) * sizeof(WCHAR), &size ))
-        return 0;
+    DWORD ret = 0;
 
-    size /= sizeof(WCHAR);
-    title[size] = 0;
-    return size + 1;
+    SERVER_START_REQ( get_console_input_info )
+    {
+        req->handle = 0;
+        wine_server_set_reply( req, title, (size - 1) * sizeof(WCHAR) );
+        if (!wine_server_call_err( req ))
+        {
+            ret = wine_server_reply_size(reply) / sizeof(WCHAR);
+            title[ret] = 0;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -781,11 +786,24 @@ COORD WINAPI DECLSPEC_HOTPATCH GetLargestConsoleWindowSize( HANDLE handle )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetNumberOfConsoleInputEvents( HANDLE handle, DWORD *count )
 {
-    struct condrv_input_info info;
-    if (!console_ioctl( handle, IOCTL_CONDRV_GET_INPUT_INFO, NULL, 0, &info, sizeof(info), NULL ))
-        return FALSE;
-    *count = info.input_count;
-    return TRUE;
+    BOOL ret;
+
+    SERVER_START_REQ( read_console_input )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->flush  = FALSE;
+        if ((ret = !wine_server_call_err( req )))
+        {
+            if (count) *count = reply->read;
+            else
+            {
+                SetLastError( ERROR_INVALID_ACCESS );
+                ret = FALSE;
+            }
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -810,11 +828,20 @@ BOOL WINAPI DECLSPEC_HOTPATCH PeekConsoleInputA( HANDLE handle, INPUT_RECORD *bu
 BOOL WINAPI DECLSPEC_HOTPATCH PeekConsoleInputW( HANDLE handle, INPUT_RECORD *buffer,
                                                  DWORD length, DWORD *count )
 {
-    DWORD read;
-    if (!console_ioctl( handle, IOCTL_CONDRV_PEEK, NULL, 0, buffer, length * sizeof(*buffer), &read ))
-        return FALSE;
-    if (count) *count = read / sizeof(*buffer);
-    return TRUE;
+    BOOL ret;
+
+    SERVER_START_REQ( read_console_input )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->flush  = FALSE;
+        wine_server_set_reply( req, buffer, length * sizeof(INPUT_RECORD) );
+        if ((ret = !wine_server_call_err( req )))
+        {
+            if (count) *count = length ? reply->read : 0;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -824,7 +851,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH PeekConsoleInputW( HANDLE handle, INPUT_RECORD *bu
 BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputAttribute( HANDLE handle, WORD *attr, DWORD length,
                                                           COORD coord, DWORD *count )
 {
-    struct condrv_output_params params;
     BOOL ret;
 
     TRACE( "(%p,%p,%d,%dx%d,%p)\n", handle, attr, length, coord.X, coord.Y, count );
@@ -835,13 +861,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputAttribute( HANDLE handle, WORD *a
         return FALSE;
     }
 
-    params.mode  = CHAR_INFO_MODE_ATTR;
-    params.x     = coord.X;
-    params.y     = coord.Y;
-    params.width = 0;
-    ret = console_ioctl( handle, IOCTL_CONDRV_READ_OUTPUT, &params, sizeof(params),
-                         attr, length * sizeof(*attr), count );
-    *count /= sizeof(*attr);
+    *count = 0;
+    SERVER_START_REQ( read_console_output )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->x      = coord.X;
+        req->y      = coord.Y;
+        req->mode   = CHAR_INFO_MODE_ATTR;
+        req->wrap   = TRUE;
+        wine_server_set_reply( req, attr, length * sizeof(WORD) );
+        if ((ret = !wine_server_call_err( req ))) *count = wine_server_reply_size(reply) / sizeof(WORD);
+    }
+    SERVER_END_REQ;
     return ret;
 }
 
@@ -884,7 +915,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputCharacterA( HANDLE handle, LPSTR
 BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputCharacterW( HANDLE handle, LPWSTR buffer, DWORD length,
                                                            COORD coord, DWORD *count )
 {
-    struct condrv_output_params params;
     BOOL ret;
 
     TRACE( "(%p,%p,%d,%dx%d,%p)\n", handle, buffer, length, coord.X, coord.Y, count );
@@ -895,13 +925,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputCharacterW( HANDLE handle, LPWSTR
         return FALSE;
     }
 
-    params.mode  = CHAR_INFO_MODE_TEXT;
-    params.x     = coord.X;
-    params.y     = coord.Y;
-    params.width = 0;
-    ret = console_ioctl( handle, IOCTL_CONDRV_READ_OUTPUT, &params, sizeof(params), buffer,
-                         length * sizeof(*buffer), count );
-    *count /= sizeof(*buffer);
+    *count = 0;
+    SERVER_START_REQ( read_console_output )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->x      = coord.X;
+        req->y      = coord.Y;
+        req->mode   = CHAR_INFO_MODE_TEXT;
+        req->wrap   = TRUE;
+        wine_server_set_reply( req, buffer, length * sizeof(WCHAR) );
+        if ((ret = !wine_server_call_err( req ))) *count = wine_server_reply_size(reply) / sizeof(WCHAR);
+    }
+    SERVER_END_REQ;
     return ret;
 }
 
@@ -918,9 +953,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputA( HANDLE handle, CHAR_INFO *buff
     ret = ReadConsoleOutputW( handle, buffer, size, coord, region );
     if (ret && region->Right >= region->Left)
     {
-        UINT cp = GetConsoleOutputCP();
         for (y = 0; y <= region->Bottom - region->Top; y++)
-            char_info_WtoA( cp, &buffer[(coord.Y + y) * size.X + coord.X], region->Right - region->Left + 1 );
+            char_info_WtoA( &buffer[(coord.Y + y) * size.X + coord.X], region->Right - region->Left + 1 );
     }
     return ret;
 }
@@ -932,50 +966,39 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputA( HANDLE handle, CHAR_INFO *buff
 BOOL WINAPI DECLSPEC_HOTPATCH ReadConsoleOutputW( HANDLE handle, CHAR_INFO *buffer, COORD size,
                                                   COORD coord, SMALL_RECT *region )
 {
-    struct condrv_output_params params;
-    unsigned int width, height, y;
-    SMALL_RECT *result;
-    DWORD count;
-    BOOL ret;
+    int width, height, y;
+    BOOL ret = TRUE;
 
-    if (region->Left > region->Right || region->Top > region->Bottom)
-    {
-        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-        return FALSE;
-    }
-    if (size.X <= coord.X || size.Y <= coord.Y)
-    {
-        region->Right  = region->Left - 1;
-        region->Bottom = region->Top - 1;
-        SetLastError( ERROR_INVALID_FUNCTION );
-        return FALSE;
-    }
     width = min( region->Right - region->Left + 1, size.X - coord.X );
     height = min( region->Bottom - region->Top + 1, size.Y - coord.Y );
     region->Right = region->Left + width - 1;
     region->Bottom = region->Top + height - 1;
 
-    count = sizeof(*result) + width * height * sizeof(*buffer);
-    if (!(result = HeapAlloc( GetProcessHeap(), 0, count )))
+    if (width > 0 && height > 0)
     {
-        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-        return FALSE;
-    }
-
-    params.mode  = CHAR_INFO_MODE_TEXTATTR;
-    params.x     = region->Left;
-    params.y     = region->Top;
-    params.width = width;
-    if ((ret = console_ioctl( handle, IOCTL_CONDRV_READ_OUTPUT, &params, sizeof(params), result, count, &count )) && count)
-    {
-        CHAR_INFO *char_info = (CHAR_INFO *)(result + 1);
-        *region = *result;
-        width  = region->Right - region->Left + 1;
-        height = region->Bottom - region->Top + 1;
         for (y = 0; y < height; y++)
-            memcpy( &buffer[(y + coord.Y) * size.X + coord.X], &char_info[y * width], width * sizeof(*buffer) );
+        {
+            SERVER_START_REQ( read_console_output )
+            {
+                req->handle = console_handle_unmap( handle );
+                req->x      = region->Left;
+                req->y      = region->Top + y;
+                req->mode   = CHAR_INFO_MODE_TEXTATTR;
+                req->wrap   = FALSE;
+                wine_server_set_reply( req, &buffer[(y+coord.Y) * size.X + coord.X],
+                                       width * sizeof(CHAR_INFO) );
+                if ((ret = !wine_server_call_err( req )))
+                {
+                    width  = min( width, reply->width - region->Left );
+                    height = min( height, reply->height - region->Top );
+                }
+            }
+            SERVER_END_REQ;
+            if (!ret) break;
+        }
     }
-    HeapFree( GetProcessHeap(), 0, result );
+    region->Bottom = region->Top + height - 1;
+    region->Right = region->Left + width - 1;
     return ret;
 }
 
@@ -1002,7 +1025,12 @@ BOOL WINAPI DECLSPEC_HOTPATCH ScrollConsoleScreenBufferW( HANDLE handle, const S
                                                           const SMALL_RECT *clip_rect, COORD origin,
                                                           const CHAR_INFO *fill )
 {
-    struct condrv_scroll_params params;
+    CONSOLE_SCREEN_BUFFER_INFO info;
+    SMALL_RECT dst, clip;
+    int i, j, start = -1;
+    DWORD ret;
+    BOOL inside;
+    COORD src;
 
     if (clip_rect)
 	TRACE( "(%p,(%d,%d-%d,%d),(%d,%d-%d,%d),%d-%d,%p)\n", handle,
@@ -1014,17 +1042,85 @@ BOOL WINAPI DECLSPEC_HOTPATCH ScrollConsoleScreenBufferW( HANDLE handle, const S
 	      scroll->Left, scroll->Top, scroll->Right, scroll->Bottom,
 	      origin.X, origin.Y, fill );
 
-    params.scroll    = *scroll;
-    params.origin    = origin;
-    params.fill.ch   = fill->Char.UnicodeChar;
-    params.fill.attr = fill->Attributes;
-    if (!clip_rect)
+    if (!GetConsoleScreenBufferInfo( handle, &info )) return FALSE;
+
+    src.X = scroll->Left;
+    src.Y = scroll->Top;
+
+    /* step 1: get dst rect */
+    dst.Left = origin.X;
+    dst.Top = origin.Y;
+    dst.Right = dst.Left + (scroll->Right - scroll->Left);
+    dst.Bottom = dst.Top + (scroll->Bottom - scroll->Top);
+
+    /* step 2a: compute the final clip rect (optional passed clip and screen buffer limits */
+    if (clip_rect)
     {
-        params.clip.Left = params.clip.Top = 0;
-        params.clip.Right = params.clip.Bottom = SHRT_MAX;
+	clip.Left   = max(0, clip_rect->Left);
+	clip.Right  = min(info.dwSize.X - 1, clip_rect->Right);
+	clip.Top    = max(0, clip_rect->Top);
+	clip.Bottom = min(info.dwSize.Y - 1, clip_rect->Bottom);
     }
-    else params.clip = *clip_rect;
-    return console_ioctl( handle, IOCTL_CONDRV_SCROLL, (void *)&params, sizeof(params), NULL, 0, NULL );
+    else
+    {
+	clip.Left   = 0;
+	clip.Right  = info.dwSize.X - 1;
+	clip.Top    = 0;
+	clip.Bottom = info.dwSize.Y - 1;
+    }
+    if (clip.Left > clip.Right || clip.Top > clip.Bottom) return FALSE;
+
+    /* step 2b: clip dst rect */
+    if (dst.Left   < clip.Left  ) {src.X += clip.Left - dst.Left; dst.Left   = clip.Left;}
+    if (dst.Top    < clip.Top   ) {src.Y += clip.Top  - dst.Top;  dst.Top    = clip.Top;}
+    if (dst.Right  > clip.Right ) dst.Right  = clip.Right;
+    if (dst.Bottom > clip.Bottom) dst.Bottom = clip.Bottom;
+
+    /* step 3: transfer the bits */
+    SERVER_START_REQ( move_console_output )
+    {
+        req->handle = console_handle_unmap( handle );
+	req->x_src = src.X;
+	req->y_src = src.Y;
+	req->x_dst = dst.Left;
+	req->y_dst = dst.Top;
+	req->w = dst.Right - dst.Left + 1;
+	req->h = dst.Bottom - dst.Top + 1;
+	ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+
+    if (!ret) return FALSE;
+
+    /* step 4: clean out the exposed part */
+
+    /* have to write cell [i,j] if it is not in dst rect (because it has already
+     * been written to by the scroll) and is in clip (we shall not write
+     * outside of clip)
+     */
+    for (j = max(scroll->Top, clip.Top); j <= min(scroll->Bottom, clip.Bottom); j++)
+    {
+	inside = dst.Top <= j && j <= dst.Bottom;
+	start = -1;
+	for (i = max(scroll->Left, clip.Left); i <= min(scroll->Right, clip.Right); i++)
+	{
+	    if (inside && dst.Left <= i && i <= dst.Right)
+	    {
+		if (start != -1)
+		{
+		    fill_console_output( handle, start, j, i - start, fill );
+		    start = -1;
+		}
+	    }
+	    else
+	    {
+		if (start == -1) start = i;
+	    }
+	}
+	if (start != -1) fill_console_output( handle, start, j, i - start, fill );
+    }
+
+    return TRUE;
 }
 
 
@@ -1033,8 +1129,19 @@ BOOL WINAPI DECLSPEC_HOTPATCH ScrollConsoleScreenBufferW( HANDLE handle, const S
  */
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleActiveScreenBuffer( HANDLE handle )
 {
+    BOOL ret;
+
     TRACE( "(%p)\n", handle );
-    return console_ioctl( handle, IOCTL_CONDRV_ACTIVATE, NULL, 0, NULL, 0, NULL );
+
+    SERVER_START_REQ( set_console_input_info )
+    {
+        req->handle    = 0;
+        req->mask      = SET_CONSOLE_INPUT_INFO_ACTIVE_SB;
+        req->active_sb = wine_server_obj_handle( handle );
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -1118,14 +1225,20 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleCtrlHandler( PHANDLER_ROUTINE func, BOOL
  */
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleCursorInfo( HANDLE handle, CONSOLE_CURSOR_INFO *info )
 {
-    struct condrv_output_info_params params = { SET_CONSOLE_OUTPUT_INFO_CURSOR_GEOM };
+    BOOL ret;
 
     TRACE( "(%p,%d,%d)\n", handle, info->dwSize, info->bVisible);
 
-    params.info.cursor_size    = info->dwSize;
-    params.info.cursor_visible = info->bVisible;
-    return console_ioctl( handle, IOCTL_CONDRV_SET_OUTPUT_INFO, &params, sizeof(params),
-                          NULL, 0, NULL );
+    SERVER_START_REQ( set_console_output_info )
+    {
+        req->handle         = console_handle_unmap( handle );
+        req->cursor_size    = info->dwSize;
+        req->cursor_visible = info->bVisible;
+        req->mask           = SET_CONSOLE_OUTPUT_INFO_CURSOR_GEOM;
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -1134,18 +1247,23 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleCursorInfo( HANDLE handle, CONSOLE_CURSO
  */
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleCursorPosition( HANDLE handle, COORD pos )
 {
-    struct condrv_output_info_params params = { SET_CONSOLE_OUTPUT_INFO_CURSOR_POS };
     CONSOLE_SCREEN_BUFFER_INFO info;
     int w, h, do_move = 0;
+    BOOL ret;
 
     TRACE( "%p %d %d\n", handle, pos.X, pos.Y );
 
-    params.info.cursor_x = pos.X;
-    params.info.cursor_y = pos.Y;
-    if (!console_ioctl( handle, IOCTL_CONDRV_SET_OUTPUT_INFO, &params, sizeof(params), NULL, 0, NULL ))
-        return FALSE;
+    SERVER_START_REQ( set_console_output_info )
+    {
+        req->handle         = console_handle_unmap( handle );
+        req->cursor_x       = pos.X;
+        req->cursor_y       = pos.Y;
+        req->mask           = SET_CONSOLE_OUTPUT_INFO_CURSOR_POS;
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
 
-    if (!GetConsoleScreenBufferInfo( handle, &info )) return FALSE;
+    if (!ret || !GetConsoleScreenBufferInfo( handle, &info )) return FALSE;
 
     /* if cursor is no longer visible, scroll the visible window... */
     w = info.srWindow.Right - info.srWindow.Left + 1;
@@ -1174,7 +1292,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleCursorPosition( HANDLE handle, COORD pos
     }
     info.srWindow.Bottom = info.srWindow.Top + h - 1;
 
-    return !do_move || SetConsoleWindowInfo( handle, TRUE, &info.srWindow );
+    if (do_move) ret = SetConsoleWindowInfo( handle, TRUE, &info.srWindow );
+    return ret;
 }
 
 
@@ -1217,8 +1336,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleInputExeNameW( LPCWSTR name )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleMode( HANDLE handle, DWORD mode )
 {
-    TRACE( "(%p,%x)\n", handle, mode );
-    return console_ioctl( handle, IOCTL_CONDRV_SET_MODE, &mode, sizeof(mode), NULL, 0, NULL );
+    BOOL ret;
+
+    SERVER_START_REQ(set_console_mode)
+    {
+	req->handle = console_handle_unmap( handle );
+	req->mode = mode;
+	ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+
+    TRACE( "(%p,%x) retval == %d\n", handle, mode, ret );
+    return ret;
 }
 
 
@@ -1252,10 +1381,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleOutputCP( UINT cp )
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleScreenBufferInfoEx( HANDLE handle,
                                                             CONSOLE_SCREEN_BUFFER_INFOEX *info )
 {
-    struct condrv_output_info_params params =
-        { SET_CONSOLE_OUTPUT_INFO_CURSOR_POS | SET_CONSOLE_OUTPUT_INFO_SIZE |
-          SET_CONSOLE_OUTPUT_INFO_ATTR | SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR |
-          SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW | SET_CONSOLE_OUTPUT_INFO_MAX_SIZE };
+    BOOL ret;
 
     TRACE("(%p, %p)\n", handle, info);
 
@@ -1265,19 +1391,29 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleScreenBufferInfoEx( HANDLE handle,
         return FALSE;
     }
 
-    params.info.width      = info->dwSize.X;
-    params.info.height     = info->dwSize.Y;
-    params.info.cursor_x   = info->dwCursorPosition.X;
-    params.info.cursor_y   = info->dwCursorPosition.Y;
-    params.info.attr       = info->wAttributes;
-    params.info.win_left   = info->srWindow.Left;
-    params.info.win_top    = info->srWindow.Top;
-    params.info.win_right  = info->srWindow.Right;
-    params.info.win_bottom = info->srWindow.Bottom;
-    params.info.popup_attr = info->wPopupAttributes;
-    params.info.max_width  = min( info->dwMaximumWindowSize.X, info->dwSize.X );
-    params.info.max_height = min( info->dwMaximumWindowSize.Y, info->dwSize.Y );
-    return console_ioctl( handle, IOCTL_CONDRV_SET_OUTPUT_INFO, &params, sizeof(params), NULL, 0, NULL );
+    SERVER_START_REQ( set_console_output_info )
+    {
+        req->handle     = console_handle_unmap( handle );
+        req->mask       = SET_CONSOLE_OUTPUT_INFO_CURSOR_POS | SET_CONSOLE_OUTPUT_INFO_SIZE |
+                          SET_CONSOLE_OUTPUT_INFO_ATTR | SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR |
+                          SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW | SET_CONSOLE_OUTPUT_INFO_MAX_SIZE;
+        req->width      = info->dwSize.X;
+        req->height     = info->dwSize.Y;
+        req->cursor_x   = info->dwCursorPosition.X;
+        req->cursor_y   = info->dwCursorPosition.Y;
+        req->attr       = info->wAttributes;
+        req->win_left   = info->srWindow.Left;
+        req->win_top    = info->srWindow.Top;
+        req->win_right  = info->srWindow.Right;
+        req->win_bottom = info->srWindow.Bottom;
+        req->popup_attr = info->wPopupAttributes;
+        req->max_width  = min( info->dwMaximumWindowSize.X, info->dwSize.X );
+        req->max_height = min( info->dwMaximumWindowSize.Y, info->dwSize.Y );
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+
+    return ret;
 }
 
 
@@ -1286,13 +1422,19 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleScreenBufferInfoEx( HANDLE handle,
  */
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleScreenBufferSize( HANDLE handle, COORD size )
 {
-    struct condrv_output_info_params params = { SET_CONSOLE_OUTPUT_INFO_SIZE };
+    BOOL ret;
 
     TRACE( "(%p,(%d,%d))\n", handle, size.X, size.Y );
-
-    params.info.width  = size.X;
-    params.info.height = size.Y;
-    return console_ioctl( handle, IOCTL_CONDRV_SET_OUTPUT_INFO, &params, sizeof(params), NULL, 0, NULL );
+    SERVER_START_REQ( set_console_output_info )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->width  = size.X;
+        req->height = size.Y;
+        req->mask   = SET_CONSOLE_OUTPUT_INFO_SIZE;
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -1301,12 +1443,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleScreenBufferSize( HANDLE handle, COORD s
  */
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleTextAttribute( HANDLE handle, WORD attr )
 {
-    struct condrv_output_info_params params = { SET_CONSOLE_OUTPUT_INFO_ATTR };
+    BOOL ret;
 
     TRACE( "(%p,%d)\n", handle, attr );
-
-    params.info.attr = attr;
-    return console_ioctl( handle, IOCTL_CONDRV_SET_OUTPUT_INFO, &params, sizeof(params), NULL, 0, NULL );
+    SERVER_START_REQ( set_console_output_info )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->attr   = attr;
+        req->mask   = SET_CONSOLE_OUTPUT_INFO_ATTR;
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -1335,8 +1483,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleTitleW( LPCWSTR title )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleWindowInfo( HANDLE handle, BOOL absolute, SMALL_RECT *window )
 {
-    struct condrv_output_info_params params = { SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW };
     SMALL_RECT rect = *window;
+    BOOL ret;
 
     TRACE( "(%p,%d,(%d,%d-%d,%d))\n", handle, absolute, rect.Left, rect.Top, rect.Right, rect.Bottom );
 
@@ -1350,12 +1498,19 @@ BOOL WINAPI DECLSPEC_HOTPATCH SetConsoleWindowInfo( HANDLE handle, BOOL absolute
 	rect.Right  += info.srWindow.Right;
 	rect.Bottom += info.srWindow.Bottom;
     }
+    SERVER_START_REQ( set_console_output_info )
+    {
+        req->handle     = console_handle_unmap( handle );
+	req->win_left   = rect.Left;
+	req->win_top    = rect.Top;
+	req->win_right  = rect.Right;
+	req->win_bottom = rect.Bottom;
+        req->mask       = SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW;
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
 
-    params.info.win_left   = rect.Left;
-    params.info.win_top    = rect.Top;
-    params.info.win_right  = rect.Right;
-    params.info.win_bottom = rect.Bottom;
-    return console_ioctl( handle, IOCTL_CONDRV_SET_OUTPUT_INFO, &params, sizeof(params), NULL, 0, NULL );
+    return ret;
 }
 
 
@@ -1395,6 +1550,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleInputA( HANDLE handle, const INPUT_REC
 BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleInputW( HANDLE handle, const INPUT_RECORD *buffer,
                                                   DWORD count, DWORD *written )
 {
+    DWORD events_written = 0;
+    BOOL ret;
+
     TRACE( "(%p,%p,%d,%p)\n", handle, buffer, count, written );
 
     if (count > 0 && !buffer)
@@ -1402,17 +1560,21 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleInputW( HANDLE handle, const INPUT_REC
         SetLastError( ERROR_INVALID_ACCESS );
         return FALSE;
     }
+    SERVER_START_REQ( write_console_input )
+    {
+        req->handle = console_handle_unmap( handle );
+        wine_server_add_data( req, buffer, count * sizeof(INPUT_RECORD) );
+        if ((ret = !wine_server_call_err( req ))) events_written = reply->written;
+    }
+    SERVER_END_REQ;
 
-    if (!DeviceIoControl( handle, IOCTL_CONDRV_WRITE_INPUT, (void *)buffer, count * sizeof(*buffer), NULL, 0, NULL, NULL ))
-        return FALSE;
-
-    if (!written)
+    if (written) *written = events_written;
+    else
     {
         SetLastError( ERROR_INVALID_ACCESS );
-        return FALSE;
+        ret = FALSE;
     }
-    *written = count;
-    return TRUE;
+    return ret;
 }
 
 
@@ -1457,43 +1619,41 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputA( HANDLE handle, const CHAR_INF
 BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputW( HANDLE handle, const CHAR_INFO *buffer,
                                                    COORD size, COORD coord, SMALL_RECT *region )
 {
-    struct condrv_output_params *params;
-    unsigned int width, height, y;
-    size_t params_size;
-    BOOL ret;
+    int width, height, y;
+    BOOL ret = TRUE;
 
     TRACE( "(%p,%p,(%d,%d),(%d,%d),(%d,%dx%d,%d)\n",
            handle, buffer, size.X, size.Y, coord.X, coord.Y,
            region->Left, region->Top, region->Right, region->Bottom );
 
-    if (region->Left > region->Right || region->Top > region->Bottom || size.X <= coord.X || size.Y <= coord.Y)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return FALSE;
-    }
-
-    width  = min( region->Right - region->Left + 1, size.X - coord.X );
+    width = min( region->Right - region->Left + 1, size.X - coord.X );
     height = min( region->Bottom - region->Top + 1, size.Y - coord.Y );
-    region->Right = region->Left + width - 1;
-    region->Bottom = region->Top + height - 1;
 
-    params_size = sizeof(*params) + width * height * sizeof(*buffer);
-    if (!(params = HeapAlloc( GetProcessHeap(), 0, params_size )))
+    if (width > 0 && height > 0)
     {
-        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-        return FALSE;
+        for (y = 0; y < height; y++)
+        {
+            SERVER_START_REQ( write_console_output )
+            {
+                req->handle = console_handle_unmap( handle );
+                req->x      = region->Left;
+                req->y      = region->Top + y;
+                req->mode   = CHAR_INFO_MODE_TEXTATTR;
+                req->wrap   = FALSE;
+                wine_server_add_data( req, &buffer[(y + coord.Y) * size.X + coord.X],
+                                      width * sizeof(CHAR_INFO));
+                if ((ret = !wine_server_call_err( req )))
+                {
+                    width  = min( width, reply->width - region->Left );
+                    height = min( height, reply->height - region->Top );
+                }
+            }
+            SERVER_END_REQ;
+            if (!ret) break;
+        }
     }
-
-    params->mode  = CHAR_INFO_MODE_TEXTATTR;
-    params->x     = region->Left;
-    params->y     = region->Top;
-    params->width = width;
-
-    for (y = 0; y < height; y++)
-        memcpy( &((CHAR_INFO *)(params + 1))[y * width], &buffer[(y + coord.Y) * size.X + coord.X], width * sizeof(CHAR_INFO) );
-
-    ret = console_ioctl( handle, IOCTL_CONDRV_WRITE_OUTPUT, params, params_size, region, sizeof(*region), NULL );
-    HeapFree( GetProcessHeap(), 0, params );
+    region->Bottom = region->Top + height - 1;
+    region->Right = region->Left + width - 1;
     return ret;
 }
 
@@ -1504,8 +1664,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputW( HANDLE handle, const CHAR_INF
 BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputAttribute( HANDLE handle, const WORD *attr, DWORD length,
                                                            COORD coord, DWORD *written )
 {
-    struct condrv_output_params *params;
-    size_t size;
     BOOL ret;
 
     TRACE( "(%p,%p,%d,%dx%d,%p)\n", handle, attr, length, coord.X, coord.Y, written );
@@ -1517,15 +1675,17 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputAttribute( HANDLE handle, const
     }
 
     *written = 0;
-    size = sizeof(*params) + length * sizeof(WORD);
-    if (!(params = HeapAlloc( GetProcessHeap(), 0, size ))) return FALSE;
-    params->mode   = CHAR_INFO_MODE_ATTR;
-    params->x      = coord.X;
-    params->y      = coord.Y;
-    params->width  = 0;
-    memcpy( params + 1, attr, length * sizeof(*attr) );
-    ret = console_ioctl( handle, IOCTL_CONDRV_WRITE_OUTPUT, params, size, written, sizeof(*written), NULL );
-    HeapFree( GetProcessHeap(), 0, params );
+    SERVER_START_REQ( write_console_output )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->x      = coord.X;
+        req->y      = coord.Y;
+        req->mode   = CHAR_INFO_MODE_ATTR;
+        req->wrap   = TRUE;
+        wine_server_add_data( req, attr, length * sizeof(WORD) );
+        if ((ret = !wine_server_call_err( req ))) *written = reply->written;
+    }
+    SERVER_END_REQ;
     return ret;
 }
 
@@ -1544,20 +1704,19 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputCharacterA( HANDLE handle, LPCST
 
     if (length > 0)
     {
-        UINT cp = GetConsoleOutputCP();
         if (!str)
         {
             SetLastError( ERROR_INVALID_ACCESS );
             return FALSE;
         }
-        lenW = MultiByteToWideChar( cp, 0, str, length, NULL, 0 );
+        lenW = MultiByteToWideChar( GetConsoleOutputCP(), 0, str, length, NULL, 0 );
 
         if (!(strW = HeapAlloc( GetProcessHeap(), 0, lenW * sizeof(WCHAR) )))
         {
             SetLastError( ERROR_NOT_ENOUGH_MEMORY );
             return FALSE;
         }
-        MultiByteToWideChar( cp, 0, str, length, strW, lenW );
+        MultiByteToWideChar( GetConsoleOutputCP(), 0, str, length, strW, lenW );
     }
     ret = WriteConsoleOutputCharacterW( handle, strW, lenW, coord, written );
     HeapFree( GetProcessHeap(), 0, strW );
@@ -1571,8 +1730,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputCharacterA( HANDLE handle, LPCST
 BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputCharacterW( HANDLE handle, LPCWSTR str, DWORD length,
                                                             COORD coord, DWORD *written )
 {
-    struct condrv_output_params *params;
-    size_t size;
     BOOL ret;
 
     TRACE( "(%p,%s,%d,%dx%d,%p)\n", handle, debugstr_wn(str, length), length, coord.X, coord.Y, written );
@@ -1584,15 +1741,17 @@ BOOL WINAPI DECLSPEC_HOTPATCH WriteConsoleOutputCharacterW( HANDLE handle, LPCWS
     }
 
     *written = 0;
-    size = sizeof(*params) + length * sizeof(WCHAR);
-    if (!(params = HeapAlloc( GetProcessHeap(), 0, size ))) return FALSE;
-    params->mode   = CHAR_INFO_MODE_TEXT;
-    params->x      = coord.X;
-    params->y      = coord.Y;
-    params->width  = 0;
-    memcpy( params + 1, str, length * sizeof(*str) );
-    ret = console_ioctl( handle, IOCTL_CONDRV_WRITE_OUTPUT, params, size, written, sizeof(*written), NULL );
-    HeapFree( GetProcessHeap(), 0, params );
+    SERVER_START_REQ( write_console_output )
+    {
+        req->handle = console_handle_unmap( handle );
+        req->x      = coord.X;
+        req->y      = coord.Y;
+        req->mode   = CHAR_INFO_MODE_TEXT;
+        req->wrap   = TRUE;
+        wine_server_add_data( req, str, length * sizeof(WCHAR) );
+        if ((ret = !wine_server_call_err( req ))) *written = reply->written;
+    }
+    SERVER_END_REQ;
     return ret;
 }
 
@@ -1621,8 +1780,3 @@ HRESULT WINAPI ResizePseudoConsole( HPCON handle, COORD size )
     FIXME( "%p (%u,%u)\n", handle, size.X, size.Y );
     return E_NOTIMPL;
 }
-
-void init_console( void )
-{
-    RtlAddVectoredExceptionHandler( FALSE, handle_ctrl_c );
-}
diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index d9b3440869..cc79284520 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -473,12 +473,12 @@ DWORD file_name_WtoA( LPCWSTR src, INT srclen, LPSTR dest, INT destlen )
  */
 static BOOL is_same_file( HANDLE h1, HANDLE h2 )
 {
-    FILE_OBJECTID_BUFFER id1, id2;
+    FILE_ID_INFORMATION id1, id2;
     IO_STATUS_BLOCK io;
 
-    return (!NtFsControlFile( h1, 0, NULL, NULL, &io, FSCTL_GET_OBJECT_ID, NULL, 0, &id1, sizeof(id1) ) &&
-            !NtFsControlFile( h2, 0, NULL, NULL, &io, FSCTL_GET_OBJECT_ID, NULL, 0, &id2, sizeof(id2) ) &&
-            !memcmp( &id1.ObjectId, &id2.ObjectId, sizeof(id1.ObjectId) ));
+    return !NtQueryInformationFile( h1, &io, &id1, sizeof(id1), FileIdInformation ) &&
+           !NtQueryInformationFile( h2, &io, &id2, sizeof(id2), FileIdInformation ) &&
+           !memcmp( &id1, &id2, sizeof(FILE_ID_INFORMATION) );
 }
 
 
@@ -744,6 +744,13 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
            (sharing & FILE_SHARE_DELETE) ? "FILE_SHARE_DELETE " : "",
            creation, attributes);
 
+    /* Open a console for CONIN$ or CONOUT$ */
+
+    if (!wcsicmp( filename, L"CONIN$" ))
+        return open_console( FALSE, access, sa, creation ? OPEN_EXISTING : 0 );
+    if (!wcsicmp( filename, L"CONOUT$" ))
+        return open_console( TRUE, access, sa, creation ? OPEN_EXISTING : 0 );
+
     if (!wcsncmp( filename, L"\\\\.\\", 4 ))
     {
         if ((filename[4] && filename[5] == ':' && !filename[6]) ||
@@ -764,6 +771,24 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
     }
     else dosdev = RtlIsDosDeviceName_U( filename );
 
+    if (dosdev)
+    {
+        if (LOWORD(dosdev) == 3 * sizeof(WCHAR) &&
+            !wcsnicmp( filename + HIWORD(dosdev)/sizeof(WCHAR), L"CON", 3 ))
+        {
+            switch (access & (GENERIC_READ|GENERIC_WRITE))
+            {
+            case GENERIC_READ:
+                return open_console( FALSE, access, sa, OPEN_EXISTING );
+            case GENERIC_WRITE:
+                return open_console( TRUE, access, sa, OPEN_EXISTING );
+            default:
+                SetLastError( ERROR_FILE_NOT_FOUND );
+                return INVALID_HANDLE_VALUE;
+            }
+        }
+    }
+
     if (creation < CREATE_NEW || creation > TRUNCATE_EXISTING)
     {
         SetLastError( ERROR_INVALID_PARAMETER );
@@ -828,12 +853,6 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
     }
     else
     {
-        if (dosdev &&
-            ((LOWORD(dosdev) == 3 * sizeof(WCHAR) && !wcsnicmp( filename + HIWORD(dosdev)/sizeof(WCHAR), L"CON", 3 )) ||
-             (LOWORD(dosdev) == 6 * sizeof(WCHAR) && !wcsnicmp( filename + HIWORD(dosdev)/sizeof(WCHAR), L"CONIN$", 6 )) ||
-             (LOWORD(dosdev) == 7 * sizeof(WCHAR) && !wcsnicmp( filename + HIWORD(dosdev)/sizeof(WCHAR), L"CONOUT$", 7 ))))
-            ret = console_handle_map( ret );
-
         if ((creation == CREATE_ALWAYS && io.Information == FILE_OVERWRITTEN) ||
             (creation == OPEN_ALWAYS && io.Information == FILE_OPENED))
             SetLastError( ERROR_ALREADY_EXISTS );
@@ -3448,50 +3467,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReadFileScatter( HANDLE file, FILE_SEGMENT_ELEMENT
 }
 
 
-/***********************************************************************
- *	RemoveDirectoryA   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH RemoveDirectoryA( LPCSTR path )
-{
-    WCHAR *pathW;
-
-    if (!(pathW = file_name_AtoW( path, FALSE ))) return FALSE;
-    return RemoveDirectoryW( pathW );
-}
-
-
-/***********************************************************************
- *	RemoveDirectoryW   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH RemoveDirectoryW( LPCWSTR path )
-{
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nt_name;
-    IO_STATUS_BLOCK io;
-    NTSTATUS status;
-    HANDLE handle;
-
-    TRACE( "%s\n", debugstr_w(path) );
-
-    status = RtlDosPathNameToNtPathName_U_WithStatus( path, &nt_name, NULL, NULL );
-    if (!set_ntstatus( status )) return FALSE;
-
-    InitializeObjectAttributes( &attr, &nt_name, OBJ_CASE_INSENSITIVE, 0, NULL );
-    status = NtOpenFile( &handle, DELETE | SYNCHRONIZE, &attr, &io,
-                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
-    RtlFreeUnicodeString( &nt_name );
-
-    if (!status)
-    {
-        FILE_DISPOSITION_INFORMATION info = { TRUE };
-        status = NtSetInformationFile( handle, &io, &info, sizeof(info), FileDispositionInformation );
-        NtClose( handle );
-    }
-    return set_ntstatus( status );
-}
-
-
 /**************************************************************************
  *	SetEndOfFile   (kernelbase.@)
  */
diff --git a/dlls/kernelbase/kernelbase.h b/dlls/kernelbase/kernelbase.h
index 59265bab2c..99ce640f40 100644
--- a/dlls/kernelbase/kernelbase.h
+++ b/dlls/kernelbase/kernelbase.h
@@ -28,7 +28,6 @@ extern WCHAR *file_name_AtoW( LPCSTR name, BOOL alloc ) DECLSPEC_HIDDEN;
 extern DWORD file_name_WtoA( LPCWSTR src, INT srclen, LPSTR dest, INT destlen ) DECLSPEC_HIDDEN;
 extern void init_startup_info( RTL_USER_PROCESS_PARAMETERS *params ) DECLSPEC_HIDDEN;
 extern void init_locale(void) DECLSPEC_HIDDEN;
-extern void init_console(void) DECLSPEC_HIDDEN;
 extern HANDLE get_console_wait_handle( HANDLE handle ) DECLSPEC_HIDDEN;
 
 extern const WCHAR windows_dir[] DECLSPEC_HIDDEN;
@@ -37,6 +36,8 @@ extern const WCHAR system_dir[] DECLSPEC_HIDDEN;
 static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
 extern BOOL is_wow64 DECLSPEC_HIDDEN;
 
+extern HANDLE open_console( BOOL output, DWORD access, SECURITY_ATTRIBUTES *sa, DWORD creation ) DECLSPEC_HIDDEN;
+
 static inline BOOL is_console_handle(HANDLE h)
 {
     return h != INVALID_HANDLE_VALUE && ((UINT_PTR)h & 3) == 3;
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index f5411a161f..3f59baa4df 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1333,8 +1333,8 @@
 @ stdcall ReleaseSemaphoreWhenCallbackReturns(ptr long long) ntdll.TpCallbackReleaseSemaphoreOnCompletion
 # @ stub ReleaseStateLock
 @ stdcall RemapPredefinedHandleInternal(long long)
-@ stdcall RemoveDirectoryA(str)
-@ stdcall RemoveDirectoryW(wstr)
+@ stdcall RemoveDirectoryA(str) kernel32.RemoveDirectoryA
+@ stdcall RemoveDirectoryW(wstr) kernel32.RemoveDirectoryW
 @ stdcall RemoveDllDirectory(ptr)
 # @ stub RemovePackageStatus
 # @ stub RemovePackageStatusForUser
diff --git a/dlls/kernelbase/main.c b/dlls/kernelbase/main.c
index e85586a075..f1edf8614e 100644
--- a/dlls/kernelbase/main.c
+++ b/dlls/kernelbase/main.c
@@ -47,7 +47,6 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
         IsWow64Process( GetCurrentProcess(), &is_wow64 );
         init_locale();
         init_startup_info( NtCurrentTeb()->Peb->ProcessParameters );
-        init_console();
     }
     return TRUE;
 }
diff --git a/dlls/kernelbase/volume.c b/dlls/kernelbase/volume.c
index 53cc0d49b6..9939ea3bef 100644
--- a/dlls/kernelbase/volume.c
+++ b/dlls/kernelbase/volume.c
@@ -972,13 +972,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH DefineDosDeviceW( DWORD flags, const WCHAR *device
 
     lstrcatW( link_name, device );
     RtlInitUnicodeString( &nt_name, link_name );
-    InitializeObjectAttributes( &attr, &nt_name, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, 0, NULL );
+    InitializeObjectAttributes( &attr, &nt_name, OBJ_CASE_INSENSITIVE, 0, NULL );
     if (flags & DDD_REMOVE_DEFINITION)
     {
         if (!set_ntstatus( NtOpenSymbolicLinkObject( &handle, 0, &attr ) ))
             return FALSE;
 
-        status = NtMakeTemporaryObject( handle );
+        SERVER_START_REQ( unlink_object )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
         NtClose( handle );
 
         return set_ntstatus( status );
@@ -995,9 +1000,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH DefineDosDeviceW( DWORD flags, const WCHAR *device
     else
         RtlInitUnicodeString( &nt_target, target );
 
-    if (!(status = NtCreateSymbolicLinkObject( &handle, SYMBOLIC_LINK_ALL_ACCESS, &attr, &nt_target )))
-        NtClose( handle );
-    return set_ntstatus( status );
+    return set_ntstatus( NtCreateSymbolicLinkObject( &handle, SYMBOLIC_LINK_ALL_ACCESS, &attr, &nt_target ) );
 }
 
 
diff --git a/dlls/krnl386.exe16/kernel16_private.h b/dlls/krnl386.exe16/kernel16_private.h
index fbc1a5f825..f15934daa0 100644
--- a/dlls/krnl386.exe16/kernel16_private.h
+++ b/dlls/krnl386.exe16/kernel16_private.h
@@ -304,10 +304,9 @@ struct kernel_thread_data
     WORD                htask16;        /* Win16 task handle */
     DWORD               sys_count[4];   /* syslevel mutex entry counters */
     struct tagSYSLEVEL *sys_mutex[4];   /* syslevel mutex pointers */
+    void               *pad[45];        /* change this if you add fields! */
 };
 
-C_ASSERT( sizeof(struct kernel_thread_data) <= sizeof(((TEB *)0)->SystemReserved1) );
-
 static inline struct kernel_thread_data *kernel_get_thread_data(void)
 {
     return (struct kernel_thread_data *)NtCurrentTeb()->SystemReserved1;
diff --git a/dlls/krnl386.exe16/selector.c b/dlls/krnl386.exe16/selector.c
index 26c86f06a9..94088276d6 100644
--- a/dlls/krnl386.exe16/selector.c
+++ b/dlls/krnl386.exe16/selector.c
@@ -69,12 +69,10 @@ static LDT_ENTRY ldt_make_entry( const void *base, unsigned int limit, unsigned
  */
 void init_selectors(void)
 {
-    const struct ldt_copy **ldt_copy_ptr;
     if (!is_gdt_sel( get_gs() )) first_ldt_entry += 512;
     if (!is_gdt_sel( get_fs() )) first_ldt_entry += 512;
     RtlSetBits( &ldt_bitmap, 0, first_ldt_entry );
-    ldt_copy_ptr = (void *)GetProcAddress( GetModuleHandleA("ntdll.dll"), "__wine_ldt_copy" );
-    if (ldt_copy_ptr) ldt_copy = *ldt_copy_ptr;
+    ldt_copy = (void *)GetProcAddress( GetModuleHandleA("ntdll.dll"), "__wine_ldt_copy" );
 }
 
 /***********************************************************************
diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
index bc8215b6bf..3b688cbde1 100644
--- a/dlls/ntdll/Makefile.in
+++ b/dlls/ntdll/Makefile.in
@@ -1,14 +1,15 @@
-EXTRADEFS = -D_NTSYSTEM_ -D_ACRTIMP=
+EXTRADEFS = -D_NTSYSTEM_
 MODULE    = ntdll.dll
 IMPORTLIB = ntdll
 IMPORTS   = winecrt0
 EXTRAINCL = $(UNWIND_CFLAGS)
 EXTRALIBS = -lwine $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS)
-EXTRADLLFLAGS = -mno-cygwin -nodefaultlibs -Wl,--image-base,0x7bc00000
+EXTRADLLFLAGS = -nodefaultlibs -Wl,--image-base,0x7bc00000
 
 C_SRCS = \
 	actctx.c \
 	atom.c \
+	cdrom.c \
 	critsection.c \
 	crypt.c \
 	debugbuffer.c \
@@ -16,6 +17,7 @@ C_SRCS = \
 	env.c \
 	error.c \
 	exception.c \
+	file.c \
 	handletable.c \
 	heap.c \
 	large_int.c \
@@ -24,6 +26,7 @@ C_SRCS = \
 	locale.c \
 	misc.c \
 	nt.c \
+	om.c \
 	path.c \
 	printf.c \
 	process.c \
@@ -34,34 +37,21 @@ C_SRCS = \
 	rtlbitmap.c \
 	rtlstr.c \
 	sec.c \
+	serial.c \
 	server.c \
 	signal_arm.c \
 	signal_arm64.c \
 	signal_i386.c \
+	signal_powerpc.c \
 	signal_x86_64.c \
 	string.c \
 	sync.c \
+	tape.c \
 	thread.c \
 	threadpool.c \
 	time.c \
-	unix/cdrom.c \
 	unix/debug.c \
-	unix/env.c \
-	unix/file.c \
 	unix/loader.c \
-	unix/process.c \
-	unix/registry.c \
-	unix/security.c \
-	unix/serial.c \
-	unix/server.c \
-	unix/signal_arm.c \
-	unix/signal_arm64.c \
-	unix/signal_i386.c \
-	unix/signal_x86_64.c \
-	unix/sync.c \
-	unix/system.c \
-	unix/tape.c \
-	unix/thread.c \
 	unix/virtual.c \
 	version.c \
 	virtual.c \
diff --git a/dlls/ntdll/actctx.c b/dlls/ntdll/actctx.c
index 625cffcca8..1fa97ac037 100644
--- a/dlls/ntdll/actctx.c
+++ b/dlls/ntdll/actctx.c
@@ -22,6 +22,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <stdio.h>
 
@@ -1098,7 +1101,7 @@ static WCHAR *build_assembly_dir(struct assembly_identity* ai)
     wcscat( ret, undW );
     wcscat( ret, key );
     wcscat( ret, undW );
-    swprintf( ret + wcslen(ret), size - wcslen(ret), version_formatW,
+    NTDLL_swprintf( ret + wcslen(ret), version_formatW,
               ai->version.major, ai->version.minor, ai->version.build, ai->version.revision );
     wcscat( ret, undW );
     wcscat( ret, lang );
@@ -1135,7 +1138,7 @@ static WCHAR *build_assembly_id( const struct assembly_identity *ai )
     WCHAR version[64], *ret;
     SIZE_T size = 0;
 
-    swprintf( version, ARRAY_SIZE(version), version_formatW,
+    NTDLL_swprintf( version, version_formatW,
               ai->version.major, ai->version.minor, ai->version.build, ai->version.revision );
     if (ai->name) size += wcslen(ai->name) * sizeof(WCHAR);
     if (ai->arch) size += wcslen(archW) + wcslen(ai->arch) + 2;
@@ -1981,7 +1984,7 @@ static int get_assembly_version(struct assembly *assembly, WCHAR *ret)
     WCHAR buff[25];
 
     if (!ret) ret = buff;
-    return swprintf(ret, ARRAY_SIZE(buff), fmtW, ver->major, ver->minor, ver->build, ver->revision);
+    return NTDLL_swprintf(ret, fmtW, ver->major, ver->minor, ver->build, ver->revision);
 }
 
 static void parse_window_class_elem( xmlbuf_t *xmlbuf, struct dll_redirect *dll,
@@ -3091,7 +3094,7 @@ static NTSTATUS get_manifest_in_associated_manifest( struct actctx_loader* acl,
 
         if (!(status = get_module_filename( module, &name, sizeof(dotManifestW) + 10*sizeof(WCHAR) )))
         {
-            if (resid != 1) swprintf( name.Buffer + wcslen(name.Buffer), 10, fmtW, resid );
+            if (resid != 1) NTDLL_swprintf( name.Buffer + wcslen(name.Buffer), fmtW, resid );
             wcscat( name.Buffer, dotManifestW );
             if (!RtlDosPathNameToNtPathName_U( name.Buffer, &nameW, NULL, NULL ))
                 status = STATUS_RESOURCE_DATA_NOT_FOUND;
@@ -3105,7 +3108,7 @@ static NTSTATUS get_manifest_in_associated_manifest( struct actctx_loader* acl,
                                         (wcslen(filename) + 10) * sizeof(WCHAR) + sizeof(dotManifestW) )))
             return STATUS_NO_MEMORY;
         wcscpy( buffer, filename );
-        if (resid != 1) swprintf( buffer + wcslen(buffer), 10, fmtW, resid );
+        if (resid != 1) NTDLL_swprintf( buffer + wcslen(buffer), fmtW, resid );
         wcscat( buffer, dotManifestW );
         RtlInitUnicodeString( &nameW, buffer );
     }
@@ -3131,14 +3134,17 @@ static WCHAR *lookup_manifest_file( HANDLE dir, struct assembly_identity *ai )
     UNICODE_STRING lookup_us;
     IO_STATUS_BLOCK io;
     const WCHAR *lang = ai->language;
-    unsigned int data_pos = 0, data_len, len;
+    unsigned int data_pos = 0, data_len;
     char buffer[8192];
 
     if (!lang || !wcsicmp( lang, neutralW )) lang = wildcardW;
 
-    len = wcslen(ai->arch) + wcslen(ai->name) + wcslen(ai->public_key) + wcslen(lang) + 20 + ARRAY_SIZE(lookup_fmtW);
-    if (!(lookup = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) ))) return NULL;
-    swprintf( lookup, len, lookup_fmtW, ai->arch, ai->name, ai->public_key,
+    if (!(lookup = RtlAllocateHeap( GetProcessHeap(), 0,
+                                    (wcslen(ai->arch) + wcslen(ai->name)
+                                     + wcslen(ai->public_key) + wcslen(lang) + 20) * sizeof(WCHAR)
+                                    + sizeof(lookup_fmtW) )))
+        return NULL;
+    NTDLL_swprintf( lookup, lookup_fmtW, ai->arch, ai->name, ai->public_key,
               ai->version.major, ai->version.minor, lang );
     RtlInitUnicodeString( &lookup_us, lookup );
 
@@ -5156,25 +5162,16 @@ NTSTATUS WINAPI RtlZombifyActivationContext( HANDLE handle )
  *		RtlActivateActivationContext (NTDLL.@)
  */
 NTSTATUS WINAPI RtlActivateActivationContext( ULONG unknown, HANDLE handle, PULONG_PTR cookie )
-{
-    return RtlActivateActivationContextEx( 0, NtCurrentTeb(), handle, cookie );
-}
-
-
-/******************************************************************
- *		RtlActivateActivationContextEx (NTDLL.@)
- */
-NTSTATUS WINAPI RtlActivateActivationContextEx( ULONG flags, TEB *teb, HANDLE handle, ULONG_PTR *cookie )
 {
     RTL_ACTIVATION_CONTEXT_STACK_FRAME *frame;
 
     if (!(frame = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*frame) )))
         return STATUS_NO_MEMORY;
 
-    frame->Previous = teb->ActivationContextStack.ActiveFrame;
+    frame->Previous = NtCurrentTeb()->ActivationContextStack.ActiveFrame;
     frame->ActivationContext = handle;
     frame->Flags = 0;
-    teb->ActivationContextStack.ActiveFrame = frame;
+    NtCurrentTeb()->ActivationContextStack.ActiveFrame = frame;
     RtlAddRefActivationContext( handle );
 
     *cookie = (ULONG_PTR)frame;
diff --git a/dlls/ntdll/atom.c b/dlls/ntdll/atom.c
index fd1f17b619..d0f8c8803e 100644
--- a/dlls/ntdll/atom.c
+++ b/dlls/ntdll/atom.c
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -106,7 +109,7 @@ static ULONG integral_atom_name(WCHAR* buffer, ULONG len, RTL_ATOM atom)
     WCHAR tmp[16];
     int ret;
 
-    ret = swprintf( tmp, ARRAY_SIZE(tmp), fmt, atom );
+    ret = NTDLL_swprintf( tmp, fmt, atom );
     if (!len) return ret * sizeof(WCHAR);
     if (len <= ret) ret = len - 1;
     memcpy( buffer, tmp, ret * sizeof(WCHAR) );
@@ -300,3 +303,146 @@ NTSTATUS WINAPI RtlPinAtomInAtomTable( RTL_ATOM_TABLE table, RTL_ATOM atom )
 
     return status;
 }
+
+/*************************************************
+ *        Global handle table management
+ *************************************************/
+
+/******************************************************************
+ *		NtAddAtom (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAddAtom( const WCHAR* name, ULONG length, RTL_ATOM* atom )
+{
+    NTSTATUS    status;
+
+    status = is_integral_atom( name, length / sizeof(WCHAR), atom );
+    if (status == STATUS_MORE_ENTRIES)
+    {
+        SERVER_START_REQ( add_atom )
+        {
+            wine_server_add_data( req, name, length );
+            req->table = 0;
+            status = wine_server_call( req );
+            *atom = reply->atom;
+        }
+        SERVER_END_REQ;
+    }
+    TRACE( "%s -> %x\n",
+           debugstr_wn(name, length/sizeof(WCHAR)), status == STATUS_SUCCESS ? *atom : 0 );
+    return status;
+}
+
+/******************************************************************
+ *		NtDeleteAtom (NTDLL.@)
+ */
+NTSTATUS WINAPI NtDeleteAtom(RTL_ATOM atom)
+{
+    NTSTATUS    status;
+
+    SERVER_START_REQ( delete_atom )
+    {
+        req->atom = atom;
+        req->table = 0;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************
+ *		NtFindAtom (NTDLL.@)
+ */
+NTSTATUS WINAPI NtFindAtom( const WCHAR* name, ULONG length, RTL_ATOM* atom )
+{
+    NTSTATUS    status;
+
+    status = is_integral_atom( name, length / sizeof(WCHAR), atom );
+    if (status == STATUS_MORE_ENTRIES)
+    {
+        SERVER_START_REQ( find_atom )
+        {
+            wine_server_add_data( req, name, length );
+            req->table = 0;
+            status = wine_server_call( req );
+            *atom = reply->atom;
+        }
+        SERVER_END_REQ;
+    }
+    TRACE( "%s -> %x\n",
+           debugstr_wn(name, length/sizeof(WCHAR)), status == STATUS_SUCCESS ? *atom : 0 );
+    return status;
+}
+
+/******************************************************************
+ *		NtQueryInformationAtom (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryInformationAtom( RTL_ATOM atom, ATOM_INFORMATION_CLASS class,
+                                        PVOID ptr, ULONG size, PULONG psize )
+{
+    NTSTATUS status;
+
+    switch (class)
+    {
+    case AtomBasicInformation:
+        {
+            ULONG name_len;
+            ATOM_BASIC_INFORMATION* abi = ptr;
+
+            if (size < sizeof(ATOM_BASIC_INFORMATION))
+                return STATUS_INVALID_PARAMETER;
+            name_len = size - sizeof(ATOM_BASIC_INFORMATION);
+
+            if (atom < MAXINTATOM)
+            {
+                if (atom)
+                {
+                    abi->NameLength = integral_atom_name( abi->Name, name_len, atom );
+                    status = (name_len) ? STATUS_SUCCESS : STATUS_BUFFER_TOO_SMALL;
+                    abi->ReferenceCount = 1;
+                    abi->Pinned = 1;
+                }
+                else status = STATUS_INVALID_PARAMETER;
+            }
+            else
+            {
+                SERVER_START_REQ( get_atom_information )
+                {
+                    req->atom = atom;
+                    req->table = 0;
+                    if (name_len) wine_server_set_reply( req, abi->Name, name_len );
+                    status = wine_server_call( req );
+                    if (status == STATUS_SUCCESS)
+                    {
+                        name_len = wine_server_reply_size( reply );
+                        if (name_len)
+                        {
+                            abi->NameLength = name_len;
+                            abi->Name[name_len / sizeof(WCHAR)] = '\0';
+                        }
+                        else
+                        {
+                            name_len = reply->total;
+                            abi->NameLength = name_len;
+                            status = STATUS_BUFFER_TOO_SMALL;
+                        }
+                        abi->ReferenceCount = reply->count;
+                        abi->Pinned = reply->pinned;
+                    }
+                    else name_len = 0;
+                }
+                SERVER_END_REQ;
+            }
+            TRACE( "%x -> %s (%u)\n", 
+                   atom, debugstr_wn(abi->Name, abi->NameLength / sizeof(WCHAR)),
+                   status );
+            if (psize)
+                *psize = sizeof(ATOM_BASIC_INFORMATION) + name_len;
+        }
+        break;
+    default:
+        FIXME( "Unsupported class %u\n", class );
+        status = STATUS_INVALID_INFO_CLASS;
+        break;
+    }
+    return status;
+}
diff --git a/dlls/ntdll/unix/cdrom.c b/dlls/ntdll/cdrom.c
similarity index 90%
rename from dlls/ntdll/unix/cdrom.c
rename to dlls/ntdll/cdrom.c
index 0d8b624308..f6e3a86e34 100644
--- a/dlls/ntdll/unix/cdrom.c
+++ b/dlls/ntdll/cdrom.c
@@ -1,5 +1,5 @@
-/*
- * CD-ROM support
+/* -*- tab-width: 8; c-basic-offset: 4 -*- */
+/* Main file for CD-ROM support
  *
  * Copyright 1994 Martin Ayotte
  * Copyright 1999, 2001, 2003 Eric Pouech
@@ -21,10 +21,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 #include "wine/port.h"
 
@@ -132,8 +128,9 @@ typedef struct
 #include "ntddcdrm.h"
 #include "ddk/ntddcdvd.h"
 #include "ntddscsi.h"
+#include "ntdll_misc.h"
 #include "wine/server.h"
-#include "unix_private.h"
+#include "wine/library.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(cdrom);
@@ -279,7 +276,7 @@ struct linux_cdrom_generic_command
 
 /* FIXME: this is needed because we can't open simultaneously several times /dev/cdrom
  * this should be removed when a proper device interface is implemented
- *
+ * 
  * (WS) We need this to keep track of current position and to safely
  * detect media changes. Besides this should provide a great speed up
  * for toc inquiries.
@@ -292,13 +289,20 @@ struct cdrom_cache {
     SUB_Q_CURRENT_POSITION CurrentPosition;
 };
 /* who has more than 5 cdroms on his/her machine ?? */
-/* FIXME: this should grow depending on the number of cdroms we install/configure
+/* FIXME: this should grow depending on the number of cdroms we install/configure 
  * at startup
  */
 #define MAX_CACHE_ENTRIES       5
 static struct cdrom_cache cdrom_cache[MAX_CACHE_ENTRIES];
 
-static pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+static RTL_CRITICAL_SECTION cache_section;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &cache_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": cache_section") }
+};
+static RTL_CRITICAL_SECTION cache_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 /* Proposed media change function: not really needed at this time */
 /* This is a 1 or 0 type of function */
@@ -355,7 +359,7 @@ static NTSTATUS get_parent_device( int fd, char *name, size_t len )
     CFMutableDictionaryRef dict;
     CFTypeRef val;
 
-    if (fstat( fd, &st ) == -1) return errno_to_status( errno );
+    if (fstat( fd, &st ) == -1) return FILE_GetNtStatus();
     if (!S_ISCHR( st.st_mode )) return STATUS_OBJECT_TYPE_MISMATCH;
 
     /* create a dictionary with the right major/minor numbers */
@@ -435,7 +439,7 @@ static NTSTATUS CDROM_SyncCache(int dev, int fd)
    if (ioctl(fd, CDROMREADTOCHDR, &hdr) == -1)
    {
       WARN("(%d) -- Error occurred (%s)!\n", dev, strerror(errno));
-      return errno_to_status( errno );
+      return FILE_GetNtStatus();
    }
 
    toc->FirstTrack = hdr.cdth_trk0;
@@ -451,13 +455,13 @@ static NTSTATUS CDROM_SyncCache(int dev, int fd)
    {
      if (i == toc->LastTrack + 1)
        entry.cdte_track = CDROM_LEADOUT;
-     else
+     else 
        entry.cdte_track = i;
      entry.cdte_format = CDROM_MSF;
      if (ioctl(fd, CDROMREADTOCENTRY, &entry) == -1)
      {
        WARN("error read entry (%s)\n", strerror(errno));
-       return errno_to_status( errno );
+       return FILE_GetNtStatus();
      }
      toc->TrackData[i - toc->FirstTrack].Control = entry.cdte_ctrl;
      toc->TrackData[i - toc->FirstTrack].Adr = entry.cdte_adr;
@@ -484,7 +488,7 @@ static NTSTATUS CDROM_SyncCache(int dev, int fd)
     if (ioctl(fd, CDIOREADTOCHEADER, &hdr) == -1)
     {
         WARN("(%d) -- Error occurred (%s)!\n", dev, strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     toc->FirstTrack = hdr.starting_track;
     toc->LastTrack  = hdr.ending_track;
@@ -511,7 +515,7 @@ static NTSTATUS CDROM_SyncCache(int dev, int fd)
         if (ioctl(fd, CDIOREADTOCENTRYS, &entry) == -1)
         {
 	    WARN("error read entry (%s)\n", strerror(errno));
-            return errno_to_status( errno );
+            return FILE_GetNtStatus();
 	}
         toc->TrackData[i - toc->FirstTrack].Control = toc_buffer.control;
         toc->TrackData[i - toc->FirstTrack].Adr = toc_buffer.addr_type;
@@ -537,7 +541,7 @@ static NTSTATUS CDROM_SyncCache(int dev, int fd)
     if (ioctl(fd, DKIOCCDREADTOC, &hdr) == -1)
     {
         WARN("(%d) -- Error occurred (%s)!\n", dev, strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     for (i = toc->FirstTrack; i <= toc->LastTrack + 1; i++)
     {
@@ -559,9 +563,9 @@ static NTSTATUS CDROM_SyncCache(int dev, int fd)
 
 static void CDROM_ClearCacheEntry(int dev)
 {
-    pthread_mutex_lock( &cache_mutex );
+    RtlEnterCriticalSection( &cache_section );
     cdrom_cache[dev].toc_good = 0;
-    pthread_mutex_unlock( &cache_mutex );
+    RtlLeaveCriticalSection( &cache_section );
 }
 
 
@@ -665,9 +669,9 @@ static NTSTATUS CDROM_Open(int fd, int* dev)
     NTSTATUS ret = STATUS_SUCCESS;
     int         empty = -1;
 
-    if (fstat(fd, &st) == -1) return errno_to_status( errno );
+    if (fstat(fd, &st) == -1) return FILE_GetNtStatus();
 
-    pthread_mutex_lock( &cache_mutex );
+    RtlEnterCriticalSection( &cache_section );
     for (*dev = 0; *dev < MAX_CACHE_ENTRIES; (*dev)++)
     {
         if (empty == -1 &&
@@ -688,7 +692,7 @@ static NTSTATUS CDROM_Open(int fd, int* dev)
             cdrom_cache[*dev].inode   = st.st_ino;
         }
     }
-    pthread_mutex_unlock( &cache_mutex );
+    RtlLeaveCriticalSection( &cache_section );
 
     TRACE("%d, %d\n", *dev, fd);
     return ret;
@@ -702,7 +706,7 @@ static NTSTATUS CDROM_Open(int fd, int* dev)
 static NTSTATUS CDROM_GetStatusCode(int io)
 {
     if (io == 0) return STATUS_SUCCESS;
-    return errno_to_status( errno );
+    return FILE_GetNtStatus();
 }
 
 /******************************************************************
@@ -755,10 +759,10 @@ static NTSTATUS CDROM_GetDriveGeometry(int dev, int fd, DISK_GEOMETRY* dg)
         - FRAME_OF_TOC(toc, 1); /* Total size in frames */
 
   dg->Cylinders.QuadPart = fsize / (64 * 32);
-  dg->MediaType = RemovableMedia;
-  dg->TracksPerCylinder = 64;
-  dg->SectorsPerTrack = 32;
-  dg->BytesPerSector= 2048;
+  dg->MediaType = RemovableMedia;  
+  dg->TracksPerCylinder = 64; 
+  dg->SectorsPerTrack = 32;  
+  dg->BytesPerSector= 2048; 
   return ret;
 }
 
@@ -840,13 +844,13 @@ static NTSTATUS CDROM_ReadTOC(int dev, int fd, CDROM_TOC* toc)
     if (dev < 0 || dev >= MAX_CACHE_ENTRIES)
         return STATUS_INVALID_PARAMETER;
 
-    pthread_mutex_lock( &cache_mutex );
+    RtlEnterCriticalSection( &cache_section );
     if (cdrom_cache[dev].toc_good || !(ret = CDROM_SyncCache(dev, fd)))
     {
         *toc = cdrom_cache[dev].toc;
         ret = STATUS_SUCCESS;
     }
-    pthread_mutex_unlock( &cache_mutex );
+    RtlLeaveCriticalSection( &cache_section );
     return ret;
 }
 
@@ -926,21 +930,21 @@ static NTSTATUS CDROM_ReadQChannel(int dev, int fd, const CDROM_SUB_Q_DATA_FORMA
     switch (fmt->Format)
     {
     case IOCTL_CDROM_CURRENT_POSITION:
-        pthread_mutex_lock( &cache_mutex );
+        RtlEnterCriticalSection( &cache_section );
 	if (hdr->AudioStatus==AUDIO_STATUS_IN_PROGRESS) {
           data->CurrentPosition.FormatCode = IOCTL_CDROM_CURRENT_POSITION;
-          data->CurrentPosition.Control = sc.cdsc_ctrl;
-          data->CurrentPosition.ADR = sc.cdsc_adr;
-          data->CurrentPosition.TrackNumber = sc.cdsc_trk;
-          data->CurrentPosition.IndexNumber = sc.cdsc_ind;
+          data->CurrentPosition.Control = sc.cdsc_ctrl; 
+          data->CurrentPosition.ADR = sc.cdsc_adr; 
+          data->CurrentPosition.TrackNumber = sc.cdsc_trk; 
+          data->CurrentPosition.IndexNumber = sc.cdsc_ind; 
 
-          data->CurrentPosition.AbsoluteAddress[0] = 0;
-          data->CurrentPosition.AbsoluteAddress[1] = sc.cdsc_absaddr.msf.minute;
+          data->CurrentPosition.AbsoluteAddress[0] = 0; 
+          data->CurrentPosition.AbsoluteAddress[1] = sc.cdsc_absaddr.msf.minute; 
           data->CurrentPosition.AbsoluteAddress[2] = sc.cdsc_absaddr.msf.second;
           data->CurrentPosition.AbsoluteAddress[3] = sc.cdsc_absaddr.msf.frame;
-
-          data->CurrentPosition.TrackRelativeAddress[0] = 0;
-          data->CurrentPosition.TrackRelativeAddress[1] = sc.cdsc_reladdr.msf.minute;
+ 
+          data->CurrentPosition.TrackRelativeAddress[0] = 0; 
+          data->CurrentPosition.TrackRelativeAddress[1] = sc.cdsc_reladdr.msf.minute; 
           data->CurrentPosition.TrackRelativeAddress[2] = sc.cdsc_reladdr.msf.second;
           data->CurrentPosition.TrackRelativeAddress[3] = sc.cdsc_reladdr.msf.frame;
 
@@ -951,7 +955,7 @@ static NTSTATUS CDROM_ReadQChannel(int dev, int fd, const CDROM_SUB_Q_DATA_FORMA
 	  cdrom_cache[dev].CurrentPosition.Header = *hdr; /* Preserve header info */
 	  data->CurrentPosition = cdrom_cache[dev].CurrentPosition;
 	}
-        pthread_mutex_unlock( &cache_mutex );
+        RtlLeaveCriticalSection( &cache_section );
         break;
     case IOCTL_CDROM_MEDIA_CATALOG:
         data->MediaCatalog.FormatCode = IOCTL_CDROM_MEDIA_CATALOG;
@@ -1037,7 +1041,7 @@ static NTSTATUS CDROM_ReadQChannel(int dev, int fd, const CDROM_SUB_Q_DATA_FORMA
     switch (fmt->Format)
     {
     case IOCTL_CDROM_CURRENT_POSITION:
-        pthread_mutex_lock( &cache_mutex );
+        RtlEnterCriticalSection( &cache_section );
 	if (hdr->AudioStatus==AUDIO_STATUS_IN_PROGRESS) {
           data->CurrentPosition.FormatCode = IOCTL_CDROM_CURRENT_POSITION;
           data->CurrentPosition.Control = sc.what.position.control;
@@ -1059,7 +1063,7 @@ static NTSTATUS CDROM_ReadQChannel(int dev, int fd, const CDROM_SUB_Q_DATA_FORMA
 	  cdrom_cache[dev].CurrentPosition.Header = *hdr; /* Preserve header info */
 	  data->CurrentPosition = cdrom_cache[dev].CurrentPosition;
 	}
-        pthread_mutex_unlock( &cache_mutex );
+        RtlLeaveCriticalSection( &cache_section );
         break;
     case IOCTL_CDROM_MEDIA_CATALOG:
         data->MediaCatalog.FormatCode = IOCTL_CDROM_MEDIA_CATALOG;
@@ -1248,21 +1252,21 @@ static NTSTATUS CDROM_SeekAudioMSF(int dev, int fd, const CDROM_SEEK_AUDIO_MSF*
     if (i <= toc.FirstTrack || i > toc.LastTrack+1)
       return STATUS_INVALID_PARAMETER;
     i--;
-    pthread_mutex_lock( &cache_mutex );
+    RtlEnterCriticalSection( &cache_section );
     cp = &cdrom_cache[dev].CurrentPosition;
-    cp->FormatCode = IOCTL_CDROM_CURRENT_POSITION;
-    cp->Control = toc.TrackData[i-toc.FirstTrack].Control;
-    cp->ADR = toc.TrackData[i-toc.FirstTrack].Adr;
+    cp->FormatCode = IOCTL_CDROM_CURRENT_POSITION; 
+    cp->Control = toc.TrackData[i-toc.FirstTrack].Control; 
+    cp->ADR = toc.TrackData[i-toc.FirstTrack].Adr; 
     cp->TrackNumber = toc.TrackData[i-toc.FirstTrack].TrackNumber;
     cp->IndexNumber = 0; /* FIXME: where do they keep these? */
-    cp->AbsoluteAddress[0] = 0;
+    cp->AbsoluteAddress[0] = 0; 
     cp->AbsoluteAddress[1] = toc.TrackData[i-toc.FirstTrack].Address[1];
     cp->AbsoluteAddress[2] = toc.TrackData[i-toc.FirstTrack].Address[2];
     cp->AbsoluteAddress[3] = toc.TrackData[i-toc.FirstTrack].Address[3];
     frame -= FRAME_OF_TOC(toc,i);
     cp->TrackRelativeAddress[0] = 0;
-    MSF_OF_FRAME(cp->TrackRelativeAddress[1], frame);
-    pthread_mutex_unlock( &cache_mutex );
+    MSF_OF_FRAME(cp->TrackRelativeAddress[1], frame); 
+    RtlLeaveCriticalSection( &cache_section );
 
     /* If playing, then issue a seek command, otherwise do nothing */
 #ifdef linux
@@ -1297,7 +1301,7 @@ static NTSTATUS CDROM_SeekAudioMSF(int dev, int fd, const CDROM_SEEK_AUDIO_MSF*
 	CDROM_ClearCacheEntry(dev);
         return CDROM_GetStatusCode(io);
     }
-    if (sc.header.audio_status==CD_AS_PLAY_IN_PROGRESS)
+    if (sc.header.audio_status==CD_AS_PLAY_IN_PROGRESS) 
     {
 
       msf.start_m      = audio_msf->M;
@@ -2022,7 +2026,7 @@ static NTSTATUS CDROM_GetAddress(int fd, SCSI_ADDRESS* address)
 
     address->PortNumber = portnum; /* primary=0 secondary=1 for ide */
     address->PathId = busid;       /* always 0 for ide */
-    address->TargetId = targetid;  /* device id 0/1 for ide */
+    address->TargetId = targetid;  /* master=0 slave=1 for ide */
     address->Lun = lun;
     return STATUS_SUCCESS;
 }
@@ -2122,7 +2126,7 @@ static NTSTATUS DVD_SendKey(int fd, const DVD_COPY_PROTECT_KEY *key)
 	auth_info.hsk.agid = (int)key->SessionId;
 
 	memcpy( auth_info.hsk.key, key->KeyData, DVD_KEY_SIZE );
-
+	
 	TRACE("DvdBusKey2\n");
 	ret = CDROM_GetStatusCode(ioctl( fd, DVD_AUTH, &auth_info ));
 	break;
@@ -2179,7 +2183,7 @@ static NTSTATUS DVD_SendKey(int fd, const DVD_COPY_PROTECT_KEY *key)
 #else
     FIXME("not supported on this O/S\n");
     return STATUS_NOT_SUPPORTED;
-#endif
+#endif    
 }
 
 /******************************************************************
@@ -2199,11 +2203,11 @@ static NTSTATUS DVD_ReadKey(int fd, PDVD_COPY_PROTECT_KEY key)
     switch (key->KeyType)
     {
     case DvdDiskKey:
-
+	
 	dvd.type = DVD_STRUCT_DISCKEY;
 	dvd.disckey.agid = (int)key->SessionId;
 	memset( dvd.disckey.value, 0, DVD_DISCKEY_SIZE );
-
+	
 	TRACE("DvdDiskKey\n");
 	ret = CDROM_GetStatusCode(ioctl( fd, DVD_READ_STRUCT, &dvd ));
 	if (ret == STATUS_SUCCESS)
@@ -2214,7 +2218,7 @@ static NTSTATUS DVD_ReadKey(int fd, PDVD_COPY_PROTECT_KEY key)
 	auth_info.lstk.agid = (int)key->SessionId;
 	auth_info.lstk.lba = (int)(key->Parameters.TitleOffset.QuadPart>>11);
 	TRACE("DvdTitleKey session %d Quadpart 0x%08lx offset 0x%08x\n",
-	      (int)key->SessionId, (long)key->Parameters.TitleOffset.QuadPart,
+	      (int)key->SessionId, (long)key->Parameters.TitleOffset.QuadPart, 
 	      auth_info.lstk.lba);
 	ret = CDROM_GetStatusCode(ioctl( fd, DVD_AUTH, &auth_info ));
 	if (ret == STATUS_SUCCESS)
@@ -2762,7 +2766,7 @@ static NTSTATUS DVD_ReadStructure(int dev, const DVD_READ_STRUCTURE *structure,
  *        GetInquiryData
  *        Implements the IOCTL_GET_INQUIRY_DATA ioctl.
  *        Returns Inquiry data for all devices on the specified scsi bus
- *        Returns STATUS_BUFFER_TOO_SMALL if the output buffer is too small,
+ *        Returns STATUS_BUFFER_TOO_SMALL if the output buffer is too small, 
  *        STATUS_INVALID_DEVICE_REQUEST if the given handle isn't to a SCSI device,
  *        or STATUS_NOT_SUPPORTED if the OS driver is too old
  */
@@ -2818,21 +2822,29 @@ static NTSTATUS GetInquiryData(int fd, PSCSI_ADAPTER_BUS_INFO BufferOut, DWORD O
 }
 
 /******************************************************************
- *		cdrom_DeviceIoControl
+ *		CDROM_DeviceIoControl
+ *
+ *
  */
-NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
-                                ULONG in_size, void *out_buffer, ULONG out_size )
+NTSTATUS CDROM_DeviceIoControl(HANDLE hDevice, 
+                               HANDLE hEvent, PIO_APC_ROUTINE UserApcRoutine,
+                               PVOID UserApcContext, 
+                               PIO_STATUS_BLOCK piosb, 
+                               ULONG dwIoControlCode,
+                               LPVOID lpInBuffer, DWORD nInBufferSize,
+                               LPVOID lpOutBuffer, DWORD nOutBufferSize)
 {
     DWORD       sz = 0;
     NTSTATUS    status = STATUS_SUCCESS;
     int fd, needs_close, dev = 0;
 
-    TRACE( "%p %s %p %d %p %d %p\n", device, iocodex(code), in_buffer, in_size, out_buffer, out_size, io );
+    TRACE("%p %s %p %d %p %d %p\n",
+          hDevice, iocodex(dwIoControlCode), lpInBuffer, nInBufferSize,
+          lpOutBuffer, nOutBufferSize, piosb);
 
-    io->Information = 0;
+    piosb->Information = 0;
 
-    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL )))
+    if ((status = server_get_unix_fd( hDevice, 0, &fd, &needs_close, NULL, NULL )))
     {
         if (status == STATUS_BAD_DEVICE_TYPE) return status;  /* no associated fd */
         goto error;
@@ -2856,20 +2868,20 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
          * open the parent if we're trying to eject the disk.
          */
         if ((status = get_parent_device( fd, name, sizeof(name) ))) goto error;
-        if (code == IOCTL_STORAGE_EJECT_MEDIA)
-            NtClose( device );
+        if (dwIoControlCode == IOCTL_STORAGE_EJECT_MEDIA)
+            NtClose( hDevice );
         if (needs_close) close( fd );
         TRACE("opening parent %s\n", name );
         if ((fd = open( name, O_RDONLY )) == -1)
         {
-            status = errno_to_status( errno );
+            status = FILE_GetNtStatus();
             goto error;
         }
         needs_close = 1;
     }
 #endif
 
-    switch (code)
+    switch (dwIoControlCode)
     {
     case IOCTL_CDROM_CHECK_VERIFY:
     case IOCTL_DISK_CHECK_VERIFY:
@@ -2877,7 +2889,7 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
     case IOCTL_STORAGE_CHECK_VERIFY2:
         sz = 0;
 	CDROM_ClearCacheEntry(dev);
-        if (in_buffer != NULL || in_size != 0 || out_buffer != NULL || out_size != 0)
+        if (lpInBuffer != NULL || nInBufferSize != 0 || lpOutBuffer != NULL || nOutBufferSize != 0)
             status = STATUS_INVALID_PARAMETER;
         else status = CDROM_Verify(dev, fd);
         break;
@@ -2891,14 +2903,14 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
     case IOCTL_CDROM_LOAD_MEDIA:
         sz = 0;
 	CDROM_ClearCacheEntry(dev);
-        if (in_buffer != NULL || in_size != 0 || out_buffer != NULL || out_size != 0)
+        if (lpInBuffer != NULL || nInBufferSize != 0 || lpOutBuffer != NULL || nOutBufferSize != 0)
             status = STATUS_INVALID_PARAMETER;
         else status = CDROM_SetTray(fd, FALSE);
         break;
      case IOCTL_STORAGE_EJECT_MEDIA:
         sz = 0;
 	CDROM_ClearCacheEntry(dev);
-        if (in_buffer != NULL || in_size != 0 || out_buffer != NULL || out_size != 0)
+        if (lpInBuffer != NULL || nInBufferSize != 0 || lpOutBuffer != NULL || nOutBufferSize != 0)
             status = STATUS_INVALID_PARAMETER;
         else
             status = CDROM_SetTray(fd, TRUE);
@@ -2912,216 +2924,216 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
          * lockcount/owner should be handled */
         sz = 0;
 	CDROM_ClearCacheEntry(dev);
-        if (out_buffer != NULL || out_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (in_size < sizeof(PREVENT_MEDIA_REMOVAL)) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_ControlEjection(fd, in_buffer);
+        if (lpOutBuffer != NULL || nOutBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nInBufferSize < sizeof(PREVENT_MEDIA_REMOVAL)) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_ControlEjection(fd, lpInBuffer);
         break;
 
     case IOCTL_DISK_GET_MEDIA_TYPES:
     case IOCTL_STORAGE_GET_MEDIA_TYPES:
     case IOCTL_STORAGE_GET_MEDIA_TYPES_EX:
         sz = sizeof(GET_MEDIA_TYPES);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_GetMediaType(dev, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_GetMediaType(dev, lpOutBuffer);
         break;
 
     case IOCTL_STORAGE_GET_DEVICE_NUMBER:
         sz = sizeof(STORAGE_DEVICE_NUMBER);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_GetDeviceNumber(dev, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_GetDeviceNumber(dev, lpOutBuffer);
         break;
 
     case IOCTL_STORAGE_RESET_DEVICE:
         sz = 0;
 	CDROM_ClearCacheEntry(dev);
-        if (in_buffer != NULL || in_size != 0 || out_buffer != NULL || out_size != 0)
+        if (lpInBuffer != NULL || nInBufferSize != 0 || lpOutBuffer != NULL || nOutBufferSize != 0)
             status = STATUS_INVALID_PARAMETER;
         else status = CDROM_ResetAudio(fd);
         break;
 
     case IOCTL_CDROM_GET_CONTROL:
         sz = sizeof(CDROM_AUDIO_CONTROL);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_GetControl(dev, fd, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_GetControl(dev, fd, lpOutBuffer);
         break;
 
     case IOCTL_CDROM_GET_DRIVE_GEOMETRY:
         sz = sizeof(DISK_GEOMETRY);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_GetDriveGeometry(dev, fd, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_GetDriveGeometry(dev, fd, lpOutBuffer);
         break;
 
     case IOCTL_CDROM_DISK_TYPE:
         sz = sizeof(CDROM_DISK_DATA);
 	/* CDROM_ClearCacheEntry(dev); */
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_GetDiskData(dev, fd, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_GetDiskData(dev, fd, lpOutBuffer);
         break;
 
 /* EPP     case IOCTL_CDROM_GET_LAST_SESSION: */
 
     case IOCTL_CDROM_READ_Q_CHANNEL:
         sz = sizeof(SUB_Q_CHANNEL_DATA);
-        if (in_buffer == NULL || in_size < sizeof(CDROM_SUB_Q_DATA_FORMAT))
+        if (lpInBuffer == NULL || nInBufferSize < sizeof(CDROM_SUB_Q_DATA_FORMAT))
             status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_ReadQChannel(dev, fd, in_buffer, out_buffer);
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_ReadQChannel(dev, fd, lpInBuffer, lpOutBuffer);
         break;
 
     case IOCTL_CDROM_READ_TOC:
         sz = sizeof(CDROM_TOC);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_ReadTOC(dev, fd, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_ReadTOC(dev, fd, lpOutBuffer);
         break;
 
 /* EPP     case IOCTL_CDROM_READ_TOC_EX: */
 
     case IOCTL_CDROM_PAUSE_AUDIO:
         sz = 0;
-        if (in_buffer != NULL || in_size != 0 || out_buffer != NULL || out_size != 0)
+        if (lpInBuffer != NULL || nInBufferSize != 0 || lpOutBuffer != NULL || nOutBufferSize != 0)
             status = STATUS_INVALID_PARAMETER;
         else status = CDROM_PauseAudio(fd);
         break;
     case IOCTL_CDROM_PLAY_AUDIO_MSF:
         sz = 0;
-        if (out_buffer != NULL || out_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (in_size < sizeof(CDROM_PLAY_AUDIO_MSF)) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_PlayAudioMSF(fd, in_buffer);
+        if (lpOutBuffer != NULL || nOutBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nInBufferSize < sizeof(CDROM_PLAY_AUDIO_MSF)) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_PlayAudioMSF(fd, lpInBuffer);
         break;
     case IOCTL_CDROM_RESUME_AUDIO:
         sz = 0;
-        if (in_buffer != NULL || in_size != 0 || out_buffer != NULL || out_size != 0)
+        if (lpInBuffer != NULL || nInBufferSize != 0 || lpOutBuffer != NULL || nOutBufferSize != 0)
             status = STATUS_INVALID_PARAMETER;
         else status = CDROM_ResumeAudio(fd);
         break;
     case IOCTL_CDROM_SEEK_AUDIO_MSF:
         sz = 0;
-        if (out_buffer != NULL || out_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (in_size < sizeof(CDROM_SEEK_AUDIO_MSF)) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_SeekAudioMSF(dev, fd, in_buffer);
+        if (lpOutBuffer != NULL || nOutBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nInBufferSize < sizeof(CDROM_SEEK_AUDIO_MSF)) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_SeekAudioMSF(dev, fd, lpInBuffer);
         break;
     case IOCTL_CDROM_STOP_AUDIO:
         sz = 0;
 	CDROM_ClearCacheEntry(dev); /* Maybe intention is to change media */
-        if (in_buffer != NULL || in_size != 0 || out_buffer != NULL || out_size != 0)
+        if (lpInBuffer != NULL || nInBufferSize != 0 || lpOutBuffer != NULL || nOutBufferSize != 0)
             status = STATUS_INVALID_PARAMETER;
         else status = CDROM_StopAudio(fd);
         break;
     case IOCTL_CDROM_GET_VOLUME:
         sz = sizeof(VOLUME_CONTROL);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_GetVolume(fd, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_GetVolume(fd, lpOutBuffer);
         break;
     case IOCTL_CDROM_SET_VOLUME:
         sz = 0;
 	CDROM_ClearCacheEntry(dev);
-        if (in_buffer == NULL || in_size < sizeof(VOLUME_CONTROL) || out_buffer != NULL)
+        if (lpInBuffer == NULL || nInBufferSize < sizeof(VOLUME_CONTROL) || lpOutBuffer != NULL)
             status = STATUS_INVALID_PARAMETER;
-        else status = CDROM_SetVolume(fd, in_buffer);
+        else status = CDROM_SetVolume(fd, lpInBuffer);
         break;
     case IOCTL_CDROM_RAW_READ:
         sz = 0;
-        if (in_size < sizeof(RAW_READ_INFO)) status = STATUS_INVALID_PARAMETER;
-        else if (out_buffer == NULL) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_RawRead(fd, in_buffer, out_buffer,
-                                    out_size, &sz);
+        if (nInBufferSize < sizeof(RAW_READ_INFO)) status = STATUS_INVALID_PARAMETER;
+        else if (lpOutBuffer == NULL) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_RawRead(fd, lpInBuffer, lpOutBuffer,
+                                    nOutBufferSize, &sz);
         break;
     case IOCTL_SCSI_GET_ADDRESS:
         sz = sizeof(SCSI_ADDRESS);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_GetAddress(fd, out_buffer);
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_GetAddress(fd, lpOutBuffer);
         break;
     case IOCTL_SCSI_PASS_THROUGH_DIRECT:
         sz = sizeof(SCSI_PASS_THROUGH_DIRECT);
-        if (out_buffer == NULL) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sizeof(SCSI_PASS_THROUGH_DIRECT)) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_ScsiPassThroughDirect(fd, out_buffer);
+        if (lpOutBuffer == NULL) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sizeof(SCSI_PASS_THROUGH_DIRECT)) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_ScsiPassThroughDirect(fd, lpOutBuffer);
         break;
     case IOCTL_SCSI_PASS_THROUGH:
         sz = sizeof(SCSI_PASS_THROUGH);
-        if (out_buffer == NULL) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sizeof(SCSI_PASS_THROUGH)) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_ScsiPassThrough(fd, out_buffer);
+        if (lpOutBuffer == NULL) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sizeof(SCSI_PASS_THROUGH)) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_ScsiPassThrough(fd, lpOutBuffer);
         break;
     case IOCTL_SCSI_GET_CAPABILITIES:
         sz = sizeof(IO_SCSI_CAPABILITIES);
-        if (out_buffer == NULL) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sizeof(IO_SCSI_CAPABILITIES)) status = STATUS_BUFFER_TOO_SMALL;
-        else status = CDROM_ScsiGetCaps(fd, out_buffer);
+        if (lpOutBuffer == NULL) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sizeof(IO_SCSI_CAPABILITIES)) status = STATUS_BUFFER_TOO_SMALL;
+        else status = CDROM_ScsiGetCaps(fd, lpOutBuffer);
         break;
     case IOCTL_DVD_START_SESSION:
         sz = sizeof(DVD_SESSION_ID);
-        if (out_buffer == NULL) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
+        if (lpOutBuffer == NULL) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
         else
         {
-            TRACE("before in 0x%08x out 0x%08x\n",(in_buffer)?*(PDVD_SESSION_ID)in_buffer:0,
-                  *(PDVD_SESSION_ID)out_buffer);
-            status = DVD_StartSession(fd, in_buffer, out_buffer);
-            TRACE("before in 0x%08x out 0x%08x\n",(in_buffer)?*(PDVD_SESSION_ID)in_buffer:0,
-                  *(PDVD_SESSION_ID)out_buffer);
+            TRACE("before in 0x%08x out 0x%08x\n",(lpInBuffer)?*(PDVD_SESSION_ID)lpInBuffer:0,
+                  *(PDVD_SESSION_ID)lpOutBuffer);
+            status = DVD_StartSession(fd, lpInBuffer, lpOutBuffer);
+            TRACE("before in 0x%08x out 0x%08x\n",(lpInBuffer)?*(PDVD_SESSION_ID)lpInBuffer:0,
+                  *(PDVD_SESSION_ID)lpOutBuffer);
         }
         break;
     case IOCTL_DVD_END_SESSION:
         sz = sizeof(DVD_SESSION_ID);
-        if ((in_buffer == NULL) ||  (in_size < sz))status = STATUS_INVALID_PARAMETER;
-        else status = DVD_EndSession(fd, in_buffer);
+        if ((lpInBuffer == NULL) ||  (nInBufferSize < sz))status = STATUS_INVALID_PARAMETER;
+        else status = DVD_EndSession(fd, lpInBuffer);
         break;
     case IOCTL_DVD_SEND_KEY:
         sz = 0;
-        if (!in_buffer ||
-            (((PDVD_COPY_PROTECT_KEY)in_buffer)->KeyLength != in_size))
+        if (!lpInBuffer ||
+            (((PDVD_COPY_PROTECT_KEY)lpInBuffer)->KeyLength != nInBufferSize))
             status = STATUS_INVALID_PARAMETER;
         else
         {
             TRACE("doing DVD_SendKey\n");
-            status = DVD_SendKey(fd, in_buffer);
+            status = DVD_SendKey(fd, lpInBuffer);
         }
         break;
     case IOCTL_DVD_READ_KEY:
-        if (!in_buffer ||
-            (((PDVD_COPY_PROTECT_KEY)in_buffer)->KeyLength != in_size))
+        if (!lpInBuffer ||
+            (((PDVD_COPY_PROTECT_KEY)lpInBuffer)->KeyLength != nInBufferSize))
             status = STATUS_INVALID_PARAMETER;
-        else if (in_buffer !=out_buffer) status = STATUS_BUFFER_TOO_SMALL;
+        else if (lpInBuffer !=lpOutBuffer) status = STATUS_BUFFER_TOO_SMALL;
         else
         {
             TRACE("doing DVD_READ_KEY\n");
-            sz = ((PDVD_COPY_PROTECT_KEY)in_buffer)->KeyLength;
-            status = DVD_ReadKey(fd, in_buffer);
+            sz = ((PDVD_COPY_PROTECT_KEY)lpInBuffer)->KeyLength;
+            status = DVD_ReadKey(fd, lpInBuffer);
         }
         break;
     case IOCTL_DVD_GET_REGION:
         sz = sizeof(DVD_REGION);
-        if (in_buffer != NULL || in_size != 0) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz) status = STATUS_BUFFER_TOO_SMALL;
+        if (lpInBuffer != NULL || nInBufferSize != 0) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz) status = STATUS_BUFFER_TOO_SMALL;
         else
         {
             TRACE("doing DVD_Get_REGION\n");
-            status = DVD_GetRegion(fd, out_buffer);
+            status = DVD_GetRegion(fd, lpOutBuffer);
         }
         break;
     case IOCTL_DVD_READ_STRUCTURE:
-        sz = DVD_ReadStructureSize(in_buffer, in_size);
-        if (in_buffer == NULL || in_size != sizeof(DVD_READ_STRUCTURE)) status = STATUS_INVALID_PARAMETER;
-        else if (out_size < sz || !out_buffer) status = STATUS_BUFFER_TOO_SMALL;
+        sz = DVD_ReadStructureSize(lpInBuffer, nInBufferSize);
+        if (lpInBuffer == NULL || nInBufferSize != sizeof(DVD_READ_STRUCTURE)) status = STATUS_INVALID_PARAMETER;
+        else if (nOutBufferSize < sz || !lpOutBuffer) status = STATUS_BUFFER_TOO_SMALL;
         else
         {
             TRACE("doing DVD_READ_STRUCTURE\n");
-            status = DVD_ReadStructure(fd, in_buffer, out_buffer);
+            status = DVD_ReadStructure(fd, lpInBuffer, lpOutBuffer);
         }
         break;
 
     case IOCTL_SCSI_GET_INQUIRY_DATA:
         sz = INQ_REPLY_LEN;
-        status = GetInquiryData(fd, out_buffer, out_size);
+        status = GetInquiryData(fd, lpOutBuffer, nOutBufferSize);
         break;
 
     default:
@@ -3130,8 +3142,8 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
     }
     if (needs_close) close( fd );
  error:
-    io->u.Status = status;
-    io->Information = sz;
-    if (event) NtSetEvent(event, NULL);
+    piosb->u.Status = status;
+    piosb->Information = sz;
+    if (hEvent) NtSetEvent(hEvent, NULL);
     return status;
 }
diff --git a/dlls/ntdll/critsection.c b/dlls/ntdll/critsection.c
index fe7d933c0f..71cc6c3f19 100644
--- a/dlls/ntdll/critsection.c
+++ b/dlls/ntdll/critsection.c
@@ -18,11 +18,17 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <errno.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <sys/types.h>
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
 #include <time.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -50,6 +56,147 @@ static BOOL crit_section_has_debuginfo(const RTL_CRITICAL_SECTION *crit)
     return crit->DebugInfo != NULL && crit->DebugInfo != no_debug_info_marker;
 }
 
+#ifdef __linux__
+
+static int wait_op = 128; /*FUTEX_WAIT|FUTEX_PRIVATE_FLAG*/
+static int wake_op = 129; /*FUTEX_WAKE|FUTEX_PRIVATE_FLAG*/
+
+static inline int futex_wait( int *addr, int val, struct timespec *timeout )
+{
+    return syscall( __NR_futex, addr, wait_op, val, timeout, 0, 0 );
+}
+
+static inline int futex_wake( int *addr, int val )
+{
+    return syscall( __NR_futex, addr, wake_op, val, NULL, 0, 0 );
+}
+
+static inline int use_futexes(void)
+{
+    static int supported = -1;
+
+    if (supported == -1)
+    {
+        futex_wait( &supported, 10, NULL );
+        if (errno == ENOSYS)
+        {
+            wait_op = 0; /*FUTEX_WAIT*/
+            wake_op = 1; /*FUTEX_WAKE*/
+            futex_wait( &supported, 10, NULL );
+        }
+        supported = (errno != ENOSYS);
+    }
+    return supported;
+}
+
+static inline NTSTATUS fast_wait( RTL_CRITICAL_SECTION *crit, int timeout )
+{
+    int val;
+    struct timespec timespec;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    timespec.tv_sec  = timeout;
+    timespec.tv_nsec = 0;
+    while ((val = InterlockedCompareExchange( (int *)&crit->LockSemaphore, 0, 1 )) != 1)
+    {
+        /* note: this may wait longer than specified in case of signals or */
+        /*       multiple wake-ups, but that shouldn't be a problem */
+        if (futex_wait( (int *)&crit->LockSemaphore, val, &timespec ) == -1 && errno == ETIMEDOUT)
+            return STATUS_TIMEOUT;
+    }
+    return STATUS_WAIT_0;
+}
+
+static inline NTSTATUS fast_wake( RTL_CRITICAL_SECTION *crit )
+{
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    *(int *)&crit->LockSemaphore = 1;
+    futex_wake( (int *)&crit->LockSemaphore, 1 );
+    return STATUS_SUCCESS;
+}
+
+static inline void close_semaphore( RTL_CRITICAL_SECTION *crit )
+{
+    if (!use_futexes()) NtClose( crit->LockSemaphore );
+}
+
+#elif defined(__APPLE__)
+
+#include <mach/mach.h>
+#include <mach/task.h>
+#include <mach/semaphore.h>
+
+static inline semaphore_t get_mach_semaphore( RTL_CRITICAL_SECTION *crit )
+{
+    semaphore_t ret = *(int *)&crit->LockSemaphore;
+    if (!ret)
+    {
+        semaphore_t sem;
+        if (semaphore_create( mach_task_self(), &sem, SYNC_POLICY_FIFO, 0 )) return 0;
+        if (!(ret = InterlockedCompareExchange( (int *)&crit->LockSemaphore, sem, 0 )))
+            ret = sem;
+        else
+            semaphore_destroy( mach_task_self(), sem );  /* somebody beat us to it */
+    }
+    return ret;
+}
+
+static inline NTSTATUS fast_wait( RTL_CRITICAL_SECTION *crit, int timeout )
+{
+    mach_timespec_t timespec;
+    semaphore_t sem = get_mach_semaphore( crit );
+
+    timespec.tv_sec = timeout;
+    timespec.tv_nsec = 0;
+    for (;;)
+    {
+        switch( semaphore_timedwait( sem, timespec ))
+        {
+        case KERN_SUCCESS:
+            return STATUS_WAIT_0;
+        case KERN_ABORTED:
+            continue;  /* got a signal, restart */
+        case KERN_OPERATION_TIMED_OUT:
+            return STATUS_TIMEOUT;
+        default:
+            return STATUS_INVALID_HANDLE;
+        }
+    }
+}
+
+static inline NTSTATUS fast_wake( RTL_CRITICAL_SECTION *crit )
+{
+    semaphore_t sem = get_mach_semaphore( crit );
+    semaphore_signal( sem );
+    return STATUS_SUCCESS;
+}
+
+static inline void close_semaphore( RTL_CRITICAL_SECTION *crit )
+{
+    semaphore_destroy( mach_task_self(), *(int *)&crit->LockSemaphore );
+}
+
+#else  /* __APPLE__ */
+
+static inline NTSTATUS fast_wait( RTL_CRITICAL_SECTION *crit, int timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static inline NTSTATUS fast_wake( RTL_CRITICAL_SECTION *crit )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static inline void close_semaphore( RTL_CRITICAL_SECTION *crit )
+{
+    NtClose( crit->LockSemaphore );
+}
+
+#endif
+
 /***********************************************************************
  *           get_semaphore
  */
@@ -76,14 +223,16 @@ static inline NTSTATUS wait_semaphore( RTL_CRITICAL_SECTION *crit, int timeout )
     NTSTATUS ret;
 
     /* debug info is cleared by MakeCriticalSectionGlobal */
-    if (!crit_section_has_debuginfo( crit ) ||
-        ((ret = unix_funcs->fast_RtlpWaitForCriticalSection( crit, timeout )) == STATUS_NOT_IMPLEMENTED))
+    if (!crit_section_has_debuginfo( crit ) || ((ret = fast_wait( crit, timeout )) == STATUS_NOT_IMPLEMENTED))
     {
         HANDLE sem = get_semaphore( crit );
         LARGE_INTEGER time;
+        select_op_t select_op;
 
         time.QuadPart = timeout * (LONGLONG)-10000000;
-        ret = NtWaitForSingleObject( sem, FALSE, &time );
+        select_op.wait.op = SELECT_WAIT;
+        select_op.wait.handles[0] = wine_server_obj_handle( sem );
+        ret = server_wait( &select_op, offsetof( select_op_t, wait.handles[1] ), 0, &time );
     }
     return ret;
 }
@@ -253,8 +402,7 @@ NTSTATUS WINAPI RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
             RtlFreeHeap( GetProcessHeap(), 0, crit->DebugInfo );
             crit->DebugInfo = NULL;
         }
-        if (unix_funcs->fast_RtlDeleteCriticalSection( crit ) == STATUS_NOT_IMPLEMENTED)
-            NtClose( crit->LockSemaphore );
+        close_semaphore( crit );
     }
     else NtClose( crit->LockSemaphore );
     crit->LockSemaphore = 0;
@@ -368,8 +516,7 @@ NTSTATUS WINAPI RtlpUnWaitCriticalSection( RTL_CRITICAL_SECTION *crit )
     NTSTATUS ret;
 
     /* debug info is cleared by MakeCriticalSectionGlobal */
-    if (!crit_section_has_debuginfo( crit ) ||
-        ((ret = unix_funcs->fast_RtlpUnWaitCriticalSection( crit )) == STATUS_NOT_IMPLEMENTED))
+    if (!crit_section_has_debuginfo( crit ) || ((ret = fast_wake( crit )) == STATUS_NOT_IMPLEMENTED))
     {
         HANDLE sem = get_semaphore( crit );
         ret = NtReleaseSemaphore( sem, 1, NULL );
diff --git a/dlls/ntdll/debugbuffer.c b/dlls/ntdll/debugbuffer.c
index 3ac765d454..ef8baebda0 100644
--- a/dlls/ntdll/debugbuffer.c
+++ b/dlls/ntdll/debugbuffer.c
@@ -18,6 +18,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
index dbfba303b2..d18df38f62 100644
--- a/dlls/ntdll/directory.c
+++ b/dlls/ntdll/directory.c
@@ -20,66 +20,2661 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <sys/types.h>
+#ifdef HAVE_DIRENT_H
+# include <dirent.h>
+#endif
+#include <errno.h>
 #include <fcntl.h>
 #include <stdarg.h>
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <limits.h>
+#ifdef HAVE_MNTENT_H
+#include <mntent.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+#ifdef HAVE_SYS_ATTR_H
+#include <sys/attr.h>
+#endif
+#ifdef MAJOR_IN_MKDEV
+# include <sys/mkdev.h>
+#elif defined(MAJOR_IN_SYSMACROS)
+# include <sys/sysmacros.h>
+#endif
+#ifdef HAVE_SYS_VNODE_H
+# ifdef HAVE_STDINT_H
+# include <stdint.h>  /* needed for kfreebsd */
+# endif
+/* Work around a conflict with Solaris' system list defined in sys/list.h. */
+#define list SYSLIST
+#define list_next SYSLIST_NEXT
+#define list_prev SYSLIST_PREV
+#define list_head SYSLIST_HEAD
+#define list_tail SYSLIST_TAIL
+#define list_move_tail SYSLIST_MOVE_TAIL
+#define list_remove SYSLIST_REMOVE
+#include <sys/vnode.h>
+#undef list
+#undef list_next
+#undef list_prev
+#undef list_head
+#undef list_tail
+#undef list_move_tail
+#undef list_remove
+#endif
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+#ifdef HAVE_LINUX_IOCTL_H
+#include <linux/ioctl.h>
+#endif
+#ifdef HAVE_LINUX_MAJOR_H
+# include <linux/major.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+#ifdef HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#include <time.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#define NONAMELESSUNION
+#include "windef.h"
+#include "winnt.h"
+#include "winternl.h"
+#include "ddk/wdm.h"
+#include "ntdll_misc.h"
+#include "wine/server.h"
+#include "wine/list.h"
+#include "wine/debug.h"
+#include "wine/exception.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(file);
+
+/* just in case... */
+#undef VFAT_IOCTL_READDIR_BOTH
+#undef EXT2_IOC_GETFLAGS
+#undef EXT4_CASEFOLD_FL
+
+#ifdef linux
+
+/* We want the real kernel dirent structure, not the libc one */
+typedef struct
+{
+    long d_ino;
+    long d_off;
+    unsigned short d_reclen;
+    char d_name[256];
+} KERNEL_DIRENT;
+
+/* Define the VFAT ioctl to get both short and long file names */
+#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, KERNEL_DIRENT [2] )
+
+/* Define the ext2 ioctl for handling extra attributes */
+#define EXT2_IOC_GETFLAGS _IOR('f', 1, long)
+
+/* Case-insensitivity attribute */
+#define EXT4_CASEFOLD_FL 0x40000000
+
+#ifndef O_DIRECTORY
+# define O_DIRECTORY 0200000 /* must be directory */
+#endif
+
+#ifndef AT_NO_AUTOMOUNT
+#define AT_NO_AUTOMOUNT 0x800
+#endif
+
+#endif  /* linux */
+
+#define IS_OPTION_TRUE(ch) ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+#define IS_SEPARATOR(ch)   ((ch) == '\\' || (ch) == '/')
+
+#define INVALID_NT_CHARS   '*','?','<','>','|','"'
+#define INVALID_DOS_CHARS  INVALID_NT_CHARS,'+','=',',',';','[',']',' ','\345'
+
+#define MAX_DIR_ENTRY_LEN 255  /* max length of a directory entry in chars */
+
+#define MAX_IGNORED_FILES 4
+
+struct file_identity
+{
+    dev_t dev;
+    ino_t ino;
+};
+
+static struct file_identity ignored_files[MAX_IGNORED_FILES];
+static unsigned int ignored_files_count;
+
+union file_directory_info
+{
+    ULONG                              next;
+    FILE_DIRECTORY_INFORMATION         dir;
+    FILE_BOTH_DIRECTORY_INFORMATION    both;
+    FILE_FULL_DIRECTORY_INFORMATION    full;
+    FILE_ID_BOTH_DIRECTORY_INFORMATION id_both;
+    FILE_ID_FULL_DIRECTORY_INFORMATION id_full;
+    FILE_ID_GLOBAL_TX_DIR_INFORMATION  id_tx;
+    FILE_NAMES_INFORMATION             names;
+};
+
+struct dir_data_buffer
+{
+    struct dir_data_buffer *next;    /* next buffer in the list */
+    unsigned int            size;    /* total size of the buffer */
+    unsigned int            pos;     /* current position in the buffer */
+    char                    data[1];
+};
+
+struct dir_data_names
+{
+    const WCHAR *long_name;          /* long file name in Unicode */
+    const WCHAR *short_name;         /* short file name in Unicode */
+    const char  *unix_name;          /* Unix file name in host encoding */
+};
+
+struct dir_data
+{
+    unsigned int            size;    /* size of the names array */
+    unsigned int            count;   /* count of used entries in the names array */
+    unsigned int            pos;     /* current reading position in the names array */
+    struct file_identity    id;      /* directory file identity */
+    struct dir_data_names  *names;   /* directory file names */
+    struct dir_data_buffer *buffer;  /* head of data buffers list */
+};
+
+static const unsigned int dir_data_buffer_initial_size = 4096;
+static const unsigned int dir_data_cache_initial_size  = 256;
+static const unsigned int dir_data_names_initial_size  = 64;
+
+static struct dir_data **dir_data_cache;
+static unsigned int dir_data_cache_size;
+
+static BOOL show_dot_files;
+static RTL_RUN_ONCE init_once = RTL_RUN_ONCE_INIT;
+
+/* at some point we may want to allow Winelib apps to set this */
+static const BOOL is_case_sensitive = FALSE;
+
+static struct file_identity windir;
+
+static RTL_CRITICAL_SECTION dir_section;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &dir_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dir_section") }
+};
+static RTL_CRITICAL_SECTION dir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+
+/* check if a given Unicode char is OK in a DOS short name */
+static inline BOOL is_invalid_dos_char( WCHAR ch )
+{
+    static const WCHAR invalid_chars[] = { INVALID_DOS_CHARS,'~','.',0 };
+    if (ch > 0x7f) return TRUE;
+    return wcschr( invalid_chars, ch ) != NULL;
+}
+
+/* check if the device can be a mounted volume */
+static inline BOOL is_valid_mounted_device( const struct stat *st )
+{
+#if defined(linux) || defined(__sun__)
+    return S_ISBLK( st->st_mode );
+#else
+    /* disks are char devices on *BSD */
+    return S_ISCHR( st->st_mode );
+#endif
+}
+
+static inline void ignore_file( const char *name )
+{
+    struct stat st;
+    assert( ignored_files_count < MAX_IGNORED_FILES );
+    if (!stat( name, &st ))
+    {
+        ignored_files[ignored_files_count].dev = st.st_dev;
+        ignored_files[ignored_files_count].ino = st.st_ino;
+        ignored_files_count++;
+    }
+}
+
+static inline BOOL is_same_file( const struct file_identity *file, const struct stat *st )
+{
+    return st->st_dev == file->dev && st->st_ino == file->ino;
+}
+
+static inline BOOL is_ignored_file( const struct stat *st )
+{
+    unsigned int i;
+
+    for (i = 0; i < ignored_files_count; i++)
+        if (is_same_file( &ignored_files[i], st )) return TRUE;
+    return FALSE;
+}
+
+static inline unsigned int dir_info_align( unsigned int len )
+{
+    return (len + 7) & ~7;
+}
+
+static inline unsigned int dir_info_size( FILE_INFORMATION_CLASS class, unsigned int len )
+{
+    switch (class)
+    {
+    case FileDirectoryInformation:
+        return offsetof( FILE_DIRECTORY_INFORMATION, FileName[len] );
+    case FileBothDirectoryInformation:
+        return offsetof( FILE_BOTH_DIRECTORY_INFORMATION, FileName[len] );
+    case FileFullDirectoryInformation:
+        return offsetof( FILE_FULL_DIRECTORY_INFORMATION, FileName[len] );
+    case FileIdBothDirectoryInformation:
+        return offsetof( FILE_ID_BOTH_DIRECTORY_INFORMATION, FileName[len] );
+    case FileIdFullDirectoryInformation:
+        return offsetof( FILE_ID_FULL_DIRECTORY_INFORMATION, FileName[len] );
+    case FileIdGlobalTxDirectoryInformation:
+        return offsetof( FILE_ID_GLOBAL_TX_DIR_INFORMATION, FileName[len] );
+    case FileNamesInformation:
+        return offsetof( FILE_NAMES_INFORMATION, FileName[len] );
+    default:
+        assert(0);
+        return 0;
+    }
+}
+
+static inline BOOL has_wildcard( const UNICODE_STRING *mask )
+{
+    int i;
+
+    if (!mask) return TRUE;
+    for (i = 0; i < mask->Length / sizeof(WCHAR); i++)
+        if (mask->Buffer[i] == '*' || mask->Buffer[i] == '?') return TRUE;
+    return FALSE;
+}
+
+/* get space from the current directory data buffer, allocating a new one if necessary */
+static void *get_dir_data_space( struct dir_data *data, unsigned int size )
+{
+    struct dir_data_buffer *buffer = data->buffer;
+    void *ret;
+
+    if (!buffer || size > buffer->size - buffer->pos)
+    {
+        unsigned int new_size = buffer ? buffer->size * 2 : dir_data_buffer_initial_size;
+        if (new_size < size) new_size = size;
+        if (!(buffer = RtlAllocateHeap( GetProcessHeap(), 0,
+                                        offsetof( struct dir_data_buffer, data[new_size] ) ))) return NULL;
+        buffer->pos  = 0;
+        buffer->size = new_size;
+        buffer->next = data->buffer;
+        data->buffer = buffer;
+    }
+    ret = buffer->data + buffer->pos;
+    buffer->pos += size;
+    return ret;
+}
+
+/* add a string to the directory data buffer */
+static const char *add_dir_data_nameA( struct dir_data *data, const char *name )
+{
+    /* keep buffer data WCHAR-aligned */
+    char *ptr = get_dir_data_space( data, (strlen( name ) + sizeof(WCHAR)) & ~(sizeof(WCHAR) - 1) );
+    if (ptr) strcpy( ptr, name );
+    return ptr;
+}
+
+/* add a Unicode string to the directory data buffer */
+static const WCHAR *add_dir_data_nameW( struct dir_data *data, const WCHAR *name )
+{
+    WCHAR *ptr = get_dir_data_space( data, (wcslen( name ) + 1) * sizeof(WCHAR) );
+    if (ptr) wcscpy( ptr, name );
+    return ptr;
+}
+
+/* add an entry to the directory names array */
+static BOOL add_dir_data_names( struct dir_data *data, const WCHAR *long_name,
+                                const WCHAR *short_name, const char *unix_name )
+{
+    static const WCHAR empty[1];
+    struct dir_data_names *names = data->names;
+
+    if (data->count >= data->size)
+    {
+        unsigned int new_size = max( data->size * 2, dir_data_names_initial_size );
+
+        if (names) names = RtlReAllocateHeap( GetProcessHeap(), 0, names, new_size * sizeof(*names) );
+        else names = RtlAllocateHeap( GetProcessHeap(), 0, new_size * sizeof(*names) );
+        if (!names) return FALSE;
+        data->size  = new_size;
+        data->names = names;
+    }
+
+    if (short_name[0])
+    {
+        if (!(names[data->count].short_name = add_dir_data_nameW( data, short_name ))) return FALSE;
+    }
+    else names[data->count].short_name = empty;
+
+    if (!(names[data->count].long_name = add_dir_data_nameW( data, long_name ))) return FALSE;
+    if (!(names[data->count].unix_name = add_dir_data_nameA( data, unix_name ))) return FALSE;
+    data->count++;
+    return TRUE;
+}
+
+/* free the complete directory data structure */
+static void free_dir_data( struct dir_data *data )
+{
+    struct dir_data_buffer *buffer, *next;
+
+    if (!data) return;
+
+    for (buffer = data->buffer; buffer; buffer = next)
+    {
+        next = buffer->next;
+        RtlFreeHeap( GetProcessHeap(), 0, buffer );
+    }
+    RtlFreeHeap( GetProcessHeap(), 0, data->names );
+    RtlFreeHeap( GetProcessHeap(), 0, data );
+}
+
+
+/* support for a directory queue for filesystem searches */
+
+struct dir_name
+{
+    struct list entry;
+    char name[1];
+};
+
+static struct list dir_queue = LIST_INIT( dir_queue );
+
+static NTSTATUS add_dir_to_queue( const char *name )
+{
+    int len = strlen( name ) + 1;
+    struct dir_name *dir = RtlAllocateHeap( GetProcessHeap(), 0,
+                                            FIELD_OFFSET( struct dir_name, name[len] ));
+    if (!dir) return STATUS_NO_MEMORY;
+    strcpy( dir->name, name );
+    list_add_tail( &dir_queue, &dir->entry );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS next_dir_in_queue( char *name )
+{
+    struct list *head = list_head( &dir_queue );
+    if (head)
+    {
+        struct dir_name *dir = LIST_ENTRY( head, struct dir_name, entry );
+        strcpy( name, dir->name );
+        list_remove( &dir->entry );
+        RtlFreeHeap( GetProcessHeap(), 0, dir );
+        return STATUS_SUCCESS;
+    }
+    return STATUS_OBJECT_NAME_NOT_FOUND;
+}
+
+static void flush_dir_queue(void)
+{
+    struct list *head;
+
+    while ((head = list_head( &dir_queue )))
+    {
+        struct dir_name *dir = LIST_ENTRY( head, struct dir_name, entry );
+        list_remove( &dir->entry );
+        RtlFreeHeap( GetProcessHeap(), 0, dir );
+    }
+}
+
+
+#ifdef __ANDROID__
+
+static char *unescape_field( char *str )
+{
+    char *in, *out;
+
+    for (in = out = str; *in; in++, out++)
+    {
+        *out = *in;
+        if (in[0] == '\\')
+        {
+            if (in[1] == '\\')
+            {
+                out[0] = '\\';
+                in++;
+            }
+            else if (in[1] == '0' && in[2] == '4' && in[3] == '0')
+            {
+                out[0] = ' ';
+                in += 3;
+            }
+            else if (in[1] == '0' && in[2] == '1' && in[3] == '1')
+            {
+                out[0] = '\t';
+                in += 3;
+            }
+            else if (in[1] == '0' && in[2] == '1' && in[3] == '2')
+            {
+                out[0] = '\n';
+                in += 3;
+            }
+            else if (in[1] == '1' && in[2] == '3' && in[3] == '4')
+            {
+                out[0] = '\\';
+                in += 3;
+            }
+        }
+    }
+    *out = '\0';
+
+    return str;
+}
+
+static inline char *get_field( char **str )
+{
+    char *ret;
+
+    ret = strsep( str, " \t" );
+    if (*str) *str += strspn( *str, " \t" );
+
+    return ret;
+}
+/************************************************************************
+ *                    getmntent_replacement
+ *
+ * getmntent replacement for Android.
+ *
+ * NB returned static buffer is not thread safe; protect with dir_section.
+ */
+static struct mntent *getmntent_replacement( FILE *f )
+{
+    static struct mntent entry;
+    static char buf[4096];
+    char *p, *start;
+
+    do
+    {
+        if (!fgets( buf, sizeof(buf), f )) return NULL;
+        p = strchr( buf, '\n' );
+        if (p) *p = '\0';
+        else /* Partially unread line, move file ptr to end */
+        {
+            char tmp[1024];
+            while (fgets( tmp, sizeof(tmp), f ))
+                if (strchr( tmp, '\n' )) break;
+        }
+        start = buf + strspn( buf, " \t" );
+    } while (start[0] == '\0' || start[0] == '#');
+
+    p = get_field( &start );
+    entry.mnt_fsname = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_dir = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_type = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_opts = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_freq = p ? atoi(p) : 0;
+
+    p = get_field( &start );
+    entry.mnt_passno = p ? atoi(p) : 0;
+
+    return &entry;
+}
+#define getmntent getmntent_replacement
+#endif
+
+/***********************************************************************
+ *           DIR_get_drives_info
+ *
+ * Retrieve device/inode number for all the drives. Helper for find_drive_root.
+ */
+unsigned int DIR_get_drives_info( struct drive_info info[MAX_DOS_DRIVES] )
+{
+    static struct drive_info cache[MAX_DOS_DRIVES];
+    static time_t last_update;
+    static unsigned int nb_drives;
+    unsigned int ret;
+    time_t now = time(NULL);
+
+    RtlEnterCriticalSection( &dir_section );
+    if (now != last_update)
+    {
+        char *buffer, *p;
+        struct stat st;
+        unsigned int i;
+
+        if ((buffer = RtlAllocateHeap( GetProcessHeap(), 0,
+                                       strlen(config_dir) + sizeof("/dosdevices/a:") )))
+        {
+            strcpy( buffer, config_dir );
+            strcat( buffer, "/dosdevices/a:" );
+            p = buffer + strlen(buffer) - 2;
+
+            for (i = nb_drives = 0; i < MAX_DOS_DRIVES; i++)
+            {
+                *p = 'a' + i;
+                if (!stat( buffer, &st ))
+                {
+                    cache[i].dev = st.st_dev;
+                    cache[i].ino = st.st_ino;
+                    nb_drives++;
+                }
+                else
+                {
+                    cache[i].dev = 0;
+                    cache[i].ino = 0;
+                }
+            }
+            RtlFreeHeap( GetProcessHeap(), 0, buffer );
+        }
+        last_update = now;
+    }
+    memcpy( info, cache, sizeof(cache) );
+    ret = nb_drives;
+    RtlLeaveCriticalSection( &dir_section );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           parse_mount_entries
+ *
+ * Parse mount entries looking for a given device. Helper for get_default_drive_device.
+ */
+
+#ifdef sun
+#include <sys/vfstab.h>
+static char *parse_vfstab_entries( FILE *f, dev_t dev, ino_t ino)
+{
+    struct vfstab entry;
+    struct stat st;
+    char *device;
+
+    while (! getvfsent( f, &entry ))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry.vfs_fstype, "nfs" ) ||
+            !strcmp( entry.vfs_fstype, "smbfs" ) ||
+            !strcmp( entry.vfs_fstype, "ncpfs" )) continue;
+
+        if (stat( entry.vfs_mountp, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        if (!strcmp( entry.vfs_fstype, "fd" ))
+        {
+            if ((device = strstr( entry.vfs_mntopts, "dev=" )))
+            {
+                char *p = strchr( device + 4, ',' );
+                if (p) *p = 0;
+                return device + 4;
+            }
+        }
+        else
+            return entry.vfs_special;
+    }
+    return NULL;
+}
+#endif
+
+#ifdef linux
+static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
+{
+    struct mntent *entry;
+    struct stat st;
+    char *device;
+
+    while ((entry = getmntent( f )))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry->mnt_type, "nfs" ) ||
+            !strcmp( entry->mnt_type, "cifs" ) ||
+            !strcmp( entry->mnt_type, "smbfs" ) ||
+            !strcmp( entry->mnt_type, "ncpfs" )) continue;
+
+        if (stat( entry->mnt_dir, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        if (!strcmp( entry->mnt_type, "supermount" ))
+        {
+            if ((device = strstr( entry->mnt_opts, "dev=" )))
+            {
+                char *p = strchr( device + 4, ',' );
+                if (p) *p = 0;
+                return device + 4;
+            }
+        }
+        else if (!stat( entry->mnt_fsname, &st ) && S_ISREG(st.st_mode))
+        {
+            /* if device is a regular file check for a loop mount */
+            if ((device = strstr( entry->mnt_opts, "loop=" )))
+            {
+                char *p = strchr( device + 5, ',' );
+                if (p) *p = 0;
+                return device + 5;
+            }
+        }
+        else
+            return entry->mnt_fsname;
+    }
+    return NULL;
+}
+#endif
+
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#include <fstab.h>
+static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
+{
+    struct fstab *entry;
+    struct stat st;
+
+    while ((entry = getfsent()))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry->fs_vfstype, "nfs" ) ||
+            !strcmp( entry->fs_vfstype, "smbfs" ) ||
+            !strcmp( entry->fs_vfstype, "ncpfs" )) continue;
+
+        if (stat( entry->fs_file, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        return entry->fs_spec;
+    }
+    return NULL;
+}
+#endif
+
+#ifdef sun
+#include <sys/mnttab.h>
+static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
+{
+    struct mnttab entry;
+    struct stat st;
+    char *device;
+
+
+    while (( ! getmntent( f, &entry) ))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry.mnt_fstype, "nfs" ) ||
+            !strcmp( entry.mnt_fstype, "smbfs" ) ||
+            !strcmp( entry.mnt_fstype, "ncpfs" )) continue;
+
+        if (stat( entry.mnt_mountp, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        if (!strcmp( entry.mnt_fstype, "fd" ))
+        {
+            if ((device = strstr( entry.mnt_mntopts, "dev=" )))
+            {
+                char *p = strchr( device + 4, ',' );
+                if (p) *p = 0;
+                return device + 4;
+            }
+        }
+        else
+            return entry.mnt_special;
+    }
+    return NULL;
+}
+#endif
+
+/***********************************************************************
+ *           get_default_drive_device
+ *
+ * Return the default device to use for a given drive mount point.
+ */
+static char *get_default_drive_device( const char *root )
+{
+    char *ret = NULL;
+
+#ifdef linux
+    FILE *f;
+    char *device = NULL;
+    int fd, res = -1;
+    struct stat st;
+
+    /* try to open it first to force it to get mounted */
+    if ((fd = open( root, O_RDONLY | O_DIRECTORY )) != -1)
+    {
+        res = fstat( fd, &st );
+        close( fd );
+    }
+    /* now try normal stat just in case */
+    if (res == -1) res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    RtlEnterCriticalSection( &dir_section );
+
+#ifdef __ANDROID__
+    if ((f = fopen( "/proc/mounts", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+#else
+    if ((f = fopen( "/etc/mtab", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+    /* look through fstab too in case it's not mounted (for instance if it's an audio CD) */
+    if (!device && (f = fopen( "/etc/fstab", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+#endif
+    if (device)
+    {
+        ret = RtlAllocateHeap( GetProcessHeap(), 0, strlen(device) + 1 );
+        if (ret) strcpy( ret, device );
+    }
+    RtlLeaveCriticalSection( &dir_section );
+
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__ ) || defined(__DragonFly__)
+    char *device = NULL;
+    int fd, res = -1;
+    struct stat st;
+
+    /* try to open it first to force it to get mounted */
+    if ((fd = open( root, O_RDONLY )) != -1)
+    {
+        res = fstat( fd, &st );
+        close( fd );
+    }
+    /* now try normal stat just in case */
+    if (res == -1) res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    RtlEnterCriticalSection( &dir_section );
+
+    /* The FreeBSD parse_mount_entries doesn't require a file argument, so just
+     * pass NULL.  Leave the argument in for symmetry.
+     */
+    device = parse_mount_entries( NULL, st.st_dev, st.st_ino );
+    if (device)
+    {
+        ret = RtlAllocateHeap( GetProcessHeap(), 0, strlen(device) + 1 );
+        if (ret) strcpy( ret, device );
+    }
+    RtlLeaveCriticalSection( &dir_section );
+
+#elif defined( sun )
+    FILE *f;
+    char *device = NULL;
+    int fd, res = -1;
+    struct stat st;
+
+    /* try to open it first to force it to get mounted */
+    if ((fd = open( root, O_RDONLY )) != -1)
+    {
+        res = fstat( fd, &st );
+        close( fd );
+    }
+    /* now try normal stat just in case */
+    if (res == -1) res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    RtlEnterCriticalSection( &dir_section );
+
+    if ((f = fopen( "/etc/mnttab", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino);
+        fclose( f );
+    }
+    /* look through fstab too in case it's not mounted (for instance if it's an audio CD) */
+    if (!device && (f = fopen( "/etc/vfstab", "r" )))
+    {
+        device = parse_vfstab_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+    if (device)
+    {
+        ret = RtlAllocateHeap( GetProcessHeap(), 0, strlen(device) + 1 );
+        if (ret) strcpy( ret, device );
+    }
+    RtlLeaveCriticalSection( &dir_section );
+
+#elif defined(__APPLE__)
+    struct statfs *mntStat;
+    struct stat st;
+    int i;
+    int mntSize;
+    dev_t dev;
+    ino_t ino;
+    static const char path_bsd_device[] = "/dev/disk";
+    int res;
+
+    res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    dev = st.st_dev;
+    ino = st.st_ino;
+
+    RtlEnterCriticalSection( &dir_section );
+
+    mntSize = getmntinfo(&mntStat, MNT_NOWAIT);
+
+    for (i = 0; i < mntSize && !ret; i++)
+    {
+        if (stat(mntStat[i].f_mntonname, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+
+        /* FIXME add support for mounted network drive */
+        if ( strncmp(mntStat[i].f_mntfromname, path_bsd_device, strlen(path_bsd_device)) == 0)
+        {
+            /* set return value to the corresponding raw BSD node */
+            ret = RtlAllocateHeap( GetProcessHeap(), 0, strlen(mntStat[i].f_mntfromname) + 2 /* 2 : r and \0 */ );
+            if (ret)
+            {
+                strcpy(ret, "/dev/r");
+                strcat(ret, mntStat[i].f_mntfromname+sizeof("/dev/")-1);
+            }
+        }
+    }
+    RtlLeaveCriticalSection( &dir_section );
+#else
+    static int warned;
+    if (!warned++) FIXME( "auto detection of DOS devices not supported on this platform\n" );
+#endif
+    return ret;
+}
+
+
+/***********************************************************************
+ *           get_device_mount_point
+ *
+ * Return the current mount point for a device.
+ */
+static char *get_device_mount_point( dev_t dev )
+{
+    char *ret = NULL;
+
+#ifdef linux
+    FILE *f;
+
+    RtlEnterCriticalSection( &dir_section );
+
+#ifdef __ANDROID__
+    if ((f = fopen( "/proc/mounts", "r" )))
+#else
+    if ((f = fopen( "/etc/mtab", "r" )))
+#endif
+    {
+        struct mntent *entry;
+        struct stat st;
+        char *p, *device;
+
+        while ((entry = getmntent( f )))
+        {
+            /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+            if (!strcmp( entry->mnt_type, "nfs" ) ||
+                !strcmp( entry->mnt_type, "cifs" ) ||
+                !strcmp( entry->mnt_type, "smbfs" ) ||
+                !strcmp( entry->mnt_type, "ncpfs" )) continue;
+
+            if (!strcmp( entry->mnt_type, "supermount" ))
+            {
+                if ((device = strstr( entry->mnt_opts, "dev=" )))
+                {
+                    device += 4;
+                    if ((p = strchr( device, ',' ))) *p = 0;
+                }
+            }
+            else if (!stat( entry->mnt_fsname, &st ) && S_ISREG(st.st_mode))
+            {
+                /* if device is a regular file check for a loop mount */
+                if ((device = strstr( entry->mnt_opts, "loop=" )))
+                {
+                    device += 5;
+                    if ((p = strchr( device, ',' ))) *p = 0;
+                }
+            }
+            else device = entry->mnt_fsname;
+
+            if (device && !stat( device, &st ) && S_ISBLK(st.st_mode) && st.st_rdev == dev)
+            {
+                ret = RtlAllocateHeap( GetProcessHeap(), 0, strlen(entry->mnt_dir) + 1 );
+                if (ret) strcpy( ret, entry->mnt_dir );
+                break;
+            }
+        }
+        fclose( f );
+    }
+    RtlLeaveCriticalSection( &dir_section );
+#elif defined(__APPLE__)
+    struct statfs *entry;
+    struct stat st;
+    int i, size;
+
+    RtlEnterCriticalSection( &dir_section );
+
+    size = getmntinfo( &entry, MNT_NOWAIT );
+    for (i = 0; i < size; i++)
+    {
+        if (stat( entry[i].f_mntfromname, &st ) == -1) continue;
+        if (S_ISBLK(st.st_mode) && st.st_rdev == dev)
+        {
+            ret = RtlAllocateHeap( GetProcessHeap(), 0, strlen(entry[i].f_mntonname) + 1 );
+            if (ret) strcpy( ret, entry[i].f_mntonname );
+            break;
+        }
+    }
+    RtlLeaveCriticalSection( &dir_section );
+#else
+    static int warned;
+    if (!warned++) FIXME( "unmounting devices not supported on this platform\n" );
+#endif
+    return ret;
+}
+
+
+#if defined(HAVE_GETATTRLIST) && defined(ATTR_VOL_CAPABILITIES) && \
+    defined(VOL_CAPABILITIES_FORMAT) && defined(VOL_CAP_FMT_CASE_SENSITIVE)
+
+struct get_fsid
+{
+    ULONG size;
+    dev_t dev;
+    fsid_t fsid;
+};
+
+struct fs_cache
+{
+    dev_t dev;
+    fsid_t fsid;
+    BOOLEAN case_sensitive;
+} fs_cache[64];
+
+struct vol_caps
+{
+    ULONG size;
+    vol_capabilities_attr_t caps;
+};
+
+/***********************************************************************
+ *           look_up_fs_cache
+ *
+ * Checks if the specified file system is in the cache.
+ */
+static struct fs_cache *look_up_fs_cache( dev_t dev )
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE( fs_cache ); i++)
+        if (fs_cache[i].dev == dev)
+            return fs_cache+i;
+    return NULL;
+}
+
+/***********************************************************************
+ *           add_fs_cache
+ *
+ * Adds the specified file system to the cache.
+ */
+static void add_fs_cache( dev_t dev, fsid_t fsid, BOOLEAN case_sensitive )
+{
+    int i;
+    struct fs_cache *entry = look_up_fs_cache( dev );
+    static int once = 0;
+    if (entry)
+    {
+        /* Update the cache */
+        entry->fsid = fsid;
+        entry->case_sensitive = case_sensitive;
+        return;
+    }
+
+    /* Add a new entry */
+    for (i = 0; i < ARRAY_SIZE( fs_cache ); i++)
+        if (fs_cache[i].dev == 0)
+        {
+            /* This entry is empty, use it */
+            fs_cache[i].dev = dev;
+            fs_cache[i].fsid = fsid;
+            fs_cache[i].case_sensitive = case_sensitive;
+            return;
+        }
+
+    /* Cache is out of space, warn */
+    if (!once++)
+        WARN( "FS cache is out of space, expect performance problems\n" );
+}
+
+/***********************************************************************
+ *           get_dir_case_sensitivity_attr
+ *
+ * Checks if the volume containing the specified directory is case
+ * sensitive or not. Uses getattrlist(2).
+ */
+static int get_dir_case_sensitivity_attr( const char *dir )
+{
+    char *mntpoint;
+    struct attrlist attr;
+    struct vol_caps caps;
+    struct get_fsid get_fsid;
+    struct fs_cache *entry;
+
+    /* First get the FS ID of the volume */
+    attr.bitmapcount = ATTR_BIT_MAP_COUNT;
+    attr.reserved = 0;
+    attr.commonattr = ATTR_CMN_DEVID|ATTR_CMN_FSID;
+    attr.volattr = attr.dirattr = attr.fileattr = attr.forkattr = 0;
+    get_fsid.size = 0;
+    if (getattrlist( dir, &attr, &get_fsid, sizeof(get_fsid), 0 ) != 0 ||
+        get_fsid.size != sizeof(get_fsid))
+        return -1;
+    /* Try to look it up in the cache */
+    entry = look_up_fs_cache( get_fsid.dev );
+    if (entry && !memcmp( &entry->fsid, &get_fsid.fsid, sizeof(fsid_t) ))
+        /* Cache lookup succeeded */
+        return entry->case_sensitive;
+    /* Cache is stale at this point, we have to update it */
+
+    mntpoint = get_device_mount_point( get_fsid.dev );
+    /* Now look up the case-sensitivity */
+    attr.commonattr = 0;
+    attr.volattr = ATTR_VOL_INFO|ATTR_VOL_CAPABILITIES;
+    if (getattrlist( mntpoint, &attr, &caps, sizeof(caps), 0 ) < 0)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, mntpoint );
+        add_fs_cache( get_fsid.dev, get_fsid.fsid, TRUE );
+        return TRUE;
+    }
+    RtlFreeHeap( GetProcessHeap(), 0, mntpoint );
+    if (caps.size == sizeof(caps) &&
+        (caps.caps.valid[VOL_CAPABILITIES_FORMAT] &
+         (VOL_CAP_FMT_CASE_SENSITIVE | VOL_CAP_FMT_CASE_PRESERVING)) ==
+        (VOL_CAP_FMT_CASE_SENSITIVE | VOL_CAP_FMT_CASE_PRESERVING))
+    {
+        BOOLEAN ret;
+
+        if ((caps.caps.capabilities[VOL_CAPABILITIES_FORMAT] &
+            VOL_CAP_FMT_CASE_SENSITIVE) != VOL_CAP_FMT_CASE_SENSITIVE)
+            ret = FALSE;
+        else
+            ret = TRUE;
+        /* Update the cache */
+        add_fs_cache( get_fsid.dev, get_fsid.fsid, ret );
+        return ret;
+    }
+    return FALSE;
+}
+#endif
+
+/***********************************************************************
+ *           get_dir_case_sensitivity_stat
+ *
+ * Checks if the volume containing the specified directory is case
+ * sensitive or not. Uses (f)statfs(2), statvfs(2), fstatat(2), or ioctl(2).
+ */
+static BOOLEAN get_dir_case_sensitivity_stat( const char *dir )
+{
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+    struct statfs stfs;
+
+    if (statfs( dir, &stfs ) == -1) return FALSE;
+    /* Assume these file systems are always case insensitive on Mac OS.
+     * For FreeBSD, only assume CIOPFS is case insensitive (AFAIK, Mac OS
+     * is the only UNIX that supports case-insensitive lookup).
+     */
+    if (!strcmp( stfs.f_fstypename, "fusefs" ) &&
+        !strncmp( stfs.f_mntfromname, "ciopfs", 5 ))
+        return FALSE;
+#ifdef __APPLE__
+    if (!strcmp( stfs.f_fstypename, "msdos" ) ||
+        !strcmp( stfs.f_fstypename, "cd9660" ) ||
+        !strcmp( stfs.f_fstypename, "udf" ) ||
+        !strcmp( stfs.f_fstypename, "ntfs" ) ||
+        !strcmp( stfs.f_fstypename, "smbfs" ))
+        return FALSE;
+#ifdef _DARWIN_FEATURE_64_BIT_INODE
+     if (!strcmp( stfs.f_fstypename, "hfs" ) && (stfs.f_fssubtype == 0 ||
+                                                 stfs.f_fssubtype == 1 ||
+                                                 stfs.f_fssubtype == 128))
+        return FALSE;
+#else
+     /* The field says "reserved", but a quick look at the kernel source
+      * tells us that this "reserved" field is really the same as the
+      * "fssubtype" field from the inode64 structure (see munge_statfs()
+      * in <xnu-source>/bsd/vfs/vfs_syscalls.c).
+      */
+     if (!strcmp( stfs.f_fstypename, "hfs" ) && (stfs.f_reserved1 == 0 ||
+                                                 stfs.f_reserved1 == 1 ||
+                                                 stfs.f_reserved1 == 128))
+        return FALSE;
+#endif
+#endif
+    return TRUE;
+
+#elif defined(__NetBSD__)
+    struct statvfs stfs;
+
+    if (statvfs( dir, &stfs ) == -1) return FALSE;
+    /* Only assume CIOPFS is case insensitive. */
+    if (strcmp( stfs.f_fstypename, "fusefs" ) ||
+        strncmp( stfs.f_mntfromname, "ciopfs", 5 ))
+        return TRUE;
+    return FALSE;
+
+#elif defined(__linux__)
+    BOOLEAN sens = TRUE;
+    struct statfs stfs;
+    struct stat st;
+    int fd, flags;
+
+    if ((fd = open( dir, O_RDONLY | O_NONBLOCK | O_LARGEFILE )) == -1)
+        return TRUE;
+
+    if (ioctl( fd, EXT2_IOC_GETFLAGS, &flags ) != -1 && (flags & EXT4_CASEFOLD_FL))
+    {
+        sens = FALSE;
+    }
+    else if (fstatfs( fd, &stfs ) == 0 &&                          /* CIOPFS is case insensitive.  Instead of */
+             stfs.f_type == 0x65735546 /* FUSE_SUPER_MAGIC */ &&   /* parsing mtab to discover if the FUSE FS */
+             fstatat( fd, ".ciopfs", &st, AT_NO_AUTOMOUNT ) == 0)  /* is CIOPFS, look for .ciopfs in the dir. */
+    {
+        sens = FALSE;
+    }
+
+    close( fd );
+    return sens;
+#else
+    return TRUE;
+#endif
+}
+
+
+/***********************************************************************
+ *           get_dir_case_sensitivity
+ *
+ * Checks if the volume containing the specified directory is case
+ * sensitive or not. Uses multiple methods, depending on platform.
+ */
+static BOOLEAN get_dir_case_sensitivity( const char *dir )
+{
+#if defined(HAVE_GETATTRLIST) && defined(ATTR_VOL_CAPABILITIES) && \
+    defined(VOL_CAPABILITIES_FORMAT) && defined(VOL_CAP_FMT_CASE_SENSITIVE)
+    int case_sensitive = get_dir_case_sensitivity_attr( dir );
+    if (case_sensitive != -1) return case_sensitive;
+#endif
+    return get_dir_case_sensitivity_stat( dir );
+}
+
+
+/***********************************************************************
+ *           init_options
+ *
+ * Initialize the show_dot_files options.
+ */
+static DWORD WINAPI init_options( RTL_RUN_ONCE *once, void *param, void **context )
+{
+    static const WCHAR WineW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e',0};
+    static const WCHAR ShowDotFilesW[] = {'S','h','o','w','D','o','t','F','i','l','e','s',0};
+    char tmp[80];
+    HANDLE root, hkey;
+    DWORD dummy;
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING nameW;
+
+    RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString( &nameW, WineW );
+
+    /* @@ Wine registry key: HKCU\Software\Wine */
+    if (!NtOpenKey( &hkey, KEY_ALL_ACCESS, &attr ))
+    {
+        RtlInitUnicodeString( &nameW, ShowDotFilesW );
+        if (!NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation, tmp, sizeof(tmp), &dummy ))
+        {
+            WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)tmp)->Data;
+            show_dot_files = IS_OPTION_TRUE( str[0] );
+        }
+        NtClose( hkey );
+    }
+    NtClose( root );
+
+    /* a couple of directories that we don't want to return in directory searches */
+    ignore_file( config_dir );
+    ignore_file( "/dev" );
+    ignore_file( "/proc" );
+#ifdef linux
+    ignore_file( "/sys" );
+#endif
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           DIR_is_hidden_file
+ *
+ * Check if the specified file should be hidden based on its name and the show dot files option.
+ */
+BOOL DIR_is_hidden_file( const UNICODE_STRING *name )
+{
+    WCHAR *p, *end;
+
+    RtlRunOnceExecuteOnce( &init_once, init_options, NULL, NULL );
+
+    if (show_dot_files) return FALSE;
+
+    end = p = name->Buffer + name->Length/sizeof(WCHAR);
+    while (p > name->Buffer && IS_SEPARATOR(p[-1])) p--;
+    while (p > name->Buffer && !IS_SEPARATOR(p[-1])) p--;
+    if (p == end || *p != '.') return FALSE;
+    /* make sure it isn't '.' or '..' */
+    if (p + 1 == end) return FALSE;
+    if (p[1] == '.' && p + 2 == end) return FALSE;
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           hash_short_file_name
+ *
+ * Transform a Unix file name into a hashed DOS name. If the name is not a valid
+ * DOS name, it is replaced by a hashed version that fits in 8.3 format.
+ * 'buffer' must be at least 12 characters long.
+ * Returns length of short name in bytes; short name is NOT null-terminated.
+ */
+static ULONG hash_short_file_name( const UNICODE_STRING *name, LPWSTR buffer )
+{
+    static const char hash_chars[32] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345";
+
+    LPCWSTR p, ext, end = name->Buffer + name->Length / sizeof(WCHAR);
+    LPWSTR dst;
+    unsigned short hash;
+    int i;
+
+    /* Compute the hash code of the file name */
+    /* If you know something about hash functions, feel free to */
+    /* insert a better algorithm here... */
+    if (!is_case_sensitive)
+    {
+        for (p = name->Buffer, hash = 0xbeef; p < end - 1; p++)
+            hash = (hash<<3) ^ (hash>>5) ^ RtlDowncaseUnicodeChar(*p) ^ (RtlDowncaseUnicodeChar(p[1]) << 8);
+        hash = (hash<<3) ^ (hash>>5) ^ RtlDowncaseUnicodeChar(*p); /* Last character */
+    }
+    else
+    {
+        for (p = name->Buffer, hash = 0xbeef; p < end - 1; p++)
+            hash = (hash << 3) ^ (hash >> 5) ^ *p ^ (p[1] << 8);
+        hash = (hash << 3) ^ (hash >> 5) ^ *p;  /* Last character */
+    }
+
+    /* Find last dot for start of the extension */
+    for (p = name->Buffer + 1, ext = NULL; p < end - 1; p++) if (*p == '.') ext = p;
+
+    /* Copy first 4 chars, replacing invalid chars with '_' */
+    for (i = 4, p = name->Buffer, dst = buffer; i > 0; i--, p++)
+    {
+        if (p == end || p == ext) break;
+        *dst++ = is_invalid_dos_char(*p) ? '_' : *p;
+    }
+    /* Pad to 5 chars with '~' */
+    while (i-- >= 0) *dst++ = '~';
+
+    /* Insert hash code converted to 3 ASCII chars */
+    *dst++ = hash_chars[(hash >> 10) & 0x1f];
+    *dst++ = hash_chars[(hash >> 5) & 0x1f];
+    *dst++ = hash_chars[hash & 0x1f];
+
+    /* Copy the first 3 chars of the extension (if any) */
+    if (ext)
+    {
+        *dst++ = '.';
+        for (i = 3, ext++; (i > 0) && ext < end; i--, ext++)
+            *dst++ = is_invalid_dos_char(*ext) ? '_' : *ext;
+    }
+    return dst - buffer;
+}
+
+
+/***********************************************************************
+ *           match_filename
+ *
+ * Check a long file name against a mask.
+ *
+ * Tests (done in W95 DOS shell - case insensitive):
+ * *.txt			test1.test.txt				*
+ * *st1*			test1.txt				*
+ * *.t??????.t*			test1.ta.tornado.txt			*
+ * *tornado*			test1.ta.tornado.txt			*
+ * t*t				test1.ta.tornado.txt			*
+ * ?est*			test1.txt				*
+ * ?est???			test1.txt				-
+ * *test1.txt*			test1.txt				*
+ * h?l?o*t.dat			hellothisisatest.dat			*
+ */
+static BOOLEAN match_filename( const UNICODE_STRING *name_str, const UNICODE_STRING *mask_str )
+{
+    BOOL mismatch;
+    const WCHAR *name = name_str->Buffer;
+    const WCHAR *mask = mask_str->Buffer;
+    const WCHAR *name_end = name + name_str->Length / sizeof(WCHAR);
+    const WCHAR *mask_end = mask + mask_str->Length / sizeof(WCHAR);
+    const WCHAR *lastjoker = NULL;
+    const WCHAR *next_to_retry = NULL;
+
+    while (name < name_end && mask < mask_end)
+    {
+        switch(*mask)
+        {
+        case '*':
+            mask++;
+            while (mask < mask_end && *mask == '*') mask++;  /* Skip consecutive '*' */
+            if (mask == mask_end) return TRUE; /* end of mask is all '*', so match */
+            lastjoker = mask;
+
+            /* skip to the next match after the joker(s) */
+            if (is_case_sensitive)
+                while (name < name_end && (*name != *mask)) name++;
+            else
+                while (name < name_end && (towupper(*name) != towupper(*mask))) name++;
+            next_to_retry = name;
+            break;
+        case '?':
+            mask++;
+            name++;
+            break;
+        default:
+            if (is_case_sensitive) mismatch = (*mask != *name);
+            else mismatch = (towupper(*mask) != towupper(*name));
+
+            if (!mismatch)
+            {
+                mask++;
+                name++;
+                if (mask == mask_end)
+                {
+                    if (name == name_end) return TRUE;
+                    if (lastjoker) mask = lastjoker;
+                }
+            }
+            else /* mismatch ! */
+            {
+                if (lastjoker) /* we had an '*', so we can try unlimitedly */
+                {
+                    mask = lastjoker;
+
+                    /* this scan sequence was a mismatch, so restart
+                     * 1 char after the first char we checked last time */
+                    next_to_retry++;
+                    name = next_to_retry;
+                }
+                else return FALSE; /* bad luck */
+            }
+            break;
+        }
+    }
+    while (mask < mask_end && ((*mask == '.') || (*mask == '*')))
+        mask++;  /* Ignore trailing '.' or '*' in mask */
+    return (name == name_end && mask == mask_end);
+}
+
+
+/***********************************************************************
+ *           append_entry
+ *
+ * Add a file to the directory data if it matches the mask.
+ */
+static BOOL append_entry( struct dir_data *data, const char *long_name,
+                          const char *short_name, const UNICODE_STRING *mask )
+{
+    int long_len, short_len;
+    WCHAR long_nameW[MAX_DIR_ENTRY_LEN + 1];
+    WCHAR short_nameW[13];
+    UNICODE_STRING str;
+
+    long_len = ntdll_umbstowcs( long_name, strlen(long_name), long_nameW, ARRAY_SIZE(long_nameW) );
+    if (long_len == ARRAY_SIZE(long_nameW)) return TRUE;
+    long_nameW[long_len] = 0;
+
+    str.Buffer = long_nameW;
+    str.Length = long_len * sizeof(WCHAR);
+    str.MaximumLength = sizeof(long_nameW);
+
+    if (short_name)
+    {
+        short_len = ntdll_umbstowcs( short_name, strlen(short_name),
+                                     short_nameW, ARRAY_SIZE( short_nameW ) - 1 );
+    }
+    else  /* generate a short name if necessary */
+    {
+        BOOLEAN spaces;
+
+        short_len = 0;
+        if (!RtlIsNameLegalDOS8Dot3( &str, NULL, &spaces ) || spaces)
+            short_len = hash_short_file_name( &str, short_nameW );
+    }
+    short_nameW[short_len] = 0;
+    wcsupr( short_nameW );
+
+    TRACE( "long %s short %s mask %s\n",
+           debugstr_w( long_nameW ), debugstr_w( short_nameW ), debugstr_us( mask ));
+
+    if (mask && !match_filename( &str, mask ))
+    {
+        if (!short_len) return TRUE;  /* no short name to match */
+        str.Buffer = short_nameW;
+        str.Length = short_len * sizeof(WCHAR);
+        str.MaximumLength = sizeof(short_nameW);
+        if (!match_filename( &str, mask )) return TRUE;
+    }
+
+    return add_dir_data_names( data, long_nameW, short_nameW, long_name );
+}
+
+
+/***********************************************************************
+ *           get_dir_data_entry
+ *
+ * Return a directory entry from the cached data.
+ */
+static NTSTATUS get_dir_data_entry( struct dir_data *dir_data, void *info_ptr, IO_STATUS_BLOCK *io,
+                                    ULONG max_length, FILE_INFORMATION_CLASS class,
+                                    union file_directory_info **last_info )
+{
+    const struct dir_data_names *names = &dir_data->names[dir_data->pos];
+    union file_directory_info *info;
+    struct stat st;
+    ULONG name_len, start, dir_size, attributes;
+
+    if (get_file_info( names->unix_name, &st, &attributes ) == -1)
+    {
+        TRACE( "file no longer exists %s\n", names->unix_name );
+        return STATUS_SUCCESS;
+    }
+    if (is_ignored_file( &st ))
+    {
+        TRACE( "ignoring file %s\n", names->unix_name );
+        return STATUS_SUCCESS;
+    }
+    start = dir_info_align( io->Information );
+    dir_size = dir_info_size( class, 0 );
+    if (start + dir_size > max_length) return STATUS_MORE_ENTRIES;
+
+    max_length -= start + dir_size;
+    name_len = wcslen( names->long_name ) * sizeof(WCHAR);
+    /* if this is not the first entry, fail; the first entry is always returned (but truncated) */
+    if (*last_info && name_len > max_length) return STATUS_MORE_ENTRIES;
+
+    info = (union file_directory_info *)((char *)info_ptr + start);
+    info->dir.NextEntryOffset = 0;
+    info->dir.FileIndex = 0;  /* NTFS always has 0 here, so let's not bother with it */
+
+    /* all the structures except FileNamesInformation start with a FileDirectoryInformation layout */
+    if (class != FileNamesInformation)
+    {
+        if (st.st_dev != dir_data->id.dev) st.st_ino = 0;  /* ignore inode if on a different device */
+
+        if (!show_dot_files && names->long_name[0] == '.' && names->long_name[1] &&
+            (names->long_name[1] != '.' || names->long_name[2]))
+            attributes |= FILE_ATTRIBUTE_HIDDEN;
+
+        fill_file_info( &st, attributes, info, class );
+    }
+
+    switch (class)
+    {
+    case FileDirectoryInformation:
+        info->dir.FileNameLength = name_len;
+        break;
+
+    case FileFullDirectoryInformation:
+        info->full.EaSize = 0; /* FIXME */
+        info->full.FileNameLength = name_len;
+        break;
+
+    case FileIdFullDirectoryInformation:
+        info->id_full.EaSize = 0; /* FIXME */
+        info->id_full.FileNameLength = name_len;
+        break;
+
+    case FileBothDirectoryInformation:
+        info->both.EaSize = 0; /* FIXME */
+        info->both.ShortNameLength = wcslen( names->short_name ) * sizeof(WCHAR);
+        memcpy( info->both.ShortName, names->short_name, info->both.ShortNameLength );
+        info->both.FileNameLength = name_len;
+        break;
+
+    case FileIdBothDirectoryInformation:
+        info->id_both.EaSize = 0; /* FIXME */
+        info->id_both.ShortNameLength = wcslen( names->short_name ) * sizeof(WCHAR);
+        memcpy( info->id_both.ShortName, names->short_name, info->id_both.ShortNameLength );
+        info->id_both.FileNameLength = name_len;
+        break;
+
+    case FileIdGlobalTxDirectoryInformation:
+        info->id_tx.TxInfoFlags = 0;
+        info->id_tx.FileNameLength = name_len;
+        break;
+
+    case FileNamesInformation:
+        info->names.FileNameLength = name_len;
+        break;
+
+    default:
+        assert(0);
+        return 0;
+    }
+
+    memcpy( (char *)info + dir_size, names->long_name, min( name_len, max_length ) );
+    io->Information = start + dir_size + min( name_len, max_length );
+    if (*last_info) (*last_info)->next = (char *)info - (char *)*last_info;
+    *last_info = info;
+    return name_len > max_length ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
+}
+
+#ifdef VFAT_IOCTL_READDIR_BOTH
+
+/***********************************************************************
+ *           read_directory_vfat
+ *
+ * Read a directory using the VFAT ioctl; helper for NtQueryDirectoryFile.
+ */
+static NTSTATUS read_directory_data_vfat( struct dir_data *data, int fd, const UNICODE_STRING *mask )
+{
+    char *short_name, *long_name;
+    KERNEL_DIRENT de[2];
+    NTSTATUS status = STATUS_NO_MEMORY;
+    off_t old_pos = lseek( fd, 0, SEEK_CUR );
+
+    lseek( fd, 0, SEEK_SET );
+
+    if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)de ) == -1)
+    {
+        if (errno != ENOENT)
+        {
+            status = STATUS_NOT_SUPPORTED;
+            goto done;
+        }
+        de[0].d_reclen = 0;
+    }
+
+    if (!append_entry( data, ".", NULL, mask )) goto done;
+    if (!append_entry( data, "..", NULL, mask )) goto done;
+
+    while (de[0].d_reclen)
+    {
+        if (strcmp( de[0].d_name, "." ) && strcmp( de[0].d_name, ".." ))
+        {
+            if (de[1].d_name[0])
+            {
+                short_name = de[0].d_name;
+                long_name = de[1].d_name;
+            }
+            else
+            {
+                long_name = de[0].d_name;
+                short_name = NULL;
+            }
+            if (!append_entry( data, long_name, short_name, mask )) goto done;
+        }
+        if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)de ) == -1) break;
+    }
+    status = STATUS_SUCCESS;
+done:
+    lseek( fd, old_pos, SEEK_SET );
+    return status;
+}
+#endif /* VFAT_IOCTL_READDIR_BOTH */
+
+
+#ifdef HAVE_GETATTRLIST
+/***********************************************************************
+ *           read_directory_getattrlist
+ *
+ * Read a single file from a directory by determining whether the file
+ * identified by mask exists using getattrlist.
+ */
+static NTSTATUS read_directory_data_getattrlist( struct dir_data *data, const char *unix_name )
+{
+    struct attrlist attrlist;
+#include "pshpack4.h"
+    struct
+    {
+        u_int32_t length;
+        struct attrreference name_reference;
+        fsobj_type_t type;
+        char name[NAME_MAX * 3 + 1];
+    } buffer;
+#include "poppack.h"
+
+    memset( &attrlist, 0, sizeof(attrlist) );
+    attrlist.bitmapcount = ATTR_BIT_MAP_COUNT;
+    attrlist.commonattr = ATTR_CMN_NAME | ATTR_CMN_OBJTYPE;
+    if (getattrlist( unix_name, &attrlist, &buffer, sizeof(buffer), FSOPT_NOFOLLOW ) == -1)
+        return STATUS_NO_SUCH_FILE;
+    /* If unix_name named a symlink, the above may have succeeded even if the symlink is broken.
+       Check that with another call without FSOPT_NOFOLLOW.  We don't ask for any attributes. */
+    if (buffer.type == VLNK)
+    {
+        u_int32_t dummy;
+        attrlist.commonattr = 0;
+        if (getattrlist( unix_name, &attrlist, &dummy, sizeof(dummy), 0 ) == -1)
+            return STATUS_NO_SUCH_FILE;
+    }
+
+    TRACE( "found %s\n", buffer.name );
+
+    if (!append_entry( data, buffer.name, NULL, NULL )) return STATUS_NO_MEMORY;
+
+    return STATUS_SUCCESS;
+}
+#endif  /* HAVE_GETATTRLIST */
+
+
+/***********************************************************************
+ *           read_directory_stat
+ *
+ * Read a single file from a directory by determining whether the file
+ * identified by mask exists using stat.
+ */
+static NTSTATUS read_directory_data_stat( struct dir_data *data, const char *unix_name )
+{
+    struct stat st;
+
+    /* if the file system is not case sensitive we can't find the actual name through stat() */
+    if (!get_dir_case_sensitivity(".")) return STATUS_NO_SUCH_FILE;
+    if (stat( unix_name, &st ) == -1) return STATUS_NO_SUCH_FILE;
+
+    TRACE( "found %s\n", unix_name );
+
+    if (!append_entry( data, unix_name, NULL, NULL )) return STATUS_NO_MEMORY;
+
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           read_directory_readdir
+ *
+ * Read a directory using the POSIX readdir interface; helper for NtQueryDirectoryFile.
+ */
+static NTSTATUS read_directory_data_readdir( struct dir_data *data, const UNICODE_STRING *mask )
+{
+    struct dirent *de;
+    NTSTATUS status = STATUS_NO_MEMORY;
+    DIR *dir = opendir( "." );
+
+    if (!dir) return STATUS_NO_SUCH_FILE;
+
+    if (!append_entry( data, ".", NULL, mask )) goto done;
+    if (!append_entry( data, "..", NULL, mask )) goto done;
+    while ((de = readdir( dir )))
+    {
+        if (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." )) continue;
+        if (!append_entry( data, de->d_name, NULL, mask )) goto done;
+    }
+    status = STATUS_SUCCESS;
+
+done:
+    closedir( dir );
+    return status;
+}
+
+
+/***********************************************************************
+ *           read_directory_data
+ *
+ * Read the full contents of a directory, using one of the above helper functions.
+ */
+static NTSTATUS read_directory_data( struct dir_data *data, int fd, const UNICODE_STRING *mask )
+{
+    NTSTATUS status;
+
+#ifdef VFAT_IOCTL_READDIR_BOTH
+    if (!(status = read_directory_data_vfat( data, fd, mask ))) return status;
+#endif
+
+    if (!has_wildcard( mask ))
+    {
+        /* convert the mask to a Unix name and check for it */
+        char unix_name[MAX_DIR_ENTRY_LEN * 3 + 1];
+        int ret = ntdll_wcstoumbs( mask->Buffer, mask->Length / sizeof(WCHAR),
+                                   unix_name, sizeof(unix_name) - 1, TRUE );
+        if (ret > 0)
+        {
+            unix_name[ret] = 0;
+#ifdef HAVE_GETATTRLIST
+            if (!(status = read_directory_data_getattrlist( data, unix_name ))) return status;
+#endif
+            if (!(status = read_directory_data_stat( data, unix_name ))) return status;
+        }
+    }
+
+    return read_directory_data_readdir( data, mask );
+}
+
+
+/* compare file names for directory sorting */
+static int name_compare( const void *a, const void *b )
+{
+    const struct dir_data_names *file_a = (const struct dir_data_names *)a;
+    const struct dir_data_names *file_b = (const struct dir_data_names *)b;
+    int ret = RtlCompareUnicodeStrings( file_a->long_name, wcslen(file_a->long_name),
+                                        file_b->long_name, wcslen(file_b->long_name), TRUE );
+    if (!ret) ret = wcscmp( file_a->long_name, file_b->long_name );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           init_cached_dir_data
+ *
+ * Initialize the cached directory contents.
+ */
+static NTSTATUS init_cached_dir_data( struct dir_data **data_ret, int fd, const UNICODE_STRING *mask )
+{
+    struct dir_data *data;
+    struct stat st;
+    NTSTATUS status;
+    unsigned int i;
+
+    if (!(data = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data) )))
+        return STATUS_NO_MEMORY;
+
+    if ((status = read_directory_data( data, fd, mask )))
+    {
+        free_dir_data( data );
+        return status;
+    }
+
+    /* sort filenames, but not "." and ".." */
+    i = 0;
+    if (i < data->count && !strcmp( data->names[i].unix_name, "." )) i++;
+    if (i < data->count && !strcmp( data->names[i].unix_name, ".." )) i++;
+    if (i < data->count) qsort( data->names + i, data->count - i, sizeof(*data->names), name_compare );
+
+    if (data->count)
+    {
+        /* release unused space */
+        if (data->buffer)
+            RtlReAllocateHeap( GetProcessHeap(), HEAP_REALLOC_IN_PLACE_ONLY, data->buffer,
+                               offsetof( struct dir_data_buffer, data[data->buffer->pos] ));
+        if (data->count < data->size)
+            RtlReAllocateHeap( GetProcessHeap(), HEAP_REALLOC_IN_PLACE_ONLY, data->names,
+                               data->count * sizeof(*data->names) );
+        if (!fstat( fd, &st ))
+        {
+            data->id.dev = st.st_dev;
+            data->id.ino = st.st_ino;
+        }
+    }
+
+    TRACE( "mask %s found %u files\n", debugstr_us( mask ), data->count );
+    for (i = 0; i < data->count; i++)
+        TRACE( "%s %s\n", debugstr_w(data->names[i].long_name), debugstr_w(data->names[i].short_name) );
+
+    *data_ret = data;
+    return data->count ? STATUS_SUCCESS : STATUS_NO_SUCH_FILE;
+}
+
+
+/***********************************************************************
+ *           get_cached_dir_data
+ *
+ * Retrieve the cached directory data, or initialize it if necessary.
+ */
+static NTSTATUS get_cached_dir_data( HANDLE handle, struct dir_data **data_ret, int fd,
+                                     const UNICODE_STRING *mask )
+{
+    unsigned int i;
+    int entry = -1, free_entries[16];
+    NTSTATUS status;
+
+    SERVER_START_REQ( get_directory_cache_entry )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        wine_server_set_reply( req, free_entries, sizeof(free_entries) );
+        if (!(status = wine_server_call( req ))) entry = reply->entry;
+
+        for (i = 0; i < wine_server_reply_size( reply ) / sizeof(*free_entries); i++)
+        {
+            int free_idx = free_entries[i];
+            if (free_idx < dir_data_cache_size)
+            {
+                free_dir_data( dir_data_cache[free_idx] );
+                dir_data_cache[free_idx] = NULL;
+            }
+        }
+    }
+    SERVER_END_REQ;
+
+    if (status)
+    {
+        if (status == STATUS_SHARING_VIOLATION) FIXME( "shared directory handle not supported yet\n" );
+        return status;
+    }
+
+    if (entry >= dir_data_cache_size)
+    {
+        unsigned int size = max( dir_data_cache_initial_size, max( dir_data_cache_size * 2, entry + 1 ) );
+        struct dir_data **new_cache;
+
+        if (dir_data_cache)
+            new_cache = RtlReAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, dir_data_cache,
+                                           size * sizeof(*new_cache) );
+        else
+            new_cache = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, size * sizeof(*new_cache) );
+        if (!new_cache) return STATUS_NO_MEMORY;
+        dir_data_cache = new_cache;
+        dir_data_cache_size = size;
+    }
+
+    if (!dir_data_cache[entry]) status = init_cached_dir_data( &dir_data_cache[entry], fd, mask );
+
+    *data_ret = dir_data_cache[entry];
+    return status;
+}
+
+
+/******************************************************************************
+ *  NtQueryDirectoryFile	[NTDLL.@]
+ *  ZwQueryDirectoryFile	[NTDLL.@]
+ */
+NTSTATUS WINAPI DECLSPEC_HOTPATCH NtQueryDirectoryFile( HANDLE handle, HANDLE event,
+                                      PIO_APC_ROUTINE apc_routine, PVOID apc_context,
+                                      PIO_STATUS_BLOCK io,
+                                      PVOID buffer, ULONG length,
+                                      FILE_INFORMATION_CLASS info_class,
+                                      BOOLEAN single_entry,
+                                      PUNICODE_STRING mask,
+                                      BOOLEAN restart_scan )
+{
+    int cwd, fd, needs_close;
+    struct dir_data *data;
+    NTSTATUS status;
+
+    TRACE("(%p %p %p %p %p %p 0x%08x 0x%08x 0x%08x %s 0x%08x\n",
+          handle, event, apc_routine, apc_context, io, buffer,
+          length, info_class, single_entry, debugstr_us(mask),
+          restart_scan);
+
+    if (event || apc_routine)
+    {
+        FIXME( "Unsupported yet option\n" );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+    switch (info_class)
+    {
+    case FileDirectoryInformation:
+    case FileBothDirectoryInformation:
+    case FileFullDirectoryInformation:
+    case FileIdBothDirectoryInformation:
+    case FileIdFullDirectoryInformation:
+    case FileIdGlobalTxDirectoryInformation:
+    case FileNamesInformation:
+        if (length < dir_info_align( dir_info_size( info_class, 1 ))) return STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case FileObjectIdInformation:
+        if (length != sizeof(FILE_OBJECTID_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        return STATUS_INVALID_INFO_CLASS;
+    case FileQuotaInformation:
+        if (length != sizeof(FILE_QUOTA_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        return STATUS_INVALID_INFO_CLASS;
+    case FileReparsePointInformation:
+        if (length != sizeof(FILE_REPARSE_POINT_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        return STATUS_INVALID_INFO_CLASS;
+    default:
+        return STATUS_INVALID_INFO_CLASS;
+    }
+    if (!buffer) return STATUS_ACCESS_VIOLATION;
+
+    if ((status = server_get_unix_fd( handle, FILE_LIST_DIRECTORY, &fd, &needs_close, NULL, NULL )) != STATUS_SUCCESS)
+        return status;
+
+    io->Information = 0;
+
+    RtlRunOnceExecuteOnce( &init_once, init_options, NULL, NULL );
+
+    RtlEnterCriticalSection( &dir_section );
+
+    cwd = open( ".", O_RDONLY );
+    if (fchdir( fd ) != -1)
+    {
+        if (!(status = get_cached_dir_data( handle, &data, fd, mask )))
+        {
+            union file_directory_info *last_info = NULL;
+
+            if (restart_scan) data->pos = 0;
+
+            while (!status && data->pos < data->count)
+            {
+                status = get_dir_data_entry( data, buffer, io, length, info_class, &last_info );
+                if (!status || status == STATUS_BUFFER_OVERFLOW) data->pos++;
+                if (single_entry && last_info) break;
+            }
+
+            if (!last_info) status = STATUS_NO_MORE_FILES;
+            else if (status == STATUS_MORE_ENTRIES) status = STATUS_SUCCESS;
+
+            io->u.Status = status;
+        }
+        if (cwd == -1 || fchdir( cwd ) == -1) chdir( "/" );
+    }
+    else status = FILE_GetNtStatus();
+
+    RtlLeaveCriticalSection( &dir_section );
+
+    if (needs_close) close( fd );
+    if (cwd != -1) close( cwd );
+    TRACE( "=> %x (%ld)\n", status, io->Information );
+    return status;
+}
+
+
+/***********************************************************************
+ *           find_file_in_dir
+ *
+ * Find a file in a directory the hard way, by doing a case-insensitive search.
+ * The file found is appended to unix_name at pos.
+ * There must be at least MAX_DIR_ENTRY_LEN+2 chars available at pos.
+ */
+static NTSTATUS find_file_in_dir( char *unix_name, int pos, const WCHAR *name, int length,
+                                  BOOLEAN check_case, BOOLEAN *is_win_dir )
+{
+    WCHAR buffer[MAX_DIR_ENTRY_LEN];
+    UNICODE_STRING str;
+    BOOLEAN spaces, is_name_8_dot_3;
+    DIR *dir;
+    struct dirent *de;
+    struct stat st;
+    int ret;
+
+    /* try a shortcut for this directory */
+
+    unix_name[pos++] = '/';
+    ret = ntdll_wcstoumbs( name, length, unix_name + pos, MAX_DIR_ENTRY_LEN + 1, TRUE );
+    if (ret >= 0 && ret <= MAX_DIR_ENTRY_LEN)
+    {
+        unix_name[pos + ret] = 0;
+        if (!stat( unix_name, &st ))
+        {
+            if (is_win_dir) *is_win_dir = is_same_file( &windir, &st );
+            return STATUS_SUCCESS;
+        }
+    }
+    if (check_case) goto not_found;  /* we want an exact match */
+
+    if (pos > 1) unix_name[pos - 1] = 0;
+    else unix_name[1] = 0;  /* keep the initial slash */
+
+    /* check if it fits in 8.3 so that we don't look for short names if we won't need them */
+
+    str.Buffer = (WCHAR *)name;
+    str.Length = length * sizeof(WCHAR);
+    str.MaximumLength = str.Length;
+    is_name_8_dot_3 = RtlIsNameLegalDOS8Dot3( &str, NULL, &spaces ) && !spaces;
+#ifndef VFAT_IOCTL_READDIR_BOTH
+    is_name_8_dot_3 = is_name_8_dot_3 && length >= 8 && name[4] == '~';
+#endif
+
+    if (!is_name_8_dot_3 && !get_dir_case_sensitivity( unix_name )) goto not_found;
+
+    /* now look for it through the directory */
+
+#ifdef VFAT_IOCTL_READDIR_BOTH
+    if (is_name_8_dot_3)
+    {
+        int fd = open( unix_name, O_RDONLY | O_DIRECTORY );
+        if (fd != -1)
+        {
+            KERNEL_DIRENT kde[2];
+
+            if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)kde ) != -1)
+            {
+                unix_name[pos - 1] = '/';
+                while (kde[0].d_reclen)
+                {
+                    if (kde[1].d_name[0])
+                    {
+                        ret = ntdll_umbstowcs( kde[1].d_name, strlen(kde[1].d_name),
+                                               buffer, MAX_DIR_ENTRY_LEN );
+                        if (ret == length && !RtlCompareUnicodeStrings( buffer, ret, name, ret, TRUE ))
+                        {
+                            strcpy( unix_name + pos, kde[1].d_name );
+                            close( fd );
+                            goto success;
+                        }
+                    }
+                    ret = ntdll_umbstowcs( kde[0].d_name, strlen(kde[0].d_name),
+                                           buffer, MAX_DIR_ENTRY_LEN );
+                    if (ret == length && !RtlCompareUnicodeStrings( buffer, ret, name, ret, TRUE ))
+                    {
+                        strcpy( unix_name + pos,
+                                kde[1].d_name[0] ? kde[1].d_name : kde[0].d_name );
+                        close( fd );
+                        goto success;
+                    }
+                    if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)kde ) == -1)
+                    {
+                        close( fd );
+                        goto not_found;
+                    }
+                }
+            }
+            close( fd );
+        }
+        /* fall through to normal handling */
+    }
+#endif /* VFAT_IOCTL_READDIR_BOTH */
+
+    if (!(dir = opendir( unix_name )))
+    {
+        if (errno == ENOENT) return STATUS_OBJECT_PATH_NOT_FOUND;
+        else return FILE_GetNtStatus();
+    }
+    unix_name[pos - 1] = '/';
+    str.Buffer = buffer;
+    str.MaximumLength = sizeof(buffer);
+    while ((de = readdir( dir )))
+    {
+        ret = ntdll_umbstowcs( de->d_name, strlen(de->d_name), buffer, MAX_DIR_ENTRY_LEN );
+        if (ret == length && !RtlCompareUnicodeStrings( buffer, ret, name, ret, TRUE ))
+        {
+            strcpy( unix_name + pos, de->d_name );
+            closedir( dir );
+            goto success;
+        }
+
+        if (!is_name_8_dot_3) continue;
+
+        str.Length = ret * sizeof(WCHAR);
+        if (!RtlIsNameLegalDOS8Dot3( &str, NULL, &spaces ) || spaces)
+        {
+            WCHAR short_nameW[12];
+            ret = hash_short_file_name( &str, short_nameW );
+            if (ret == length && !wcsnicmp( short_nameW, name, length ))
+            {
+                strcpy( unix_name + pos, de->d_name );
+                closedir( dir );
+                goto success;
+            }
+        }
+    }
+    closedir( dir );
+
+not_found:
+    unix_name[pos - 1] = 0;
+    return STATUS_OBJECT_PATH_NOT_FOUND;
+
+success:
+    if (is_win_dir && !stat( unix_name, &st )) *is_win_dir = is_same_file( &windir, &st );
+    return STATUS_SUCCESS;
+}
+
+
+#ifndef _WIN64
+
+static const WCHAR catrootW[] = {'s','y','s','t','e','m','3','2','\\','c','a','t','r','o','o','t',0};
+static const WCHAR catroot2W[] = {'s','y','s','t','e','m','3','2','\\','c','a','t','r','o','o','t','2',0};
+static const WCHAR driversstoreW[] = {'s','y','s','t','e','m','3','2','\\','d','r','i','v','e','r','s','s','t','o','r','e',0};
+static const WCHAR driversetcW[] = {'s','y','s','t','e','m','3','2','\\','d','r','i','v','e','r','s','\\','e','t','c',0};
+static const WCHAR logfilesW[] = {'s','y','s','t','e','m','3','2','\\','l','o','g','f','i','l','e','s',0};
+static const WCHAR spoolW[] = {'s','y','s','t','e','m','3','2','\\','s','p','o','o','l',0};
+static const WCHAR system32W[] = {'s','y','s','t','e','m','3','2',0};
+static const WCHAR sysnativeW[] = {'s','y','s','n','a','t','i','v','e',0};
+static const WCHAR regeditW[] = {'r','e','g','e','d','i','t','.','e','x','e',0};
+
+static struct
+{
+    const WCHAR *source;
+    const char *unix_target;
+} redirects[] =
+{
+    { catrootW, NULL },
+    { catroot2W, NULL },
+    { driversstoreW, NULL },
+    { driversetcW, NULL },
+    { logfilesW, NULL },
+    { spoolW, NULL },
+    { system32W, "syswow64" },
+    { sysnativeW, "system32" },
+    { regeditW, "syswow64/regedit.exe" }
+};
+
+static unsigned int nb_redirects;
+
+
+/***********************************************************************
+ *           init_redirects
+ */
+static void init_redirects(void)
+{
+    static const char windows_dir[] = "/dosdevices/c:/windows";
+    char *dir;
+    struct stat st;
+
+    if (!(dir = RtlAllocateHeap( GetProcessHeap(), 0, strlen(config_dir) + sizeof(windows_dir) ))) return;
+    strcpy( dir, config_dir );
+    strcat( dir, windows_dir );
+    if (!stat( dir, &st ))
+    {
+        windir.dev = st.st_dev;
+        windir.ino = st.st_ino;
+        nb_redirects = ARRAY_SIZE( redirects );
+    }
+    else ERR( "%s: %s\n", dir, strerror(errno) );
+    RtlFreeHeap( GetProcessHeap(), 0, dir );
+
+}
+
+
+/***********************************************************************
+ *           match_redirect
+ *
+ * Check if path matches a redirect name. If yes, return matched length.
+ */
+static int match_redirect( const WCHAR *path, int len, const WCHAR *redir, BOOLEAN check_case )
+{
+    int i = 0;
+
+    while (i < len)
+    {
+        int start = i;
+        while (i < len && !IS_SEPARATOR(path[i])) i++;
+        if (check_case)
+        {
+            if (wcsncmp( path + start, redir, i - start )) return 0;
+        }
+        else
+        {
+            if (wcsnicmp( path + start, redir, i - start )) return 0;
+        }
+        redir += i - start;
+        while (i < len && IS_SEPARATOR(path[i])) i++;
+        if (!*redir) return i;
+        if (*redir++ != '\\') return 0;
+    }
+    return 0;
+}
+
+
+/***********************************************************************
+ *           get_redirect_path
+ *
+ * Retrieve the Unix path corresponding to a redirected path if any.
+ */
+static int get_redirect_path( char *unix_name, int pos, const WCHAR *name, int length, BOOLEAN check_case )
+{
+    unsigned int i;
+    int len;
+
+    for (i = 0; i < nb_redirects; i++)
+    {
+        if ((len = match_redirect( name, length, redirects[i].source, check_case )))
+        {
+            if (!redirects[i].unix_target) break;
+            unix_name[pos++] = '/';
+            strcpy( unix_name + pos, redirects[i].unix_target );
+            return len;
+        }
+    }
+    return 0;
+}
 
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#define NONAMELESSUNION
-#include "windef.h"
-#include "winnt.h"
-#include "winternl.h"
-#include "ddk/wdm.h"
-#include "ntdll_misc.h"
-#include "wine/server.h"
-#include "wine/list.h"
-#include "wine/debug.h"
-#include "wine/exception.h"
+#else  /* _WIN64 */
 
-#define IS_OPTION_TRUE(ch) ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+/* there are no redirects on 64-bit */
 
-static BOOL show_dot_files;
+static const unsigned int nb_redirects = 0;
+
+static int get_redirect_path( char *unix_name, int pos, const WCHAR *name, int length, BOOLEAN check_case )
+{
+    return 0;
+}
+
+#endif
 
 /***********************************************************************
  *           init_directories
  */
 void init_directories(void)
 {
-    static const WCHAR WineW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e',0};
-    static const WCHAR ShowDotFilesW[] = {'S','h','o','w','D','o','t','F','i','l','e','s',0};
-    char tmp[80];
-    HANDLE root, hkey;
-    DWORD dummy;
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
+#ifndef _WIN64
+    if (is_wow64) init_redirects();
+#endif
+}
 
-    RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = root;
-    attr.ObjectName = &nameW;
-    attr.Attributes = 0;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &nameW, WineW );
 
-    /* @@ Wine registry key: HKCU\Software\Wine */
-    if (!NtOpenKey( &hkey, KEY_ALL_ACCESS, &attr ))
+/******************************************************************************
+ *           get_dos_device
+ *
+ * Get the Unix path of a DOS device.
+ */
+static NTSTATUS get_dos_device( const WCHAR *name, UINT name_len, ANSI_STRING *unix_name_ret )
+{
+    struct stat st;
+    char *unix_name, *new_name, *dev;
+    unsigned int i;
+    int unix_len;
+
+    /* make sure the device name is ASCII */
+    for (i = 0; i < name_len; i++)
+        if (name[i] <= 32 || name[i] >= 127) return STATUS_BAD_DEVICE_TYPE;
+
+    unix_len = strlen(config_dir) + sizeof("/dosdevices/") + name_len + 1;
+
+    if (!(unix_name = RtlAllocateHeap( GetProcessHeap(), 0, unix_len )))
+        return STATUS_NO_MEMORY;
+
+    strcpy( unix_name, config_dir );
+    strcat( unix_name, "/dosdevices/" );
+    dev = unix_name + strlen(unix_name);
+
+    for (i = 0; i < name_len; i++) dev[i] = (name[i] >= 'A' && name[i] <= 'Z' ? name[i] + 32 : name[i]);
+    dev[i] = 0;
+
+    /* special case for drive devices */
+    if (name_len == 2 && dev[1] == ':')
     {
-        RtlInitUnicodeString( &nameW, ShowDotFilesW );
-        if (!NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation, tmp, sizeof(tmp), &dummy ))
+        dev[i++] = ':';
+        dev[i] = 0;
+    }
+
+    for (;;)
+    {
+        if (!stat( unix_name, &st ))
         {
-            WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)tmp)->Data;
-            show_dot_files = IS_OPTION_TRUE( str[0] );
+            TRACE( "%s -> %s\n", debugstr_wn(name,name_len), debugstr_a(unix_name) );
+            unix_name_ret->Buffer = unix_name;
+            unix_name_ret->Length = strlen(unix_name);
+            unix_name_ret->MaximumLength = unix_len;
+            return STATUS_SUCCESS;
         }
-        NtClose( hkey );
+        if (!dev) break;
+
+        /* now try some defaults for it */
+        if (!strcmp( dev, "aux" ))
+        {
+            strcpy( dev, "com1" );
+            continue;
+        }
+        if (!strcmp( dev, "prn" ))
+        {
+            strcpy( dev, "lpt1" );
+            continue;
+        }
+
+        new_name = NULL;
+        if (dev[1] == ':' && dev[2] == ':')  /* drive device */
+        {
+            dev[2] = 0;  /* remove last ':' to get the drive mount point symlink */
+            new_name = get_default_drive_device( unix_name );
+        }
+
+        if (!new_name) break;
+
+        RtlFreeHeap( GetProcessHeap(), 0, unix_name );
+        unix_name = new_name;
+        unix_len = strlen(unix_name) + 1;
+        dev = NULL; /* last try */
     }
-    NtClose( root );
-    unix_funcs->set_show_dot_files( show_dot_files );
+    RtlFreeHeap( GetProcessHeap(), 0, unix_name );
+    return STATUS_BAD_DEVICE_TYPE;
+}
+
+
+/* return the length of the DOS namespace prefix if any */
+static inline int get_dos_prefix_len( const UNICODE_STRING *name )
+{
+    static const WCHAR nt_prefixW[] = {'\\','?','?','\\'};
+    static const WCHAR dosdev_prefixW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\'};
+
+    if (name->Length >= sizeof(nt_prefixW) &&
+        !memcmp( name->Buffer, nt_prefixW, sizeof(nt_prefixW) ))
+        return ARRAY_SIZE( nt_prefixW );
+
+    if (name->Length >= sizeof(dosdev_prefixW) &&
+        !wcsnicmp( name->Buffer, dosdev_prefixW, ARRAY_SIZE( dosdev_prefixW )))
+        return ARRAY_SIZE( dosdev_prefixW );
+
+    return 0;
+}
+
+
+/******************************************************************************
+ *           find_file_id
+ *
+ * Recursively search directories from the dir queue for a given inode.
+ */
+static NTSTATUS find_file_id( ANSI_STRING *unix_name, ULONGLONG file_id, dev_t dev )
+{
+    unsigned int pos;
+    DIR *dir;
+    struct dirent *de;
+    NTSTATUS status;
+    struct stat st;
+
+    while (!(status = next_dir_in_queue( unix_name->Buffer )))
+    {
+        if (!(dir = opendir( unix_name->Buffer ))) continue;
+        TRACE( "searching %s for %s\n", unix_name->Buffer, wine_dbgstr_longlong(file_id) );
+        pos = strlen( unix_name->Buffer );
+        if (pos + MAX_DIR_ENTRY_LEN >= unix_name->MaximumLength/sizeof(WCHAR))
+        {
+            char *new = RtlReAllocateHeap( GetProcessHeap(), 0, unix_name->Buffer,
+                                           unix_name->MaximumLength * 2 );
+            if (!new)
+            {
+                closedir( dir );
+                return STATUS_NO_MEMORY;
+            }
+            unix_name->MaximumLength *= 2;
+            unix_name->Buffer = new;
+        }
+        unix_name->Buffer[pos++] = '/';
+        while ((de = readdir( dir )))
+        {
+            if (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." )) continue;
+            strcpy( unix_name->Buffer + pos, de->d_name );
+            if (lstat( unix_name->Buffer, &st ) == -1) continue;
+            if (st.st_dev != dev) continue;
+            if (st.st_ino == file_id)
+            {
+                closedir( dir );
+                return STATUS_SUCCESS;
+            }
+            if (!S_ISDIR( st.st_mode )) continue;
+            if ((status = add_dir_to_queue( unix_name->Buffer )) != STATUS_SUCCESS)
+            {
+                closedir( dir );
+                return status;
+            }
+        }
+        closedir( dir );
+    }
+    return status;
+}
+
+
+/******************************************************************************
+ *           file_id_to_unix_file_name
+ *
+ * Lookup a file from its file id instead of its name.
+ */
+NTSTATUS file_id_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, ANSI_STRING *unix_name )
+{
+    enum server_fd_type type;
+    int old_cwd, root_fd, needs_close;
+    NTSTATUS status;
+    ULONGLONG file_id;
+    struct stat st, root_st;
+
+    if (attr->ObjectName->Length != sizeof(ULONGLONG)) return STATUS_OBJECT_PATH_SYNTAX_BAD;
+    if (!attr->RootDirectory) return STATUS_INVALID_PARAMETER;
+    memcpy( &file_id, attr->ObjectName->Buffer, sizeof(file_id) );
+
+    unix_name->MaximumLength = 2 * MAX_DIR_ENTRY_LEN + 4;
+    if (!(unix_name->Buffer = RtlAllocateHeap( GetProcessHeap(), 0, unix_name->MaximumLength )))
+        return STATUS_NO_MEMORY;
+    strcpy( unix_name->Buffer, "." );
+
+    if ((status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
+        goto done;
+
+    if (type != FD_TYPE_DIR)
+    {
+        status = STATUS_OBJECT_TYPE_MISMATCH;
+        goto done;
+    }
+
+    fstat( root_fd, &root_st );
+    if (root_st.st_ino == file_id)  /* shortcut for "." */
+    {
+        status = STATUS_SUCCESS;
+        goto done;
+    }
+
+    RtlEnterCriticalSection( &dir_section );
+    if ((old_cwd = open( ".", O_RDONLY )) != -1 && fchdir( root_fd ) != -1)
+    {
+        /* shortcut for ".." */
+        if (!stat( "..", &st ) && st.st_dev == root_st.st_dev && st.st_ino == file_id)
+        {
+            strcpy( unix_name->Buffer, ".." );
+            status = STATUS_SUCCESS;
+        }
+        else
+        {
+            status = add_dir_to_queue( "." );
+            if (!status)
+                status = find_file_id( unix_name, file_id, root_st.st_dev );
+            if (!status)  /* get rid of "./" prefix */
+                memmove( unix_name->Buffer, unix_name->Buffer + 2, strlen(unix_name->Buffer) - 1 );
+            flush_dir_queue();
+        }
+        if (fchdir( old_cwd ) == -1) chdir( "/" );
+    }
+    else status = FILE_GetNtStatus();
+    RtlLeaveCriticalSection( &dir_section );
+    if (old_cwd != -1) close( old_cwd );
+
+done:
+    if (status == STATUS_SUCCESS)
+    {
+        TRACE( "%s -> %s\n", wine_dbgstr_longlong(file_id), debugstr_a(unix_name->Buffer) );
+        unix_name->Length = strlen( unix_name->Buffer );
+    }
+    else
+    {
+        TRACE( "%s not found in dir %p\n", wine_dbgstr_longlong(file_id), attr->RootDirectory );
+        RtlFreeHeap( GetProcessHeap(), 0, unix_name->Buffer );
+    }
+    if (needs_close) close( root_fd );
+    return status;
+}
+
+
+/******************************************************************************
+ *           lookup_unix_name
+ *
+ * Helper for nt_to_unix_file_name
+ */
+static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer, int unix_len, int pos,
+                                  UINT disposition, BOOLEAN check_case )
+{
+    NTSTATUS status;
+    int ret, len;
+    struct stat st;
+    char *unix_name = *buffer;
+    const BOOL redirect = nb_redirects && ntdll_get_thread_data()->wow64_redir;
+
+    /* try a shortcut first */
+
+    while (name_len && IS_SEPARATOR(*name))
+    {
+        name++;
+        name_len--;
+    }
+
+    unix_name[pos] = '/';
+    ret = ntdll_wcstoumbs( name, name_len, unix_name + pos + 1, unix_len - pos - 1, TRUE );
+    if (ret >= 0 && ret < unix_len - pos - 1)
+    {
+        char *p;
+        unix_name[pos + 1 + ret] = 0;
+        for (p = unix_name + pos ; *p; p++) if (*p == '\\') *p = '/';
+        if (!name_len || !redirect || (!strstr( unix_name, "/windows/") && strncmp( unix_name, "windows/", 8 )))
+        {
+            if (!stat( unix_name, &st ))
+            {
+                if (disposition == FILE_CREATE)
+                    return STATUS_OBJECT_NAME_COLLISION;
+                return STATUS_SUCCESS;
+            }
+        }
+    }
+
+    if (!name_len)  /* empty name -> drive root doesn't exist */
+        return STATUS_OBJECT_PATH_NOT_FOUND;
+    if (check_case && !redirect && (disposition == FILE_OPEN || disposition == FILE_OVERWRITE))
+        return STATUS_OBJECT_NAME_NOT_FOUND;
+
+    /* now do it component by component */
+
+    while (name_len)
+    {
+        const WCHAR *end, *next;
+        BOOLEAN is_win_dir = FALSE;
+
+        end = name;
+        while (end < name + name_len && !IS_SEPARATOR(*end)) end++;
+        next = end;
+        while (next < name + name_len && IS_SEPARATOR(*next)) next++;
+        name_len -= next - name;
+
+        /* grow the buffer if needed */
+
+        if (unix_len - pos < MAX_DIR_ENTRY_LEN + 2)
+        {
+            char *new_name;
+            unix_len += 2 * MAX_DIR_ENTRY_LEN;
+            if (!(new_name = RtlReAllocateHeap( GetProcessHeap(), 0, unix_name, unix_len )))
+                return STATUS_NO_MEMORY;
+            unix_name = *buffer = new_name;
+        }
+
+        status = find_file_in_dir( unix_name, pos, name, end - name,
+                                   check_case, redirect ? &is_win_dir : NULL );
+
+        /* if this is the last element, not finding it is not necessarily fatal */
+        if (!name_len)
+        {
+            if (status == STATUS_OBJECT_PATH_NOT_FOUND)
+            {
+                status = STATUS_OBJECT_NAME_NOT_FOUND;
+                if (disposition != FILE_OPEN && disposition != FILE_OVERWRITE)
+                {
+                    ret = ntdll_wcstoumbs( name, end - name, unix_name + pos + 1, MAX_DIR_ENTRY_LEN + 1, TRUE );
+                    if (ret > 0 && ret <= MAX_DIR_ENTRY_LEN)
+                    {
+                        unix_name[pos] = '/';
+                        unix_name[pos + 1 + ret] = 0;
+                        status = STATUS_NO_SUCH_FILE;
+                        break;
+                    }
+                }
+            }
+            else if (status == STATUS_SUCCESS && disposition == FILE_CREATE)
+            {
+                status = STATUS_OBJECT_NAME_COLLISION;
+            }
+        }
+
+        if (status != STATUS_SUCCESS) break;
+
+        pos += strlen( unix_name + pos );
+        name = next;
+
+        if (is_win_dir && (len = get_redirect_path( unix_name, pos, name, name_len, check_case )))
+        {
+            name += len;
+            name_len -= len;
+            pos += strlen( unix_name + pos );
+            TRACE( "redirecting -> %s + %s\n", debugstr_a(unix_name), debugstr_w(name) );
+        }
+    }
+
+    return status;
+}
+
+
+/******************************************************************************
+ *           nt_to_unix_file_name_attr
+ */
+NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, ANSI_STRING *unix_name_ret,
+                                    UINT disposition )
+{
+    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
+    enum server_fd_type type;
+    int old_cwd, root_fd, needs_close;
+    const WCHAR *name, *p;
+    char *unix_name;
+    int name_len, unix_len;
+    NTSTATUS status;
+    BOOLEAN check_case = !(attr->Attributes & OBJ_CASE_INSENSITIVE);
+
+    if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
+        return wine_nt_to_unix_file_name( attr->ObjectName, unix_name_ret, disposition, check_case );
+
+    name     = attr->ObjectName->Buffer;
+    name_len = attr->ObjectName->Length / sizeof(WCHAR);
+
+    if (name_len && IS_SEPARATOR(name[0])) return STATUS_INVALID_PARAMETER;
+
+    /* check for invalid characters */
+    for (p = name; p < name + name_len; p++)
+        if (*p < 32 || wcschr( invalid_charsW, *p )) return STATUS_OBJECT_NAME_INVALID;
+
+    unix_len = name_len * 3 + MAX_DIR_ENTRY_LEN + 3;
+    if (!(unix_name = RtlAllocateHeap( GetProcessHeap(), 0, unix_len )))
+        return STATUS_NO_MEMORY;
+    unix_name[0] = '.';
+
+    if (!(status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
+    {
+        if (type != FD_TYPE_DIR)
+        {
+            if (needs_close) close( root_fd );
+            status = STATUS_BAD_DEVICE_TYPE;
+        }
+        else
+        {
+            RtlEnterCriticalSection( &dir_section );
+            if ((old_cwd = open( ".", O_RDONLY )) != -1 && fchdir( root_fd ) != -1)
+            {
+                status = lookup_unix_name( name, name_len, &unix_name, unix_len, 1,
+                                           disposition, check_case );
+                if (fchdir( old_cwd ) == -1) chdir( "/" );
+            }
+            else status = FILE_GetNtStatus();
+            RtlLeaveCriticalSection( &dir_section );
+            if (old_cwd != -1) close( old_cwd );
+            if (needs_close) close( root_fd );
+        }
+    }
+    else if (status == STATUS_OBJECT_TYPE_MISMATCH) status = STATUS_BAD_DEVICE_TYPE;
+
+    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+    {
+        TRACE( "%s -> %s\n", debugstr_us(attr->ObjectName), debugstr_a(unix_name) );
+        unix_name_ret->Buffer = unix_name;
+        unix_name_ret->Length = strlen(unix_name);
+        unix_name_ret->MaximumLength = unix_len;
+    }
+    else
+    {
+        TRACE( "%s not found in %s\n", debugstr_w(name), unix_name );
+        RtlFreeHeap( GetProcessHeap(), 0, unix_name );
+    }
+    return status;
 }
 
 
@@ -92,10 +2687,114 @@ void init_directories(void)
  * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
  * returned, but the unix name is still filled in properly.
  */
-NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, char *nameA, SIZE_T *size,
-                                          UINT disposition )
+NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRING *unix_name_ret,
+                                          UINT disposition, BOOLEAN check_case )
 {
-    return unix_funcs->nt_to_unix_file_name( nameW, nameA, size, disposition );
+    static const WCHAR unixW[] = {'u','n','i','x'};
+    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
+
+    NTSTATUS status = STATUS_SUCCESS;
+    const WCHAR *name, *p;
+    struct stat st;
+    char *unix_name;
+    int pos, ret, name_len, unix_len, prefix_len;
+    WCHAR prefix[MAX_DIR_ENTRY_LEN + 1];
+    BOOLEAN is_unix = FALSE;
+
+    name     = nameW->Buffer;
+    name_len = nameW->Length / sizeof(WCHAR);
+
+    if (!name_len || !IS_SEPARATOR(name[0])) return STATUS_OBJECT_PATH_SYNTAX_BAD;
+
+    if (!(pos = get_dos_prefix_len( nameW )))
+        return STATUS_BAD_DEVICE_TYPE;  /* no DOS prefix, assume NT native name */
+
+    name += pos;
+    name_len -= pos;
+
+    if (!name_len) return STATUS_OBJECT_NAME_INVALID;
+
+    /* check for sub-directory */
+    for (pos = 0; pos < name_len; pos++)
+    {
+        if (IS_SEPARATOR(name[pos])) break;
+        if (name[pos] < 32 || wcschr( invalid_charsW, name[pos] ))
+            return STATUS_OBJECT_NAME_INVALID;
+    }
+    if (pos > MAX_DIR_ENTRY_LEN)
+        return STATUS_OBJECT_NAME_INVALID;
+
+    if (pos == name_len)  /* no subdir, plain DOS device */
+        return get_dos_device( name, name_len, unix_name_ret );
+
+    prefix_len = pos;
+    memcpy( prefix, name, prefix_len * sizeof(WCHAR) );
+    prefix[prefix_len] = 0;
+    wcslwr( prefix );
+
+    name += prefix_len;
+    name_len -= prefix_len;
+
+    /* check for invalid characters (all chars except 0 are valid for unix) */
+    is_unix = (prefix_len == 4 && !memcmp( prefix, unixW, sizeof(unixW) ));
+    if (is_unix)
+    {
+        for (p = name; p < name + name_len; p++)
+            if (!*p) return STATUS_OBJECT_NAME_INVALID;
+        check_case = TRUE;
+    }
+    else
+    {
+        for (p = name; p < name + name_len; p++)
+            if (*p < 32 || wcschr( invalid_charsW, *p )) return STATUS_OBJECT_NAME_INVALID;
+    }
+
+    unix_len = (prefix_len + name_len) * 3 + MAX_DIR_ENTRY_LEN + 3;
+    unix_len += strlen(config_dir) + sizeof("/dosdevices/");
+    if (!(unix_name = RtlAllocateHeap( GetProcessHeap(), 0, unix_len )))
+        return STATUS_NO_MEMORY;
+    strcpy( unix_name, config_dir );
+    strcat( unix_name, "/dosdevices/" );
+    pos = strlen(unix_name);
+
+    ret = ntdll_wcstoumbs( prefix, prefix_len, unix_name + pos, unix_len - pos - 1, TRUE );
+    if (ret <= 0)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, unix_name );
+        return STATUS_OBJECT_NAME_INVALID;
+    }
+    pos += ret;
+
+    /* check if prefix exists (except for DOS drives to avoid extra stat calls) */
+
+    if (prefix_len != 2 || prefix[1] != ':')
+    {
+        unix_name[pos] = 0;
+        if (lstat( unix_name, &st ) == -1 && errno == ENOENT)
+        {
+            if (!is_unix)
+            {
+                RtlFreeHeap( GetProcessHeap(), 0, unix_name );
+                return STATUS_BAD_DEVICE_TYPE;
+            }
+            pos = 0;  /* fall back to unix root */
+        }
+    }
+
+    status = lookup_unix_name( name, name_len, &unix_name, unix_len, pos, disposition, check_case );
+    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+    {
+        TRACE( "%s -> %s\n", debugstr_us(nameW), debugstr_a(unix_name) );
+        unix_name_ret->Buffer = unix_name;
+        unix_name_ret->Length = strlen(unix_name);
+        unix_name_ret->MaximumLength = unix_len;
+    }
+    else
+    {
+        TRACE( "%s not found in %s\n", debugstr_w(name), unix_name );
+        RtlFreeHeap( GetProcessHeap(), 0, unix_name );
+    }
+    return status;
 }
 
 
@@ -104,13 +2803,9 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, char *nam
  */
 NTSTATUS WINAPI RtlWow64EnableFsRedirection( BOOLEAN enable )
 {
-#ifdef _WIN64
-     return STATUS_NOT_IMPLEMENTED;
-#else
-    if (!NtCurrentTeb64()) return STATUS_NOT_IMPLEMENTED;
-    NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = !enable;
+    if (!is_wow64) return STATUS_NOT_IMPLEMENTED;
+    ntdll_get_thread_data()->wow64_redir = enable;
     return STATUS_SUCCESS;
-#endif
 }
 
 
@@ -119,14 +2814,11 @@ NTSTATUS WINAPI RtlWow64EnableFsRedirection( BOOLEAN enable )
  */
 NTSTATUS WINAPI RtlWow64EnableFsRedirectionEx( ULONG disable, ULONG *old_value )
 {
-#ifdef _WIN64
-     return STATUS_NOT_IMPLEMENTED;
-#else
-    if (!NtCurrentTeb64()) return STATUS_NOT_IMPLEMENTED;
+    if (!is_wow64) return STATUS_NOT_IMPLEMENTED;
 
     __TRY
     {
-        *old_value = NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR];
+        *old_value = !ntdll_get_thread_data()->wow64_redir;
     }
     __EXCEPT_PAGE_FAULT
     {
@@ -134,9 +2826,8 @@ NTSTATUS WINAPI RtlWow64EnableFsRedirectionEx( ULONG disable, ULONG *old_value )
     }
     __ENDTRY
 
-    NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = disable;
+    ntdll_get_thread_data()->wow64_redir = !disable;
     return STATUS_SUCCESS;
-#endif
 }
 
 
@@ -164,3 +2855,135 @@ BOOLEAN WINAPI RtlDoesFileExists_U(LPCWSTR file_name)
     RtlFreeUnicodeString( &nt_name );
     return ret;
 }
+
+
+/***********************************************************************
+ *           DIR_unmount_device
+ *
+ * Unmount the specified device.
+ */
+NTSTATUS DIR_unmount_device( HANDLE handle )
+{
+    NTSTATUS status;
+    int unix_fd, needs_close;
+
+    if (!(status = server_get_unix_fd( handle, 0, &unix_fd, &needs_close, NULL, NULL )))
+    {
+        struct stat st;
+        char *mount_point = NULL;
+
+        if (fstat( unix_fd, &st ) == -1 || !is_valid_mounted_device( &st ))
+            status = STATUS_INVALID_PARAMETER;
+        else
+        {
+            if ((mount_point = get_device_mount_point( st.st_rdev )))
+            {
+#ifdef __APPLE__
+                static const char umount[] = "diskutil unmount >/dev/null 2>&1 ";
+#else
+                static const char umount[] = "umount >/dev/null 2>&1 ";
+#endif
+                char *cmd = RtlAllocateHeap( GetProcessHeap(), 0, strlen(mount_point)+sizeof(umount));
+                if (cmd)
+                {
+                    strcpy( cmd, umount );
+                    strcat( cmd, mount_point );
+                    system( cmd );
+                    RtlFreeHeap( GetProcessHeap(), 0, cmd );
+#ifdef linux
+                    /* umount will fail to release the loop device since we still have
+                       a handle to it, so we release it here */
+                    if (major(st.st_rdev) == LOOP_MAJOR) ioctl( unix_fd, 0x4c01 /*LOOP_CLR_FD*/, 0 );
+#endif
+                }
+                RtlFreeHeap( GetProcessHeap(), 0, mount_point );
+            }
+        }
+        if (needs_close) close( unix_fd );
+    }
+    return status;
+}
+
+
+/******************************************************************************
+ *           DIR_get_unix_cwd
+ *
+ * Retrieve the Unix name of the current directory; helper for wine_unix_to_nt_file_name.
+ * Returned value must be freed by caller.
+ */
+NTSTATUS DIR_get_unix_cwd( char **cwd )
+{
+    int old_cwd, unix_fd, needs_close;
+    CURDIR *curdir;
+    HANDLE handle;
+    NTSTATUS status;
+
+    RtlAcquirePebLock();
+
+    if (NtCurrentTeb()->Tib.SubSystemTib)  /* FIXME: hack */
+        curdir = &((WIN16_SUBSYSTEM_TIB *)NtCurrentTeb()->Tib.SubSystemTib)->curdir;
+    else
+        curdir = &NtCurrentTeb()->Peb->ProcessParameters->CurrentDirectory;
+
+    if (!(handle = curdir->Handle))
+    {
+        UNICODE_STRING dirW;
+        OBJECT_ATTRIBUTES attr;
+        IO_STATUS_BLOCK io;
+
+        if (!RtlDosPathNameToNtPathName_U( curdir->DosPath.Buffer, &dirW, NULL, NULL ))
+        {
+            status = STATUS_OBJECT_NAME_INVALID;
+            goto done;
+        }
+        attr.Length = sizeof(attr);
+        attr.RootDirectory = 0;
+        attr.Attributes = OBJ_CASE_INSENSITIVE;
+        attr.ObjectName = &dirW;
+        attr.SecurityDescriptor = NULL;
+        attr.SecurityQualityOfService = NULL;
+
+        status = NtOpenFile( &handle, SYNCHRONIZE, &attr, &io, 0,
+                             FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
+        RtlFreeUnicodeString( &dirW );
+        if (status != STATUS_SUCCESS) goto done;
+    }
+
+    if ((status = server_get_unix_fd( handle, 0, &unix_fd, &needs_close, NULL, NULL )) == STATUS_SUCCESS)
+    {
+        RtlEnterCriticalSection( &dir_section );
+
+        if ((old_cwd = open(".", O_RDONLY)) != -1 && fchdir( unix_fd ) != -1)
+        {
+            unsigned int size = 512;
+
+            for (;;)
+            {
+                if (!(*cwd = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+                {
+                    status = STATUS_NO_MEMORY;
+                    break;
+                }
+                if (getcwd( *cwd, size )) break;
+                RtlFreeHeap( GetProcessHeap(), 0, *cwd );
+                if (errno != ERANGE)
+                {
+                    status = STATUS_OBJECT_PATH_INVALID;
+                    break;
+                }
+                size *= 2;
+            }
+            if (fchdir( old_cwd ) == -1) chdir( "/" );
+        }
+        else status = FILE_GetNtStatus();
+
+        RtlLeaveCriticalSection( &dir_section );
+        if (old_cwd != -1) close( old_cwd );
+        if (needs_close) close( unix_fd );
+    }
+    if (!curdir->Handle) NtClose( handle );
+
+done:
+    RtlReleasePebLock();
+    return status;
+}
diff --git a/dlls/ntdll/env.c b/dlls/ntdll/env.c
index 06e7c1bb37..6b32f4d57e 100644
--- a/dlls/ntdll/env.c
+++ b/dlls/ntdll/env.c
@@ -18,10 +18,21 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
+#include "config.h"
 
 #include <assert.h>
+#include <errno.h>
 #include <stdarg.h>
 #include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_PWD_H
+# include <pwd.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -49,6 +60,24 @@ static inline SIZE_T get_env_length( const WCHAR *env )
 }
 
 
+/***********************************************************************
+ *           is_special_env_var
+ *
+ * Check if an environment variable needs to be handled specially when
+ * passed through the Unix environment (i.e. prefixed with "WINE").
+ */
+static inline BOOL is_special_env_var( const char *var )
+{
+    return (!strncmp( var, "PATH=", sizeof("PATH=")-1 ) ||
+            !strncmp( var, "PWD=", sizeof("PWD=")-1 ) ||
+            !strncmp( var, "HOME=", sizeof("HOME=")-1 ) ||
+            !strncmp( var, "TEMP=", sizeof("TEMP=")-1 ) ||
+            !strncmp( var, "TMP=", sizeof("TMP=")-1 ) ||
+            !strncmp( var, "QT_", sizeof("QT_")-1 ) ||
+            !strncmp( var, "VK_", sizeof("VK_")-1 ));
+}
+
+
 /***********************************************************************
  *           set_env_var
  */
@@ -57,12 +86,8 @@ static void set_env_var( WCHAR **env, const WCHAR *name, const WCHAR *val )
     UNICODE_STRING nameW, valW;
 
     RtlInitUnicodeString( &nameW, name );
-    if (val)
-    {
-        RtlInitUnicodeString( &valW, val );
-        RtlSetEnvironmentVariable( env, &nameW, &valW );
-    }
-    else RtlSetEnvironmentVariable( env, &nameW, NULL );
+    RtlInitUnicodeString( &valW, val );
+    RtlSetEnvironmentVariable( env, &nameW, &valW );
 }
 
 
@@ -297,6 +322,24 @@ static void set_additional_environment( WCHAR **env )
 }
 
 
+/* set an environment variable for one of the wine path variables */
+static void set_wine_path_variable( WCHAR **env, const WCHAR *name, const char *unix_path )
+{
+    UNICODE_STRING nt_name, var_name;
+    ANSI_STRING unix_name;
+
+    RtlInitUnicodeString( &var_name, name );
+    if (unix_path)
+    {
+        RtlInitAnsiString( &unix_name, unix_path );
+        if (wine_unix_to_nt_file_name( &unix_name, &nt_name )) return;
+        RtlSetEnvironmentVariable( env, &var_name, &nt_name );
+        RtlFreeUnicodeString( &nt_name );
+    }
+    else RtlSetEnvironmentVariable( env, &var_name, NULL );
+}
+
+
 /***********************************************************************
  *           set_wow64_environment
  *
@@ -323,6 +366,12 @@ static void set_wow64_environment( WCHAR **env )
     static const WCHAR commonfilesW[] = {'C','o','m','m','o','n','P','r','o','g','r','a','m','F','i','l','e','s',0};
     static const WCHAR commonfiles86W[] = {'C','o','m','m','o','n','P','r','o','g','r','a','m','F','i','l','e','s','(','x','8','6',')',0};
     static const WCHAR commonw6432W[] = {'C','o','m','m','o','n','P','r','o','g','r','a','m','W','6','4','3','2',0};
+    static const WCHAR winedlldirW[] = {'W','I','N','E','D','L','L','D','I','R','%','u',0};
+    static const WCHAR winehomedirW[] = {'W','I','N','E','H','O','M','E','D','I','R',0};
+    static const WCHAR winedatadirW[] = {'W','I','N','E','D','A','T','A','D','I','R',0};
+    static const WCHAR winebuilddirW[] = {'W','I','N','E','B','U','I','L','D','D','I','R',0};
+    static const WCHAR wineusernameW[] = {'W','I','N','E','U','S','E','R','N','A','M','E',0};
+    static const WCHAR wineconfigdirW[] = {'W','I','N','E','C','O','N','F','I','G','D','I','R',0};
 
     WCHAR buf[256];
     UNICODE_STRING arch_strW = { sizeof(archW) - sizeof(WCHAR), sizeof(archW), archW };
@@ -330,23 +379,47 @@ static void set_wow64_environment( WCHAR **env )
     UNICODE_STRING valW = { 0, sizeof(buf), buf };
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING nameW;
+    const char *p;
+    const char *home = getenv( "HOME" );
+    const char *name = getenv( "USER" );
+    const char **dll_paths;
+    SIZE_T dll_path_maxlen;
+    WCHAR *val;
     HANDLE hkey;
-    SIZE_T size = 1024;
-    WCHAR *ptr, *val, *p;
+    DWORD i;
 
-    for (;;)
+    if (!home || !name)
     {
-        if (!(ptr = RtlAllocateHeap( GetProcessHeap(), 0, size * sizeof(WCHAR) ))) break;
-        if (!unix_funcs->get_dynamic_environment( ptr, &size )) break;
-        RtlFreeHeap( GetProcessHeap(), 0, ptr );
+        struct passwd *pwd = getpwuid( getuid() );
+        if (pwd)
+        {
+            if (!home) home = pwd->pw_dir;
+            if (!name) name = pwd->pw_name;
+        }
     }
-    for (p = ptr; *p; p += wcslen(p) + 1)
+
+    /* set the Wine paths */
+
+    set_wine_path_variable( env, winedatadirW, data_dir );
+    set_wine_path_variable( env, winehomedirW, home );
+    set_wine_path_variable( env, winebuilddirW, build_dir );
+    set_wine_path_variable( env, wineconfigdirW, config_dir );
+    unix_funcs->get_dll_path( &dll_paths, &dll_path_maxlen );
+    for (i = 0; dll_paths[i]; i++)
     {
-        if ((val = wcschr( p, '=' ))) *val++ = 0;
-        set_env_var( env, p, val );
-        if (val) p = val;
+        NTDLL_swprintf( buf, winedlldirW, i );
+        set_wine_path_variable( env, buf, dll_paths[i] );
     }
-    RtlFreeHeap( GetProcessHeap(), 0, ptr );
+    NTDLL_swprintf( buf, winedlldirW, i );
+    set_wine_path_variable( env, buf, NULL );
+
+    /* set user name */
+
+    if (!name) name = "wine";
+    if ((p = strrchr( name, '/' ))) name = p + 1;
+    if ((p = strrchr( name, '\\' ))) name = p + 1;
+    ntdll_umbstowcs( name, strlen(name) + 1, buf, ARRAY_SIZE(buf) );
+    set_env_var( env, wineusernameW, buf );
 
     /* set the PROCESSOR_ARCHITECTURE variable */
 
@@ -410,23 +483,114 @@ static void set_wow64_environment( WCHAR **env )
  *
  * Build the Win32 environment from the Unix environment
  */
-static WCHAR *build_initial_environment( WCHAR **wargv[] )
+static WCHAR *build_initial_environment( char **env )
 {
-    SIZE_T size = 1024;
-    WCHAR *ptr;
+    SIZE_T size = 1;
+    char **e;
+    WCHAR *p, *ptr;
+
+    /* compute the total size of the Unix environment */
+
+    for (e = env; *e; e++)
+    {
+        if (is_special_env_var( *e )) continue;
+        size += strlen(*e) + 1;
+    }
+
+    if (!(ptr = RtlAllocateHeap( GetProcessHeap(), 0, size * sizeof(WCHAR) ))) return NULL;
+    p = ptr;
 
-    for (;;)
+    /* and fill it with the Unix environment */
+
+    for (e = env; *e; e++)
     {
-        if (!(ptr = RtlAllocateHeap( GetProcessHeap(), 0, size * sizeof(WCHAR) ))) return NULL;
-        if (!unix_funcs->get_initial_environment( wargv, ptr, &size )) break;
-        RtlFreeHeap( GetProcessHeap(), 0, ptr );
+        char *str = *e;
+
+        /* skip Unix special variables and use the Wine variants instead */
+        if (!strncmp( str, "WINE", 4 ))
+        {
+            if (is_special_env_var( str + 4 )) str += 4;
+            else if (!strncmp( str, "WINEPRELOADRESERVE=", 19 )) continue;  /* skip it */
+        }
+        else if (is_special_env_var( str )) continue;  /* skip it */
+
+        ntdll_umbstowcs( str, strlen(str) + 1, p, size - (p - ptr) );
+        p += wcslen(p) + 1;
     }
+    *p = 0;
     first_prefix_start = set_registry_environment( &ptr, TRUE );
     set_additional_environment( &ptr );
     return ptr;
 }
 
 
+/***********************************************************************
+ *           build_envp
+ *
+ * Build the environment of a new child process.
+ */
+char **build_envp( const WCHAR *envW )
+{
+    static const char * const unix_vars[] = { "PATH", "TEMP", "TMP", "HOME" };
+    char **envp;
+    char *env, *p;
+    int count = 1, length, lenW;
+    unsigned int i;
+
+    lenW = get_env_length( envW );
+    if (!(env = RtlAllocateHeap( GetProcessHeap(), 0, lenW * 3 ))) return NULL;
+    length = ntdll_wcstoumbs( envW, lenW, env, lenW * 3, FALSE );
+
+    for (p = env; *p; p += strlen(p) + 1, count++)
+        if (is_special_env_var( p )) length += 4; /* prefix it with "WINE" */
+
+    for (i = 0; i < ARRAY_SIZE( unix_vars ); i++)
+    {
+        if (!(p = getenv(unix_vars[i]))) continue;
+        length += strlen(unix_vars[i]) + strlen(p) + 2;
+        count++;
+    }
+
+    if ((envp = RtlAllocateHeap( GetProcessHeap(), 0, count * sizeof(*envp) + length )))
+    {
+        char **envptr = envp;
+        char *dst = (char *)(envp + count);
+
+        /* some variables must not be modified, so we get them directly from the unix env */
+        for (i = 0; i < ARRAY_SIZE( unix_vars ); i++)
+        {
+            if (!(p = getenv( unix_vars[i] ))) continue;
+            *envptr++ = strcpy( dst, unix_vars[i] );
+            strcat( dst, "=" );
+            strcat( dst, p );
+            dst += strlen(dst) + 1;
+        }
+
+        /* now put the Windows environment strings */
+        for (p = env; *p; p += strlen(p) + 1)
+        {
+            if (*p == '=') continue;  /* skip drive curdirs, this crashes some unix apps */
+            if (!strncmp( p, "WINEPRELOADRESERVE=", sizeof("WINEPRELOADRESERVE=")-1 )) continue;
+            if (!strncmp( p, "WINELOADERNOEXEC=", sizeof("WINELOADERNOEXEC=")-1 )) continue;
+            if (!strncmp( p, "WINESERVERSOCKET=", sizeof("WINESERVERSOCKET=")-1 )) continue;
+            if (is_special_env_var( p ))  /* prefix it with "WINE" */
+            {
+                *envptr++ = strcpy( dst, "WINE" );
+                strcat( dst, p );
+            }
+            else
+            {
+                *envptr++ = strcpy( dst, p );
+            }
+            dst += strlen(dst) + 1;
+        }
+        *envptr = 0;
+    }
+    RtlFreeHeap( GetProcessHeap(), 0, env );
+    return envp;
+}
+
+
 /***********************************************************************
  *           get_current_directory
  *
@@ -434,13 +598,69 @@ static WCHAR *build_initial_environment( WCHAR **wargv[] )
  */
 static void get_current_directory( UNICODE_STRING *dir )
 {
-    unix_funcs->get_initial_directory( dir );
+    const char *pwd;
+    char *cwd;
+    int size;
+
+    dir->Length = 0;
+
+    /* try to get it from the Unix cwd */
+
+    for (size = 1024; ; size *= 2)
+    {
+        if (!(cwd = RtlAllocateHeap( GetProcessHeap(), 0, size ))) break;
+        if (getcwd( cwd, size )) break;
+        RtlFreeHeap( GetProcessHeap(), 0, cwd );
+        if (errno == ERANGE) continue;
+        cwd = NULL;
+        break;
+    }
+
+    /* try to use PWD if it is valid, so that we don't resolve symlinks */
+
+    pwd = getenv( "PWD" );
+    if (cwd)
+    {
+        struct stat st1, st2;
+
+        if (!pwd || stat( pwd, &st1 ) == -1 ||
+            (!stat( cwd, &st2 ) && (st1.st_dev != st2.st_dev || st1.st_ino != st2.st_ino)))
+            pwd = cwd;
+    }
+
+    if (pwd)
+    {
+        ANSI_STRING unix_name;
+        UNICODE_STRING nt_name;
+
+        RtlInitAnsiString( &unix_name, pwd );
+        if (!wine_unix_to_nt_file_name( &unix_name, &nt_name ))
+        {
+            /* skip the \??\ prefix */
+            if (nt_name.Length > 6 * sizeof(WCHAR) && nt_name.Buffer[5] == ':')
+            {
+                dir->Length = nt_name.Length - 4 * sizeof(WCHAR);
+                memcpy( dir->Buffer, nt_name.Buffer + 4, dir->Length );
+            }
+            else  /* change \??\ to \\?\ */
+            {
+                dir->Length = nt_name.Length;
+                memcpy( dir->Buffer, nt_name.Buffer, dir->Length );
+                dir->Buffer[1] = '\\';
+            }
+            RtlFreeUnicodeString( &nt_name );
+        }
+    }
 
     if (!dir->Length)  /* still not initialized */
     {
+        MESSAGE("Warning: could not find DOS drive for current working directory '%s', "
+                "starting in the Windows directory.\n", cwd ? cwd : "" );
         dir->Length = wcslen( windows_dir ) * sizeof(WCHAR);
         memcpy( dir->Buffer, windows_dir, dir->Length );
     }
+    RtlFreeHeap( GetProcessHeap(), 0, cwd );
+
     /* add trailing backslash */
     if (dir->Buffer[dir->Length / sizeof(WCHAR) - 1] != '\\')
     {
@@ -467,11 +687,14 @@ static inline BOOL is_path_prefix( const WCHAR *prefix, const WCHAR *path, const
 /***********************************************************************
  *           get_image_path
  */
-static void get_image_path( const WCHAR *name, UNICODE_STRING *path )
+static void get_image_path( const char *argv0, UNICODE_STRING *path )
 {
     static const WCHAR exeW[] = {'.','e','x','e',0};
-    WCHAR *load_path, *file_part, full_name[MAX_PATH];
-    DWORD len;
+    WCHAR *load_path, *file_part, *name, full_name[MAX_PATH];
+    DWORD len = strlen(argv0) + 1;
+
+    if (!(name = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) ))) goto failed;
+    ntdll_umbstowcs( argv0, len, name, len );
 
     if (RtlDetermineDosPathNameType_U( name ) != RELATIVE_PATH ||
         wcschr( name, '/' ) || wcschr( name, '\\' ))
@@ -509,11 +732,48 @@ static void get_image_path( const WCHAR *name, UNICODE_STRING *path )
     }
 done:
     RtlCreateUnicodeString( path, full_name );
+    RtlFreeHeap( GetProcessHeap(), 0, name );
     return;
 
 failed:
-    MESSAGE( "wine: cannot find %s\n", debugstr_w(name) );
-    RtlExitUserProcess( STATUS_DLL_NOT_FOUND );
+    MESSAGE( "wine: cannot find '%s'\n", argv0 );
+    RtlExitUserProcess( GetLastError() );
+}
+
+
+/***********************************************************************
+ *              set_library_wargv
+ *
+ * Set the Wine library Unicode argv global variables.
+ */
+static void set_library_wargv( char **argv, const UNICODE_STRING *image )
+{
+    int argc;
+    WCHAR *p, **wargv;
+    DWORD total = 0;
+
+    if (image) total += 1 + image->Length / sizeof(WCHAR);
+    for (argc = (image != NULL); argv[argc]; argc++) total += strlen(argv[argc]) + 1;
+
+    wargv = RtlAllocateHeap( GetProcessHeap(), 0,
+                             total * sizeof(WCHAR) + (argc + 1) * sizeof(*wargv) );
+    p = (WCHAR *)(wargv + argc + 1);
+    if (image)
+    {
+        wcscpy( p, image->Buffer );
+        wargv[0] = p;
+        p += 1 + image->Length / sizeof(WCHAR);
+        total -= 1 + image->Length / sizeof(WCHAR);
+    }
+    for (argc = (image != NULL); argv[argc]; argc++)
+    {
+        DWORD reslen = ntdll_umbstowcs( argv[argc], strlen(argv[argc]) + 1, p, total );
+        wargv[argc] = p;
+        p += reslen;
+        total -= reslen;
+    }
+    wargv[argc] = NULL;
+    __wine_main_wargv = wargv;
 }
 
 
@@ -607,6 +867,28 @@ static void build_command_line( WCHAR **argv, UNICODE_STRING *cmdline )
 }
 
 
+/******************************************************************************
+ *  NtQuerySystemEnvironmentValue		[NTDLL.@]
+ */
+NTSYSAPI NTSTATUS WINAPI NtQuerySystemEnvironmentValue(PUNICODE_STRING VariableName,
+                                                       PWCHAR Value,
+                                                       ULONG ValueBufferLength,
+                                                       PULONG RequiredLength)
+{
+    FIXME("(%s, %p, %u, %p), stub\n", debugstr_us(VariableName), Value, ValueBufferLength, RequiredLength);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtQuerySystemEnvironmentValueEx		[NTDLL.@]
+ */
+NTSYSAPI NTSTATUS WINAPI NtQuerySystemEnvironmentValueEx(PUNICODE_STRING name, LPGUID vendor,
+                                                         PVOID value, PULONG retlength, PULONG attrib)
+{
+    FIXME("(%s, %s, %p, %p, %p), stub\n", debugstr_us(name), debugstr_guid(vendor), value, retlength, attrib);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
 /******************************************************************************
  *  RtlCreateEnvironment		[NTDLL.@]
  */
@@ -1214,30 +1496,33 @@ wait:
  *
  * Fill the initial RTL_USER_PROCESS_PARAMETERS structure from the server.
  */
-void init_user_process_params(void)
+void init_user_process_params( SIZE_T data_size )
 {
     WCHAR *src, *load_path, *dummy;
-    SIZE_T info_size, env_size, data_size = 0;
+    SIZE_T info_size, env_size;
+    NTSTATUS status;
     startup_info_t *info = NULL;
     RTL_USER_PROCESS_PARAMETERS *params = NULL;
     UNICODE_STRING curdir, dllpath, imagepath, cmdline, title, desktop, shellinfo, runtime;
-    WCHAR **wargv;
+    int argc;
+    char **argv, **envp;
+
+    unix_funcs->get_main_args( &argc, &argv, &envp );
 
-    unix_funcs->get_startup_info( NULL, &data_size, &info_size );
     if (!data_size)
     {
         RTL_USER_PROCESS_PARAMETERS initial_params = {0};
         WCHAR *env, curdir_buffer[MAX_PATH];
 
         NtCurrentTeb()->Peb->ProcessParameters = &initial_params;
-        initial_params.Environment = build_initial_environment( &wargv );
+        initial_params.Environment = build_initial_environment( envp );
         curdir.Buffer = curdir_buffer;
         curdir.MaximumLength = sizeof(curdir_buffer);
         get_current_directory( &curdir );
         initial_params.CurrentDirectory.DosPath = curdir;
-        get_image_path( wargv[0], &initial_params.ImagePathName );
-        wargv[0] = initial_params.ImagePathName.Buffer;
-        build_command_line( wargv, &cmdline );
+        get_image_path( argv[0], &initial_params.ImagePathName );
+        set_library_wargv( argv, &initial_params.ImagePathName );
+        build_command_line( __wine_main_wargv, &cmdline );
         LdrGetDllPath( initial_params.ImagePathName.Buffer, 0, &load_path, &dummy );
         RtlInitUnicodeString( &dllpath, load_path );
 
@@ -1250,11 +1535,18 @@ void init_user_process_params(void)
 
         params->Environment = env;
         NtCurrentTeb()->Peb->ProcessParameters = params;
+        RtlFreeUnicodeString( &initial_params.ImagePathName );
         RtlFreeUnicodeString( &cmdline );
         RtlReleasePath( load_path );
 
-        unix_funcs->get_initial_console( &params->ConsoleHandle, &params->hStdInput,
-                                         &params->hStdOutput, &params->hStdError );
+        if (isatty(0) || isatty(1) || isatty(2))
+            params->ConsoleHandle = (HANDLE)2; /* see kernel32/kernel_private.h */
+        if (!isatty(0))
+            wine_server_fd_to_handle( 0, GENERIC_READ|SYNCHRONIZE,  OBJ_INHERIT, &params->hStdInput );
+        if (!isatty(1))
+            wine_server_fd_to_handle( 1, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, &params->hStdOutput );
+        if (!isatty(2))
+            wine_server_fd_to_handle( 2, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, &params->hStdError );
         params->wShowWindow = 1; /* SW_SHOWNORMAL */
 
         run_wineboot( &params->Environment );
@@ -1263,7 +1555,18 @@ void init_user_process_params(void)
 
     if (!(info = RtlAllocateHeap( GetProcessHeap(), 0, data_size ))) return;
 
-    if (unix_funcs->get_startup_info( info, &data_size, &info_size )) goto done;
+    SERVER_START_REQ( get_startup_info )
+    {
+        wine_server_set_reply( req, info, data_size );
+        if (!(status = wine_server_call( req )))
+        {
+            data_size = wine_server_reply_size( reply );
+            info_size = reply->info_size;
+            env_size  = data_size - info_size;
+        }
+    }
+    SERVER_END_REQ;
+    if (status) goto done;
 
     src = (WCHAR *)(info + 1);
     get_unicode_string( &curdir, &src, info->curdir_len );
@@ -1300,13 +1603,14 @@ void init_user_process_params(void)
     params->wShowWindow     = info->show;
 
     /* environment needs to be a separate memory block */
-    env_size = data_size - info_size;
     if ((params->Environment = RtlAllocateHeap( GetProcessHeap(), 0, max( env_size, sizeof(WCHAR) ))))
     {
         if (env_size) memcpy( params->Environment, (char *)info + info_size, env_size );
         else params->Environment[0] = 0;
     }
 
+    set_library_wargv( argv, NULL );
+
 done:
     RtlFreeHeap( GetProcessHeap(), 0, info );
     if (RtlSetCurrentDirectory_U( &params->CurrentDirectory.DosPath ))
@@ -1316,5 +1620,6 @@ done:
         RtlInitUnicodeString( &curdir, windows_dir );
         RtlSetCurrentDirectory_U( &curdir );
     }
+    if (!params->CurrentDirectory.Handle) chdir("/"); /* avoid locking removable devices */
     set_wow64_environment( &params->Environment );
 }
diff --git a/dlls/ntdll/error.c b/dlls/ntdll/error.c
index fb630fa986..8dfe68f44e 100644
--- a/dlls/ntdll/error.c
+++ b/dlls/ntdll/error.c
@@ -20,6 +20,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
 #include <stdarg.h>
 
 #include "ntstatus.h"
@@ -108,6 +110,17 @@ DWORD WINAPI RtlGetLastWin32Error(void)
     return NtCurrentTeb()->LastErrorValue;
 }
 
+/**********************************************************************
+ *      NtRaiseHardError (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRaiseHardError( NTSTATUS ErrorStatus, ULONG NumberOfParameters,
+                                  PUNICODE_STRING UnicodeStringParameterMask, PVOID *Parameters,
+                                  HARDERROR_RESPONSE_OPTION ResponseOption, PHARDERROR_RESPONSE Response )
+{
+    FIXME(": stub. Errorstatus was %08x\n", ErrorStatus);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
 /***********************************************************************
  *      RtlSetLastWin32Error (NTDLL.@)
  *      RtlRestoreLastWin32Error (NTDLL.@)
diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index f8aca6dfb7..fd1d7c6d64 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <errno.h>
 #include <signal.h>
@@ -101,6 +104,77 @@ static ULONG remove_vectored_handler( struct list *handler_list, VECTORED_HANDLE
 }
 
 
+/**********************************************************************
+ *           wait_suspend
+ *
+ * Wait until the thread is no longer suspended.
+ */
+void wait_suspend( CONTEXT *context )
+{
+    int saved_errno = errno;
+
+    /* wait with 0 timeout, will only return once the thread is no longer suspended */
+    server_select( NULL, 0, SELECT_INTERRUPTIBLE, 0, context, NULL, NULL );
+
+    errno = saved_errno;
+}
+
+
+/**********************************************************************
+ *           send_debug_event
+ *
+ * Send an EXCEPTION_DEBUG_EVENT event to the debugger.
+ */
+NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, int first_chance, CONTEXT *context )
+{
+    NTSTATUS ret;
+    DWORD i;
+    obj_handle_t handle = 0;
+    client_ptr_t params[EXCEPTION_MAXIMUM_PARAMETERS];
+    CONTEXT exception_context = *context;
+    select_op_t select_op;
+    sigset_t old_set;
+
+    if (!NtCurrentTeb()->Peb->BeingDebugged) return 0;  /* no debugger present */
+
+    pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
+
+    for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
+        params[i] = rec->ExceptionInformation[i];
+
+    SERVER_START_REQ( queue_exception_event )
+    {
+        req->first   = first_chance;
+        req->code    = rec->ExceptionCode;
+        req->flags   = rec->ExceptionFlags;
+        req->record  = wine_server_client_ptr( rec->ExceptionRecord );
+        req->address = wine_server_client_ptr( rec->ExceptionAddress );
+        req->len     = i * sizeof(params[0]);
+        wine_server_add_data( req, params, req->len );
+        if (!(ret = wine_server_call( req ))) handle = reply->handle;
+    }
+    SERVER_END_REQ;
+
+    if (handle)
+    {
+        select_op.wait.op = SELECT_WAIT;
+        select_op.wait.handles[0] = handle;
+        server_select( &select_op, offsetof( select_op_t, wait.handles[1] ), SELECT_INTERRUPTIBLE, TIMEOUT_INFINITE, &exception_context, NULL, NULL );
+
+        SERVER_START_REQ( get_exception_status )
+        {
+            req->handle = handle;
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        if (ret >= 0) *context = exception_context;
+    }
+
+    pthread_sigmask( SIG_SETMASK, &old_set, NULL );
+    return ret;
+}
+
+
 /**********************************************************************
  *           call_vectored_handlers
  *
@@ -176,18 +250,6 @@ void WINAPI RtlRaiseStatus( NTSTATUS status )
 }
 
 
-/*******************************************************************
- *		KiRaiseUserExceptionDispatcher  (NTDLL.@)
- */
-NTSTATUS WINAPI KiRaiseUserExceptionDispatcher(void)
-{
-    DWORD code = NtCurrentTeb()->ExceptionCode;
-    EXCEPTION_RECORD rec = { code };
-    RtlRaiseException( &rec );
-    return code;
-}
-
-
 /*******************************************************************
  *         RtlAddVectoredContinueHandler   (NTDLL.@)
  */
@@ -581,17 +643,6 @@ PRUNTIME_FUNCTION WINAPI RtlLookupFunctionEntry( ULONG_PTR pc, ULONG_PTR *base,
 
 #endif  /* __x86_64__ || __arm__ || __aarch64__ */
 
-
-/*************************************************************
- *            _assert
- */
-void __cdecl _assert( const char *str, const char *file, unsigned int line )
-{
-    ERR( "%s:%u: Assertion failed %s\n", file, line, debugstr_a(str) );
-    RtlRaiseStatus( EXCEPTION_WINE_ASSERTION );
-}
-
-
 /*************************************************************
  *            __wine_spec_unimplemented_stub
  *
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
new file mode 100644
index 0000000000..bb5edc602e
--- /dev/null
+++ b/dlls/ntdll/file.c
@@ -0,0 +1,3906 @@
+/*
+ * Copyright 1999, 2000 Juergen Schmied
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <assert.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_LINUX_MAJOR_H
+# include <linux/major.h>
+#endif
+#ifdef HAVE_SYS_STATVFS_H
+# include <sys/statvfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+#ifdef HAVE_SYS_FILIO_H
+# include <sys/filio.h>
+#endif
+#ifdef HAVE_POLL_H
+#include <poll.h>
+#endif
+#ifdef HAVE_SYS_POLL_H
+#include <sys/poll.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef MAJOR_IN_MKDEV
+# include <sys/mkdev.h>
+#elif defined(MAJOR_IN_SYSMACROS)
+# include <sys/sysmacros.h>
+#endif
+#ifdef HAVE_UTIME_H
+# include <utime.h>
+#endif
+#ifdef HAVE_SYS_VFS_H
+/* Work around a conflict with Solaris' system list defined in sys/list.h. */
+#define list SYSLIST
+#define list_next SYSLIST_NEXT
+#define list_prev SYSLIST_PREV
+#define list_head SYSLIST_HEAD
+#define list_tail SYSLIST_TAIL
+#define list_move_tail SYSLIST_MOVE_TAIL
+#define list_remove SYSLIST_REMOVE
+# include <sys/vfs.h>
+#undef list
+#undef list_next
+#undef list_prev
+#undef list_head
+#undef list_tail
+#undef list_move_tail
+#undef list_remove
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+# include <sys/mount.h>
+#endif
+#ifdef HAVE_SYS_STATFS_H
+# include <sys/statfs.h>
+#endif
+#ifdef HAVE_TERMIOS_H
+#include <termios.h>
+#endif
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+# include <valgrind/memcheck.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#define NONAMELESSUNION
+#include "wine/debug.h"
+#include "wine/server.h"
+#include "ntdll_misc.h"
+
+#include "winternl.h"
+#include "winioctl.h"
+#include "ddk/ntddk.h"
+#include "ddk/ntddser.h"
+#define WINE_MOUNTMGR_EXTENSIONS
+#include "ddk/mountmgr.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
+
+mode_t FILE_umask = 0;
+
+#define SECSPERDAY         86400
+#define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)SECSPERDAY)
+
+#define FILE_WRITE_TO_END_OF_FILE      ((LONGLONG)-1)
+#define FILE_USE_FILE_POINTER_POSITION ((LONGLONG)-2)
+
+/* fetch the attributes of a file */
+static inline ULONG get_file_attributes( const struct stat *st )
+{
+    ULONG attr;
+
+    if (S_ISDIR(st->st_mode))
+        attr = FILE_ATTRIBUTE_DIRECTORY;
+    else
+        attr = FILE_ATTRIBUTE_ARCHIVE;
+    if (!(st->st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
+        attr |= FILE_ATTRIBUTE_READONLY;
+    return attr;
+}
+
+static BOOL fd_is_mount_point( int fd, const struct stat *st )
+{
+    struct stat parent;
+    return S_ISDIR( st->st_mode ) && !fstatat( fd, "..", &parent, 0 )
+            && (parent.st_dev != st->st_dev || parent.st_ino == st->st_ino);
+}
+
+/* get the stat info and file attributes for a file (by file descriptor) */
+int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULONG *attr )
+{
+    int ret;
+
+    *attr = 0;
+    ret = fstat( fd, st );
+    if (ret == -1) return ret;
+    *attr |= get_file_attributes( st );
+    /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
+    if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, st ))
+        *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+    return ret;
+}
+
+/* get the stat info and file attributes for a file (by name) */
+int get_file_info( const char *path, struct stat *st, ULONG *attr )
+{
+    char *parent_path;
+    int ret;
+
+    *attr = 0;
+    ret = lstat( path, st );
+    if (ret == -1) return ret;
+    if (S_ISLNK( st->st_mode ))
+    {
+        ret = stat( path, st );
+        if (ret == -1) return ret;
+        /* is a symbolic link and a directory, consider these "reparse points" */
+        if (S_ISDIR( st->st_mode )) *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+    }
+    else if (S_ISDIR( st->st_mode ) && (parent_path = RtlAllocateHeap( GetProcessHeap(), 0, strlen(path) + 4 )))
+    {
+        struct stat parent_st;
+
+        /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
+        strcpy( parent_path, path );
+        strcat( parent_path, "/.." );
+        if (!stat( parent_path, &parent_st )
+                && (st->st_dev != parent_st.st_dev || st->st_ino == parent_st.st_ino))
+            *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+
+        RtlFreeHeap( GetProcessHeap(), 0, parent_path );
+    }
+    *attr |= get_file_attributes( st );
+    return ret;
+}
+
+/**************************************************************************
+ *                 FILE_CreateFile                    (internal)
+ * Open a file.
+ *
+ * Parameter set fully identical with NtCreateFile
+ */
+static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATTRIBUTES attr,
+                                 PIO_STATUS_BLOCK io, PLARGE_INTEGER alloc_size,
+                                 ULONG attributes, ULONG sharing, ULONG disposition,
+                                 ULONG options, PVOID ea_buffer, ULONG ea_length )
+{
+    ANSI_STRING unix_name;
+    BOOL created = FALSE;
+
+    TRACE("handle=%p access=%08x name=%s objattr=%08x root=%p sec=%p io=%p alloc_size=%p "
+          "attr=%08x sharing=%08x disp=%d options=%08x ea=%p.0x%08x\n",
+          handle, access, debugstr_us(attr->ObjectName), attr->Attributes,
+          attr->RootDirectory, attr->SecurityDescriptor, io, alloc_size,
+          attributes, sharing, disposition, options, ea_buffer, ea_length );
+
+    if (!attr || !attr->ObjectName) return STATUS_INVALID_PARAMETER;
+
+    if (alloc_size) FIXME( "alloc_size not supported\n" );
+
+    if (options & FILE_OPEN_BY_FILE_ID)
+        io->u.Status = file_id_to_unix_file_name( attr, &unix_name );
+    else
+        io->u.Status = nt_to_unix_file_name_attr( attr, &unix_name, disposition );
+
+    if (io->u.Status == STATUS_BAD_DEVICE_TYPE)
+    {
+        SERVER_START_REQ( open_file_object )
+        {
+            req->access     = access;
+            req->attributes = attr->Attributes;
+            req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+            req->sharing    = sharing;
+            req->options    = options;
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+            io->u.Status = wine_server_call( req );
+            *handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+        if (io->u.Status == STATUS_SUCCESS) io->Information = FILE_OPENED;
+        return io->u.Status;
+    }
+
+    if (io->u.Status == STATUS_NO_SUCH_FILE &&
+        disposition != FILE_OPEN && disposition != FILE_OVERWRITE)
+    {
+        created = TRUE;
+        io->u.Status = STATUS_SUCCESS;
+    }
+
+    if (io->u.Status == STATUS_SUCCESS)
+    {
+        static UNICODE_STRING empty_string;
+        OBJECT_ATTRIBUTES unix_attr = *attr;
+        data_size_t len;
+        struct object_attributes *objattr;
+
+        unix_attr.ObjectName = &empty_string;  /* we send the unix name instead */
+        if ((io->u.Status = alloc_object_attributes( &unix_attr, &objattr, &len )))
+        {
+            RtlFreeAnsiString( &unix_name );
+            return io->u.Status;
+        }
+
+        SERVER_START_REQ( create_file )
+        {
+            req->access     = access;
+            req->sharing    = sharing;
+            req->create     = disposition;
+            req->options    = options;
+            req->attrs      = attributes;
+            wine_server_add_data( req, objattr, len );
+            wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
+            io->u.Status = wine_server_call( req );
+            *handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+        RtlFreeHeap( GetProcessHeap(), 0, objattr );
+        RtlFreeAnsiString( &unix_name );
+    }
+    else WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
+
+    if (io->u.Status == STATUS_SUCCESS)
+    {
+        if (created) io->Information = FILE_CREATED;
+        else switch(disposition)
+        {
+        case FILE_SUPERSEDE:
+            io->Information = FILE_SUPERSEDED;
+            break;
+        case FILE_CREATE:
+            io->Information = FILE_CREATED;
+            break;
+        case FILE_OPEN:
+        case FILE_OPEN_IF:
+            io->Information = FILE_OPENED;
+            break;
+        case FILE_OVERWRITE:
+        case FILE_OVERWRITE_IF:
+            io->Information = FILE_OVERWRITTEN;
+            break;
+        }
+    }
+    else if (io->u.Status == STATUS_TOO_MANY_OPENED_FILES)
+    {
+        static int once;
+        if (!once++) ERR_(winediag)( "Too many open files, ulimit -n probably needs to be increased\n" );
+    }
+
+    return io->u.Status;
+}
+
+/**************************************************************************
+ *                 NtOpenFile				[NTDLL.@]
+ *                 ZwOpenFile				[NTDLL.@]
+ *
+ * Open a file.
+ *
+ * PARAMS
+ *  handle    [O] Variable that receives the file handle on return
+ *  access    [I] Access desired by the caller to the file
+ *  attr      [I] Structure describing the file to be opened
+ *  io        [O] Receives details about the result of the operation
+ *  sharing   [I] Type of shared access the caller requires
+ *  options   [I] Options for the file open
+ *
+ * RETURNS
+ *  Success: 0. FileHandle and IoStatusBlock are updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtOpenFile( PHANDLE handle, ACCESS_MASK access,
+                            POBJECT_ATTRIBUTES attr, PIO_STATUS_BLOCK io,
+                            ULONG sharing, ULONG options )
+{
+    return FILE_CreateFile( handle, access, attr, io, NULL, 0,
+                            sharing, FILE_OPEN, options, NULL, 0 );
+}
+
+/**************************************************************************
+ *		NtCreateFile				[NTDLL.@]
+ *		ZwCreateFile				[NTDLL.@]
+ *
+ * Either create a new file or directory, or open an existing file, device,
+ * directory or volume.
+ *
+ * PARAMS
+ *	handle       [O] Points to a variable which receives the file handle on return
+ *	access       [I] Desired access to the file
+ *	attr         [I] Structure describing the file
+ *	io           [O] Receives information about the operation on return
+ *	alloc_size   [I] Initial size of the file in bytes
+ *	attributes   [I] Attributes to create the file with
+ *	sharing      [I] Type of shared access the caller would like to the file
+ *	disposition  [I] Specifies what to do, depending on whether the file already exists
+ *	options      [I] Options for creating a new file
+ *	ea_buffer    [I] Pointer to an extended attributes buffer
+ *	ea_length    [I] Length of ea_buffer
+ *
+ * RETURNS
+ *  Success: 0. handle and io are updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtCreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATTRIBUTES attr,
+                              PIO_STATUS_BLOCK io, PLARGE_INTEGER alloc_size,
+                              ULONG attributes, ULONG sharing, ULONG disposition,
+                              ULONG options, PVOID ea_buffer, ULONG ea_length )
+{
+    return FILE_CreateFile( handle, access, attr, io, alloc_size, attributes,
+                            sharing, disposition, options, ea_buffer, ea_length );
+}
+
+/***********************************************************************
+ *                  Asynchronous file I/O                              *
+ */
+
+typedef NTSTATUS async_callback_t( void *user, IO_STATUS_BLOCK *io, NTSTATUS status );
+
+struct async_fileio
+{
+    async_callback_t    *callback; /* must be the first field */
+    struct async_fileio *next;
+    HANDLE               handle;
+};
+
+struct async_fileio_read
+{
+    struct async_fileio io;
+    char*               buffer;
+    unsigned int        already;
+    unsigned int        count;
+    BOOL                avail_mode;
+};
+
+struct async_fileio_write
+{
+    struct async_fileio io;
+    const char         *buffer;
+    unsigned int        already;
+    unsigned int        count;
+};
+
+struct async_irp
+{
+    struct async_fileio io;
+    void               *buffer;   /* buffer for output */
+    ULONG               size;     /* size of buffer */
+};
+
+static struct async_fileio *fileio_freelist;
+
+static void release_fileio( struct async_fileio *io )
+{
+    for (;;)
+    {
+        struct async_fileio *next = fileio_freelist;
+        io->next = next;
+        if (InterlockedCompareExchangePointer( (void **)&fileio_freelist, io, next ) == next) return;
+    }
+}
+
+static struct async_fileio *alloc_fileio( DWORD size, async_callback_t callback, HANDLE handle )
+{
+    /* first free remaining previous fileinfos */
+
+    struct async_fileio *io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
+
+    while (io)
+    {
+        struct async_fileio *next = io->next;
+        RtlFreeHeap( GetProcessHeap(), 0, io );
+        io = next;
+    }
+
+    if ((io = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    {
+        io->callback = callback;
+        io->handle   = handle;
+    }
+    return io;
+}
+
+static async_data_t server_async( HANDLE handle, struct async_fileio *user, HANDLE event,
+                                  PIO_APC_ROUTINE apc, void *apc_context, IO_STATUS_BLOCK *io )
+{
+    async_data_t async;
+    async.handle      = wine_server_obj_handle( handle );
+    async.user        = wine_server_client_ptr( user );
+    async.iosb        = wine_server_client_ptr( io );
+    async.event       = wine_server_obj_handle( event );
+    async.apc         = wine_server_client_ptr( apc );
+    async.apc_context = wine_server_client_ptr( apc_context );
+    return async;
+}
+
+static NTSTATUS wait_async( HANDLE handle, BOOL alertable, IO_STATUS_BLOCK *io )
+{
+    if (NtWaitForSingleObject( handle, alertable, NULL )) return STATUS_PENDING;
+    return io->u.Status;
+}
+
+/* callback for irp async I/O completion */
+static NTSTATUS irp_completion( void *user, IO_STATUS_BLOCK *io, NTSTATUS status )
+{
+    struct async_irp *async = user;
+    ULONG information = 0;
+
+    if (status == STATUS_ALERTED)
+    {
+        SERVER_START_REQ( get_async_result )
+        {
+            req->user_arg = wine_server_client_ptr( async );
+            wine_server_set_reply( req, async->buffer, async->size );
+            status = virtual_locked_server_call( req );
+            information = reply->size;
+        }
+        SERVER_END_REQ;
+    }
+    if (status != STATUS_PENDING)
+    {
+        io->u.Status = status;
+        io->Information = information;
+        release_fileio( &async->io );
+    }
+    return status;
+}
+
+/***********************************************************************
+ *           FILE_GetNtStatus(void)
+ *
+ * Retrieve the Nt Status code from errno.
+ * Try to be consistent with FILE_SetDosError().
+ */
+NTSTATUS FILE_GetNtStatus(void)
+{
+    int err = errno;
+
+    TRACE( "errno = %d\n", errno );
+    switch (err)
+    {
+    case EAGAIN:    return STATUS_SHARING_VIOLATION;
+    case EBADF:     return STATUS_INVALID_HANDLE;
+    case EBUSY:     return STATUS_DEVICE_BUSY;
+    case ENOSPC:    return STATUS_DISK_FULL;
+    case EPERM:
+    case EROFS:
+    case EACCES:    return STATUS_ACCESS_DENIED;
+    case ENOTDIR:   return STATUS_OBJECT_PATH_NOT_FOUND;
+    case ENOENT:    return STATUS_OBJECT_NAME_NOT_FOUND;
+    case EISDIR:    return STATUS_FILE_IS_A_DIRECTORY;
+    case EMFILE:
+    case ENFILE:    return STATUS_TOO_MANY_OPENED_FILES;
+    case EINVAL:    return STATUS_INVALID_PARAMETER;
+    case ENOTEMPTY: return STATUS_DIRECTORY_NOT_EMPTY;
+    case EPIPE:     return STATUS_PIPE_DISCONNECTED;
+    case EIO:       return STATUS_DEVICE_NOT_READY;
+#ifdef ENOMEDIUM
+    case ENOMEDIUM: return STATUS_NO_MEDIA_IN_DEVICE;
+#endif
+    case ENXIO:     return STATUS_NO_SUCH_DEVICE;
+    case ENOTTY:
+    case EOPNOTSUPP:return STATUS_NOT_SUPPORTED;
+    case ECONNRESET:return STATUS_PIPE_DISCONNECTED;
+    case EFAULT:    return STATUS_ACCESS_VIOLATION;
+    case ESPIPE:    return STATUS_ILLEGAL_FUNCTION;
+    case ELOOP:     return STATUS_REPARSE_POINT_NOT_RESOLVED;
+#ifdef ETIME /* Missing on FreeBSD */
+    case ETIME:     return STATUS_IO_TIMEOUT;
+#endif
+    case ENOEXEC:   /* ?? */
+    case EEXIST:    /* ?? */
+    default:
+        FIXME( "Converting errno %d to STATUS_UNSUCCESSFUL\n", err );
+        return STATUS_UNSUCCESSFUL;
+    }
+}
+
+/***********************************************************************
+ *             FILE_AsyncReadService      (INTERNAL)
+ */
+static NTSTATUS FILE_AsyncReadService( void *user, IO_STATUS_BLOCK *iosb, NTSTATUS status )
+{
+    struct async_fileio_read *fileio = user;
+    int fd, needs_close, result;
+
+    switch (status)
+    {
+    case STATUS_ALERTED: /* got some new data */
+        /* check to see if the data is ready (non-blocking) */
+        if ((status = server_get_unix_fd( fileio->io.handle, FILE_READ_DATA, &fd,
+                                          &needs_close, NULL, NULL )))
+            break;
+
+        result = virtual_locked_read(fd, &fileio->buffer[fileio->already], fileio->count-fileio->already);
+        if (needs_close) close( fd );
+
+        if (result < 0)
+        {
+            if (errno == EAGAIN || errno == EINTR)
+                status = STATUS_PENDING;
+            else /* check to see if the transfer is complete */
+                status = FILE_GetNtStatus();
+        }
+        else if (result == 0)
+        {
+            status = fileio->already ? STATUS_SUCCESS : STATUS_PIPE_BROKEN;
+        }
+        else
+        {
+            fileio->already += result;
+            if (fileio->already >= fileio->count || fileio->avail_mode)
+                status = STATUS_SUCCESS;
+            else
+                status = STATUS_PENDING;
+        }
+        break;
+
+    case STATUS_TIMEOUT:
+    case STATUS_IO_TIMEOUT:
+        if (fileio->already) status = STATUS_SUCCESS;
+        break;
+    }
+    if (status != STATUS_PENDING)
+    {
+        iosb->u.Status = status;
+        iosb->Information = fileio->already;
+        release_fileio( &fileio->io );
+    }
+    return status;
+}
+
+/* do a read call through the server */
+static NTSTATUS server_read_file( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
+                                  IO_STATUS_BLOCK *io, void *buffer, ULONG size,
+                                  LARGE_INTEGER *offset, ULONG *key )
+{
+    struct async_irp *async;
+    NTSTATUS status;
+    HANDLE wait_handle;
+    ULONG options;
+
+    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+        return STATUS_NO_MEMORY;
+
+    async->buffer  = buffer;
+    async->size    = size;
+
+    SERVER_START_REQ( read )
+    {
+        req->async = server_async( handle, &async->io, event, apc, apc_context, io );
+        req->pos   = offset ? offset->QuadPart : 0;
+        wine_server_set_reply( req, buffer, size );
+        status = virtual_locked_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
+        if (wait_handle && status != STATUS_PENDING)
+        {
+            io->u.Status    = status;
+            io->Information = wine_server_reply_size( reply );
+        }
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, async );
+
+    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT), io );
+    return status;
+}
+
+/* do a write call through the server */
+static NTSTATUS server_write_file( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
+                                   IO_STATUS_BLOCK *io, const void *buffer, ULONG size,
+                                   LARGE_INTEGER *offset, ULONG *key )
+{
+    struct async_irp *async;
+    NTSTATUS status;
+    HANDLE wait_handle;
+    ULONG options;
+
+    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+        return STATUS_NO_MEMORY;
+
+    async->buffer  = NULL;
+    async->size    = 0;
+
+    SERVER_START_REQ( write )
+    {
+        req->async = server_async( handle, &async->io, event, apc, apc_context, io );
+        req->pos   = offset ? offset->QuadPart : 0;
+        wine_server_add_data( req, buffer, size );
+        status = wine_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
+        if (wait_handle && status != STATUS_PENDING)
+        {
+            io->u.Status    = status;
+            io->Information = reply->size;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, async );
+
+    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT), io );
+    return status;
+}
+
+struct io_timeouts
+{
+    int interval;   /* max interval between two bytes */
+    int total;      /* total timeout for the whole operation */
+    int end_time;   /* absolute time of end of operation */
+};
+
+/* retrieve the I/O timeouts to use for a given handle */
+static NTSTATUS get_io_timeouts( HANDLE handle, enum server_fd_type type, ULONG count, BOOL is_read,
+                                 struct io_timeouts *timeouts )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+
+    timeouts->interval = timeouts->total = -1;
+
+    switch(type)
+    {
+    case FD_TYPE_SERIAL:
+        {
+            /* GetCommTimeouts */
+            SERIAL_TIMEOUTS st;
+            IO_STATUS_BLOCK io;
+
+            status = NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io,
+                                            IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) );
+            if (status) break;
+
+            if (is_read)
+            {
+                if (st.ReadIntervalTimeout)
+                    timeouts->interval = st.ReadIntervalTimeout;
+
+                if (st.ReadTotalTimeoutMultiplier || st.ReadTotalTimeoutConstant)
+                {
+                    timeouts->total = st.ReadTotalTimeoutConstant;
+                    if (st.ReadTotalTimeoutMultiplier != MAXDWORD)
+                        timeouts->total += count * st.ReadTotalTimeoutMultiplier;
+                }
+                else if (st.ReadIntervalTimeout == MAXDWORD)
+                    timeouts->interval = timeouts->total = 0;
+            }
+            else  /* write */
+            {
+                if (st.WriteTotalTimeoutMultiplier || st.WriteTotalTimeoutConstant)
+                {
+                    timeouts->total = st.WriteTotalTimeoutConstant;
+                    if (st.WriteTotalTimeoutMultiplier != MAXDWORD)
+                        timeouts->total += count * st.WriteTotalTimeoutMultiplier;
+                }
+            }
+        }
+        break;
+    case FD_TYPE_MAILSLOT:
+        if (is_read)
+        {
+            timeouts->interval = 0;  /* return as soon as we got something */
+            SERVER_START_REQ( set_mailslot_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags = 0;
+                if (!(status = wine_server_call( req )) &&
+                    reply->read_timeout != TIMEOUT_INFINITE)
+                    timeouts->total = reply->read_timeout / -10000;
+            }
+            SERVER_END_REQ;
+        }
+        break;
+    case FD_TYPE_SOCKET:
+    case FD_TYPE_CHAR:
+        if (is_read) timeouts->interval = 0;  /* return as soon as we got something */
+        break;
+    default:
+        break;
+    }
+    if (timeouts->total != -1) timeouts->end_time = NtGetTickCount() + timeouts->total;
+    return STATUS_SUCCESS;
+}
+
+
+/* retrieve the timeout for the next wait, in milliseconds */
+static inline int get_next_io_timeout( const struct io_timeouts *timeouts, ULONG already )
+{
+    int ret = -1;
+
+    if (timeouts->total != -1)
+    {
+        ret = timeouts->end_time - NtGetTickCount();
+        if (ret < 0) ret = 0;
+    }
+    if (already && timeouts->interval != -1)
+    {
+        if (ret == -1 || ret > timeouts->interval) ret = timeouts->interval;
+    }
+    return ret;
+}
+
+
+/* retrieve the avail_mode flag for async reads */
+static NTSTATUS get_io_avail_mode( HANDLE handle, enum server_fd_type type, BOOL *avail_mode )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+
+    switch(type)
+    {
+    case FD_TYPE_SERIAL:
+        {
+            /* GetCommTimeouts */
+            SERIAL_TIMEOUTS st;
+            IO_STATUS_BLOCK io;
+
+            status = NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io,
+                                            IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) );
+            if (status) break;
+            *avail_mode = (!st.ReadTotalTimeoutMultiplier &&
+                           !st.ReadTotalTimeoutConstant &&
+                           st.ReadIntervalTimeout == MAXDWORD);
+        }
+        break;
+    case FD_TYPE_MAILSLOT:
+    case FD_TYPE_SOCKET:
+    case FD_TYPE_CHAR:
+        *avail_mode = TRUE;
+        break;
+    default:
+        *avail_mode = FALSE;
+        break;
+    }
+    return status;
+}
+
+/* register an async I/O for a file read; helper for NtReadFile */
+static NTSTATUS register_async_file_read( HANDLE handle, HANDLE event,
+                                          PIO_APC_ROUTINE apc, void *apc_user,
+                                          IO_STATUS_BLOCK *iosb, void *buffer,
+                                          ULONG already, ULONG length, BOOL avail_mode )
+{
+    struct async_fileio_read *fileio;
+    NTSTATUS status;
+
+    if (!(fileio = (struct async_fileio_read *)alloc_fileio( sizeof(*fileio), FILE_AsyncReadService, handle )))
+        return STATUS_NO_MEMORY;
+
+    fileio->already = already;
+    fileio->count = length;
+    fileio->buffer = buffer;
+    fileio->avail_mode = avail_mode;
+
+    SERVER_START_REQ( register_async )
+    {
+        req->type   = ASYNC_TYPE_READ;
+        req->count  = length;
+        req->async  = server_async( handle, &fileio->io, event, apc, apc_user, iosb );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, fileio );
+    return status;
+}
+
+
+/******************************************************************************
+ *  NtReadFile					[NTDLL.@]
+ *  ZwReadFile					[NTDLL.@]
+ *
+ * Read from an open file handle.
+ *
+ * PARAMS
+ *  FileHandle    [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  Event         [I] Event to signal upon completion (or NULL)
+ *  ApcRoutine    [I] Callback to call upon completion (or NULL)
+ *  ApcContext    [I] Context for ApcRoutine (or NULL)
+ *  IoStatusBlock [O] Receives information about the operation on return
+ *  Buffer        [O] Destination for the data read
+ *  Length        [I] Size of Buffer
+ *  ByteOffset    [O] Destination for the new file pointer position (or NULL)
+ *  Key           [O] Function unknown (may be NULL)
+ *
+ * RETURNS
+ *  Success: 0. IoStatusBlock is updated, and the Information member contains
+ *           The number of bytes read.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
+                           PIO_APC_ROUTINE apc, void* apc_user,
+                           PIO_STATUS_BLOCK io_status, void* buffer, ULONG length,
+                           PLARGE_INTEGER offset, PULONG key)
+{
+    int result, unix_handle, needs_close;
+    unsigned int options;
+    struct io_timeouts timeouts;
+    NTSTATUS status, ret_status;
+    ULONG total = 0;
+    enum server_fd_type type;
+    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
+    BOOL send_completion = FALSE, async_read, timeout_init_done = FALSE;
+
+    TRACE("(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p)\n",
+          hFile,hEvent,apc,apc_user,io_status,buffer,length,offset,key);
+
+    if (!io_status) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( hFile, FILE_READ_DATA, &unix_handle,
+                                 &needs_close, &type, &options );
+    if (status && status != STATUS_BAD_DEVICE_TYPE) return status;
+
+    if (!virtual_check_buffer_for_write( buffer, length )) return STATUS_ACCESS_VIOLATION;
+
+    if (status == STATUS_BAD_DEVICE_TYPE)
+        return server_read_file( hFile, hEvent, apc, apc_user, io_status, buffer, length, offset, key );
+
+    async_read = !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
+
+    if (type == FD_TYPE_FILE)
+    {
+        if (async_read && (!offset || offset->QuadPart < 0))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+        {
+            /* async I/O doesn't make sense on regular files */
+            while ((result = virtual_locked_pread( unix_handle, buffer, length, offset->QuadPart )) == -1)
+            {
+                if (errno != EINTR)
+                {
+                    status = FILE_GetNtStatus();
+                    goto done;
+                }
+            }
+            if (!async_read)
+                /* update file pointer position */
+                lseek( unix_handle, offset->QuadPart + result, SEEK_SET );
+
+            total = result;
+            status = (total || !length) ? STATUS_SUCCESS : STATUS_END_OF_FILE;
+            goto done;
+        }
+    }
+    else if (type == FD_TYPE_SERIAL || type == FD_TYPE_DEVICE)
+    {
+        if (async_read && (!offset || offset->QuadPart < 0))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+    }
+
+    if (type == FD_TYPE_SERIAL && async_read && length)
+    {
+        /* an asynchronous serial port read with a read interval timeout needs to
+           skip the synchronous read to make sure that the server starts the read
+           interval timer after the first read */
+        if ((status = get_io_timeouts( hFile, type, length, TRUE, &timeouts ))) goto err;
+        if (timeouts.interval)
+        {
+            status = register_async_file_read( hFile, hEvent, apc, apc_user, io_status,
+                                               buffer, total, length, FALSE );
+            goto err;
+        }
+    }
+
+    for (;;)
+    {
+        if ((result = virtual_locked_read( unix_handle, (char *)buffer + total, length - total )) >= 0)
+        {
+            total += result;
+            if (!result || total == length)
+            {
+                if (total)
+                {
+                    status = STATUS_SUCCESS;
+                    goto done;
+                }
+                switch (type)
+                {
+                case FD_TYPE_FILE:
+                case FD_TYPE_CHAR:
+                case FD_TYPE_DEVICE:
+                    status = length ? STATUS_END_OF_FILE : STATUS_SUCCESS;
+                    goto done;
+                case FD_TYPE_SERIAL:
+                    if (!length)
+                    {
+                        status = STATUS_SUCCESS;
+                        goto done;
+                    }
+                    break;
+                default:
+                    status = STATUS_PIPE_BROKEN;
+                    goto err;
+                }
+            }
+            else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
+        }
+        else if (errno != EAGAIN)
+        {
+            if (errno == EINTR) continue;
+            if (!total) status = FILE_GetNtStatus();
+            goto err;
+        }
+
+        if (async_read)
+        {
+            BOOL avail_mode;
+
+            if ((status = get_io_avail_mode( hFile, type, &avail_mode )))
+                goto err;
+            if (total && avail_mode)
+            {
+                status = STATUS_SUCCESS;
+                goto done;
+            }
+            status = register_async_file_read( hFile, hEvent, apc, apc_user, io_status,
+                                               buffer, total, length, avail_mode );
+            goto err;
+        }
+        else  /* synchronous read, wait for the fd to become ready */
+        {
+            struct pollfd pfd;
+            int ret, timeout;
+
+            if (!timeout_init_done)
+            {
+                timeout_init_done = TRUE;
+                if ((status = get_io_timeouts( hFile, type, length, TRUE, &timeouts )))
+                    goto err;
+                if (hEvent) NtResetEvent( hEvent, NULL );
+            }
+            timeout = get_next_io_timeout( &timeouts, total );
+
+            pfd.fd = unix_handle;
+            pfd.events = POLLIN;
+
+            if (!timeout || !(ret = poll( &pfd, 1, timeout )))
+            {
+                if (total)  /* return with what we got so far */
+                    status = STATUS_SUCCESS;
+                else
+                    status = (type == FD_TYPE_MAILSLOT) ? STATUS_IO_TIMEOUT : STATUS_TIMEOUT;
+                goto done;
+            }
+            if (ret == -1 && errno != EINTR)
+            {
+                status = FILE_GetNtStatus();
+                goto done;
+            }
+            /* will now restart the read */
+        }
+    }
+
+done:
+    send_completion = cvalue != 0;
+
+err:
+    if (needs_close) close( unix_handle );
+    if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && (!async_read || type == FD_TYPE_FILE)))
+    {
+        io_status->u.Status = status;
+        io_status->Information = total;
+        TRACE("= SUCCESS (%u)\n", total);
+        if (hEvent) NtSetEvent( hEvent, NULL );
+        if (apc && (!status || async_read)) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
+                                              (ULONG_PTR)apc_user, (ULONG_PTR)io_status, 0 );
+    }
+    else
+    {
+        TRACE("= 0x%08x\n", status);
+        if (status != STATUS_PENDING && hEvent) NtResetEvent( hEvent, NULL );
+    }
+
+    ret_status = async_read && type == FD_TYPE_FILE && (status == STATUS_SUCCESS || status == STATUS_END_OF_FILE)
+            ? STATUS_PENDING : status;
+
+    if (send_completion) NTDLL_AddCompletion( hFile, cvalue, status, total, ret_status == STATUS_PENDING );
+    return ret_status;
+}
+
+
+/******************************************************************************
+ *  NtReadFileScatter   [NTDLL.@]
+ *  ZwReadFileScatter   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtReadFileScatter( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                                   PIO_STATUS_BLOCK io_status, FILE_SEGMENT_ELEMENT *segments,
+                                   ULONG length, PLARGE_INTEGER offset, PULONG key )
+{
+    int result, unix_handle, needs_close;
+    unsigned int options;
+    NTSTATUS status;
+    ULONG pos = 0, total = 0;
+    enum server_fd_type type;
+    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
+    BOOL send_completion = FALSE;
+
+    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p),partial stub!\n",
+           file, event, apc, apc_user, io_status, segments, length, offset, key);
+
+    if (!io_status) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( file, FILE_READ_DATA, &unix_handle,
+                                 &needs_close, &type, &options );
+    if (status) return status;
+
+    if ((type != FD_TYPE_FILE) ||
+        (options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ||
+        !(options & FILE_NO_INTERMEDIATE_BUFFERING))
+    {
+        status = STATUS_INVALID_PARAMETER;
+        goto error;
+    }
+
+    while (length)
+    {
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+            result = pread( unix_handle, (char *)segments->Buffer + pos,
+                            min( length - pos, page_size - pos ), offset->QuadPart + total );
+        else
+            result = read( unix_handle, (char *)segments->Buffer + pos, min( length - pos, page_size - pos ) );
+
+        if (result == -1)
+        {
+            if (errno == EINTR) continue;
+            status = FILE_GetNtStatus();
+            break;
+        }
+        if (!result) break;
+        total += result;
+        length -= result;
+        if ((pos += result) == page_size)
+        {
+            pos = 0;
+            segments++;
+        }
+    }
+
+    if (total == 0) status = STATUS_END_OF_FILE;
+
+    send_completion = cvalue != 0;
+
+    if (needs_close) close( unix_handle );
+
+    io_status->u.Status = status;
+    io_status->Information = total;
+    TRACE("= 0x%08x (%u)\n", status, total);
+    if (event) NtSetEvent( event, NULL );
+    if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
+                               (ULONG_PTR)apc_user, (ULONG_PTR)io_status, 0 );
+    if (send_completion) NTDLL_AddCompletion( file, cvalue, status, total, TRUE );
+
+    return STATUS_PENDING;
+
+error:
+    if (needs_close) close( unix_handle );
+
+    TRACE("= 0x%08x\n", status);
+    if (event) NtResetEvent( event, NULL );
+
+    return status;
+}
+
+
+/***********************************************************************
+ *             FILE_AsyncWriteService      (INTERNAL)
+ */
+static NTSTATUS FILE_AsyncWriteService( void *user, IO_STATUS_BLOCK *iosb, NTSTATUS status )
+{
+    struct async_fileio_write *fileio = user;
+    int result, fd, needs_close;
+    enum server_fd_type type;
+
+    switch (status)
+    {
+    case STATUS_ALERTED:
+        /* write some data (non-blocking) */
+        if ((status = server_get_unix_fd( fileio->io.handle, FILE_WRITE_DATA, &fd,
+                                          &needs_close, &type, NULL )))
+            break;
+
+        if (!fileio->count && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_SOCKET))
+            result = send( fd, fileio->buffer, 0, 0 );
+        else
+            result = write( fd, &fileio->buffer[fileio->already], fileio->count - fileio->already );
+
+        if (needs_close) close( fd );
+
+        if (result < 0)
+        {
+            if (errno == EAGAIN || errno == EINTR) status = STATUS_PENDING;
+            else status = FILE_GetNtStatus();
+        }
+        else
+        {
+            fileio->already += result;
+            status = (fileio->already < fileio->count) ? STATUS_PENDING : STATUS_SUCCESS;
+        }
+        break;
+
+    case STATUS_TIMEOUT:
+    case STATUS_IO_TIMEOUT:
+        if (fileio->already) status = STATUS_SUCCESS;
+        break;
+    }
+    if (status != STATUS_PENDING)
+    {
+        iosb->u.Status = status;
+        iosb->Information = fileio->already;
+        release_fileio( &fileio->io );
+    }
+    return status;
+}
+
+static NTSTATUS set_pending_write( HANDLE device )
+{
+    NTSTATUS status;
+
+    SERVER_START_REQ( set_serial_info )
+    {
+        req->handle = wine_server_obj_handle( device );
+        req->flags  = SERIALINFO_PENDING_WRITE;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************************
+ *  NtWriteFile					[NTDLL.@]
+ *  ZwWriteFile					[NTDLL.@]
+ *
+ * Write to an open file handle.
+ *
+ * PARAMS
+ *  FileHandle    [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  Event         [I] Event to signal upon completion (or NULL)
+ *  ApcRoutine    [I] Callback to call upon completion (or NULL)
+ *  ApcContext    [I] Context for ApcRoutine (or NULL)
+ *  IoStatusBlock [O] Receives information about the operation on return
+ *  Buffer        [I] Source for the data to write
+ *  Length        [I] Size of Buffer
+ *  ByteOffset    [O] Destination for the new file pointer position (or NULL)
+ *  Key           [O] Function unknown (may be NULL)
+ *
+ * RETURNS
+ *  Success: 0. IoStatusBlock is updated, and the Information member contains
+ *           The number of bytes written.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtWriteFile(HANDLE hFile, HANDLE hEvent,
+                            PIO_APC_ROUTINE apc, void* apc_user,
+                            PIO_STATUS_BLOCK io_status, 
+                            const void* buffer, ULONG length,
+                            PLARGE_INTEGER offset, PULONG key)
+{
+    int result, unix_handle, needs_close;
+    unsigned int options;
+    struct io_timeouts timeouts;
+    NTSTATUS status, ret_status;
+    ULONG total = 0;
+    enum server_fd_type type;
+    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
+    BOOL send_completion = FALSE, async_write, append_write = FALSE, timeout_init_done = FALSE;
+    LARGE_INTEGER offset_eof;
+
+    TRACE("(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p)\n",
+          hFile,hEvent,apc,apc_user,io_status,buffer,length,offset,key);
+
+    if (!io_status) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( hFile, FILE_WRITE_DATA, &unix_handle,
+                                 &needs_close, &type, &options );
+    if (status == STATUS_ACCESS_DENIED)
+    {
+        status = server_get_unix_fd( hFile, FILE_APPEND_DATA, &unix_handle,
+                                     &needs_close, &type, &options );
+        append_write = TRUE;
+    }
+    if (status && status != STATUS_BAD_DEVICE_TYPE) return status;
+
+    async_write = !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
+
+    if (!virtual_check_buffer_for_read( buffer, length ))
+    {
+        status = STATUS_INVALID_USER_BUFFER;
+        goto done;
+    }
+
+    if (status == STATUS_BAD_DEVICE_TYPE)
+        return server_write_file( hFile, hEvent, apc, apc_user, io_status, buffer, length, offset, key );
+
+    if (type == FD_TYPE_FILE)
+    {
+        if (async_write &&
+            (!offset || (offset->QuadPart < 0 && offset->QuadPart != FILE_WRITE_TO_END_OF_FILE)))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+
+        if (append_write)
+        {
+            offset_eof.QuadPart = FILE_WRITE_TO_END_OF_FILE;
+            offset = &offset_eof;
+        }
+
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+        {
+            off_t off = offset->QuadPart;
+
+            if (offset->QuadPart == FILE_WRITE_TO_END_OF_FILE)
+            {
+                struct stat st;
+
+                if (fstat( unix_handle, &st ) == -1)
+                {
+                    status = FILE_GetNtStatus();
+                    goto done;
+                }
+                off = st.st_size;
+            }
+            else if (offset->QuadPart < 0)
+            {
+                status = STATUS_INVALID_PARAMETER;
+                goto done;
+            }
+
+            /* async I/O doesn't make sense on regular files */
+            while ((result = pwrite( unix_handle, buffer, length, off )) == -1)
+            {
+                if (errno != EINTR)
+                {
+                    if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
+                    else status = FILE_GetNtStatus();
+                    goto done;
+                }
+            }
+
+            if (!async_write)
+                /* update file pointer position */
+                lseek( unix_handle, off + result, SEEK_SET );
+
+            total = result;
+            status = STATUS_SUCCESS;
+            goto done;
+        }
+    }
+    else if (type == FD_TYPE_SERIAL || type == FD_TYPE_DEVICE)
+    {
+        if (async_write &&
+            (!offset || (offset->QuadPart < 0 && offset->QuadPart != FILE_WRITE_TO_END_OF_FILE)))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+    }
+
+    for (;;)
+    {
+        /* zero-length writes on sockets may not work with plain write(2) */
+        if (!length && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_SOCKET))
+            result = send( unix_handle, buffer, 0, 0 );
+        else
+            result = write( unix_handle, (const char *)buffer + total, length - total );
+
+        if (result >= 0)
+        {
+            total += result;
+            if (total == length)
+            {
+                status = STATUS_SUCCESS;
+                goto done;
+            }
+            if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
+        }
+        else if (errno != EAGAIN)
+        {
+            if (errno == EINTR) continue;
+            if (!total)
+            {
+                if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
+                else status = FILE_GetNtStatus();
+            }
+            goto err;
+        }
+
+        if (async_write)
+        {
+            struct async_fileio_write *fileio;
+
+            fileio = (struct async_fileio_write *)alloc_fileio( sizeof(*fileio), FILE_AsyncWriteService, hFile );
+            if (!fileio)
+            {
+                status = STATUS_NO_MEMORY;
+                goto err;
+            }
+            fileio->already = total;
+            fileio->count = length;
+            fileio->buffer = buffer;
+
+            SERVER_START_REQ( register_async )
+            {
+                req->type   = ASYNC_TYPE_WRITE;
+                req->count  = length;
+                req->async  = server_async( hFile, &fileio->io, hEvent, apc, apc_user, io_status );
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+
+            if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, fileio );
+            goto err;
+        }
+        else  /* synchronous write, wait for the fd to become ready */
+        {
+            struct pollfd pfd;
+            int ret, timeout;
+
+            if (!timeout_init_done)
+            {
+                timeout_init_done = TRUE;
+                if ((status = get_io_timeouts( hFile, type, length, FALSE, &timeouts )))
+                    goto err;
+                if (hEvent) NtResetEvent( hEvent, NULL );
+            }
+            timeout = get_next_io_timeout( &timeouts, total );
+
+            pfd.fd = unix_handle;
+            pfd.events = POLLOUT;
+
+            if (!timeout || !(ret = poll( &pfd, 1, timeout )))
+            {
+                /* return with what we got so far */
+                status = total ? STATUS_SUCCESS : STATUS_TIMEOUT;
+                goto done;
+            }
+            if (ret == -1 && errno != EINTR)
+            {
+                status = FILE_GetNtStatus();
+                goto done;
+            }
+            /* will now restart the write */
+        }
+    }
+
+done:
+    send_completion = cvalue != 0;
+
+err:
+    if (needs_close) close( unix_handle );
+
+    if (type == FD_TYPE_SERIAL && (status == STATUS_SUCCESS || status == STATUS_PENDING))
+        set_pending_write( hFile );
+
+    if (status == STATUS_SUCCESS)
+    {
+        io_status->u.Status = status;
+        io_status->Information = total;
+        TRACE("= SUCCESS (%u)\n", total);
+        if (hEvent) NtSetEvent( hEvent, NULL );
+        if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
+                                   (ULONG_PTR)apc_user, (ULONG_PTR)io_status, 0 );
+    }
+    else
+    {
+        TRACE("= 0x%08x\n", status);
+        if (status != STATUS_PENDING && hEvent) NtResetEvent( hEvent, NULL );
+    }
+
+    ret_status = async_write && type == FD_TYPE_FILE && status == STATUS_SUCCESS ? STATUS_PENDING : status;
+    if (send_completion) NTDLL_AddCompletion( hFile, cvalue, status, total, ret_status == STATUS_PENDING );
+
+    return ret_status;
+}
+
+
+/******************************************************************************
+ *  NtWriteFileGather   [NTDLL.@]
+ *  ZwWriteFileGather   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtWriteFileGather( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                                   PIO_STATUS_BLOCK io_status, FILE_SEGMENT_ELEMENT *segments,
+                                   ULONG length, PLARGE_INTEGER offset, PULONG key )
+{
+    int result, unix_handle, needs_close;
+    unsigned int options;
+    NTSTATUS status;
+    ULONG pos = 0, total = 0;
+    enum server_fd_type type;
+    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
+    BOOL send_completion = FALSE;
+
+    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p),partial stub!\n",
+           file, event, apc, apc_user, io_status, segments, length, offset, key);
+
+    if (length % page_size) return STATUS_INVALID_PARAMETER;
+    if (!io_status) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( file, FILE_WRITE_DATA, &unix_handle,
+                                 &needs_close, &type, &options );
+    if (status) return status;
+
+    if ((type != FD_TYPE_FILE) ||
+        (options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ||
+        !(options & FILE_NO_INTERMEDIATE_BUFFERING))
+    {
+        status = STATUS_INVALID_PARAMETER;
+        goto error;
+    }
+
+    while (length)
+    {
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+            result = pwrite( unix_handle, (char *)segments->Buffer + pos,
+                             page_size - pos, offset->QuadPart + total );
+        else
+            result = write( unix_handle, (char *)segments->Buffer + pos, page_size - pos );
+
+        if (result == -1)
+        {
+            if (errno == EINTR) continue;
+            if (errno == EFAULT)
+            {
+                status = STATUS_INVALID_USER_BUFFER;
+                goto error;
+            }
+            status = FILE_GetNtStatus();
+            break;
+        }
+        if (!result)
+        {
+            status = STATUS_DISK_FULL;
+            break;
+        }
+        total += result;
+        length -= result;
+        if ((pos += result) == page_size)
+        {
+            pos = 0;
+            segments++;
+        }
+    }
+
+    send_completion = cvalue != 0;
+
+ error:
+    if (needs_close) close( unix_handle );
+    if (status == STATUS_SUCCESS)
+    {
+        io_status->u.Status = status;
+        io_status->Information = total;
+        TRACE("= SUCCESS (%u)\n", total);
+        if (event) NtSetEvent( event, NULL );
+        if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
+                                   (ULONG_PTR)apc_user, (ULONG_PTR)io_status, 0 );
+    }
+    else
+    {
+        TRACE("= 0x%08x\n", status);
+        if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
+    }
+
+    if (send_completion) NTDLL_AddCompletion( file, cvalue, status, total, FALSE );
+
+    return status;
+}
+
+
+/* do an ioctl call through the server */
+static NTSTATUS server_ioctl_file( HANDLE handle, HANDLE event,
+                                   PIO_APC_ROUTINE apc, PVOID apc_context,
+                                   IO_STATUS_BLOCK *io, ULONG code,
+                                   const void *in_buffer, ULONG in_size,
+                                   PVOID out_buffer, ULONG out_size )
+{
+    struct async_irp *async;
+    NTSTATUS status;
+    HANDLE wait_handle;
+    ULONG options;
+
+    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+        return STATUS_NO_MEMORY;
+    async->buffer  = out_buffer;
+    async->size    = out_size;
+
+    SERVER_START_REQ( ioctl )
+    {
+        req->code  = code;
+        req->async = server_async( handle, &async->io, event, apc, apc_context, io );
+        wine_server_add_data( req, in_buffer, in_size );
+        if ((code & 3) != METHOD_BUFFERED)
+            wine_server_add_data( req, out_buffer, out_size );
+        wine_server_set_reply( req, out_buffer, out_size );
+        status = virtual_locked_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
+        if (wait_handle && status != STATUS_PENDING)
+        {
+            io->u.Status    = status;
+            io->Information = wine_server_reply_size( reply );
+        }
+    }
+    SERVER_END_REQ;
+
+    if (status == STATUS_NOT_SUPPORTED)
+        FIXME("Unsupported ioctl %x (device=%x access=%x func=%x method=%x)\n",
+              code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
+
+    if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, async );
+
+    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT), io );
+    return status;
+}
+
+/* Tell Valgrind to ignore any holes in structs we will be passing to the
+ * server */
+static void ignore_server_ioctl_struct_holes (ULONG code, const void *in_buffer,
+                                              ULONG in_size)
+{
+#ifdef VALGRIND_MAKE_MEM_DEFINED
+# define IGNORE_STRUCT_HOLE(buf, size, t, f1, f2) \
+    do { \
+        if (FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1) < FIELD_OFFSET(t, f2)) \
+            if ((size) >= FIELD_OFFSET(t, f2)) \
+                VALGRIND_MAKE_MEM_DEFINED( \
+                    (const char *)(buf) + FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1), \
+                    FIELD_OFFSET(t, f2) - FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1)); \
+    } while (0)
+
+    switch (code)
+    {
+    case FSCTL_PIPE_WAIT:
+        IGNORE_STRUCT_HOLE(in_buffer, in_size, FILE_PIPE_WAIT_FOR_BUFFER, TimeoutSpecified, Name);
+        break;
+    }
+#endif
+}
+
+
+/**************************************************************************
+ *		NtDeviceIoControlFile			[NTDLL.@]
+ *		ZwDeviceIoControlFile			[NTDLL.@]
+ *
+ * Perform an I/O control operation on an open file handle.
+ *
+ * PARAMS
+ *  handle         [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  event          [I] Event to signal upon completion (or NULL)
+ *  apc            [I] Callback to call upon completion (or NULL)
+ *  apc_context    [I] Context for ApcRoutine (or NULL)
+ *  io             [O] Receives information about the operation on return
+ *  code           [I] Control code for the operation to perform
+ *  in_buffer      [I] Source for any input data required (or NULL)
+ *  in_size        [I] Size of InputBuffer
+ *  out_buffer     [O] Source for any output data returned (or NULL)
+ *  out_size       [I] Size of OutputBuffer
+ *
+ * RETURNS
+ *  Success: 0. IoStatusBlock is updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtDeviceIoControlFile(HANDLE handle, HANDLE event,
+                                      PIO_APC_ROUTINE apc, PVOID apc_context,
+                                      PIO_STATUS_BLOCK io, ULONG code,
+                                      PVOID in_buffer, ULONG in_size,
+                                      PVOID out_buffer, ULONG out_size)
+{
+    ULONG device = (code >> 16);
+    NTSTATUS status = STATUS_NOT_SUPPORTED;
+
+    TRACE("(%p,%p,%p,%p,%p,0x%08x,%p,0x%08x,%p,0x%08x)\n",
+          handle, event, apc, apc_context, io, code,
+          in_buffer, in_size, out_buffer, out_size);
+
+    switch(device)
+    {
+    case FILE_DEVICE_DISK:
+    case FILE_DEVICE_CD_ROM:
+    case FILE_DEVICE_DVD:
+    case FILE_DEVICE_CONTROLLER:
+    case FILE_DEVICE_MASS_STORAGE:
+        status = CDROM_DeviceIoControl(handle, event, apc, apc_context, io, code,
+                                       in_buffer, in_size, out_buffer, out_size);
+        break;
+    case FILE_DEVICE_SERIAL_PORT:
+        status = COMM_DeviceIoControl(handle, event, apc, apc_context, io, code,
+                                      in_buffer, in_size, out_buffer, out_size);
+        break;
+    case FILE_DEVICE_TAPE:
+        status = TAPE_DeviceIoControl(handle, event, apc, apc_context, io, code,
+                                      in_buffer, in_size, out_buffer, out_size);
+        break;
+    }
+
+    if (status == STATUS_NOT_SUPPORTED || status == STATUS_BAD_DEVICE_TYPE)
+        return server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                  in_buffer, in_size, out_buffer, out_size );
+
+    if (status != STATUS_PENDING) io->u.Status = status;
+    return status;
+}
+
+
+/**************************************************************************
+ *              NtFsControlFile                 [NTDLL.@]
+ *              ZwFsControlFile                 [NTDLL.@]
+ *
+ * Perform a file system control operation on an open file handle.
+ *
+ * PARAMS
+ *  handle         [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  event          [I] Event to signal upon completion (or NULL)
+ *  apc            [I] Callback to call upon completion (or NULL)
+ *  apc_context    [I] Context for ApcRoutine (or NULL)
+ *  io             [O] Receives information about the operation on return
+ *  code           [I] Control code for the operation to perform
+ *  in_buffer      [I] Source for any input data required (or NULL)
+ *  in_size        [I] Size of InputBuffer
+ *  out_buffer     [O] Source for any output data returned (or NULL)
+ *  out_size       [I] Size of OutputBuffer
+ *
+ * RETURNS
+ *  Success: 0. IoStatusBlock is updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc,
+                                PVOID apc_context, PIO_STATUS_BLOCK io, ULONG code,
+                                PVOID in_buffer, ULONG in_size, PVOID out_buffer, ULONG out_size)
+{
+    NTSTATUS status;
+
+    TRACE("(%p,%p,%p,%p,%p,0x%08x,%p,0x%08x,%p,0x%08x)\n",
+          handle, event, apc, apc_context, io, code,
+          in_buffer, in_size, out_buffer, out_size);
+
+    if (!io) return STATUS_INVALID_PARAMETER;
+
+    ignore_server_ioctl_struct_holes( code, in_buffer, in_size );
+
+    switch(code)
+    {
+    case FSCTL_DISMOUNT_VOLUME:
+        status = server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                    in_buffer, in_size, out_buffer, out_size );
+        if (!status) status = DIR_unmount_device( handle );
+        return status;
+
+    case FSCTL_PIPE_IMPERSONATE:
+        FIXME("FSCTL_PIPE_IMPERSONATE: impersonating self\n");
+        status = RtlImpersonateSelf( SecurityImpersonation );
+        break;
+
+    case FSCTL_IS_VOLUME_MOUNTED:
+    case FSCTL_LOCK_VOLUME:
+    case FSCTL_UNLOCK_VOLUME:
+        FIXME("stub! return success - Unsupported fsctl %x (device=%x access=%x func=%x method=%x)\n",
+              code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
+        status = STATUS_SUCCESS;
+        break;
+
+    case FSCTL_GET_RETRIEVAL_POINTERS:
+    {
+        RETRIEVAL_POINTERS_BUFFER *buffer = (RETRIEVAL_POINTERS_BUFFER *)out_buffer;
+
+        FIXME("stub: FSCTL_GET_RETRIEVAL_POINTERS\n");
+
+        if (out_size >= sizeof(RETRIEVAL_POINTERS_BUFFER))
+        {
+            buffer->ExtentCount                 = 1;
+            buffer->StartingVcn.QuadPart        = 1;
+            buffer->Extents[0].NextVcn.QuadPart = 0;
+            buffer->Extents[0].Lcn.QuadPart     = 0;
+            io->Information = sizeof(RETRIEVAL_POINTERS_BUFFER);
+            status = STATUS_SUCCESS;
+        }
+        else
+        {
+            io->Information = 0;
+            status = STATUS_BUFFER_TOO_SMALL;
+        }
+        break;
+    }
+    case FSCTL_SET_SPARSE:
+        TRACE("FSCTL_SET_SPARSE: Ignoring request\n");
+        io->Information = 0;
+        status = STATUS_SUCCESS;
+        break;
+    default:
+        return server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                  in_buffer, in_size, out_buffer, out_size );
+    }
+
+    if (status != STATUS_PENDING) io->u.Status = status;
+    return status;
+}
+
+
+struct read_changes_fileio
+{
+    struct async_fileio io;
+    void               *buffer;
+    ULONG               buffer_size;
+    ULONG               data_size;
+    char                data[1];
+};
+
+static NTSTATUS read_changes_apc( void *user, IO_STATUS_BLOCK *iosb, NTSTATUS status )
+{
+    struct read_changes_fileio *fileio = user;
+    int size = 0;
+
+    if (status == STATUS_ALERTED)
+    {
+        SERVER_START_REQ( read_change )
+        {
+            req->handle = wine_server_obj_handle( fileio->io.handle );
+            wine_server_set_reply( req, fileio->data, fileio->data_size );
+            status = wine_server_call( req );
+            size = wine_server_reply_size( reply );
+        }
+        SERVER_END_REQ;
+
+        if (status == STATUS_SUCCESS && fileio->buffer)
+        {
+            FILE_NOTIFY_INFORMATION *pfni = fileio->buffer;
+            int i, left = fileio->buffer_size;
+            DWORD *last_entry_offset = NULL;
+            struct filesystem_event *event = (struct filesystem_event*)fileio->data;
+
+            while (size && left >= sizeof(*pfni))
+            {
+                DWORD len = (left - offsetof(FILE_NOTIFY_INFORMATION, FileName)) / sizeof(WCHAR);
+
+                /* convert to an NT style path */
+                for (i = 0; i < event->len; i++)
+                    if (event->name[i] == '/') event->name[i] = '\\';
+
+                pfni->Action = event->action;
+                pfni->FileNameLength = ntdll_umbstowcs( event->name, event->len, pfni->FileName, len );
+                last_entry_offset = &pfni->NextEntryOffset;
+
+                if (pfni->FileNameLength == len) break;
+
+                i = offsetof(FILE_NOTIFY_INFORMATION, FileName[pfni->FileNameLength]);
+                pfni->FileNameLength *= sizeof(WCHAR);
+                pfni->NextEntryOffset = i;
+                pfni = (FILE_NOTIFY_INFORMATION*)((char*)pfni + i);
+                left -= i;
+
+                i = (offsetof(struct filesystem_event, name[event->len])
+                     + sizeof(int)-1) / sizeof(int) * sizeof(int);
+                event = (struct filesystem_event*)((char*)event + i);
+                size -= i;
+            }
+
+            if (size)
+            {
+                status = STATUS_NOTIFY_ENUM_DIR;
+                size = 0;
+            }
+            else
+            {
+                if (last_entry_offset) *last_entry_offset = 0;
+                size = fileio->buffer_size - left;
+            }
+        }
+        else
+        {
+            status = STATUS_NOTIFY_ENUM_DIR;
+            size = 0;
+        }
+    }
+
+    if (status != STATUS_PENDING)
+    {
+        iosb->u.Status = status;
+        iosb->Information = size;
+        release_fileio( &fileio->io );
+    }
+    return status;
+}
+
+#define FILE_NOTIFY_ALL        (  \
+ FILE_NOTIFY_CHANGE_FILE_NAME   | \
+ FILE_NOTIFY_CHANGE_DIR_NAME    | \
+ FILE_NOTIFY_CHANGE_ATTRIBUTES  | \
+ FILE_NOTIFY_CHANGE_SIZE        | \
+ FILE_NOTIFY_CHANGE_LAST_WRITE  | \
+ FILE_NOTIFY_CHANGE_LAST_ACCESS | \
+ FILE_NOTIFY_CHANGE_CREATION    | \
+ FILE_NOTIFY_CHANGE_SECURITY   )
+
+/******************************************************************************
+ *  NtNotifyChangeDirectoryFile [NTDLL.@]
+ */
+NTSTATUS WINAPI NtNotifyChangeDirectoryFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc,
+                                             void *apc_context, PIO_STATUS_BLOCK iosb, void *buffer,
+                                             ULONG buffer_size, ULONG filter, BOOLEAN subtree )
+{
+    struct read_changes_fileio *fileio;
+    NTSTATUS status;
+    ULONG size = max( 4096, buffer_size );
+
+    TRACE( "%p %p %p %p %p %p %u %u %d\n",
+           handle, event, apc, apc_context, iosb, buffer, buffer_size, filter, subtree );
+
+    if (!iosb) return STATUS_ACCESS_VIOLATION;
+    if (filter == 0 || (filter & ~FILE_NOTIFY_ALL)) return STATUS_INVALID_PARAMETER;
+
+    fileio = (struct read_changes_fileio *)alloc_fileio( offsetof(struct read_changes_fileio, data[size]),
+                                                         read_changes_apc, handle );
+    if (!fileio) return STATUS_NO_MEMORY;
+
+    fileio->buffer      = buffer;
+    fileio->buffer_size = buffer_size;
+    fileio->data_size   = size;
+
+    SERVER_START_REQ( read_directory_changes )
+    {
+        req->filter    = filter;
+        req->want_data = (buffer != NULL);
+        req->subtree   = subtree;
+        req->async     = server_async( handle, &fileio->io, event, apc, apc_context, iosb );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, fileio );
+    return status;
+}
+
+/******************************************************************************
+ *  NtSetVolumeInformationFile		[NTDLL.@]
+ *  ZwSetVolumeInformationFile		[NTDLL.@]
+ *
+ * Set volume information for an open file handle.
+ *
+ * PARAMS
+ *  FileHandle         [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  IoStatusBlock      [O] Receives information about the operation on return
+ *  FsInformation      [I] Source for volume information
+ *  Length             [I] Size of FsInformation
+ *  FsInformationClass [I] Type of volume information to set
+ *
+ * RETURNS
+ *  Success: 0. IoStatusBlock is updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtSetVolumeInformationFile(
+	IN HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FsInformation,
+        ULONG Length,
+	FS_INFORMATION_CLASS FsInformationClass)
+{
+	FIXME("(%p,%p,%p,0x%08x,0x%08x) stub\n",
+	FileHandle,IoStatusBlock,FsInformation,Length,FsInformationClass);
+	return 0;
+}
+
+#if defined(__ANDROID__) && !defined(HAVE_FUTIMENS)
+static int futimens( int fd, const struct timespec spec[2] )
+{
+    return syscall( __NR_utimensat, fd, NULL, spec, 0 );
+}
+#define HAVE_FUTIMENS
+#endif  /* __ANDROID__ */
+
+#ifndef UTIME_OMIT
+#define UTIME_OMIT ((1 << 30) - 2)
+#endif
+
+static BOOL set_file_times_precise( int fd, const LARGE_INTEGER *mtime,
+        const LARGE_INTEGER *atime, NTSTATUS *status )
+{
+#ifdef HAVE_FUTIMENS
+    struct timespec tv[2];
+
+    tv[0].tv_sec = tv[1].tv_sec = 0;
+    tv[0].tv_nsec = tv[1].tv_nsec = UTIME_OMIT;
+    if (atime->QuadPart)
+    {
+        tv[0].tv_sec = atime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[0].tv_nsec = (atime->QuadPart % 10000000) * 100;
+    }
+    if (mtime->QuadPart)
+    {
+        tv[1].tv_sec = mtime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[1].tv_nsec = (mtime->QuadPart % 10000000) * 100;
+    }
+#ifdef __APPLE__
+    if (!&futimens) return FALSE;
+#endif
+    if (futimens( fd, tv ) == -1) *status = FILE_GetNtStatus();
+    else *status = STATUS_SUCCESS;
+    return TRUE;
+#else
+    return FALSE;
+#endif
+}
+
+static NTSTATUS set_file_times( int fd, const LARGE_INTEGER *mtime, const LARGE_INTEGER *atime )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMESAT)
+    struct timeval tv[2];
+    struct stat st;
+#endif
+
+    if (set_file_times_precise( fd, mtime, atime, &status ))
+        return status;
+
+#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMESAT)
+    if (!atime->QuadPart || !mtime->QuadPart)
+    {
+
+        tv[0].tv_sec = tv[0].tv_usec = 0;
+        tv[1].tv_sec = tv[1].tv_usec = 0;
+        if (!fstat( fd, &st ))
+        {
+            tv[0].tv_sec = st.st_atime;
+            tv[1].tv_sec = st.st_mtime;
+#ifdef HAVE_STRUCT_STAT_ST_ATIM
+            tv[0].tv_usec = st.st_atim.tv_nsec / 1000;
+#elif defined(HAVE_STRUCT_STAT_ST_ATIMESPEC)
+            tv[0].tv_usec = st.st_atimespec.tv_nsec / 1000;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_MTIM
+            tv[1].tv_usec = st.st_mtim.tv_nsec / 1000;
+#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC)
+            tv[1].tv_usec = st.st_mtimespec.tv_nsec / 1000;
+#endif
+        }
+    }
+    if (atime->QuadPart)
+    {
+        tv[0].tv_sec = atime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[0].tv_usec = (atime->QuadPart % 10000000) / 10;
+    }
+    if (mtime->QuadPart)
+    {
+        tv[1].tv_sec = mtime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[1].tv_usec = (mtime->QuadPart % 10000000) / 10;
+    }
+#ifdef HAVE_FUTIMES
+    if (futimes( fd, tv ) == -1) status = FILE_GetNtStatus();
+#elif defined(HAVE_FUTIMESAT)
+    if (futimesat( fd, NULL, tv ) == -1) status = FILE_GetNtStatus();
+#endif
+
+#else  /* HAVE_FUTIMES || HAVE_FUTIMESAT */
+    FIXME( "setting file times not supported\n" );
+    status = STATUS_NOT_IMPLEMENTED;
+#endif
+    return status;
+}
+
+static inline void get_file_times( const struct stat *st, LARGE_INTEGER *mtime, LARGE_INTEGER *ctime,
+                                   LARGE_INTEGER *atime, LARGE_INTEGER *creation )
+{
+    RtlSecondsSince1970ToTime( st->st_mtime, mtime );
+    RtlSecondsSince1970ToTime( st->st_ctime, ctime );
+    RtlSecondsSince1970ToTime( st->st_atime, atime );
+#ifdef HAVE_STRUCT_STAT_ST_MTIM
+    mtime->QuadPart += st->st_mtim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC)
+    mtime->QuadPart += st->st_mtimespec.tv_nsec / 100;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_CTIM
+    ctime->QuadPart += st->st_ctim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_CTIMESPEC)
+    ctime->QuadPart += st->st_ctimespec.tv_nsec / 100;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_ATIM
+    atime->QuadPart += st->st_atim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_ATIMESPEC)
+    atime->QuadPart += st->st_atimespec.tv_nsec / 100;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME
+    RtlSecondsSince1970ToTime( st->st_birthtime, creation );
+#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIM
+    creation->QuadPart += st->st_birthtim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC)
+    creation->QuadPart += st->st_birthtimespec.tv_nsec / 100;
+#endif
+#elif defined(HAVE_STRUCT_STAT___ST_BIRTHTIME)
+    RtlSecondsSince1970ToTime( st->__st_birthtime, creation );
+#ifdef HAVE_STRUCT_STAT___ST_BIRTHTIM
+    creation->QuadPart += st->__st_birthtim.tv_nsec / 100;
+#endif
+#else
+    *creation = *mtime;
+#endif
+}
+
+/* fill in the file information that depends on the stat and attribute info */
+NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
+                         FILE_INFORMATION_CLASS class )
+{
+    switch (class)
+    {
+    case FileBasicInformation:
+        {
+            FILE_BASIC_INFORMATION *info = ptr;
+
+            get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
+                            &info->LastAccessTime, &info->CreationTime );
+            info->FileAttributes = attr;
+        }
+        break;
+    case FileStandardInformation:
+        {
+            FILE_STANDARD_INFORMATION *info = ptr;
+
+            if ((info->Directory = S_ISDIR(st->st_mode)))
+            {
+                info->AllocationSize.QuadPart = 0;
+                info->EndOfFile.QuadPart      = 0;
+                info->NumberOfLinks           = 1;
+            }
+            else
+            {
+                info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
+                info->EndOfFile.QuadPart      = st->st_size;
+                info->NumberOfLinks           = st->st_nlink;
+            }
+        }
+        break;
+    case FileInternalInformation:
+        {
+            FILE_INTERNAL_INFORMATION *info = ptr;
+            info->IndexNumber.QuadPart = st->st_ino;
+        }
+        break;
+    case FileEndOfFileInformation:
+        {
+            FILE_END_OF_FILE_INFORMATION *info = ptr;
+            info->EndOfFile.QuadPart = S_ISDIR(st->st_mode) ? 0 : st->st_size;
+        }
+        break;
+    case FileAllInformation:
+        {
+            FILE_ALL_INFORMATION *info = ptr;
+            fill_file_info( st, attr, &info->BasicInformation, FileBasicInformation );
+            fill_file_info( st, attr, &info->StandardInformation, FileStandardInformation );
+            fill_file_info( st, attr, &info->InternalInformation, FileInternalInformation );
+        }
+        break;
+    /* all directory structures start with the FileDirectoryInformation layout */
+    case FileBothDirectoryInformation:
+    case FileFullDirectoryInformation:
+    case FileDirectoryInformation:
+        {
+            FILE_DIRECTORY_INFORMATION *info = ptr;
+
+            get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
+                            &info->LastAccessTime, &info->CreationTime );
+            if (S_ISDIR(st->st_mode))
+            {
+                info->AllocationSize.QuadPart = 0;
+                info->EndOfFile.QuadPart      = 0;
+            }
+            else
+            {
+                info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
+                info->EndOfFile.QuadPart      = st->st_size;
+            }
+            info->FileAttributes = attr;
+        }
+        break;
+    case FileIdFullDirectoryInformation:
+        {
+            FILE_ID_FULL_DIRECTORY_INFORMATION *info = ptr;
+            info->FileId.QuadPart = st->st_ino;
+            fill_file_info( st, attr, info, FileDirectoryInformation );
+        }
+        break;
+    case FileIdBothDirectoryInformation:
+        {
+            FILE_ID_BOTH_DIRECTORY_INFORMATION *info = ptr;
+            info->FileId.QuadPart = st->st_ino;
+            fill_file_info( st, attr, info, FileDirectoryInformation );
+        }
+        break;
+    case FileIdGlobalTxDirectoryInformation:
+        {
+            FILE_ID_GLOBAL_TX_DIR_INFORMATION *info = ptr;
+            info->FileId.QuadPart = st->st_ino;
+            fill_file_info( st, attr, info, FileDirectoryInformation );
+        }
+        break;
+
+    default:
+        return STATUS_INVALID_INFO_CLASS;
+    }
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS server_get_unix_name( HANDLE handle, ANSI_STRING *unix_name )
+{
+    data_size_t size = 1024;
+    NTSTATUS ret;
+    char *name;
+
+    for (;;)
+    {
+        name = RtlAllocateHeap( GetProcessHeap(), 0, size + 1 );
+        if (!name) return STATUS_NO_MEMORY;
+        unix_name->MaximumLength = size + 1;
+
+        SERVER_START_REQ( get_handle_unix_name )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            wine_server_set_reply( req, name, size );
+            ret = wine_server_call( req );
+            size = reply->name_len;
+        }
+        SERVER_END_REQ;
+
+        if (!ret)
+        {
+            name[size] = 0;
+            unix_name->Buffer = name;
+            unix_name->Length = size;
+            break;
+        }
+        RtlFreeHeap( GetProcessHeap(), 0, name );
+        if (ret != STATUS_BUFFER_OVERFLOW) break;
+    }
+    return ret;
+}
+
+static NTSTATUS fill_name_info( const ANSI_STRING *unix_name, FILE_NAME_INFORMATION *info, LONG *name_len )
+{
+    UNICODE_STRING nt_name;
+    NTSTATUS status;
+
+    if (!(status = wine_unix_to_nt_file_name( unix_name, &nt_name )))
+    {
+        const WCHAR *ptr = nt_name.Buffer;
+        const WCHAR *end = ptr + (nt_name.Length / sizeof(WCHAR));
+
+        /* Skip the volume mount point. */
+        while (ptr != end && *ptr == '\\') ++ptr;
+        while (ptr != end && *ptr != '\\') ++ptr;
+        while (ptr != end && *ptr == '\\') ++ptr;
+        while (ptr != end && *ptr != '\\') ++ptr;
+
+        info->FileNameLength = (end - ptr) * sizeof(WCHAR);
+        if (*name_len < info->FileNameLength) status = STATUS_BUFFER_OVERFLOW;
+        else *name_len = info->FileNameLength;
+
+        memcpy( info->FileName, ptr, *name_len );
+        RtlFreeUnicodeString( &nt_name );
+    }
+
+    return status;
+}
+
+static NTSTATUS server_get_file_info( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer,
+                                      ULONG length, FILE_INFORMATION_CLASS info_class )
+{
+    SERVER_START_REQ( get_file_info )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->info_class = info_class;
+        wine_server_set_reply( req, buffer, length );
+        io->u.Status = wine_server_call( req );
+        io->Information = wine_server_reply_size( reply );
+    }
+    SERVER_END_REQ;
+    if (io->u.Status == STATUS_NOT_IMPLEMENTED)
+        FIXME( "Unsupported info class %x\n", info_class );
+    return io->u.Status;
+
+}
+
+/* Find a DOS device which can act as the root of "path".
+ * Similar to find_drive_root(), but returns -1 instead of crossing volumes. */
+static int find_dos_device( const char *path )
+{
+    int len = strlen(path);
+    int drive;
+    char *buffer;
+    struct stat st;
+    struct drive_info info[MAX_DOS_DRIVES];
+    dev_t dev_id;
+
+    if (!DIR_get_drives_info( info )) return -1;
+
+    if (stat( path, &st ) < 0) return -1;
+    dev_id = st.st_dev;
+
+    /* strip off trailing slashes */
+    while (len > 1 && path[len - 1] == '/') len--;
+
+    /* make a copy of the path */
+    if (!(buffer = RtlAllocateHeap( GetProcessHeap(), 0, len + 1 ))) return -1;
+    memcpy( buffer, path, len );
+    buffer[len] = 0;
+
+    for (;;)
+    {
+        if (!stat( buffer, &st ) && S_ISDIR( st.st_mode ))
+        {
+            if (st.st_dev != dev_id) break;
+
+            for (drive = 0; drive < MAX_DOS_DRIVES; drive++)
+            {
+                if ((info[drive].dev == st.st_dev) && (info[drive].ino == st.st_ino))
+                {
+                    if (len == 1) len = 0;  /* preserve root slash in returned path */
+                    TRACE( "%s -> drive %c:, root=%s, name=%s\n",
+                           debugstr_a(path), 'A' + drive, debugstr_a(buffer), debugstr_a(path + len));
+                    RtlFreeHeap( GetProcessHeap(), 0, buffer );
+                    return drive;
+                }
+            }
+        }
+        if (len <= 1) break;  /* reached root */
+        while (path[len - 1] != '/') len--;
+        while (path[len - 1] == '/') len--;
+        buffer[len] = 0;
+    }
+    RtlFreeHeap( GetProcessHeap(), 0, buffer );
+    return -1;
+}
+
+static struct mountmgr_unix_drive *get_mountmgr_fs_info( HANDLE handle, int fd )
+{
+    struct mountmgr_unix_drive *drive;
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING string;
+    ANSI_STRING unix_name;
+    IO_STATUS_BLOCK io;
+    HANDLE mountmgr;
+    NTSTATUS status;
+    int letter;
+
+    if (server_get_unix_name( handle, &unix_name ))
+        return NULL;
+
+    letter = find_dos_device( unix_name.Buffer );
+    RtlFreeAnsiString( &unix_name );
+
+    if (!(drive = RtlAllocateHeap( GetProcessHeap(), 0, 1024 )))
+        return NULL;
+
+    if (letter == -1)
+    {
+        struct stat st;
+
+        if (fstat( fd, &st ) == -1)
+        {
+            RtlFreeHeap( GetProcessHeap(), 0, drive );
+            return NULL;
+        }
+
+        drive->unix_dev = st.st_dev;
+        drive->letter = 0;
+    }
+    else
+        drive->letter = 'a' + letter;
+
+    RtlInitUnicodeString( &string, MOUNTMGR_DEVICE_NAME );
+    InitializeObjectAttributes( &attr, &string, 0, NULL, NULL );
+    if (NtOpenFile( &mountmgr, GENERIC_READ | SYNCHRONIZE, &attr, &io,
+                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT ))
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, drive );
+        return NULL;
+    }
+
+    status = NtDeviceIoControlFile( mountmgr, NULL, NULL, NULL, &io, IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE,
+                                    drive, sizeof(*drive), drive, 1024 );
+    if (status == STATUS_BUFFER_OVERFLOW)
+    {
+        if (!(drive = RtlReAllocateHeap( GetProcessHeap(), 0, drive, drive->size )))
+        {
+            RtlFreeHeap( GetProcessHeap(), 0, drive );
+            NtClose( mountmgr );
+            return NULL;
+        }
+        status = NtDeviceIoControlFile( mountmgr, NULL, NULL, NULL, &io, IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE,
+                                        drive, sizeof(*drive), drive, drive->size );
+    }
+    NtClose( mountmgr );
+
+    if (status)
+    {
+        WARN("failed to retrieve filesystem type from mountmgr, status %#x\n", status);
+        RtlFreeHeap( GetProcessHeap(), 0, drive );
+        return NULL;
+    }
+
+    return drive;
+}
+
+/******************************************************************************
+ *  NtQueryInformationFile		[NTDLL.@]
+ *  ZwQueryInformationFile		[NTDLL.@]
+ *
+ * Get information about an open file handle.
+ *
+ * PARAMS
+ *  hFile    [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  io       [O] Receives information about the operation on return
+ *  ptr      [O] Destination for file information
+ *  len      [I] Size of FileInformation
+ *  class    [I] Type of file information to get
+ *
+ * RETURNS
+ *  Success: 0. IoStatusBlock and FileInformation are updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtQueryInformationFile( HANDLE hFile, PIO_STATUS_BLOCK io,
+                                        PVOID ptr, LONG len, FILE_INFORMATION_CLASS class )
+{
+    static const size_t info_sizes[] =
+    {
+        0,
+        sizeof(FILE_DIRECTORY_INFORMATION),            /* FileDirectoryInformation */
+        sizeof(FILE_FULL_DIRECTORY_INFORMATION),       /* FileFullDirectoryInformation */
+        sizeof(FILE_BOTH_DIRECTORY_INFORMATION),       /* FileBothDirectoryInformation */
+        sizeof(FILE_BASIC_INFORMATION),                /* FileBasicInformation */
+        sizeof(FILE_STANDARD_INFORMATION),             /* FileStandardInformation */
+        sizeof(FILE_INTERNAL_INFORMATION),             /* FileInternalInformation */
+        sizeof(FILE_EA_INFORMATION),                   /* FileEaInformation */
+        0,                                             /* FileAccessInformation */
+        sizeof(FILE_NAME_INFORMATION),                 /* FileNameInformation */
+        sizeof(FILE_RENAME_INFORMATION)-sizeof(WCHAR), /* FileRenameInformation */
+        0,                                             /* FileLinkInformation */
+        sizeof(FILE_NAMES_INFORMATION)-sizeof(WCHAR),  /* FileNamesInformation */
+        sizeof(FILE_DISPOSITION_INFORMATION),          /* FileDispositionInformation */
+        sizeof(FILE_POSITION_INFORMATION),             /* FilePositionInformation */
+        sizeof(FILE_FULL_EA_INFORMATION),              /* FileFullEaInformation */
+        0,                                             /* FileModeInformation */
+        sizeof(FILE_ALIGNMENT_INFORMATION),            /* FileAlignmentInformation */
+        sizeof(FILE_ALL_INFORMATION),                  /* FileAllInformation */
+        sizeof(FILE_ALLOCATION_INFORMATION),           /* FileAllocationInformation */
+        sizeof(FILE_END_OF_FILE_INFORMATION),          /* FileEndOfFileInformation */
+        0,                                             /* FileAlternateNameInformation */
+        sizeof(FILE_STREAM_INFORMATION)-sizeof(WCHAR), /* FileStreamInformation */
+        sizeof(FILE_PIPE_INFORMATION),                 /* FilePipeInformation */
+        sizeof(FILE_PIPE_LOCAL_INFORMATION),           /* FilePipeLocalInformation */
+        0,                                             /* FilePipeRemoteInformation */
+        sizeof(FILE_MAILSLOT_QUERY_INFORMATION),       /* FileMailslotQueryInformation */
+        0,                                             /* FileMailslotSetInformation */
+        0,                                             /* FileCompressionInformation */
+        0,                                             /* FileObjectIdInformation */
+        0,                                             /* FileCompletionInformation */
+        0,                                             /* FileMoveClusterInformation */
+        0,                                             /* FileQuotaInformation */
+        0,                                             /* FileReparsePointInformation */
+        sizeof(FILE_NETWORK_OPEN_INFORMATION),         /* FileNetworkOpenInformation */
+        sizeof(FILE_ATTRIBUTE_TAG_INFORMATION),        /* FileAttributeTagInformation */
+        0,                                             /* FileTrackingInformation */
+        0,                                             /* FileIdBothDirectoryInformation */
+        0,                                             /* FileIdFullDirectoryInformation */
+        0,                                             /* FileValidDataLengthInformation */
+        0,                                             /* FileShortNameInformation */
+        0,                                             /* FileIoCompletionNotificationInformation, */
+        0,                                             /* FileIoStatusBlockRangeInformation */
+        0,                                             /* FileIoPriorityHintInformation */
+        0,                                             /* FileSfioReserveInformation */
+        0,                                             /* FileSfioVolumeInformation */
+        0,                                             /* FileHardLinkInformation */
+        0,                                             /* FileProcessIdsUsingFileInformation */
+        0,                                             /* FileNormalizedNameInformation */
+        0,                                             /* FileNetworkPhysicalNameInformation */
+        0,                                             /* FileIdGlobalTxDirectoryInformation */
+        0,                                             /* FileIsRemoteDeviceInformation */
+        0,                                             /* FileAttributeCacheInformation */
+        0,                                             /* FileNumaNodeInformation */
+        0,                                             /* FileStandardLinkInformation */
+        0,                                             /* FileRemoteProtocolInformation */
+        0,                                             /* FileRenameInformationBypassAccessCheck */
+        0,                                             /* FileLinkInformationBypassAccessCheck */
+        0,                                             /* FileVolumeNameInformation */
+        sizeof(FILE_ID_INFORMATION),                   /* FileIdInformation */
+        0,                                             /* FileIdExtdDirectoryInformation */
+        0,                                             /* FileReplaceCompletionInformation */
+        0,                                             /* FileHardLinkFullIdInformation */
+        0,                                             /* FileIdExtdBothDirectoryInformation */
+    };
+
+    struct stat st;
+    int fd, needs_close = FALSE;
+    ULONG attr;
+    unsigned int options;
+
+    TRACE("(%p,%p,%p,0x%08x,0x%08x)\n", hFile, io, ptr, len, class);
+
+    io->Information = 0;
+
+    if (class <= 0 || class >= FileMaximumInformation)
+        return io->u.Status = STATUS_INVALID_INFO_CLASS;
+    if (!info_sizes[class])
+        return server_get_file_info( hFile, io, ptr, len, class );
+    if (len < info_sizes[class])
+        return io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
+
+    if ((io->u.Status = server_get_unix_fd( hFile, 0, &fd, &needs_close, NULL, &options )))
+    {
+        if (io->u.Status != STATUS_BAD_DEVICE_TYPE) return io->u.Status;
+        return server_get_file_info( hFile, io, ptr, len, class );
+    }
+
+    switch (class)
+    {
+    case FileBasicInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1)
+            io->u.Status = FILE_GetNtStatus();
+        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            io->u.Status = STATUS_INVALID_INFO_CLASS;
+        else
+            fill_file_info( &st, attr, ptr, class );
+        break;
+    case FileStandardInformation:
+        {
+            FILE_STANDARD_INFORMATION *info = ptr;
+
+            if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = FILE_GetNtStatus();
+            else
+            {
+                fill_file_info( &st, attr, info, class );
+                info->DeletePending = FALSE; /* FIXME */
+            }
+        }
+        break;
+    case FilePositionInformation:
+        {
+            FILE_POSITION_INFORMATION *info = ptr;
+            off_t res = lseek( fd, 0, SEEK_CUR );
+            if (res == (off_t)-1) io->u.Status = FILE_GetNtStatus();
+            else info->CurrentByteOffset.QuadPart = res;
+        }
+        break;
+    case FileInternalInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = FILE_GetNtStatus();
+        else fill_file_info( &st, attr, ptr, class );
+        break;
+    case FileEaInformation:
+        {
+            FILE_EA_INFORMATION *info = ptr;
+            info->EaSize = 0;
+        }
+        break;
+    case FileEndOfFileInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = FILE_GetNtStatus();
+        else fill_file_info( &st, attr, ptr, class );
+        break;
+    case FileAllInformation:
+        {
+            FILE_ALL_INFORMATION *info = ptr;
+            ANSI_STRING unix_name;
+
+            if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = FILE_GetNtStatus();
+            else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+                io->u.Status = STATUS_INVALID_INFO_CLASS;
+            else if (!(io->u.Status = server_get_unix_name( hFile, &unix_name )))
+            {
+                LONG name_len = len - FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName);
+
+                fill_file_info( &st, attr, info, FileAllInformation );
+                info->StandardInformation.DeletePending = FALSE; /* FIXME */
+                info->EaInformation.EaSize = 0;
+                info->AccessInformation.AccessFlags = 0;  /* FIXME */
+                info->PositionInformation.CurrentByteOffset.QuadPart = lseek( fd, 0, SEEK_CUR );
+                info->ModeInformation.Mode = 0;  /* FIXME */
+                info->AlignmentInformation.AlignmentRequirement = 1;  /* FIXME */
+
+                io->u.Status = fill_name_info( &unix_name, &info->NameInformation, &name_len );
+                RtlFreeAnsiString( &unix_name );
+                io->Information = FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName) + name_len;
+            }
+        }
+        break;
+    case FileMailslotQueryInformation:
+        {
+            FILE_MAILSLOT_QUERY_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_mailslot_info )
+            {
+                req->handle = wine_server_obj_handle( hFile );
+                req->flags = 0;
+                io->u.Status = wine_server_call( req );
+                if( io->u.Status == STATUS_SUCCESS )
+                {
+                    info->MaximumMessageSize = reply->max_msgsize;
+                    info->MailslotQuota = 0;
+                    info->NextMessageSize = 0;
+                    info->MessagesAvailable = 0;
+                    info->ReadTimeout.QuadPart = reply->read_timeout;
+                }
+            }
+            SERVER_END_REQ;
+            if (!io->u.Status)
+            {
+                char *tmpbuf;
+                ULONG size = info->MaximumMessageSize ? info->MaximumMessageSize : 0x10000;
+                if (size > 0x10000) size = 0x10000;
+                if ((tmpbuf = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+                {
+                    if (!server_get_unix_fd( hFile, FILE_READ_DATA, &fd, &needs_close, NULL, NULL ))
+                    {
+                        int res = recv( fd, tmpbuf, size, MSG_PEEK );
+                        info->MessagesAvailable = (res > 0);
+                        info->NextMessageSize = (res >= 0) ? res : MAILSLOT_NO_MESSAGE;
+                        if (needs_close) close( fd );
+                    }
+                    RtlFreeHeap( GetProcessHeap(), 0, tmpbuf );
+                }
+            }
+        }
+        break;
+    case FileNameInformation:
+        {
+            FILE_NAME_INFORMATION *info = ptr;
+            ANSI_STRING unix_name;
+
+            if (!(io->u.Status = server_get_unix_name( hFile, &unix_name )))
+            {
+                LONG name_len = len - FIELD_OFFSET(FILE_NAME_INFORMATION, FileName);
+                io->u.Status = fill_name_info( &unix_name, info, &name_len );
+                RtlFreeAnsiString( &unix_name );
+                io->Information = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) + name_len;
+            }
+        }
+        break;
+    case FileNetworkOpenInformation:
+        {
+            FILE_NETWORK_OPEN_INFORMATION *info = ptr;
+            ANSI_STRING unix_name;
+
+            if (!(io->u.Status = server_get_unix_name( hFile, &unix_name )))
+            {
+                ULONG attributes;
+                struct stat st;
+
+                if (get_file_info( unix_name.Buffer, &st, &attributes ) == -1)
+                    io->u.Status = FILE_GetNtStatus();
+                else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+                    io->u.Status = STATUS_INVALID_INFO_CLASS;
+                else
+                {
+                    FILE_BASIC_INFORMATION basic;
+                    FILE_STANDARD_INFORMATION std;
+
+                    fill_file_info( &st, attributes, &basic, FileBasicInformation );
+                    fill_file_info( &st, attributes, &std, FileStandardInformation );
+
+                    info->CreationTime   = basic.CreationTime;
+                    info->LastAccessTime = basic.LastAccessTime;
+                    info->LastWriteTime  = basic.LastWriteTime;
+                    info->ChangeTime     = basic.ChangeTime;
+                    info->AllocationSize = std.AllocationSize;
+                    info->EndOfFile      = std.EndOfFile;
+                    info->FileAttributes = basic.FileAttributes;
+                }
+                RtlFreeAnsiString( &unix_name );
+            }
+        }
+        break;
+    case FileIdInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = FILE_GetNtStatus();
+        else
+        {
+            struct mountmgr_unix_drive *drive;
+            FILE_ID_INFORMATION *info = ptr;
+
+            info->VolumeSerialNumber = 0;
+            if ((drive = get_mountmgr_fs_info( hFile, fd )))
+            {
+                info->VolumeSerialNumber = drive->serial;
+                RtlFreeHeap( GetProcessHeap(), 0, drive );
+            }
+            memset( &info->FileId, 0, sizeof(info->FileId) );
+            *(ULONGLONG *)&info->FileId = st.st_ino;
+        }
+        break;
+    case FileAttributeTagInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = FILE_GetNtStatus();
+        else
+        {
+            FILE_ATTRIBUTE_TAG_INFORMATION *info = ptr;
+            info->FileAttributes = attr;
+            info->ReparseTag = 0; /* FIXME */
+            if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, &st ))
+                info->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+        }
+        break;
+    default:
+        FIXME("Unsupported class (%d)\n", class);
+        io->u.Status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    if (needs_close) close( fd );
+    if (io->u.Status == STATUS_SUCCESS && !io->Information) io->Information = info_sizes[class];
+    return io->u.Status;
+}
+
+/******************************************************************************
+ *  NtSetInformationFile		[NTDLL.@]
+ *  ZwSetInformationFile		[NTDLL.@]
+ *
+ * Set information about an open file handle.
+ *
+ * PARAMS
+ *  handle  [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  io      [O] Receives information about the operation on return
+ *  ptr     [I] Source for file information
+ *  len     [I] Size of FileInformation
+ *  class   [I] Type of file information to set
+ *
+ * RETURNS
+ *  Success: 0. io is updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
+                                     PVOID ptr, ULONG len, FILE_INFORMATION_CLASS class)
+{
+    int fd, needs_close;
+
+    TRACE("(%p,%p,%p,0x%08x,0x%08x)\n", handle, io, ptr, len, class);
+
+    io->u.Status = STATUS_SUCCESS;
+    switch (class)
+    {
+    case FileBasicInformation:
+        if (len >= sizeof(FILE_BASIC_INFORMATION))
+        {
+            struct stat st;
+            const FILE_BASIC_INFORMATION *info = ptr;
+            LARGE_INTEGER mtime, atime;
+
+            if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+                return io->u.Status;
+
+            mtime.QuadPart = info->LastWriteTime.QuadPart == -1 ? 0 : info->LastWriteTime.QuadPart;
+            atime.QuadPart = info->LastAccessTime.QuadPart == -1 ? 0 : info->LastAccessTime.QuadPart;
+
+            if (atime.QuadPart || mtime.QuadPart)
+                io->u.Status = set_file_times( fd, &mtime, &atime );
+
+            if (io->u.Status == STATUS_SUCCESS && info->FileAttributes)
+            {
+                if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
+                else
+                {
+                    if (info->FileAttributes & FILE_ATTRIBUTE_READONLY)
+                    {
+                        if (S_ISDIR( st.st_mode))
+                            WARN("FILE_ATTRIBUTE_READONLY ignored for directory.\n");
+                        else
+                            st.st_mode &= ~0222; /* clear write permission bits */
+                    }
+                    else
+                    {
+                        /* add write permission only where we already have read permission */
+                        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~FILE_umask);
+                    }
+                    if (fchmod( fd, st.st_mode ) == -1) io->u.Status = FILE_GetNtStatus();
+                }
+            }
+
+            if (needs_close) close( fd );
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FilePositionInformation:
+        if (len >= sizeof(FILE_POSITION_INFORMATION))
+        {
+            const FILE_POSITION_INFORMATION *info = ptr;
+
+            if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+                return io->u.Status;
+
+            if (lseek( fd, info->CurrentByteOffset.QuadPart, SEEK_SET ) == (off_t)-1)
+                io->u.Status = FILE_GetNtStatus();
+
+            if (needs_close) close( fd );
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileEndOfFileInformation:
+        if (len >= sizeof(FILE_END_OF_FILE_INFORMATION))
+        {
+            struct stat st;
+            const FILE_END_OF_FILE_INFORMATION *info = ptr;
+
+            if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+                return io->u.Status;
+
+            /* first try normal truncate */
+            if (ftruncate( fd, (off_t)info->EndOfFile.QuadPart ) != -1) break;
+
+            /* now check for the need to extend the file */
+            if (fstat( fd, &st ) != -1 && (off_t)info->EndOfFile.QuadPart > st.st_size)
+            {
+                static const char zero;
+
+                /* extend the file one byte beyond the requested size and then truncate it */
+                /* this should work around ftruncate implementations that can't extend files */
+                if (pwrite( fd, &zero, 1, (off_t)info->EndOfFile.QuadPart ) != -1 &&
+                    ftruncate( fd, (off_t)info->EndOfFile.QuadPart ) != -1) break;
+            }
+            io->u.Status = FILE_GetNtStatus();
+
+            if (needs_close) close( fd );
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FilePipeInformation:
+        if (len >= sizeof(FILE_PIPE_INFORMATION))
+        {
+            FILE_PIPE_INFORMATION *info = ptr;
+
+            if ((info->CompletionMode | info->ReadMode) & ~1)
+            {
+                io->u.Status = STATUS_INVALID_PARAMETER;
+                break;
+            }
+
+            SERVER_START_REQ( set_named_pipe_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags  = (info->CompletionMode ? NAMED_PIPE_NONBLOCKING_MODE    : 0) |
+                              (info->ReadMode       ? NAMED_PIPE_MESSAGE_STREAM_READ : 0);
+                io->u.Status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileMailslotSetInformation:
+        {
+            FILE_MAILSLOT_SET_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_mailslot_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags = MAILSLOT_SET_READ_TIMEOUT;
+                req->read_timeout = info->ReadTimeout.QuadPart;
+                io->u.Status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        break;
+
+    case FileCompletionInformation:
+        if (len >= sizeof(FILE_COMPLETION_INFORMATION))
+        {
+            FILE_COMPLETION_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_completion_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->chandle  = wine_server_obj_handle( info->CompletionPort );
+                req->ckey     = info->CompletionKey;
+                io->u.Status  = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        } else
+            io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileIoCompletionNotificationInformation:
+        if (len >= sizeof(FILE_IO_COMPLETION_NOTIFICATION_INFORMATION))
+        {
+            FILE_IO_COMPLETION_NOTIFICATION_INFORMATION *info = ptr;
+
+            if (info->Flags & FILE_SKIP_SET_USER_EVENT_ON_FAST_IO)
+                FIXME( "FILE_SKIP_SET_USER_EVENT_ON_FAST_IO not supported\n" );
+
+            SERVER_START_REQ( set_fd_completion_mode )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->flags    = info->Flags;
+                io->u.Status  = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        } else
+            io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
+    case FileIoPriorityHintInformation:
+        if (len >= sizeof(FILE_IO_PRIORITY_HINT_INFO))
+        {
+            FILE_IO_PRIORITY_HINT_INFO *info = ptr;
+            if (info->PriorityHint < MaximumIoPriorityHintType)
+                TRACE( "ignoring FileIoPriorityHintInformation %u\n", info->PriorityHint );
+            else
+                io->u.Status = STATUS_INVALID_PARAMETER;
+        }
+        else io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
+    case FileAllInformation:
+        io->u.Status = STATUS_INVALID_INFO_CLASS;
+        break;
+
+    case FileValidDataLengthInformation:
+        if (len >= sizeof(FILE_VALID_DATA_LENGTH_INFORMATION))
+        {
+            struct stat st;
+            const FILE_VALID_DATA_LENGTH_INFORMATION *info = ptr;
+
+            if ((io->u.Status = server_get_unix_fd( handle, FILE_WRITE_DATA, &fd, &needs_close, NULL, NULL )))
+                return io->u.Status;
+
+            if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
+            else if (info->ValidDataLength.QuadPart <= 0 || (off_t)info->ValidDataLength.QuadPart > st.st_size)
+                io->u.Status = STATUS_INVALID_PARAMETER;
+            else
+            {
+#ifdef HAVE_FALLOCATE
+                if (fallocate( fd, 0, 0, (off_t)info->ValidDataLength.QuadPart ) == -1)
+                {
+                    NTSTATUS status = FILE_GetNtStatus();
+                    if (status == STATUS_NOT_SUPPORTED) WARN( "fallocate not supported on this filesystem\n" );
+                    else io->u.Status = status;
+                }
+#else
+                FIXME( "setting valid data length not supported\n" );
+#endif
+            }
+            if (needs_close) close( fd );
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileDispositionInformation:
+        if (len >= sizeof(FILE_DISPOSITION_INFORMATION))
+        {
+            FILE_DISPOSITION_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_fd_disp_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->unlink   = info->DoDeleteFile;
+                io->u.Status  = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        } else
+            io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileRenameInformation:
+        if (len >= sizeof(FILE_RENAME_INFORMATION))
+        {
+            FILE_RENAME_INFORMATION *info = ptr;
+            UNICODE_STRING name_str;
+            OBJECT_ATTRIBUTES attr;
+            ANSI_STRING unix_name;
+
+            name_str.Buffer = info->FileName;
+            name_str.Length = info->FileNameLength;
+            name_str.MaximumLength = info->FileNameLength + sizeof(WCHAR);
+
+            attr.Length = sizeof(attr);
+            attr.ObjectName = &name_str;
+            attr.RootDirectory = info->RootDirectory;
+            attr.Attributes = OBJ_CASE_INSENSITIVE;
+
+            io->u.Status = nt_to_unix_file_name_attr( &attr, &unix_name, FILE_OPEN_IF );
+            if (io->u.Status != STATUS_SUCCESS && io->u.Status != STATUS_NO_SUCH_FILE)
+                break;
+
+            SERVER_START_REQ( set_fd_name_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->rootdir  = wine_server_obj_handle( attr.RootDirectory );
+                req->link     = FALSE;
+                req->replace  = info->ReplaceIfExists;
+                wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
+                io->u.Status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+
+            RtlFreeAnsiString( &unix_name );
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileLinkInformation:
+        if (len >= sizeof(FILE_LINK_INFORMATION))
+        {
+            FILE_LINK_INFORMATION *info = ptr;
+            UNICODE_STRING name_str;
+            OBJECT_ATTRIBUTES attr;
+            ANSI_STRING unix_name;
+
+            name_str.Buffer = info->FileName;
+            name_str.Length = info->FileNameLength;
+            name_str.MaximumLength = info->FileNameLength + sizeof(WCHAR);
+
+            attr.Length = sizeof(attr);
+            attr.ObjectName = &name_str;
+            attr.RootDirectory = info->RootDirectory;
+            attr.Attributes = OBJ_CASE_INSENSITIVE;
+
+            io->u.Status = nt_to_unix_file_name_attr( &attr, &unix_name, FILE_OPEN_IF );
+            if (io->u.Status != STATUS_SUCCESS && io->u.Status != STATUS_NO_SUCH_FILE)
+                break;
+
+            SERVER_START_REQ( set_fd_name_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->rootdir  = wine_server_obj_handle( attr.RootDirectory );
+                req->link     = TRUE;
+                req->replace  = info->ReplaceIfExists;
+                wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
+                io->u.Status  = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+
+            RtlFreeAnsiString( &unix_name );
+        }
+        else io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    default:
+        FIXME("Unsupported class (%d)\n", class);
+        io->u.Status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    io->Information = 0;
+    return io->u.Status;
+}
+
+
+/******************************************************************************
+ *              NtQueryFullAttributesFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
+                                           FILE_NETWORK_OPEN_INFORMATION *info )
+{
+    ANSI_STRING unix_name;
+    NTSTATUS status;
+
+    if (!(status = nt_to_unix_file_name_attr( attr, &unix_name, FILE_OPEN )))
+    {
+        ULONG attributes;
+        struct stat st;
+
+        if (get_file_info( unix_name.Buffer, &st, &attributes ) == -1)
+            status = FILE_GetNtStatus();
+        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            status = STATUS_INVALID_INFO_CLASS;
+        else
+        {
+            FILE_BASIC_INFORMATION basic;
+            FILE_STANDARD_INFORMATION std;
+
+            fill_file_info( &st, attributes, &basic, FileBasicInformation );
+            fill_file_info( &st, attributes, &std, FileStandardInformation );
+
+            info->CreationTime   = basic.CreationTime;
+            info->LastAccessTime = basic.LastAccessTime;
+            info->LastWriteTime  = basic.LastWriteTime;
+            info->ChangeTime     = basic.ChangeTime;
+            info->AllocationSize = std.AllocationSize;
+            info->EndOfFile      = std.EndOfFile;
+            info->FileAttributes = basic.FileAttributes;
+            if (DIR_is_hidden_file( attr->ObjectName ))
+                info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
+        }
+        RtlFreeAnsiString( &unix_name );
+    }
+    else WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtQueryAttributesFile   (NTDLL.@)
+ *              ZwQueryAttributesFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC_INFORMATION *info )
+{
+    ANSI_STRING unix_name;
+    NTSTATUS status;
+
+    if (!(status = nt_to_unix_file_name_attr( attr, &unix_name, FILE_OPEN )))
+    {
+        ULONG attributes;
+        struct stat st;
+
+        if (get_file_info( unix_name.Buffer, &st, &attributes ) == -1)
+            status = FILE_GetNtStatus();
+        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            status = STATUS_INVALID_INFO_CLASS;
+        else
+        {
+            status = fill_file_info( &st, attributes, info, FileBasicInformation );
+            if (DIR_is_hidden_file( attr->ObjectName ))
+                info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
+        }
+        RtlFreeAnsiString( &unix_name );
+    }
+    else WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
+    return status;
+}
+
+
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+/* helper for FILE_GetDeviceInfo to hide some platform differences in fstatfs */
+static inline void get_device_info_fstatfs( FILE_FS_DEVICE_INFORMATION *info, const char *fstypename,
+                                            unsigned int flags )
+{
+    if (!strcmp("cd9660", fstypename) || !strcmp("udf", fstypename))
+    {
+        info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
+        /* Don't assume read-only, let the mount options set it below */
+        info->Characteristics |= FILE_REMOVABLE_MEDIA;
+    }
+    else if (!strcmp("nfs", fstypename) || !strcmp("nwfs", fstypename) ||
+             !strcmp("smbfs", fstypename) || !strcmp("afpfs", fstypename))
+    {
+        info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
+        info->Characteristics |= FILE_REMOTE_DEVICE;
+    }
+    else if (!strcmp("procfs", fstypename))
+        info->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
+    else
+        info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+
+    if (flags & MNT_RDONLY)
+        info->Characteristics |= FILE_READ_ONLY_DEVICE;
+
+    if (!(flags & MNT_LOCAL))
+    {
+        info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
+        info->Characteristics |= FILE_REMOTE_DEVICE;
+    }
+}
+#endif
+
+static inline BOOL is_device_placeholder( int fd )
+{
+    static const char wine_placeholder[] = "Wine device placeholder";
+    char buffer[sizeof(wine_placeholder)-1];
+
+    if (pread( fd, buffer, sizeof(wine_placeholder) - 1, 0 ) != sizeof(wine_placeholder) - 1)
+        return FALSE;
+    return !memcmp( buffer, wine_placeholder, sizeof(wine_placeholder) - 1 );
+}
+
+/******************************************************************************
+ *              get_device_info
+ *
+ * Implementation of the FileFsDeviceInformation query for NtQueryVolumeInformationFile.
+ */
+static NTSTATUS get_device_info( int fd, FILE_FS_DEVICE_INFORMATION *info )
+{
+    struct stat st;
+
+    info->Characteristics = 0;
+    if (fstat( fd, &st ) < 0) return FILE_GetNtStatus();
+    if (S_ISCHR( st.st_mode ))
+    {
+        info->DeviceType = FILE_DEVICE_UNKNOWN;
+#ifdef linux
+        switch(major(st.st_rdev))
+        {
+        case MEM_MAJOR:
+            info->DeviceType = FILE_DEVICE_NULL;
+            break;
+        case TTY_MAJOR:
+            info->DeviceType = FILE_DEVICE_SERIAL_PORT;
+            break;
+        case LP_MAJOR:
+            info->DeviceType = FILE_DEVICE_PARALLEL_PORT;
+            break;
+        case SCSI_TAPE_MAJOR:
+            info->DeviceType = FILE_DEVICE_TAPE;
+            break;
+        }
+#endif
+    }
+    else if (S_ISBLK( st.st_mode ))
+    {
+        info->DeviceType = FILE_DEVICE_DISK;
+    }
+    else if (S_ISFIFO( st.st_mode ) || S_ISSOCK( st.st_mode ))
+    {
+        info->DeviceType = FILE_DEVICE_NAMED_PIPE;
+    }
+    else if (is_device_placeholder( fd ))
+    {
+        info->DeviceType = FILE_DEVICE_DISK;
+    }
+    else  /* regular file or directory */
+    {
+#if defined(linux) && defined(HAVE_FSTATFS)
+        struct statfs stfs;
+
+        /* check for floppy disk */
+        if (major(st.st_dev) == FLOPPY_MAJOR)
+            info->Characteristics |= FILE_REMOVABLE_MEDIA;
+
+        if (fstatfs( fd, &stfs ) < 0) stfs.f_type = 0;
+        switch (stfs.f_type)
+        {
+        case 0x9660:      /* iso9660 */
+        case 0x9fa1:      /* supermount */
+        case 0x15013346:  /* udf */
+            info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
+            info->Characteristics |= FILE_REMOVABLE_MEDIA|FILE_READ_ONLY_DEVICE;
+            break;
+        case 0x6969:  /* nfs */
+        case 0xff534d42: /* cifs */
+        case 0xfe534d42: /* smb2 */
+        case 0x517b:  /* smbfs */
+        case 0x564c:  /* ncpfs */
+            info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
+            info->Characteristics |= FILE_REMOTE_DEVICE;
+            break;
+        case 0x01021994:  /* tmpfs */
+        case 0x28cd3d45:  /* cramfs */
+        case 0x1373:      /* devfs */
+        case 0x9fa0:      /* procfs */
+            info->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
+            break;
+        default:
+            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+            break;
+        }
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+        struct statfs stfs;
+
+        if (fstatfs( fd, &stfs ) < 0)
+            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+        else
+            get_device_info_fstatfs( info, stfs.f_fstypename, stfs.f_flags );
+#elif defined(__NetBSD__)
+        struct statvfs stfs;
+
+        if (fstatvfs( fd, &stfs) < 0)
+            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+        else
+            get_device_info_fstatfs( info, stfs.f_fstypename, stfs.f_flag );
+#elif defined(sun)
+        /* Use dkio to work out device types */
+        {
+# include <sys/dkio.h>
+# include <sys/vtoc.h>
+            struct dk_cinfo dkinf;
+            int retval = ioctl(fd, DKIOCINFO, &dkinf);
+            if(retval==-1){
+                WARN("Unable to get disk device type information - assuming a disk like device\n");
+                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+            }
+            switch (dkinf.dki_ctype)
+            {
+            case DKC_CDROM:
+                info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
+                info->Characteristics |= FILE_REMOVABLE_MEDIA|FILE_READ_ONLY_DEVICE;
+                break;
+            case DKC_NCRFLOPPY:
+            case DKC_SMSFLOPPY:
+            case DKC_INTEL82072:
+            case DKC_INTEL82077:
+                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+                info->Characteristics |= FILE_REMOVABLE_MEDIA;
+                break;
+            case DKC_MD:
+                info->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
+                break;
+            default:
+                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+            }
+        }
+#else
+        static int warned;
+        if (!warned++) FIXME( "device info not properly supported on this platform\n" );
+        info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+#endif
+        info->Characteristics |= FILE_DEVICE_IS_MOUNTED;
+    }
+    return STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ *  NtQueryVolumeInformationFile		[NTDLL.@]
+ *  ZwQueryVolumeInformationFile		[NTDLL.@]
+ *
+ * Get volume information for an open file handle.
+ *
+ * PARAMS
+ *  handle      [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  io          [O] Receives information about the operation on return
+ *  buffer      [O] Destination for volume information
+ *  length      [I] Size of FsInformation
+ *  info_class  [I] Type of volume information to set
+ *
+ * RETURNS
+ *  Success: 0. io and buffer are updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, PIO_STATUS_BLOCK io,
+                                              PVOID buffer, ULONG length,
+                                              FS_INFORMATION_CLASS info_class )
+{
+    int fd, needs_close;
+    struct stat st;
+
+    io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
+    if (io->u.Status == STATUS_BAD_DEVICE_TYPE)
+    {
+        SERVER_START_REQ( get_volume_info )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->info_class = info_class;
+            wine_server_set_reply( req, buffer, length );
+            io->u.Status = wine_server_call( req );
+            if (!io->u.Status) io->Information = wine_server_reply_size( reply );
+        }
+        SERVER_END_REQ;
+        return io->u.Status;
+    }
+    else if (io->u.Status) return io->u.Status;
+
+    io->u.Status = STATUS_NOT_IMPLEMENTED;
+    io->Information = 0;
+
+    switch( info_class )
+    {
+    case FileFsLabelInformation:
+        FIXME( "%p: label info not supported\n", handle );
+        break;
+    case FileFsSizeInformation:
+        if (length < sizeof(FILE_FS_SIZE_INFORMATION))
+            io->u.Status = STATUS_BUFFER_TOO_SMALL;
+        else
+        {
+            FILE_FS_SIZE_INFORMATION *info = buffer;
+
+            if (fstat( fd, &st ) < 0)
+            {
+                io->u.Status = FILE_GetNtStatus();
+                break;
+            }
+            if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            {
+                io->u.Status = STATUS_INVALID_DEVICE_REQUEST;
+            }
+            else
+            {
+                ULONGLONG bsize;
+                /* Linux's fstatvfs is buggy */
+#if !defined(linux) || !defined(HAVE_FSTATFS)
+                struct statvfs stfs;
+
+                if (fstatvfs( fd, &stfs ) < 0)
+                {
+                    io->u.Status = FILE_GetNtStatus();
+                    break;
+                }
+                bsize = stfs.f_frsize;
+#else
+                struct statfs stfs;
+                if (fstatfs( fd, &stfs ) < 0)
+                {
+                    io->u.Status = FILE_GetNtStatus();
+                    break;
+                }
+                bsize = stfs.f_bsize;
+#endif
+                if (bsize == 2048)  /* assume CD-ROM */
+                {
+                    info->BytesPerSector = 2048;
+                    info->SectorsPerAllocationUnit = 1;
+                }
+                else
+                {
+                    info->BytesPerSector = 512;
+                    info->SectorsPerAllocationUnit = 8;
+                }
+                info->TotalAllocationUnits.QuadPart = bsize * stfs.f_blocks / (info->BytesPerSector * info->SectorsPerAllocationUnit);
+                info->AvailableAllocationUnits.QuadPart = bsize * stfs.f_bavail / (info->BytesPerSector * info->SectorsPerAllocationUnit);
+                io->Information = sizeof(*info);
+                io->u.Status = STATUS_SUCCESS;
+            }
+        }
+        break;
+    case FileFsDeviceInformation:
+        if (length < sizeof(FILE_FS_DEVICE_INFORMATION))
+            io->u.Status = STATUS_BUFFER_TOO_SMALL;
+        else
+        {
+            FILE_FS_DEVICE_INFORMATION *info = buffer;
+
+            if ((io->u.Status = get_device_info( fd, info )) == STATUS_SUCCESS)
+                io->Information = sizeof(*info);
+        }
+        break;
+    case FileFsAttributeInformation:
+    {
+        static const WCHAR fatW[] = {'F','A','T'};
+        static const WCHAR fat32W[] = {'F','A','T','3','2'};
+        static const WCHAR ntfsW[] = {'N','T','F','S'};
+        static const WCHAR cdfsW[] = {'C','D','F','S'};
+        static const WCHAR udfW[] = {'U','D','F'};
+
+        FILE_FS_ATTRIBUTE_INFORMATION *info = buffer;
+        struct mountmgr_unix_drive *drive;
+        enum mountmgr_fs_type fs_type = MOUNTMGR_FS_TYPE_NTFS;
+
+        if (length < sizeof(FILE_FS_ATTRIBUTE_INFORMATION))
+        {
+            io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
+            break;
+        }
+
+        if ((drive = get_mountmgr_fs_info( handle, fd )))
+        {
+            fs_type = drive->fs_type;
+            RtlFreeHeap( GetProcessHeap(), 0, drive );
+        }
+        else
+        {
+            struct statfs stfs;
+
+            if (!fstatfs( fd, &stfs ))
+            {
+#if defined(linux) && defined(HAVE_FSTATFS)
+                switch (stfs.f_type)
+                {
+                case 0x9660:
+                    fs_type = MOUNTMGR_FS_TYPE_ISO9660;
+                    break;
+                case 0x15013346:
+                    fs_type = MOUNTMGR_FS_TYPE_UDF;
+                    break;
+                case 0x4d44:
+                    fs_type = MOUNTMGR_FS_TYPE_FAT32;
+                    break;
+                }
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+                if (!strcmp( stfs.f_fstypename, "cd9660" ))
+                    fs_type = MOUNTMGR_FS_TYPE_ISO9660;
+                else if (!strcmp( stfs.f_fstypename, "udf" ))
+                    fs_type = MOUNTMGR_FS_TYPE_UDF;
+                else if (!strcmp( stfs.f_fstypename, "msdos" ))
+                    fs_type = MOUNTMGR_FS_TYPE_FAT32;
+#endif
+            }
+        }
+
+        switch (fs_type)
+        {
+        case MOUNTMGR_FS_TYPE_ISO9660:
+            info->FileSystemAttributes = FILE_READ_ONLY_VOLUME;
+            info->MaximumComponentNameLength = 221;
+            info->FileSystemNameLength = min( sizeof(cdfsW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, cdfsW, info->FileSystemNameLength);
+            break;
+        case MOUNTMGR_FS_TYPE_UDF:
+            info->FileSystemAttributes = FILE_READ_ONLY_VOLUME | FILE_UNICODE_ON_DISK | FILE_CASE_SENSITIVE_SEARCH;
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(udfW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, udfW, info->FileSystemNameLength);
+            break;
+        case MOUNTMGR_FS_TYPE_FAT:
+            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES; /* FIXME */
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(fatW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, fatW, info->FileSystemNameLength);
+            break;
+        case MOUNTMGR_FS_TYPE_FAT32:
+            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES; /* FIXME */
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(fat32W), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, fat32W, info->FileSystemNameLength);
+            break;
+        default:
+            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(ntfsW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, ntfsW, info->FileSystemNameLength);
+            break;
+        }
+
+        io->Information = offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) + info->FileSystemNameLength;
+        io->u.Status = STATUS_SUCCESS;
+        break;
+    }
+    case FileFsVolumeInformation:
+    {
+        FILE_FS_VOLUME_INFORMATION *info = buffer;
+        struct mountmgr_unix_drive *drive;
+        const WCHAR *label;
+
+        if (length < sizeof(FILE_FS_VOLUME_INFORMATION))
+        {
+            io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
+            break;
+        }
+
+        if (!(drive = get_mountmgr_fs_info( handle, fd )))
+        {
+            io->u.Status = STATUS_NOT_IMPLEMENTED;
+            break;
+        }
+
+        label = (WCHAR *)((char *)drive + drive->label_offset);
+        info->VolumeCreationTime.QuadPart = 0; /* FIXME */
+        info->VolumeSerialNumber = drive->serial;
+        info->VolumeLabelLength = min( wcslen( label ) * sizeof(WCHAR),
+                                       length - offsetof( FILE_FS_VOLUME_INFORMATION, VolumeLabel ) );
+        info->SupportsObjects = (drive->fs_type == MOUNTMGR_FS_TYPE_NTFS);
+        memcpy( info->VolumeLabel, label, info->VolumeLabelLength );
+        RtlFreeHeap( GetProcessHeap(), 0, drive );
+
+        io->Information = offsetof( FILE_FS_VOLUME_INFORMATION, VolumeLabel ) + info->VolumeLabelLength;
+        io->u.Status = STATUS_SUCCESS;
+        break;
+    }
+    case FileFsControlInformation:
+        FIXME( "%p: control info not supported\n", handle );
+        break;
+    case FileFsFullSizeInformation:
+        FIXME( "%p: full size info not supported\n", handle );
+        break;
+    case FileFsObjectIdInformation:
+        FIXME( "%p: object id info not supported\n", handle );
+        break;
+    case FileFsMaximumInformation:
+        FIXME( "%p: maximum info not supported\n", handle );
+        break;
+    default:
+        io->u.Status = STATUS_INVALID_PARAMETER;
+        break;
+    }
+    if (needs_close) close( fd );
+    return io->u.Status;
+}
+
+
+/******************************************************************
+ *		NtQueryEaFile  (NTDLL.@)
+ *
+ * Read extended attributes from NTFS files.
+ *
+ * PARAMS
+ *  hFile         [I] File handle, must be opened with FILE_READ_EA access
+ *  iosb          [O] Receives information about the operation on return
+ *  buffer        [O] Output buffer
+ *  length        [I] Length of output buffer
+ *  single_entry  [I] Only read and return one entry
+ *  ea_list       [I] Optional list with names of EAs to return
+ *  ea_list_len   [I] Length of ea_list in bytes
+ *  ea_index      [I] Optional pointer to 1-based index of attribute to return
+ *  restart       [I] restart EA scan
+ *
+ * RETURNS
+ *  Success: 0. Attributes read into buffer
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtQueryEaFile( HANDLE hFile, PIO_STATUS_BLOCK iosb, PVOID buffer, ULONG length,
+                               BOOLEAN single_entry, PVOID ea_list, ULONG ea_list_len,
+                               PULONG ea_index, BOOLEAN restart )
+{
+    FIXME("(%p,%p,%p,%d,%d,%p,%d,%p,%d) stub\n",
+            hFile, iosb, buffer, length, single_entry, ea_list,
+            ea_list_len, ea_index, restart);
+    return STATUS_ACCESS_DENIED;
+}
+
+
+/******************************************************************
+ *		NtSetEaFile  (NTDLL.@)
+ *
+ * Update extended attributes for NTFS files.
+ *
+ * PARAMS
+ *  hFile         [I] File handle, must be opened with FILE_READ_EA access
+ *  iosb          [O] Receives information about the operation on return
+ *  buffer        [I] Buffer with EA information
+ *  length        [I] Length of buffer
+ *
+ * RETURNS
+ *  Success: 0. Attributes are updated
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtSetEaFile( HANDLE hFile, PIO_STATUS_BLOCK iosb, PVOID buffer, ULONG length )
+{
+    FIXME("(%p,%p,%p,%d) stub\n", hFile, iosb, buffer, length);
+    return STATUS_ACCESS_DENIED;
+}
+
+
+/******************************************************************
+ *		NtFlushBuffersFile  (NTDLL.@)
+ *
+ * Flush any buffered data on an open file handle.
+ *
+ * PARAMS
+ *  FileHandle         [I] Handle returned from ZwOpenFile() or ZwCreateFile()
+ *  IoStatusBlock      [O] Receives information about the operation on return
+ *
+ * RETURNS
+ *  Success: 0. IoStatusBlock is updated.
+ *  Failure: An NTSTATUS error code describing the error.
+ */
+NTSTATUS WINAPI NtFlushBuffersFile( HANDLE hFile, IO_STATUS_BLOCK *io )
+{
+    NTSTATUS ret;
+    HANDLE wait_handle;
+    enum server_fd_type type;
+    int fd, needs_close;
+
+    if (!io || !virtual_check_buffer_for_write( io, sizeof(*io) )) return STATUS_ACCESS_VIOLATION;
+
+    ret = server_get_unix_fd( hFile, FILE_WRITE_DATA, &fd, &needs_close, &type, NULL );
+    if (ret == STATUS_ACCESS_DENIED)
+        ret = server_get_unix_fd( hFile, FILE_APPEND_DATA, &fd, &needs_close, &type, NULL );
+
+    if (!ret && (type == FD_TYPE_FILE || type == FD_TYPE_DIR))
+    {
+        if (fsync(fd))
+            ret = FILE_GetNtStatus();
+
+        io->u.Status    = ret;
+        io->Information = 0;
+    }
+    else if (!ret && type == FD_TYPE_SERIAL)
+    {
+        ret = COMM_FlushBuffersFile( fd );
+    }
+    else if (ret != STATUS_ACCESS_DENIED)
+    {
+        struct async_irp *async;
+
+        if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, hFile )))
+            return STATUS_NO_MEMORY;
+        async->buffer  = NULL;
+        async->size    = 0;
+
+        SERVER_START_REQ( flush )
+        {
+            req->async = server_async( hFile, &async->io, NULL, NULL, NULL, io );
+            ret = wine_server_call( req );
+            wait_handle = wine_server_ptr_handle( reply->event );
+            if (wait_handle && ret != STATUS_PENDING)
+            {
+                io->u.Status    = ret;
+                io->Information = 0;
+            }
+        }
+        SERVER_END_REQ;
+
+        if (ret != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, async );
+
+        if (wait_handle) ret = wait_async( wait_handle, FALSE, io );
+    }
+
+    if (needs_close) close( fd );
+    return ret;
+}
+
+/******************************************************************
+ *		NtLockFile       (NTDLL.@)
+ *
+ *
+ */
+NTSTATUS WINAPI NtLockFile( HANDLE hFile, HANDLE lock_granted_event,
+                            PIO_APC_ROUTINE apc, void* apc_user,
+                            PIO_STATUS_BLOCK io_status, PLARGE_INTEGER offset,
+                            PLARGE_INTEGER count, ULONG* key, BOOLEAN dont_wait,
+                            BOOLEAN exclusive )
+{
+    NTSTATUS    ret;
+    HANDLE      handle;
+    BOOLEAN     async;
+    static BOOLEAN     warn = TRUE;
+
+    if (apc || io_status || key)
+    {
+        FIXME("Unimplemented yet parameter\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    if (apc_user && warn)
+    {
+        FIXME("I/O completion on lock not implemented yet\n");
+        warn = FALSE;
+    }
+
+    for (;;)
+    {
+        SERVER_START_REQ( lock_file )
+        {
+            req->handle      = wine_server_obj_handle( hFile );
+            req->offset      = offset->QuadPart;
+            req->count       = count->QuadPart;
+            req->shared      = !exclusive;
+            req->wait        = !dont_wait;
+            ret = wine_server_call( req );
+            handle = wine_server_ptr_handle( reply->handle );
+            async  = reply->overlapped;
+        }
+        SERVER_END_REQ;
+        if (ret != STATUS_PENDING)
+        {
+            if (!ret && lock_granted_event) NtSetEvent(lock_granted_event, NULL);
+            return ret;
+        }
+
+        if (async)
+        {
+            FIXME( "Async I/O lock wait not implemented, might deadlock\n" );
+            if (handle) NtClose( handle );
+            return STATUS_PENDING;
+        }
+        if (handle)
+        {
+            NtWaitForSingleObject( handle, FALSE, NULL );
+            NtClose( handle );
+        }
+        else
+        {
+            LARGE_INTEGER time;
+    
+            /* Unix lock conflict, sleep a bit and retry */
+            time.QuadPart = 100 * (ULONGLONG)10000;
+            time.QuadPart = -time.QuadPart;
+            NtDelayExecution( FALSE, &time );
+        }
+    }
+}
+
+
+/******************************************************************
+ *		NtUnlockFile    (NTDLL.@)
+ *
+ *
+ */
+NTSTATUS WINAPI NtUnlockFile( HANDLE hFile, PIO_STATUS_BLOCK io_status,
+                              PLARGE_INTEGER offset, PLARGE_INTEGER count,
+                              PULONG key )
+{
+    NTSTATUS status;
+
+    TRACE( "%p %x%08x %x%08x\n",
+           hFile, offset->u.HighPart, offset->u.LowPart, count->u.HighPart, count->u.LowPart );
+
+    if (io_status || key)
+    {
+        FIXME("Unimplemented yet parameter\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    SERVER_START_REQ( unlock_file )
+    {
+        req->handle = wine_server_obj_handle( hFile );
+        req->offset = offset->QuadPart;
+        req->count  = count->QuadPart;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************
+ *		NtCreateNamedPipeFile    (NTDLL.@)
+ *
+ *
+ */
+NTSTATUS WINAPI NtCreateNamedPipeFile( PHANDLE handle, ULONG access,
+                                       POBJECT_ATTRIBUTES attr, PIO_STATUS_BLOCK iosb,
+                                       ULONG sharing, ULONG dispo, ULONG options,
+                                       ULONG pipe_type, ULONG read_mode, 
+                                       ULONG completion_mode, ULONG max_inst,
+                                       ULONG inbound_quota, ULONG outbound_quota,
+                                       PLARGE_INTEGER timeout)
+{
+    NTSTATUS status;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if (!attr) return STATUS_INVALID_PARAMETER;
+
+    TRACE("(%p %x %s %p %x %d %x %d %d %d %d %d %d %p)\n",
+          handle, access, debugstr_us(attr->ObjectName), iosb, sharing, dispo,
+          options, pipe_type, read_mode, completion_mode, max_inst, inbound_quota,
+          outbound_quota, timeout);
+
+    /* assume we only get relative timeout */
+    if (timeout->QuadPart > 0)
+        FIXME("Wrong time %s\n", wine_dbgstr_longlong(timeout->QuadPart));
+
+    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
+
+    SERVER_START_REQ( create_named_pipe )
+    {
+        req->access  = access;
+        req->options = options;
+        req->sharing = sharing;
+        req->flags = 
+            (pipe_type ? NAMED_PIPE_MESSAGE_STREAM_WRITE   : 0) |
+            (read_mode ? NAMED_PIPE_MESSAGE_STREAM_READ    : 0) |
+            (completion_mode ? NAMED_PIPE_NONBLOCKING_MODE : 0);
+        req->maxinstances = max_inst;
+        req->outsize = outbound_quota;
+        req->insize  = inbound_quota;
+        req->timeout = timeout->QuadPart;
+        wine_server_add_data( req, objattr, len );
+        status = wine_server_call( req );
+        if (!status) *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return status;
+}
+
+/******************************************************************
+ *		NtDeleteFile    (NTDLL.@)
+ *
+ *
+ */
+NTSTATUS WINAPI NtDeleteFile( POBJECT_ATTRIBUTES ObjectAttributes )
+{
+    NTSTATUS status;
+    HANDLE hFile;
+    IO_STATUS_BLOCK io;
+
+    TRACE("%p\n", ObjectAttributes);
+    status = NtCreateFile( &hFile, GENERIC_READ | GENERIC_WRITE | DELETE,
+                           ObjectAttributes, &io, NULL, 0,
+                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
+                           FILE_OPEN, FILE_DELETE_ON_CLOSE, NULL, 0 );
+    if (status == STATUS_SUCCESS) status = NtClose(hFile);
+    return status;
+}
+
+/******************************************************************
+ *		NtCancelIoFileEx    (NTDLL.@)
+ *
+ *
+ */
+NTSTATUS WINAPI NtCancelIoFileEx( HANDLE hFile, PIO_STATUS_BLOCK iosb, PIO_STATUS_BLOCK io_status )
+{
+    TRACE("%p %p %p\n", hFile, iosb, io_status );
+
+    SERVER_START_REQ( cancel_async )
+    {
+        req->handle      = wine_server_obj_handle( hFile );
+        req->iosb        = wine_server_client_ptr( iosb );
+        req->only_thread = FALSE;
+        io_status->u.Status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return io_status->u.Status;
+}
+
+/******************************************************************
+ *		NtCancelIoFile    (NTDLL.@)
+ *
+ *
+ */
+NTSTATUS WINAPI NtCancelIoFile( HANDLE hFile, PIO_STATUS_BLOCK io_status )
+{
+    TRACE("%p %p\n", hFile, io_status );
+
+    SERVER_START_REQ( cancel_async )
+    {
+        req->handle      = wine_server_obj_handle( hFile );
+        req->iosb        = 0;
+        req->only_thread = TRUE;
+        io_status->u.Status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return io_status->u.Status;
+}
+
+/******************************************************************************
+ *  NtCreateMailslotFile	[NTDLL.@]
+ *  ZwCreateMailslotFile	[NTDLL.@]
+ *
+ * PARAMS
+ *  pHandle          [O] pointer to receive the handle created
+ *  DesiredAccess    [I] access mode (read, write, etc)
+ *  ObjectAttributes [I] fully qualified NT path of the mailslot
+ *  IoStatusBlock    [O] receives completion status and other info
+ *  CreateOptions    [I]
+ *  MailslotQuota    [I]
+ *  MaxMessageSize   [I]
+ *  TimeOut          [I]
+ *
+ * RETURNS
+ *  An NT status code
+ */
+NTSTATUS WINAPI NtCreateMailslotFile(PHANDLE pHandle, ULONG DesiredAccess,
+     POBJECT_ATTRIBUTES attr, PIO_STATUS_BLOCK IoStatusBlock,
+     ULONG CreateOptions, ULONG MailslotQuota, ULONG MaxMessageSize,
+     PLARGE_INTEGER TimeOut)
+{
+    LARGE_INTEGER timeout;
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    TRACE("%p %08x %p %p %08x %08x %08x %p\n",
+              pHandle, DesiredAccess, attr, IoStatusBlock,
+              CreateOptions, MailslotQuota, MaxMessageSize, TimeOut);
+
+    if (!pHandle) return STATUS_ACCESS_VIOLATION;
+    if (!attr) return STATUS_INVALID_PARAMETER;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    /*
+     *  For a NULL TimeOut pointer set the default timeout value
+     */
+    if  (!TimeOut)
+        timeout.QuadPart = -1;
+    else
+        timeout.QuadPart = TimeOut->QuadPart;
+
+    SERVER_START_REQ( create_mailslot )
+    {
+        req->access = DesiredAccess;
+        req->max_msgsize = MaxMessageSize;
+        req->read_timeout = timeout.QuadPart;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        if( ret == STATUS_SUCCESS )
+            *pHandle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 1ac0cb2480..1a18ce3d29 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -19,13 +19,19 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <string.h>
-
-#define RUNNING_ON_VALGRIND 0  /* FIXME */
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#else
+#define RUNNING_ON_VALGRIND 0
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -116,7 +122,7 @@ C_ASSERT( HEAP_MAX_SMALL_FREE_LIST % ALIGNMENT == 0 );
 /* Max size of the blocks on the free lists above HEAP_MAX_SMALL_FREE_LIST */
 static const SIZE_T HEAP_freeListSizes[] =
 {
-    0x200, 0x400, 0x1000, ~(SIZE_T)0
+    0x200, 0x400, 0x1000, ~0UL
 };
 #define HEAP_NB_FREE_LISTS (ARRAY_SIZE( HEAP_freeListSizes ) + HEAP_NB_SMALL_FREE_LISTS)
 
@@ -2013,7 +2019,7 @@ SIZE_T WINAPI RtlSizeHeap( HANDLE heap, ULONG flags, const void *ptr )
     if (!heapPtr)
     {
         RtlSetLastWin32ErrorAndNtStatusFromNtStatus( STATUS_INVALID_HANDLE );
-        return ~(SIZE_T)0;
+        return ~0UL;
     }
     flags &= HEAP_NO_SERIALIZE;
     flags |= heapPtr->flags;
@@ -2023,7 +2029,7 @@ SIZE_T WINAPI RtlSizeHeap( HANDLE heap, ULONG flags, const void *ptr )
     if (!validate_block_pointer( heapPtr, &subheap, pArena ))
     {
         RtlSetLastWin32ErrorAndNtStatusFromNtStatus( STATUS_INVALID_PARAMETER );
-        ret = ~(SIZE_T)0;
+        ret = ~0UL;
     }
     else if (!subheap)
     {
diff --git a/dlls/ntdll/large_int.c b/dlls/ntdll/large_int.c
index 5be1af65cc..748d17adb9 100644
--- a/dlls/ntdll/large_int.c
+++ b/dlls/ntdll/large_int.c
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 
 #include "ntstatus.h"
@@ -544,11 +547,11 @@ NTSTATUS WINAPI RtlInt64ToUnicodeString(
 
 /* those builtin functions use stdcall calling convention, but compilers reference them without stdcall declarations */
 #if defined(__MINGW32__) || defined(_MSC_VER)
-LONGLONG WINAPI _alldiv( LONGLONG a, LONGLONG b ) asm(__ASM_NAME("_alldiv"));
-LONGLONG WINAPI _allmul( LONGLONG a, LONGLONG b ) asm(__ASM_NAME("_allmul"));
-LONGLONG WINAPI _allrem( LONGLONG a, LONGLONG b ) asm(__ASM_NAME("_allrem"));
-ULONGLONG WINAPI _aulldiv( ULONGLONG a, ULONGLONG b ) asm(__ASM_NAME("_aulldiv"));
-ULONGLONG WINAPI _aullrem( ULONGLONG a, ULONGLONG b ) asm(__ASM_NAME("_aullrem"));
+LONGLONG WINAPI _alldiv( LONGLONG a, LONGLONG b ) asm("_alldiv");
+LONGLONG WINAPI _allmul( LONGLONG a, LONGLONG b ) asm("_allmul");
+LONGLONG WINAPI _allrem( LONGLONG a, LONGLONG b ) asm("_allrem");
+ULONGLONG WINAPI _aulldiv( ULONGLONG a, ULONGLONG b ) asm("_aulldiv");
+ULONGLONG WINAPI _aullrem( ULONGLONG a, ULONGLONG b ) asm("_aullrem");
 #endif
 
 static ULONGLONG udivmod(ULONGLONG a, ULONGLONG b, ULONGLONG *rem)
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 6290cbcb4e..37a86f3f8d 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -19,8 +19,17 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <stdarg.h>
+#ifdef HAVE_LINK_H
+# include <link.h>
+#endif
+#ifdef HAVE_SYS_MMAN_H
+# include <sys/mman.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -28,11 +37,11 @@
 #define NONAMELESSSTRUCT
 #include "windef.h"
 #include "winnt.h"
-#include "winioctl.h"
 #include "winternl.h"
 #include "delayloadhandler.h"
 
 #include "wine/exception.h"
+#include "wine/library.h"
 #include "wine/debug.h"
 #include "wine/list.h"
 #include "wine/server.h"
@@ -113,21 +122,31 @@ static const char * const reason_names[] =
 
 static const WCHAR dllW[] = {'.','d','l','l',0};
 
-struct file_id
-{
-    BYTE ObjectId[16];
-};
-
-/* internal representation of loaded modules */
+/* internal representation of 32bit modules. per process. */
 typedef struct _wine_modref
 {
     LDR_DATA_TABLE_ENTRY  ldr;
-    struct file_id        id;
+    dev_t                 dev;
+    ino_t                 ino;
+    void                 *so_handle;
     int                   alloc_deps;
     int                   nDeps;
     struct _wine_modref **deps;
 } WINE_MODREF;
 
+/* info about the current builtin dll load */
+/* used to keep track of things across the register_dll constructor call */
+struct builtin_load_info
+{
+    const WCHAR          *load_path;
+    const UNICODE_STRING *filename;
+    NTSTATUS              status;
+    WINE_MODREF          *wm;
+};
+
+static struct builtin_load_info default_load_info;
+static struct builtin_load_info *builtin_load_info = &default_load_info;
+
 static UINT tls_module_count;      /* number of modules with TLS directory */
 static IMAGE_TLS_DIRECTORY *tls_dirs;  /* array of TLS directories */
 LIST_ENTRY tls_links = { &tls_links, &tls_links };
@@ -150,20 +169,6 @@ static CRITICAL_SECTION_DEBUG dlldir_critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &dlldir_critsect_debug, -1, 0, 0, 0, 0 };
 
-static RTL_CRITICAL_SECTION peb_lock;
-static RTL_CRITICAL_SECTION_DEBUG peb_critsect_debug =
-{
-    0, 0, &peb_lock,
-    { &peb_critsect_debug.ProcessLocksList, &peb_critsect_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": peb_lock") }
-};
-static RTL_CRITICAL_SECTION peb_lock = { &peb_critsect_debug, -1, 0, 0, 0, 0 };
-
-static PEB_LDR_DATA ldr = { sizeof(ldr), TRUE };
-static RTL_BITMAP tls_bitmap;
-static RTL_BITMAP tls_expansion_bitmap;
-static RTL_BITMAP fls_bitmap;
-
 static WINE_MODREF *cached_modref;
 static WINE_MODREF *current_modref;
 static WINE_MODREF *last_failed_modref;
@@ -549,11 +554,12 @@ static WINE_MODREF *find_fullname_module( const UNICODE_STRING *nt_name )
  * Find a module from its file id.
  * The loader_section must be locked while calling this function
  */
-static WINE_MODREF *find_fileid_module( const struct file_id *id )
+static WINE_MODREF *find_fileid_module( struct stat *st )
 {
     LIST_ENTRY *mark, *entry;
 
-    if (cached_modref && !memcmp( &cached_modref->id, id, sizeof(*id) )) return cached_modref;
+    if (cached_modref && cached_modref->dev == st->st_dev && cached_modref->ino == st->st_ino)
+        return cached_modref;
 
     mark = &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList;
     for (entry = mark->Flink; entry != mark; entry = entry->Flink)
@@ -561,7 +567,7 @@ static WINE_MODREF *find_fileid_module( const struct file_id *id )
         LDR_DATA_TABLE_ENTRY *mod = CONTAINING_RECORD( entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );
         WINE_MODREF *wm = CONTAINING_RECORD( mod, WINE_MODREF, ldr );
 
-        if (!memcmp( &wm->id, id, sizeof(*id) ))
+        if (wm->dev == st->st_dev && wm->ino == st->st_ino)
         {
             cached_modref = wm;
             return wm;
@@ -571,6 +577,28 @@ static WINE_MODREF *find_fileid_module( const struct file_id *id )
 }
 
 
+/**********************************************************************
+ *	    find_so_module
+ *
+ * Find a module from its so file handle.
+ * The loader_section must be locked while calling this function
+ */
+static WINE_MODREF *find_so_module( void *handle )
+{
+    LIST_ENTRY *mark, *entry;
+
+    mark = &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList;
+    for (entry = mark->Flink; entry != mark; entry = entry->Flink)
+    {
+        LDR_DATA_TABLE_ENTRY *mod = CONTAINING_RECORD( entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );
+        WINE_MODREF *wm = CONTAINING_RECORD( mod, WINE_MODREF, ldr );
+
+        if (wm->so_handle == handle) return wm;
+    }
+    return NULL;
+}
+
+
 /*************************************************************************
  *		grow_module_deps
  */
@@ -1002,8 +1030,9 @@ static SHORT alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
             if (!new) return -1;
             if (old) memcpy( new, old, tls_module_count * sizeof(*new) );
             teb->ThreadLocalStoragePointer = new;
-#ifdef __x86_64__  /* macOS-specific hack */
-            if (teb->Reserved5[0]) ((TEB *)teb->Reserved5[0])->ThreadLocalStoragePointer = new;
+#if defined(__APPLE__) && defined(__x86_64__)
+            if (teb->Reserved5[0])
+                ((TEB*)teb->Reserved5[0])->ThreadLocalStoragePointer = new;
 #endif
             TRACE( "thread %04lx tls block %p -> %p\n", (ULONG_PTR)teb->ClientId.UniqueThread, old, new );
             /* FIXME: can't free old block here, should be freed at thread exit */
@@ -1247,9 +1276,10 @@ static NTSTATUS alloc_thread_tls(void)
                GetCurrentThreadId(), i, size, dir->SizeOfZeroFill, pointers[i] );
     }
     NtCurrentTeb()->ThreadLocalStoragePointer = pointers;
-#ifdef __x86_64__  /* macOS-specific hack */
-    if (NtCurrentTeb()->Reserved5[0])
-        ((TEB *)NtCurrentTeb()->Reserved5[0])->ThreadLocalStoragePointer = pointers;
+#if defined(__APPLE__) && defined(__x86_64__)
+    __asm__ volatile (".byte 0x65\n\tmovq %0,%c1"
+                      :
+                      : "r" (pointers), "n" (FIELD_OFFSET(TEB, ThreadLocalStoragePointer)));
 #endif
     return STATUS_SUCCESS;
 }
@@ -1289,6 +1319,85 @@ static void call_tls_callbacks( HMODULE module, UINT reason )
     }
 }
 
+#ifdef __FreeBSD__
+/* The PT_LOAD segments are sorted in increasing order, and the first
+ * starts at the beginning of the ELF file. By parsing the file, we can
+ * find that first PT_LOAD segment, from which we can find the base
+ * address it wanted, and knowing mapbase where the binary was actually
+ * loaded, use them to work out the relocbase offset. */
+static BOOL get_relocbase(caddr_t mapbase, caddr_t *relocbase)
+{
+    Elf_Half i;
+#ifdef _WIN64
+    const Elf64_Ehdr *elf_header = (Elf64_Ehdr*) mapbase;
+#else
+    const Elf32_Ehdr *elf_header = (Elf32_Ehdr*) mapbase;
+#endif
+    const Elf_Phdr *prog_header = (const Elf_Phdr *)(mapbase + elf_header->e_phoff);
+
+    for (i = 0; i < elf_header->e_phnum; i++)
+    {
+         if (prog_header->p_type == PT_LOAD)
+         {
+             caddr_t desired_base = (caddr_t)((prog_header->p_vaddr / prog_header->p_align) * prog_header->p_align);
+             *relocbase = (caddr_t) (mapbase - desired_base);
+             return TRUE;
+         }
+         prog_header++;
+    }
+    return FALSE;
+}
+#endif
+
+/*************************************************************************
+ *              call_constructors
+ */
+static void call_constructors( WINE_MODREF *wm )
+{
+#ifdef HAVE_DLINFO
+    struct link_map *map;
+    void (*init_func)(int, char **, char **) = NULL;
+    void (**init_array)(int, char **, char **) = NULL;
+    ULONG_PTR i, init_arraysz = 0;
+    int argc;
+    char **argv, **envp;
+#ifdef _WIN64
+    const Elf64_Dyn *dyn;
+#else
+    const Elf32_Dyn *dyn;
+#endif
+
+    if (dlinfo( wm->so_handle, RTLD_DI_LINKMAP, &map ) == -1) return;
+    for (dyn = map->l_ld; dyn->d_tag; dyn++)
+    {
+        caddr_t relocbase = (caddr_t)map->l_addr;
+
+#ifdef __FreeBSD__
+        /* On older FreeBSD versions, l_addr was the absolute load address, now it's the relocation offset. */
+        if (!dlsym(RTLD_DEFAULT, "_rtld_version_laddr_offset"))
+            if (!get_relocbase(map->l_addr, &relocbase)) return;
+#endif
+        switch (dyn->d_tag)
+        {
+        case 0x60009990: init_array = (void *)(relocbase + dyn->d_un.d_val); break;
+        case 0x60009991: init_arraysz = dyn->d_un.d_val; break;
+        case 0x60009992: init_func = (void *)(relocbase + dyn->d_un.d_val); break;
+        }
+    }
+
+    TRACE( "%s: got init_func %p init_array %p %lu\n", debugstr_us( &wm->ldr.BaseDllName ),
+           init_func, init_array, init_arraysz );
+
+    unix_funcs->get_main_args( &argc, &argv, &envp );
+
+    if (init_func) init_func( argc, argv, envp );
+
+    if (init_array)
+        for (i = 0; i < init_arraysz / sizeof(*init_array); i++) init_array[i]( argc, argv, envp );
+#endif
+}
+
+
 /*************************************************************************
  *              MODULE_InitDLL
  */
@@ -1304,8 +1413,7 @@ static NTSTATUS MODULE_InitDLL( WINE_MODREF *wm, UINT reason, LPVOID lpReserved
 
     if (wm->ldr.Flags & LDR_DONT_RESOLVE_REFS) return STATUS_SUCCESS;
     if (wm->ldr.TlsIndex != -1) call_tls_callbacks( wm->ldr.DllBase, reason );
-    if (wm->ldr.Flags & LDR_WINE_INTERNAL && reason == DLL_PROCESS_ATTACH)
-        unix_funcs->init_builtin_dll( wm->ldr.DllBase );
+    if (wm->so_handle && reason == DLL_PROCESS_ATTACH) call_constructors( wm );
     if (!entry) return STATUS_SUCCESS;
 
     if (TRACE_ON(relay))
@@ -1736,6 +1844,97 @@ NTSTATUS WINAPI LdrGetProcedureAddress(HMODULE module, const ANSI_STRING *name,
 }
 
 
+/*************************************************************************
+ *		is_16bit_builtin
+ */
+static BOOL is_16bit_builtin( HMODULE module )
+{
+    const IMAGE_EXPORT_DIRECTORY *exports;
+    DWORD exp_size;
+
+    if (!(exports = RtlImageDirectoryEntryToData( module, TRUE,
+                                                  IMAGE_DIRECTORY_ENTRY_EXPORT, &exp_size )))
+        return FALSE;
+
+    return find_named_export( module, exports, exp_size, "__wine_spec_dos_header", -1, NULL ) != NULL;
+}
+
+
+/*************************************************************************
+ *		build_so_dll_module
+ *
+ * Build the module for a .so builtin library.
+ */
+static NTSTATUS build_so_dll_module( const WCHAR *load_path, const UNICODE_STRING *nt_name,
+                                     HMODULE module, DWORD flags, WINE_MODREF **pwm )
+{
+    IMAGE_NT_HEADERS *nt;
+    WINE_MODREF *wm;
+    NTSTATUS status;
+
+    if (!(nt = RtlImageNtHeader( module ))) return STATUS_INVALID_IMAGE_FORMAT;
+
+    if (!(wm = alloc_module( module, nt_name, TRUE ))) return STATUS_NO_MEMORY;
+
+    virtual_create_builtin_view( module );
+
+    if (!(flags & DONT_RESOLVE_DLL_REFERENCES) &&
+        ((nt->FileHeader.Characteristics & IMAGE_FILE_DLL) ||
+         nt->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE ||
+         is_16bit_builtin( module )))
+    {
+        if ((status = fixup_imports( wm, load_path )))
+        {
+            /* the module has only been inserted in the load & memory order lists */
+            RemoveEntryList(&wm->ldr.InLoadOrderLinks);
+            RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
+            /* FIXME: free the modref */
+            return status;
+        }
+    }
+
+    TRACE( "loaded %s %p %p\n", debugstr_us(nt_name), wm, module );
+
+    /* send the DLL load event */
+
+    SERVER_START_REQ( load_dll )
+    {
+        req->base       = wine_server_client_ptr( module );
+        req->dbg_offset = nt->FileHeader.PointerToSymbolTable;
+        req->dbg_size   = nt->FileHeader.NumberOfSymbols;
+        req->name       = wine_server_client_ptr( &wm->ldr.FullDllName.Buffer );
+        wine_server_add_data( req, wm->ldr.FullDllName.Buffer, wm->ldr.FullDllName.Length );
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    /* setup relay debugging entry points */
+    if (TRACE_ON(relay)) RELAY_SetupDLL( module );
+
+    *pwm = wm;
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           load_builtin_callback
+ *
+ * Load a library in memory; callback function for wine_dll_register
+ */
+static void load_builtin_callback( void *module, const char *filename )
+{
+    if (!module)
+    {
+        ERR("could not map image for %s\n", debugstr_us(builtin_load_info->filename) );
+        builtin_load_info->status = STATUS_NO_MEMORY;
+        return;
+    }
+    builtin_load_info->status = build_so_dll_module( builtin_load_info->load_path,
+                                                     builtin_load_info->filename, module,
+                                                     0, &builtin_load_info->wm );
+}
+
+
 /***********************************************************************
  *           set_security_cookie
  *
@@ -1859,115 +2058,6 @@ static NTSTATUS perform_relocations( void *module, IMAGE_NT_HEADERS *nt, SIZE_T
     return STATUS_SUCCESS;
 }
 
-
-/*************************************************************************
- *		build_module
- *
- * Build the module data for a mapped dll.
- */
-static NTSTATUS build_module( LPCWSTR load_path, const UNICODE_STRING *nt_name, void **module,
-                              const pe_image_info_t *image_info, const struct file_id *id,
-                              DWORD flags, WINE_MODREF **pwm )
-{
-    IMAGE_NT_HEADERS *nt;
-    WINE_MODREF *wm;
-    NTSTATUS status;
-
-    if (!(nt = RtlImageNtHeader( *module ))) return STATUS_INVALID_IMAGE_FORMAT;
-
-    if ((status = perform_relocations( *module, nt, image_info->map_size ))) return status;
-
-    /* create the MODREF */
-
-    if (!(wm = alloc_module( *module, nt_name, (image_info->image_flags & IMAGE_FLAGS_WineBuiltin) )))
-        return STATUS_NO_MEMORY;
-
-    if (id) wm->id = *id;
-    if (image_info->loader_flags) wm->ldr.Flags |= LDR_COR_IMAGE;
-    if (image_info->image_flags & IMAGE_FLAGS_ComPlusILOnly) wm->ldr.Flags |= LDR_COR_ILONLY;
-
-    set_security_cookie( *module, image_info->map_size );
-
-    /* fixup imports */
-
-    if (!(flags & DONT_RESOLVE_DLL_REFERENCES) &&
-        ((nt->FileHeader.Characteristics & IMAGE_FILE_DLL) ||
-         nt->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE))
-    {
-        if (wm->ldr.Flags & LDR_COR_ILONLY)
-            status = fixup_imports_ilonly( wm, load_path, &wm->ldr.EntryPoint );
-        else
-            status = fixup_imports( wm, load_path );
-        if (status != STATUS_SUCCESS)
-        {
-            /* the module has only be inserted in the load & memory order lists */
-            RemoveEntryList(&wm->ldr.InLoadOrderLinks);
-            RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
-
-            /* FIXME: there are several more dangling references
-             * left. Including dlls loaded by this dll before the
-             * failed one. Unrolling is rather difficult with the
-             * current structure and we can leave them lying
-             * around with no problems, so we don't care.
-             * As these might reference our wm, we don't free it.
-             */
-            *module = NULL;
-            return status;
-        }
-    }
-
-    TRACE( "loaded %s %p %p\n", debugstr_us(nt_name), wm, module );
-
-    /* send DLL load event */
-
-    SERVER_START_REQ( load_dll )
-    {
-        req->base       = wine_server_client_ptr( *module );
-        req->dbg_offset = nt->FileHeader.PointerToSymbolTable;
-        req->dbg_size   = nt->FileHeader.NumberOfSymbols;
-        req->name       = wine_server_client_ptr( &wm->ldr.FullDllName.Buffer );
-        wine_server_add_data( req, wm->ldr.FullDllName.Buffer, wm->ldr.FullDllName.Length );
-        wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    if (image_info->image_flags & IMAGE_FLAGS_WineBuiltin)
-    {
-        if (TRACE_ON(relay)) RELAY_SetupDLL( *module );
-    }
-    else
-    {
-        if ((wm->ldr.Flags & LDR_IMAGE_IS_DLL) && TRACE_ON(snoop)) SNOOP_SetupDLL( *module );
-    }
-
-    TRACE_(loaddll)( "Loaded %s at %p: %s\n", debugstr_w(wm->ldr.FullDllName.Buffer), *module,
-                     (image_info->image_flags & IMAGE_FLAGS_WineBuiltin) ? "builtin" : "native" );
-
-    wm->ldr.LoadCount = 1;
-    *pwm = wm;
-    *module = NULL;
-    return STATUS_SUCCESS;
-}
-
-
-/*************************************************************************
- *		build_builtin_module
- *
- * Build the module for a builtin library.
- */
-static NTSTATUS build_builtin_module( const WCHAR *load_path, const UNICODE_STRING *nt_name,
-                                      void *module, DWORD flags, WINE_MODREF **pwm )
-{
-    NTSTATUS status;
-    pe_image_info_t image_info = { 0 };
-
-    image_info.image_flags = IMAGE_FLAGS_WineBuiltin;
-    status = build_module( load_path, nt_name, &module, &image_info, NULL, flags, pwm );
-    if (status && module) unix_funcs->unload_builtin_dll( module );
-    return status;
-}
-
-
 #ifdef _WIN64
 /* convert PE header to 64-bit when loading a 32-bit IL-only module into a 64-bit process */
 static BOOL convert_to_pe64( HMODULE module, const pe_image_info_t *info )
@@ -2213,16 +2303,16 @@ static NTSTATUS get_dll_load_path_search_flags( LPCWSTR module, DWORD flags, WCH
  * Open a file for a new dll. Helper for find_dll_file.
  */
 static NTSTATUS open_dll_file( UNICODE_STRING *nt_name, WINE_MODREF **pwm,
-                               void **module, pe_image_info_t *image_info, struct file_id *id )
+                               void **module, pe_image_info_t *image_info, struct stat *st )
 {
     FILE_BASIC_INFORMATION info;
     OBJECT_ATTRIBUTES attr;
     IO_STATUS_BLOCK io;
     LARGE_INTEGER size;
-    FILE_OBJECTID_BUFFER fid;
     SIZE_T len = 0;
     NTSTATUS status;
     HANDLE handle, mapping;
+    int fd, needs_close;
 
     if ((*pwm = find_fullname_module( nt_name )))
     {
@@ -2252,10 +2342,11 @@ static NTSTATUS open_dll_file( UNICODE_STRING *nt_name, WINE_MODREF **pwm,
         return STATUS_DLL_NOT_FOUND;
     }
 
-    if (!NtFsControlFile( handle, 0, NULL, NULL, &io, FSCTL_GET_OBJECT_ID, NULL, 0, &fid, sizeof(fid) ))
+    if (!server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL ))
     {
-        memcpy( id, fid.ObjectId, sizeof(*id) );
-        if ((*pwm = find_fileid_module( id )))
+        fstat( fd, st );
+        if (needs_close) close( fd );
+        if ((*pwm = find_fileid_module( st )))
         {
             TRACE( "%s is the same file as existing module %p %s\n", debugstr_w( nt_name->Buffer ),
                    (*pwm)->ldr.DllBase, debugstr_w( (*pwm)->ldr.FullDllName.Buffer ));
@@ -2279,8 +2370,8 @@ static NTSTATUS open_dll_file( UNICODE_STRING *nt_name, WINE_MODREF **pwm,
             NtUnmapViewOfSection( NtCurrentProcess(), *module );
             *module = NULL;
         }
-        status = unix_funcs->virtual_map_section( mapping, module, 0, 0, NULL, &len,
-                                                  0, PAGE_EXECUTE_READ, image_info );
+        status = virtual_map_section( mapping, module, 0, 0, NULL, &len,
+                                      0, PAGE_EXECUTE_READ, image_info );
         if (status == STATUS_IMAGE_NOT_AT_BASE) status = STATUS_SUCCESS;
         NtClose( mapping );
     }
@@ -2299,10 +2390,254 @@ static NTSTATUS open_dll_file( UNICODE_STRING *nt_name, WINE_MODREF **pwm,
  *	load_native_dll  (internal)
  */
 static NTSTATUS load_native_dll( LPCWSTR load_path, const UNICODE_STRING *nt_name, void **module,
-                                 const pe_image_info_t *image_info, const struct file_id *id,
-                                 DWORD flags, WINE_MODREF** pwm )
+                                 const pe_image_info_t *image_info, DWORD flags, WINE_MODREF** pwm,
+                                 struct stat *st )
+{
+    IMAGE_NT_HEADERS *nt = RtlImageNtHeader( *module );
+    WINE_MODREF *wm;
+    NTSTATUS status;
+    const char *dll_type = (image_info->image_flags & IMAGE_FLAGS_WineBuiltin) ? "PE builtin" : "native";
+
+    TRACE("Trying %s dll %s\n", dll_type, debugstr_us(nt_name) );
+
+    /* perform base relocation, if necessary */
+
+    if ((status = perform_relocations( *module, nt, image_info->map_size ))) return status;
+
+    /* create the MODREF */
+
+    if (!(wm = alloc_module( *module, nt_name, (image_info->image_flags & IMAGE_FLAGS_WineBuiltin) )))
+        return STATUS_NO_MEMORY;
+
+    wm->dev = st->st_dev;
+    wm->ino = st->st_ino;
+    if (image_info->loader_flags) wm->ldr.Flags |= LDR_COR_IMAGE;
+    if (image_info->image_flags & IMAGE_FLAGS_ComPlusILOnly) wm->ldr.Flags |= LDR_COR_ILONLY;
+
+    set_security_cookie( *module, image_info->map_size );
+
+    /* fixup imports */
+
+    if (!(flags & DONT_RESOLVE_DLL_REFERENCES) &&
+        ((nt->FileHeader.Characteristics & IMAGE_FILE_DLL) ||
+         nt->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE))
+    {
+        if (wm->ldr.Flags & LDR_COR_ILONLY)
+            status = fixup_imports_ilonly( wm, load_path, &wm->ldr.EntryPoint );
+        else
+            status = fixup_imports( wm, load_path );
+        if (status != STATUS_SUCCESS)
+        {
+            /* the module has only be inserted in the load & memory order lists */
+            RemoveEntryList(&wm->ldr.InLoadOrderLinks);
+            RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
+
+            /* FIXME: there are several more dangling references
+             * left. Including dlls loaded by this dll before the
+             * failed one. Unrolling is rather difficult with the
+             * current structure and we can leave them lying
+             * around with no problems, so we don't care.
+             * As these might reference our wm, we don't free it.
+             */
+            *module = NULL;
+            return status;
+        }
+    }
+
+    /* send DLL load event */
+
+    SERVER_START_REQ( load_dll )
+    {
+        req->base       = wine_server_client_ptr( *module );
+        req->dbg_offset = nt->FileHeader.PointerToSymbolTable;
+        req->dbg_size   = nt->FileHeader.NumberOfSymbols;
+        req->name       = wine_server_client_ptr( &wm->ldr.FullDllName.Buffer );
+        wine_server_add_data( req, wm->ldr.FullDllName.Buffer, wm->ldr.FullDllName.Length );
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (image_info->image_flags & IMAGE_FLAGS_WineBuiltin)
+    {
+        if (TRACE_ON(relay)) RELAY_SetupDLL( *module );
+    }
+    else
+    {
+        if ((wm->ldr.Flags & LDR_IMAGE_IS_DLL) && TRACE_ON(snoop)) SNOOP_SetupDLL( *module );
+    }
+
+    TRACE_(loaddll)( "Loaded %s at %p: %s\n", debugstr_w(wm->ldr.FullDllName.Buffer), *module, dll_type );
+
+    wm->ldr.LoadCount = 1;
+    *pwm = wm;
+    *module = NULL;
+    return STATUS_SUCCESS;
+}
+
+
+/* check if the library is the correct architecture */
+/* only returns false for a valid library of the wrong arch */
+static int check_library_arch( int fd )
 {
-    return build_module( load_path, nt_name, module, image_info, id, flags, pwm );
+#ifdef __APPLE__
+    struct  /* Mach-O header */
+    {
+        unsigned int magic;
+        unsigned int cputype;
+    } header;
+
+    if (read( fd, &header, sizeof(header) ) != sizeof(header)) return 1;
+    if (header.magic != 0xfeedface) return 1;
+    if (sizeof(void *) == sizeof(int)) return !(header.cputype >> 24);
+    else return (header.cputype >> 24) == 1; /* CPU_ARCH_ABI64 */
+#else
+    struct  /* ELF header */
+    {
+        unsigned char magic[4];
+        unsigned char class;
+        unsigned char data;
+        unsigned char version;
+    } header;
+
+    if (read( fd, &header, sizeof(header) ) != sizeof(header)) return 1;
+    if (memcmp( header.magic, "\177ELF", 4 )) return 1;
+    if (header.version != 1 /* EV_CURRENT */) return 1;
+#ifdef WORDS_BIGENDIAN
+    if (header.data != 2 /* ELFDATA2MSB */) return 1;
+#else
+    if (header.data != 1 /* ELFDATA2LSB */) return 1;
+#endif
+    if (sizeof(void *) == sizeof(int)) return header.class == 1; /* ELFCLASS32 */
+    else return header.class == 2; /* ELFCLASS64 */
+#endif
+}
+
+static inline char *prepend( char *buffer, const char *str, size_t len )
+{
+    return memcpy( buffer - len, str, len );
+}
+
+/***********************************************************************
+ *           open_builtin_file
+ */
+static NTSTATUS open_builtin_file( char *name, WINE_MODREF **pwm, void **module,
+                                   pe_image_info_t *image_info, struct stat *st, char **so_name )
+{
+    ANSI_STRING strA;
+    UNICODE_STRING nt_name;
+    NTSTATUS status;
+    int fd;
+
+    nt_name.Buffer = NULL;
+    RtlInitString( &strA, name );
+    if ((status = wine_unix_to_nt_file_name( &strA, &nt_name ))) return status;
+
+    status = open_dll_file( &nt_name, pwm, module, image_info, st );
+    RtlFreeUnicodeString( &nt_name );
+
+    /* ignore non-builtins */
+    if (!status && !*pwm && !(image_info->image_flags & IMAGE_FLAGS_WineBuiltin))
+    {
+        WARN( "%s found in WINEDLLPATH but not a builtin, ignoring\n", debugstr_a(name) );
+        NtUnmapViewOfSection( NtCurrentProcess(), *module );
+        *module = NULL;
+        status = STATUS_DLL_NOT_FOUND;
+    }
+
+    if (status != STATUS_DLL_NOT_FOUND) return status;
+
+    /* try .so file */
+
+    strcat( name, ".so" );
+    if ((fd = open( name, O_RDONLY )) != -1)
+    {
+        if (check_library_arch( fd ))
+        {
+            if ((*so_name = RtlAllocateHeap( GetProcessHeap(), 0, strlen(name) + 1 )))
+                strcpy( *so_name, name );
+            NtUnmapViewOfSection( NtCurrentProcess(), *module );
+            *module = NULL;
+            status = STATUS_SUCCESS;
+        }
+        else status = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
+        close( fd );
+    }
+    return status;
+}
+
+
+/***********************************************************************
+ *           find_builtin_dll
+ */
+static NTSTATUS find_builtin_dll( const WCHAR *name, WINE_MODREF **pwm,
+                                  void **module, pe_image_info_t *image_info, struct stat *st,
+                                  char **so_name )
+{
+    unsigned int i, pos, len, namelen, maxlen = 0;
+    char *ptr, *file;
+    NTSTATUS status = STATUS_DLL_NOT_FOUND;
+    BOOL found_image = FALSE;
+    const char **dll_paths;
+    SIZE_T dll_path_maxlen;
+
+    unix_funcs->get_dll_path( &dll_paths, &dll_path_maxlen );
+
+    len = wcslen( name );
+    if (build_dir) maxlen = strlen(build_dir) + sizeof("/programs/") + len;
+    maxlen = max( maxlen, dll_path_maxlen + 1 ) + len + sizeof(".so");
+
+    if (!(file = RtlAllocateHeap( GetProcessHeap(), 0, maxlen ))) return STATUS_NO_MEMORY;
+
+    pos = maxlen - len - sizeof(".so");
+    /* we don't want to depend on the current codepage here */
+    for (i = 0; i < len; i++)
+    {
+        if (name[i] > 127) goto done;
+        file[pos + i] = (char)name[i];
+        if (file[pos + i] >= 'A' && file[pos + i] <= 'Z') file[pos + i] += 'a' - 'A';
+    }
+    file[--pos] = '/';
+
+    if (build_dir)
+    {
+        /* try as a dll */
+        ptr = file + pos;
+        namelen = len + 1;
+        file[pos + len + 1] = 0;
+        if (namelen > 4 && !memcmp( ptr + namelen - 4, ".dll", 4 )) namelen -= 4;
+        ptr = prepend( ptr, ptr, namelen );
+        ptr = prepend( ptr, "/dlls", sizeof("/dlls") - 1 );
+        ptr = prepend( ptr, build_dir, strlen(build_dir) );
+        status = open_builtin_file( ptr, pwm, module, image_info, st, so_name );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+
+        /* now as a program */
+        ptr = file + pos;
+        namelen = len + 1;
+        file[pos + len + 1] = 0;
+        if (namelen > 4 && !memcmp( ptr + namelen - 4, ".exe", 4 )) namelen -= 4;
+        ptr = prepend( ptr, ptr, namelen );
+        ptr = prepend( ptr, "/programs", sizeof("/programs") - 1 );
+        ptr = prepend( ptr, build_dir, strlen(build_dir) );
+        status = open_builtin_file( ptr, pwm, module, image_info, st, so_name );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+    }
+
+    for (i = 0; dll_paths[i]; i++)
+    {
+        file[pos + len + 1] = 0;
+        ptr = prepend( file + pos, dll_paths[i], strlen(dll_paths[i]) );
+        status = open_builtin_file( ptr, pwm, module, image_info, st, so_name );
+        if (status == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) found_image = TRUE;
+        else if (status != STATUS_DLL_NOT_FOUND) goto done;
+    }
+
+    if (found_image) status = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
+    WARN( "cannot find builtin library for %s\n", debugstr_w(name) );
+
+done:
+    RtlFreeHeap( GetProcessHeap(), 0, file );
+    return status;
 }
 
 
@@ -2310,33 +2645,108 @@ static NTSTATUS load_native_dll( LPCWSTR load_path, const UNICODE_STRING *nt_nam
  *           load_so_dll
  */
 static NTSTATUS load_so_dll( LPCWSTR load_path, const UNICODE_STRING *nt_name,
-                             DWORD flags, WINE_MODREF **pwm )
+                             const char *so_name, DWORD flags, WINE_MODREF** pwm )
 {
-    void *module;
-    NTSTATUS status;
-    WINE_MODREF *wm;
+    static const WCHAR soW[] = {'.','s','o',0};
+    DWORD len;
+    void *handle;
+    const IMAGE_NT_HEADERS *nt;
+    struct builtin_load_info info, *prev_info;
+    ANSI_STRING unix_name;
     UNICODE_STRING win_name = *nt_name;
 
-    TRACE( "trying %s as so lib\n", debugstr_us(&win_name) );
-    if (unix_funcs->load_so_dll( &win_name, &module ))
+    unix_name.Buffer = NULL;
+    info.load_path = load_path;
+    info.filename  = &win_name;
+    info.status    = STATUS_SUCCESS;
+    info.wm        = NULL;
+
+    if (!so_name)
     {
-        WARN( "failed to load .so lib %s\n", debugstr_us(nt_name) );
-        return STATUS_INVALID_IMAGE_FORMAT;
+        if (wine_nt_to_unix_file_name( nt_name, &unix_name, FILE_OPEN, FALSE ))
+            return STATUS_DLL_NOT_FOUND;
+
+        /* remove .so extension from Windows name */
+        len = nt_name->Length / sizeof(WCHAR);
+        if (len > 3 && !wcsicmp( nt_name->Buffer + len - 3, soW )) win_name.Length -= 3 * sizeof(WCHAR);
     }
 
-    if ((wm = get_modref( module )))  /* already loaded */
+    TRACE( "loading %s from so lib %s\n", debugstr_us(&win_name),
+           debugstr_a( so_name ? so_name : unix_name.Buffer ));
+
+    prev_info = builtin_load_info;
+    builtin_load_info = &info;
+    handle = dlopen( so_name ? so_name : unix_name.Buffer, RTLD_NOW );
+    builtin_load_info = prev_info;
+    RtlFreeHeap( GetProcessHeap(), 0, unix_name.Buffer );
+
+    if (!handle)
     {
+        if (so_name)
+        {
+            ERR("failed to load .so lib %s: %s\n", debugstr_a(so_name), dlerror() );
+            info.status = STATUS_PROCEDURE_NOT_FOUND;
+        }
+        else
+        {
+            WARN( "failed to load .so lib %s: %s\n", debugstr_us(nt_name), dlerror() );
+            info.status = STATUS_INVALID_IMAGE_FORMAT;
+        }
+    }
+
+    if (info.status != STATUS_SUCCESS) goto failed;
+
+    if (!info.wm && (nt = dlsym( handle, "__wine_spec_nt_header" )))
+    {
+        HMODULE module = (HMODULE)((nt->OptionalHeader.ImageBase + 0xffff) & ~0xffff);
+        if ((info.wm = get_modref( module )))  /* already loaded */
+        {
+            TRACE( "Found %s at %p for builtin %s\n",
+                   debugstr_w(info.wm->ldr.FullDllName.Buffer), info.wm->ldr.DllBase,
+                   debugstr_us(nt_name) );
+            if (info.wm->ldr.LoadCount != -1) info.wm->ldr.LoadCount++;
+            dlclose( handle );
+        }
+        else
+        {
+            if ((info.status = unix_funcs->map_so_dll( nt, module ))) goto failed;
+            if ((info.status = build_so_dll_module( load_path, &win_name, module, flags, &info.wm )))
+                goto failed;
+            TRACE_(loaddll)( "Loaded %s at %p: builtin\n",
+                             debugstr_w(info.wm->ldr.FullDllName.Buffer), info.wm->ldr.DllBase );
+            info.wm->ldr.LoadCount = 1;
+            info.wm->so_handle = handle;
+        }
+    }
+    else if (!info.wm)
+    {
+        /* The constructor wasn't called, this means the .so is already
+         * loaded under a different name. Try to find the wm for it. */
+
+        if (!(info.wm = find_so_module( handle )))
+        {
+            info.status = STATUS_INVALID_IMAGE_FORMAT;
+            goto failed;
+        }
         TRACE( "Found %s at %p for builtin %s\n",
-               debugstr_w(wm->ldr.FullDllName.Buffer), wm->ldr.DllBase, debugstr_us(nt_name) );
-        if (wm->ldr.LoadCount != -1) wm->ldr.LoadCount++;
+               debugstr_w(info.wm->ldr.FullDllName.Buffer), info.wm->ldr.DllBase,
+               debugstr_us(nt_name) );
+        if (info.wm->ldr.LoadCount != -1) info.wm->ldr.LoadCount++;
+        dlclose( handle ); /* release the libdl refcount */
     }
     else
     {
-        if ((status = build_builtin_module( load_path, &win_name, module, flags, &wm ))) return status;
-        TRACE_(loaddll)( "Loaded %s at %p: builtin\n", debugstr_us(nt_name), module );
+        TRACE_(loaddll)( "Loaded %s at %p: builtin\n", debugstr_w(info.wm->ldr.FullDllName.Buffer), info.wm->ldr.DllBase );
+        info.wm->ldr.LoadCount = 1;
+        info.wm->so_handle = handle;
     }
-    *pwm = wm;
+
+    *pwm = info.wm;
     return STATUS_SUCCESS;
+
+failed:
+    if (handle) dlclose( handle );
+    return info.status;
 }
 
 
@@ -2350,6 +2760,8 @@ static NTSTATUS load_builtin_dll( LPCWSTR load_path, const UNICODE_STRING *nt_na
     NTSTATUS status;
     void *module = NULL;
     pe_image_info_t image_info;
+    struct stat st;
+    char *so_name;
 
     /* Fix the name in case we have a full path and extension */
     name = nt_name->Buffer;
@@ -2360,22 +2772,26 @@ static NTSTATUS load_builtin_dll( LPCWSTR load_path, const UNICODE_STRING *nt_na
 
     if (!module_ptr) module_ptr = &module;
 
-    status = unix_funcs->load_builtin_dll( name, module_ptr, &image_info );
+    status = find_builtin_dll( name, pwm, module_ptr, &image_info, &st, &so_name );
     if (status) return status;
 
-    if ((*pwm = get_modref( *module_ptr )))  /* already loaded */
+    if (*pwm)
     {
         if ((*pwm)->ldr.LoadCount != -1) (*pwm)->ldr.LoadCount++;
         TRACE( "Found %s for %s at %p, count=%d\n",
                debugstr_w((*pwm)->ldr.FullDllName.Buffer), debugstr_w(name),
                (*pwm)->ldr.DllBase, (*pwm)->ldr.LoadCount);
-        *module_ptr = NULL;
         return STATUS_SUCCESS;
     }
 
-    TRACE( "loading %s from %s\n", debugstr_w(name), debugstr_us(nt_name) );
-    status = build_module( load_path, nt_name, module_ptr, &image_info, NULL, flags, pwm );
-    if (status && *module_ptr) unix_funcs->unload_builtin_dll( *module_ptr );
+    if (*module_ptr)
+    {
+        TRACE( "loading %s from PE builtin %s\n", debugstr_w(name), debugstr_us(nt_name) );
+        return load_native_dll( load_path, nt_name, module_ptr, &image_info, flags, pwm, &st );
+    }
+
+    status = load_so_dll( load_path, nt_name, so_name, flags, pwm );
+    RtlFreeHeap( GetProcessHeap(), 0, so_name );
     return status;
 }
 
@@ -2488,7 +2904,7 @@ done:
  */
 static NTSTATUS search_dll_file( LPCWSTR paths, LPCWSTR search, UNICODE_STRING *nt_name,
                                  WINE_MODREF **pwm, void **module, pe_image_info_t *image_info,
-                                 struct file_id *id )
+                                 struct stat *st )
 {
     WCHAR *name;
     BOOL found_image = FALSE;
@@ -2515,7 +2931,7 @@ static NTSTATUS search_dll_file( LPCWSTR paths, LPCWSTR search, UNICODE_STRING *
         nt_name->Buffer = NULL;
         if ((status = RtlDosPathNameToNtPathName_U_WithStatus( name, nt_name, NULL, NULL ))) goto done;
 
-        status = open_dll_file( nt_name, pwm, module, image_info, id );
+        status = open_dll_file( nt_name, pwm, module, image_info, st );
         if (status == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) found_image = TRUE;
         else if (status != STATUS_DLL_NOT_FOUND) goto done;
         RtlFreeUnicodeString( nt_name );
@@ -2544,7 +2960,7 @@ done:
  */
 static NTSTATUS find_dll_file( const WCHAR *load_path, const WCHAR *libname, const WCHAR *default_ext,
                                UNICODE_STRING *nt_name, WINE_MODREF **pwm,
-                               void **module, pe_image_info_t *image_info, struct file_id *id )
+                               void **module, pe_image_info_t *image_info, struct stat *st )
 {
     WCHAR *ext, *dllname;
     NTSTATUS status;
@@ -2595,9 +3011,9 @@ static NTSTATUS find_dll_file( const WCHAR *load_path, const WCHAR *libname, con
     }
 
     if (RtlDetermineDosPathNameType_U( libname ) == RELATIVE_PATH)
-        status = search_dll_file( load_path, libname, nt_name, pwm, module, image_info, id );
+        status = search_dll_file( load_path, libname, nt_name, pwm, module, image_info, st );
     else if (!(status = RtlDosPathNameToNtPathName_U_WithStatus( libname, nt_name, NULL, NULL )))
-        status = open_dll_file( nt_name, pwm, module, image_info, id );
+        status = open_dll_file( nt_name, pwm, module, image_info, st );
 
     if (status == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) status = STATUS_INVALID_IMAGE_FORMAT;
 
@@ -2620,14 +3036,14 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WC
     enum loadorder loadorder;
     WINE_MODREF *main_exe;
     UNICODE_STRING nt_name;
-    struct file_id id;
+    struct stat st;
     void *module;
     pe_image_info_t image_info;
     NTSTATUS nts;
 
     TRACE( "looking for %s in %s\n", debugstr_w(libname), debugstr_w(load_path) );
 
-    nts = find_dll_file( load_path, libname, default_ext, &nt_name, pwm, &module, &image_info, &id );
+    nts = find_dll_file( load_path, libname, default_ext, &nt_name, pwm, &module, &image_info, &st );
 
     if (*pwm)  /* found already loaded module */
     {
@@ -2655,7 +3071,7 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WC
         case LO_BUILTIN:
         case LO_BUILTIN_NATIVE:
         case LO_DEFAULT:
-            if (!load_so_dll( load_path, &nt_name, flags, pwm )) nts = STATUS_SUCCESS;
+            if (!load_so_dll( load_path, &nt_name, NULL, flags, pwm )) nts = STATUS_SUCCESS;
             break;
         default:
             nts = STATUS_DLL_NOT_FOUND;
@@ -2674,7 +3090,7 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WC
             case LO_DEFAULT:
                 nts = load_builtin_dll( load_path, &nt_name, &module, flags, pwm );
                 if (nts == STATUS_DLL_NOT_FOUND)
-                    nts = load_native_dll( load_path, &nt_name, &module, &image_info, &id, flags, pwm );
+                    nts = load_native_dll( load_path, &nt_name, &module, &image_info, flags, pwm, &st );
                 break;
             default:
                 nts = STATUS_DLL_NOT_FOUND;
@@ -2689,7 +3105,7 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WC
             {
             case LO_NATIVE:
             case LO_NATIVE_BUILTIN:
-                nts = load_native_dll( load_path, &nt_name, &module, &image_info, &id, flags, pwm );
+                nts = load_native_dll( load_path, &nt_name, &module, &image_info, flags, pwm, &st );
                 break;
             case LO_BUILTIN:
                 nts = load_builtin_dll( load_path, &nt_name, &module, flags, pwm );
@@ -2705,10 +3121,10 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WC
                     LdrUnloadDll( (*pwm)->ldr.DllBase );
                     nts = STATUS_DLL_NOT_FOUND;
                     /* map the dll again if it was unmapped */
-                    if (!module && open_dll_file( &nt_name, pwm, &module, &image_info, &id )) break;
+                    if (!module && open_dll_file( &nt_name, pwm, &module, &image_info, &st )) break;
                 }
                 if (nts == STATUS_DLL_NOT_FOUND)
-                    nts = load_native_dll( load_path, &nt_name, &module, &image_info, &id, flags, pwm );
+                    nts = load_native_dll( load_path, &nt_name, &module, &image_info, flags, pwm, &st );
                 break;
             default:
                 nts = STATUS_DLL_NOT_FOUND;
@@ -2787,13 +3203,13 @@ NTSTATUS WINAPI LdrGetDllHandle( LPCWSTR load_path, ULONG flags, const UNICODE_S
     WINE_MODREF *wm;
     void *module;
     pe_image_info_t image_info;
-    struct file_id id;
+    struct stat st;
 
     RtlEnterCriticalSection( &loader_section );
 
     if (!load_path) load_path = NtCurrentTeb()->Peb->ProcessParameters->DllPath.Buffer;
 
-    status = find_dll_file( load_path, name->Buffer, dllW, &nt_name, &wm, &module, &image_info, &id );
+    status = find_dll_file( load_path, name->Buffer, dllW, &nt_name, &wm, &module, &image_info, &st );
 
     if (wm) *base = wm->ldr.DllBase;
     else
@@ -3176,7 +3592,8 @@ void WINAPI RtlExitUserProcess( DWORD status )
     RtlAcquirePebLock();
     NtTerminateProcess( 0, status );
     LdrShutdownProcess();
-    for (;;) NtTerminateProcess( GetCurrentProcess(), status );
+    NtTerminateProcess( GetCurrentProcess(), status );
+    exit( get_unix_exit_code( status ));
 }
 
 /******************************************************************
@@ -3217,6 +3634,8 @@ void WINAPI LdrShutdownThread(void)
 
     RtlAcquirePebLock();
     RemoveEntryList( &NtCurrentTeb()->TlsLinks );
+    RtlReleasePebLock();
+
     if ((pointers = NtCurrentTeb()->ThreadLocalStoragePointer))
     {
         for (i = 0; i < tls_module_count; i++) RtlFreeHeap( GetProcessHeap(), 0, pointers[i] );
@@ -3224,9 +3643,6 @@ void WINAPI LdrShutdownThread(void)
     }
     RtlFreeHeap( GetProcessHeap(), 0, NtCurrentTeb()->FlsSlots );
     RtlFreeHeap( GetProcessHeap(), 0, NtCurrentTeb()->TlsExpansionSlots );
-    NtCurrentTeb()->TlsExpansionSlots = NULL;
-    RtlReleasePebLock();
-
     RtlLeaveCriticalSection( &loader_section );
 }
 
@@ -3257,7 +3673,7 @@ static void free_modref( WINE_MODREF *wm )
 
     free_tls_slot( &wm->ldr );
     RtlReleaseActivationContext( wm->ldr.ActivationContext );
-    unix_funcs->unload_builtin_dll( wm->ldr.DllBase );
+    if (wm->so_handle) dlclose( wm->so_handle );
     NtUnmapViewOfSection( NtCurrentProcess(), wm->ldr.DllBase );
     if (cached_modref == wm) cached_modref = NULL;
     RtlFreeUnicodeString( &wm->ldr.FullDllName );
@@ -3409,6 +3825,7 @@ PIMAGE_NT_HEADERS WINAPI RtlImageNtHeader(HMODULE hModule)
  */
 void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknown3, ULONG_PTR unknown4 )
 {
+    static const LARGE_INTEGER zero;
     static int attach_done;
     int i;
     NTSTATUS status;
@@ -3416,6 +3833,8 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknow
     WINE_MODREF *wm;
     LPCWSTR load_path = NtCurrentTeb()->Peb->ProcessParameters->DllPath.Buffer;
 
+    pthread_sigmask( SIG_UNBLOCK, &server_block_set, NULL );
+
     if (process_detaching) return;
 
     RtlEnterCriticalSection( &loader_section );
@@ -3472,9 +3891,9 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknow
             }
         }
         attach_implicitly_loaded_dlls( context );
-        unix_funcs->virtual_release_address_space();
+        virtual_release_address_space();
         if (wm->ldr.TlsIndex != -1) call_tls_callbacks( wm->ldr.DllBase, DLL_PROCESS_ATTACH );
-        if (wm->ldr.Flags & LDR_WINE_INTERNAL) unix_funcs->init_builtin_dll( wm->ldr.DllBase );
+        if (wm->so_handle) call_constructors( wm );
         if (wm->ldr.ActivationContext) RtlDeactivateActivationContext( 0, cookie );
     }
     else
@@ -3486,6 +3905,8 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknow
     }
 
     RtlLeaveCriticalSection( &loader_section );
+
+    NtDelayExecution( TRUE, &zero );
 }
 
 
@@ -3877,6 +4298,28 @@ void WINAPI RtlReleasePath( PWSTR path )
 }
 
 
+/***********************************************************************
+ *           NtLoadDriver   (NTDLL.@)
+ *           ZwLoadDriver   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtLoadDriver( const UNICODE_STRING *DriverServiceName )
+{
+    FIXME("(%p), stub!\n",DriverServiceName);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+
+/***********************************************************************
+ *           NtUnloadDriver   (NTDLL.@)
+ *           ZwUnloadDriver   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtUnloadDriver( const UNICODE_STRING *DriverServiceName )
+{
+    FIXME("(%p), stub!\n",DriverServiceName);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+
 /******************************************************************
  *		DllMain   (NTDLL.@)
  */
@@ -3887,84 +4330,102 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
 }
 
 
+static NTSTATUS load_ntdll_so( HMODULE module, const IMAGE_NT_HEADERS *nt )
+{
+    NTSTATUS (__cdecl *init_func)( HMODULE module, const void *ptr_in, void *ptr_out );
+    Dl_info info;
+    char *name;
+    void *handle;
+
+    if (!dladdr( load_ntdll_so, &info ))
+    {
+        fprintf( stderr, "cannot get path to ntdll.dll.so\n" );
+        exit(1);
+    }
+    name = strdup( info.dli_fname );
+    strcpy( name + strlen(name) - strlen(".dll.so"), ".so" );
+    if (!(handle = dlopen( name, RTLD_NOW )))
+    {
+        fprintf( stderr, "failed to load %s: %s\n", name, dlerror() );
+        exit(1);
+    }
+    if (!(init_func = dlsym( handle, "__wine_init_unix_lib" )))
+    {
+        fprintf( stderr, "init func not found in %s\n", name );
+        exit(1);
+    }
+    return init_func( module, nt, &unix_funcs );
+}
+
 /***********************************************************************
  *           __wine_process_init
  */
 void __wine_process_init(void)
 {
+    extern IMAGE_NT_HEADERS __wine_spec_nt_header;
     static const WCHAR ntdllW[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\',
                                    's','y','s','t','e','m','3','2','\\',
                                    'n','t','d','l','l','.','d','l','l',0};
     static const WCHAR kernel32W[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\',
                                       's','y','s','t','e','m','3','2','\\',
                                       'k','e','r','n','e','l','3','2','.','d','l','l',0};
-    void (WINAPI *kernel32_start_process)(LPTHREAD_START_ROUTINE,void*) = NULL;
     RTL_USER_PROCESS_PARAMETERS *params;
     WINE_MODREF *wm;
     NTSTATUS status;
     ANSI_STRING func_name;
     UNICODE_STRING nt_name;
-    MEMORY_BASIC_INFORMATION meminfo;
+    HMODULE ntdll_module = (HMODULE)((__wine_spec_nt_header.OptionalHeader.ImageBase + 0xffff) & ~0xffff);
     INITIAL_TEB stack;
-    TEB *teb = NtCurrentTeb();
-    PEB *peb = teb->Peb;
-
-    peb->LdrData            = &ldr;
-    peb->FastPebLock        = &peb_lock;
-    peb->TlsBitmap          = &tls_bitmap;
-    peb->TlsExpansionBitmap = &tls_expansion_bitmap;
-    peb->FlsBitmap          = &fls_bitmap;
-    peb->LoaderLock         = &loader_section;
-    peb->OSMajorVersion     = 5;
-    peb->OSMinorVersion     = 1;
-    peb->OSBuildNumber      = 0xA28;
-    peb->OSPlatformId       = VER_PLATFORM_WIN32_NT;
-    peb->SessionId          = 1;
-    peb->ProcessHeap        = RtlCreateHeap( HEAP_GROWABLE, NULL, 0, 0, NULL, NULL );
-
-    InitializeListHead( &peb->FlsListHead );
-    RtlInitializeBitMap( &tls_bitmap, peb->TlsBitmapBits, sizeof(peb->TlsBitmapBits) * 8 );
-    RtlInitializeBitMap( &tls_expansion_bitmap, peb->TlsExpansionBitmapBits,
-                         sizeof(peb->TlsExpansionBitmapBits) * 8 );
-    RtlInitializeBitMap( &fls_bitmap, peb->FlsBitmapBits, sizeof(peb->FlsBitmapBits) * 8 );
-    RtlSetBits( peb->TlsBitmap, 0, 1 ); /* TLS index 0 is reserved and should be initialized to NULL. */
-    RtlSetBits( peb->FlsBitmap, 0, 1 );
-
-    InitializeListHead( &ldr.InLoadOrderModuleList );
-    InitializeListHead( &ldr.InMemoryOrderModuleList );
-    InitializeListHead( &ldr.InInitializationOrderModuleList );
-
-#ifndef _WIN64
-    is_wow64 = !!NtCurrentTeb64();
-#endif
+    BOOL suspend;
+    SIZE_T info_size;
+    TEB *teb;
+    PEB *peb;
+
+    if (!unix_funcs) load_ntdll_so( ntdll_module, &__wine_spec_nt_header );
+
+    teb = thread_init();
+    peb = teb->Peb;
+
+    /* setup the server connection */
+    server_init_process();
+    info_size = server_init_thread( peb, &suspend );
+
+    peb->ProcessHeap = RtlCreateHeap( HEAP_GROWABLE, NULL, 0, 0, NULL, NULL );
+    peb->LoaderLock = &loader_section;
 
     init_unix_codepage();
     init_directories();
-    init_user_process_params();
+    init_user_process_params( info_size );
     params = peb->ProcessParameters;
 
+    NtCreateKeyedEvent( &keyed_event, GENERIC_READ | GENERIC_WRITE, NULL, 0 );
+
+    /* retrieve current umask */
+    FILE_umask = umask(0777);
+    umask( FILE_umask );
+
     load_global_options();
     version_init();
 
     /* setup the load callback and create ntdll modref */
     RtlInitUnicodeString( &nt_name, ntdllW );
-    NtQueryVirtualMemory( GetCurrentProcess(), __wine_process_init, MemoryBasicInformation,
-                          &meminfo, sizeof(meminfo), NULL );
-    status = build_builtin_module( params->DllPath.Buffer, &nt_name, meminfo.AllocationBase, 0, &wm );
+    status = build_so_dll_module( params->DllPath.Buffer, &nt_name, ntdll_module, 0, &wm );
     assert( !status );
 
+    wine_dll_set_callback( load_builtin_callback );
+
     RtlInitUnicodeString( &nt_name, kernel32W );
     if ((status = load_builtin_dll( params->DllPath.Buffer, &nt_name, NULL, 0, &wm )) != STATUS_SUCCESS)
     {
         MESSAGE( "wine: could not load kernel32.dll, status %x\n", status );
-        NtTerminateProcess( GetCurrentProcess(), status );
+        exit(1);
     }
     RtlInitAnsiString( &func_name, "__wine_start_process" );
     if ((status = LdrGetProcedureAddress( wm->ldr.DllBase, &func_name,
                                           0, (void **)&kernel32_start_process )) != STATUS_SUCCESS)
     {
         MESSAGE( "wine: could not find __wine_start_process in kernel32.dll, status %x\n", status );
-        NtTerminateProcess( GetCurrentProcess(), status );
+        exit(1);
     }
 
     init_locale( wm->ldr.DllBase );
@@ -3982,7 +4443,7 @@ void __wine_process_init(void)
     }
     else
     {
-        status = restart_process( params, status );
+        if (!info_size) status = restart_process( params, status );
         switch (status)
         {
         case STATUS_INVALID_IMAGE_WIN_64:
@@ -4008,18 +4469,7 @@ void __wine_process_init(void)
         NtTerminateProcess( GetCurrentProcess(), status );
     }
 
-#ifndef _WIN64
-    if (NtCurrentTeb64())
-    {
-        PEB64 *peb64 = UlongToPtr( NtCurrentTeb64()->Peb );
-        peb64->ImageBaseAddress = PtrToUlong( peb->ImageBaseAddress );
-        peb64->OSMajorVersion   = peb->OSMajorVersion;
-        peb64->OSMinorVersion   = peb->OSMinorVersion;
-        peb64->OSBuildNumber    = peb->OSBuildNumber;
-        peb64->OSPlatformId     = peb->OSPlatformId;
-        peb64->SessionId        = peb->SessionId;
-    }
-#endif
+    virtual_set_large_address_space();
 
     /* the main exe needs to be the first in the load order list */
     RemoveEntryList( &wm->ldr.InLoadOrderLinks );
@@ -4027,12 +4477,12 @@ void __wine_process_init(void)
     RemoveEntryList( &wm->ldr.InMemoryOrderLinks );
     InsertHeadList( &peb->LdrData->InMemoryOrderModuleList, &wm->ldr.InMemoryOrderLinks );
 
-    RtlCreateUserStack( 0, 0, 0, 0x10000, 0x10000, &stack );
+    virtual_alloc_thread_stack( &stack, 0, 0, NULL );
     teb->Tib.StackBase = stack.StackBase;
     teb->Tib.StackLimit = stack.StackLimit;
     teb->DeallocationStack = stack.DeallocationStack;
 
-    unix_funcs->server_init_process_done( kernel32_start_process );
+    server_init_process_done();
 }
 
 /***********************************************************************
diff --git a/dlls/ntdll/loadorder.c b/dlls/ntdll/loadorder.c
index c55806df2b..dad5d915da 100644
--- a/dlls/ntdll/loadorder.c
+++ b/dlls/ntdll/loadorder.c
@@ -19,13 +19,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
 #include "windef.h"
 #include "winternl.h"
 #include "ntdll_misc.h"
@@ -61,7 +62,7 @@ static struct loadorder_list env_list;
  * Sorting and comparing function used in sort and search of loadorder
  * entries.
  */
-static int __cdecl cmp_sort_func(const void *s1, const void *s2)
+static int cmp_sort_func(const void *s1, const void *s2)
 {
     return wcsicmp(((const module_loadorder_t *)s1)->modulename, ((const module_loadorder_t *)s2)->modulename);
 }
@@ -180,7 +181,7 @@ static void add_load_order( const module_loadorder_t *plo )
         if(!env_list.order)
         {
             MESSAGE("Virtual memory exhausted\n");
-            NtTerminateProcess( GetCurrentProcess(), 1 );
+            exit(1);
         }
     }
     env_list.order[i].loadorder  = plo->loadorder;
@@ -224,28 +225,29 @@ static void add_load_order_set( WCHAR *entry )
  */
 static void init_load_order(void)
 {
-    static const WCHAR winedlloverridesW[] = {'W','I','N','E','D','L','L','O','V','E','R','R','I','D','E','S',0};
-    WCHAR *entry, *next, *order;
-    SIZE_T len = 1024;
-    NTSTATUS status;
+    const char *order = getenv( "WINEDLLOVERRIDES" );
+    UNICODE_STRING strW;
+    WCHAR *entry, *next;
 
     init_done = TRUE;
+    if (!order) return;
 
-    for (;;)
+    if (!strcmp( order, "help" ))
     {
-        order = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) );
-        status = RtlQueryEnvironmentVariable( NULL, winedlloverridesW, wcslen(winedlloverridesW),
-                                              order, len - 1, &len );
-        if (!status)
-        {
-            order[len] = 0;
-            break;
-        }
-        RtlFreeHeap( GetProcessHeap(), 0, order );
-        if (status != STATUS_BUFFER_TOO_SMALL) return;
+        MESSAGE( "Syntax:\n"
+                 "  WINEDLLOVERRIDES=\"entry;entry;entry...\"\n"
+                 "    where each entry is of the form:\n"
+                 "        module[,module...]={native|builtin}[,{b|n}]\n"
+                 "\n"
+                 "    Only the first letter of the override (native or builtin)\n"
+                 "    is significant.\n\n"
+                 "Example:\n"
+                 "  WINEDLLOVERRIDES=\"comdlg32=n,b;shell32,shlwapi=b\"\n" );
+        exit(0);
     }
 
-    entry = order;
+    RtlCreateUnicodeStringFromAsciiz( &strW, order );
+    entry = strW.Buffer;
     while (*entry)
     {
         while (*entry == ';') entry++;
@@ -261,7 +263,8 @@ static void init_load_order(void)
     if (env_list.count)
         qsort(env_list.order, env_list.count, sizeof(env_list.order[0]), cmp_sort_func);
 
-    /* note: we don't free the string because the stored module names point inside it */
+    /* Note: we don't free the Unicode string because the
+     * stored module names point inside it */
 }
 
 
diff --git a/dlls/ntdll/locale.c b/dlls/ntdll/locale.c
index 81263f4616..15ccdeb2e6 100644
--- a/dlls/ntdll/locale.c
+++ b/dlls/ntdll/locale.c
@@ -19,11 +19,19 @@
  */
 
 #define NONAMELESSUNION
+#include "config.h"
+#include "wine/port.h"
 
+#include <locale.h>
 #include <stdarg.h>
 #include <string.h>
 #include <stdlib.h>
 
+#ifdef __APPLE__
+# include <CoreFoundation/CFLocale.h>
+# include <CoreFoundation/CFString.h>
+#endif
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -102,6 +110,7 @@ struct norm_table
 
 LCID user_lcid = 0, system_lcid = 0;
 
+static LANGID user_ui_language, system_ui_language;
 static NLSTABLEINFO nls_info;
 static HMODULE kernel32_handle;
 static CPTABLEINFO unix_table;
@@ -582,16 +591,16 @@ static NTSTATUS open_nls_data_file( ULONG type, ULONG id, HANDLE *file )
         break;
     case NLS_SECTION_CASEMAP:
         if (id) return STATUS_UNSUCCESSFUL;
-        swprintf( buffer, ARRAY_SIZE(buffer), keyfmtW, langW );
-        swprintf( value, ARRAY_SIZE(value), langfmtW, LANGIDFROMLCID(system_lcid) );
+        NTDLL_swprintf( buffer, keyfmtW, langW );
+        NTDLL_swprintf( value, langfmtW, LANGIDFROMLCID(system_lcid) );
         break;
     case NLS_SECTION_CODEPAGE:
-        swprintf( buffer, ARRAY_SIZE(buffer), keyfmtW, cpW );
-        swprintf( value, ARRAY_SIZE(value), cpfmtW, id );
+        NTDLL_swprintf( buffer, keyfmtW, cpW );
+        NTDLL_swprintf( value, cpfmtW, id );
         break;
     case NLS_SECTION_NORMALIZE:
-        swprintf( buffer, ARRAY_SIZE(buffer), keyfmtW, normW );
-        swprintf( value, ARRAY_SIZE(value), normfmtW, id );
+        NTDLL_swprintf( buffer, keyfmtW, normW );
+        NTDLL_swprintf( value, normfmtW, id );
         break;
     default:
         return STATUS_INVALID_PARAMETER_1;
@@ -627,7 +636,7 @@ static NTSTATUS open_nls_data_file( ULONG type, ULONG id, HANDLE *file )
             name = intlW;
             break;
         case NLS_SECTION_CODEPAGE:
-            swprintf( buffer, ARRAY_SIZE(buffer), cpdefaultW, id );
+            NTDLL_swprintf( buffer, cpdefaultW, id );
             name = buffer;
             break;
         case NLS_SECTION_NORMALIZE:
@@ -649,8 +658,7 @@ static NTSTATUS open_nls_data_file( ULONG type, ULONG id, HANDLE *file )
     valueW.MaximumLength = (wcslen(name) + wcslen(dir) + 5) * sizeof(WCHAR);
     if (!(valueW.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, valueW.MaximumLength )))
         return STATUS_NO_MEMORY;
-    valueW.Length = swprintf( valueW.Buffer, valueW.MaximumLength/sizeof(WCHAR),
-                              pathfmtW, dir, name ) * sizeof(WCHAR);
+    valueW.Length = NTDLL_swprintf( valueW.Buffer, pathfmtW, dir, name ) * sizeof(WCHAR);
     InitializeObjectAttributes( &attr, &valueW, 0, 0, NULL );
     status = NtOpenFile( file, GENERIC_READ, &attr, &io, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_ALERT );
     if (!status) TRACE( "found %s\n", debugstr_w( valueW.Buffer ));
@@ -686,22 +694,83 @@ static NTSTATUS open_nls_data_file( ULONG type, ULONG id, HANDLE *file )
 
 void init_unix_codepage(void)
 {
-    USHORT *data = unix_funcs->get_unix_codepage_data();
-    if (data) RtlInitCodePageTable( data, &unix_table );
+    unix_funcs->get_unix_codepage( &unix_table );
 }
 
-
-static LCID locale_to_lcid( WCHAR *win_name )
+/* Unix format is: lang[_country][.charset][@modifier]
+ * Windows format is: lang[-script][-country][_modifier] */
+static LCID unix_locale_to_lcid( const char *unix_name )
 {
-    WCHAR *p;
+    static const WCHAR sepW[] = {'_','.','@',0};
+    static const WCHAR posixW[] = {'P','O','S','I','X',0};
+    static const WCHAR cW[] = {'C',0};
+    static const WCHAR euroW[] = {'e','u','r','o',0};
+    static const WCHAR latinW[] = {'l','a','t','i','n',0};
+    static const WCHAR latnW[] = {'-','L','a','t','n',0};
+    WCHAR buffer[LOCALE_NAME_MAX_LENGTH], win_name[LOCALE_NAME_MAX_LENGTH];
+    WCHAR *p, *country = NULL, *modifier = NULL;
+    DWORD len;
     LCID lcid;
 
+    if (!unix_name || !unix_name[0] || !strcmp( unix_name, "C" ))
+    {
+        unix_name = getenv( "LC_ALL" );
+        if (!unix_name || !unix_name[0]) return 0;
+    }
+
+    len = ntdll_umbstowcs( unix_name, strlen(unix_name), buffer, ARRAY_SIZE(buffer) );
+    if (len == ARRAY_SIZE(buffer)) return 0;
+    buffer[len] = 0;
+
+    if (!(p = wcspbrk( buffer, sepW )))
+    {
+        if (!wcscmp( buffer, posixW ) || !wcscmp( buffer, cW ))
+            return MAKELCID( MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), SORT_DEFAULT );
+        wcscpy( win_name, buffer );
+    }
+    else
+    {
+        if (*p == '_')
+        {
+            *p++ = 0;
+            country = p;
+            p = wcspbrk( p, sepW + 1 );
+        }
+        if (p && *p == '.')
+        {
+            *p++ = 0;
+            /* charset, ignore */
+            p = wcschr( p, '@' );
+        }
+        if (p)
+        {
+            *p++ = 0;
+            modifier = p;
+        }
+    }
+
+    /* rebuild a Windows name */
+
+    wcscpy( win_name, buffer );
+    if (modifier)
+    {
+        if (!wcscmp( modifier, latinW )) wcscat( win_name, latnW );
+        else if (!wcscmp( modifier, euroW )) {} /* ignore */
+        else return 0;
+    }
+    if (country)
+    {
+        p = win_name + wcslen(win_name);
+        *p++ = '-';
+        wcscpy( p, country );
+    }
+
     if (!RtlLocaleNameToLcid( win_name, &lcid, 0 )) return lcid;
 
     /* try neutral name */
-    if ((p = wcsrchr( win_name, '-' )))
+    if (country)
     {
-        *p = 0;
+        p[-1] = 0;
         if (!RtlLocaleNameToLcid( win_name, &lcid, 2 ))
         {
             if (SUBLANGID(lcid) == SUBLANG_NEUTRAL)
@@ -718,14 +787,75 @@ static LCID locale_to_lcid( WCHAR *win_name )
  */
 void init_locale( HMODULE module )
 {
-    WCHAR system_locale[LOCALE_NAME_MAX_LENGTH];
-    WCHAR user_locale[LOCALE_NAME_MAX_LENGTH];
+    LCID system_lcid, user_lcid;
 
     kernel32_handle = module;
 
-    unix_funcs->get_locales( system_locale, user_locale );
-    system_lcid = locale_to_lcid( system_locale );
-    user_lcid = locale_to_lcid( user_locale );
+    setlocale( LC_ALL, "" );
+
+    system_lcid = unix_locale_to_lcid( setlocale( LC_CTYPE, NULL ));
+    user_lcid = unix_locale_to_lcid( setlocale( LC_MESSAGES, NULL ));
+
+#ifdef __APPLE__
+    {
+        const struct norm_table *info;
+        load_norm_table( NormalizationC, &info );
+    }
+    if (!system_lcid)
+    {
+        char buffer[LOCALE_NAME_MAX_LENGTH];
+
+        CFLocaleRef locale = CFLocaleCopyCurrent();
+        CFStringRef lang = CFLocaleGetValue( locale, kCFLocaleLanguageCode );
+        CFStringRef country = CFLocaleGetValue( locale, kCFLocaleCountryCode );
+        CFStringRef locale_string;
+
+        if (country)
+            locale_string = CFStringCreateWithFormat(NULL, NULL, CFSTR("%@_%@"), lang, country);
+        else
+            locale_string = CFStringCreateCopy(NULL, lang);
+
+        CFStringGetCString(locale_string, buffer, sizeof(buffer), kCFStringEncodingUTF8);
+        system_lcid = unix_locale_to_lcid( buffer );
+        CFRelease(locale);
+        CFRelease(locale_string);
+    }
+    if (!user_lcid)
+    {
+        /* Retrieve the preferred language as chosen in System Preferences. */
+        char buffer[LOCALE_NAME_MAX_LENGTH];
+        CFArrayRef preferred_langs = CFLocaleCopyPreferredLanguages();
+        if (preferred_langs && CFArrayGetCount( preferred_langs ))
+        {
+            CFStringRef preferred_lang = CFArrayGetValueAtIndex( preferred_langs, 0 );
+            CFDictionaryRef components = CFLocaleCreateComponentsFromLocaleIdentifier( NULL, preferred_lang );
+            if (components)
+            {
+                CFStringRef lang = CFDictionaryGetValue( components, kCFLocaleLanguageCode );
+                CFStringRef country = CFDictionaryGetValue( components, kCFLocaleCountryCode );
+                CFLocaleRef locale = NULL;
+                CFStringRef locale_string;
+
+                if (!country)
+                {
+                    locale = CFLocaleCopyCurrent();
+                    country = CFLocaleGetValue( locale, kCFLocaleCountryCode );
+                }
+                if (country)
+                    locale_string = CFStringCreateWithFormat( NULL, NULL, CFSTR("%@_%@"), lang, country );
+                else
+                    locale_string = CFStringCreateCopy( NULL, lang );
+                CFStringGetCString( locale_string, buffer, sizeof(buffer), kCFStringEncodingUTF8 );
+                CFRelease( locale_string );
+                if (locale) CFRelease( locale );
+                CFRelease( components );
+                user_lcid = unix_locale_to_lcid( buffer );
+            }
+        }
+        if (preferred_langs) CFRelease( preferred_langs );
+    }
+#endif
+
     if (!system_lcid) system_lcid = MAKELCID( MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), SORT_DEFAULT );
     if (!user_lcid) user_lcid = system_lcid;
 
@@ -733,6 +863,8 @@ void init_locale( HMODULE module )
     NtSetDefaultLocale( TRUE, user_lcid );
     NtSetDefaultLocale( FALSE, system_lcid );
     TRACE( "system=%04x user=%04x\n", system_lcid, user_lcid );
+
+    setlocale( LC_NUMERIC, "C" );  /* FIXME: oleaut32 depends on this */
 }
 
 
@@ -747,7 +879,13 @@ DWORD ntdll_umbstowcs( const char *src, DWORD srclen, WCHAR *dst, DWORD dstlen )
         RtlCustomCPToUnicodeN( &unix_table, dst, dstlen * sizeof(WCHAR), &reslen, src, srclen );
     else
         RtlUTF8ToUnicodeN( dst, dstlen * sizeof(WCHAR), &reslen, src, srclen );
-    return reslen / sizeof(WCHAR);
+
+    reslen /= sizeof(WCHAR);
+#ifdef __APPLE__  /* work around broken Mac OS X filesystem that enforces decomposed Unicode */
+    if (reslen && dst && norm_tables[NormalizationC])
+        reslen = compose_string( norm_tables[NormalizationC], dst, reslen );
+#endif
+    return reslen;
 }
 
 
@@ -812,6 +950,61 @@ UINT CDECL __wine_get_unix_codepage(void)
 }
 
 
+/**********************************************************************
+ *      NtQueryDefaultLocale  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryDefaultLocale( BOOLEAN user, LCID *lcid )
+{
+    *lcid = user ? user_lcid : system_lcid;
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *      NtSetDefaultLocale  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetDefaultLocale( BOOLEAN user, LCID lcid )
+{
+    if (user) user_lcid = lcid;
+    else
+    {
+        system_lcid = lcid;
+        system_ui_language = LANGIDFROMLCID(lcid); /* there is no separate call to set it */
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *      NtQueryDefaultUILanguage  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryDefaultUILanguage( LANGID *lang )
+{
+    *lang = user_ui_language;
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *      NtSetDefaultUILanguage  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetDefaultUILanguage( LANGID lang )
+{
+    user_ui_language = lang;
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *      NtQueryInstallUILanguage  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryInstallUILanguage( LANGID *lang )
+{
+    *lang = system_ui_language;
+    return STATUS_SUCCESS;
+}
+
+
 static NTSTATUS get_dummy_preferred_ui_language( DWORD flags, LANGID lang, ULONG *count,
                                                  WCHAR *buffer, ULONG *size )
 {
@@ -848,12 +1041,8 @@ static NTSTATUS get_dummy_preferred_ui_language( DWORD flags, LANGID lang, ULONG
  */
 NTSTATUS WINAPI RtlGetProcessPreferredUILanguages( DWORD flags, ULONG *count, WCHAR *buffer, ULONG *size )
 {
-    LANGID ui_language;
-
     FIXME( "%08x, %p, %p %p\n", flags, count, buffer, size );
-
-    NtQueryDefaultUILanguage( &ui_language );
-    return get_dummy_preferred_ui_language( flags, ui_language, count, buffer, size );
+    return get_dummy_preferred_ui_language( flags, user_ui_language, count, buffer, size );
 }
 
 
@@ -863,14 +1052,11 @@ NTSTATUS WINAPI RtlGetProcessPreferredUILanguages( DWORD flags, ULONG *count, WC
 NTSTATUS WINAPI RtlGetSystemPreferredUILanguages( DWORD flags, ULONG unknown, ULONG *count,
                                                   WCHAR *buffer, ULONG *size )
 {
-    LANGID ui_language;
-
     if (flags & ~(MUI_LANGUAGE_NAME | MUI_LANGUAGE_ID | MUI_MACHINE_LANGUAGE_SETTINGS)) return STATUS_INVALID_PARAMETER;
     if ((flags & MUI_LANGUAGE_NAME) && (flags & MUI_LANGUAGE_ID)) return STATUS_INVALID_PARAMETER;
     if (*size && !buffer) return STATUS_INVALID_PARAMETER;
 
-    NtQueryInstallUILanguage( &ui_language );
-    return get_dummy_preferred_ui_language( flags, ui_language, count, buffer, size );
+    return get_dummy_preferred_ui_language( flags, system_ui_language, count, buffer, size );
 }
 
 
@@ -879,12 +1065,8 @@ NTSTATUS WINAPI RtlGetSystemPreferredUILanguages( DWORD flags, ULONG unknown, UL
  */
 NTSTATUS WINAPI RtlGetThreadPreferredUILanguages( DWORD flags, ULONG *count, WCHAR *buffer, ULONG *size )
 {
-    LANGID ui_language;
-
     FIXME( "%08x, %p, %p %p\n", flags, count, buffer, size );
-
-    NtQueryDefaultUILanguage( &ui_language );
-    return get_dummy_preferred_ui_language( flags, ui_language, count, buffer, size );
+    return get_dummy_preferred_ui_language( flags, user_ui_language, count, buffer, size );
 }
 
 
@@ -894,14 +1076,11 @@ NTSTATUS WINAPI RtlGetThreadPreferredUILanguages( DWORD flags, ULONG *count, WCH
 NTSTATUS WINAPI RtlGetUserPreferredUILanguages( DWORD flags, ULONG unknown, ULONG *count,
                                                 WCHAR *buffer, ULONG *size )
 {
-    LANGID ui_language;
-
     if (flags & ~(MUI_LANGUAGE_NAME | MUI_LANGUAGE_ID)) return STATUS_INVALID_PARAMETER;
     if ((flags & MUI_LANGUAGE_NAME) && (flags & MUI_LANGUAGE_ID)) return STATUS_INVALID_PARAMETER;
     if (*size && !buffer) return STATUS_INVALID_PARAMETER;
 
-    NtQueryDefaultUILanguage( &ui_language );
-    return get_dummy_preferred_ui_language( flags, ui_language, count, buffer, size );
+    return get_dummy_preferred_ui_language( flags, user_ui_language, count, buffer, size );
 }
 
 
@@ -1425,7 +1604,7 @@ NTSTATUS WINAPI RtlUpcaseUnicodeToOemN( char *dst, DWORD dstlen, DWORD *reslen,
 /*********************************************************************
  *	towlower   (NTDLL.@)
  */
-WCHAR __cdecl towlower( WCHAR ch )
+WCHAR __cdecl NTDLL_towlower( WCHAR ch )
 {
     if (ch >= 0x100) return ch;
     return casemap( nls_info.LowerCaseTable, ch );
@@ -1435,7 +1614,7 @@ WCHAR __cdecl towlower( WCHAR ch )
 /*********************************************************************
  *           towupper    (NTDLL.@)
  */
-WCHAR __cdecl towupper( WCHAR ch )
+WCHAR __cdecl NTDLL_towupper( WCHAR ch )
 {
     if (nls_info.UpperCaseTable) return casemap( nls_info.UpperCaseTable, ch );
     return casemap_ascii( ch );
diff --git a/dlls/ntdll/misc.c b/dlls/ntdll/misc.c
index a75188e981..362c68e5e0 100644
--- a/dlls/ntdll/misc.c
+++ b/dlls/ntdll/misc.c
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <time.h>
 #include <math.h>
 
@@ -32,6 +34,14 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
+LPCSTR debugstr_ObjectAttributes(const OBJECT_ATTRIBUTES *oa)
+{
+    if (!oa) return "<null>";
+    return wine_dbg_sprintf( "{name=%s, attr=0x%08x, hRoot=%p, sd=%p}",
+                             debugstr_us(oa->ObjectName), oa->Attributes,
+                             oa->RootDirectory, oa->SecurityDescriptor );
+}
+
 LPCSTR debugstr_us( const UNICODE_STRING *us )
 {
     if (!us) return "<null>";
@@ -41,7 +51,7 @@ LPCSTR debugstr_us( const UNICODE_STRING *us )
 /*********************************************************************
  *                  wine_get_version   (NTDLL.@)
  */
-const char * CDECL wine_get_version(void)
+const char * CDECL NTDLL_wine_get_version(void)
 {
     return unix_funcs->get_version();
 }
@@ -49,7 +59,7 @@ const char * CDECL wine_get_version(void)
 /*********************************************************************
  *                  wine_get_build_id   (NTDLL.@)
  */
-const char * CDECL wine_get_build_id(void)
+const char * CDECL NTDLL_wine_get_build_id(void)
 {
     return unix_funcs->get_build_id();
 }
@@ -57,7 +67,7 @@ const char * CDECL wine_get_build_id(void)
 /*********************************************************************
  *                  wine_get_host_version   (NTDLL.@)
  */
-void CDECL wine_get_host_version( const char **sysname, const char **release )
+void CDECL NTDLL_wine_get_host_version( const char **sysname, const char **release )
 {
     return unix_funcs->get_host_version( sysname, release );
 }
@@ -65,92 +75,100 @@ void CDECL wine_get_host_version( const char **sysname, const char **release )
 /*********************************************************************
  *                  abs   (NTDLL.@)
  */
-int CDECL abs( int i )
+int CDECL NTDLL_abs( int i )
 {
-    return i >= 0 ? i : -i;
+    return abs( i );
+}
+
+/*********************************************************************
+ *                  labs   (NTDLL.@)
+ */
+LONG CDECL NTDLL_labs( LONG i )
+{
+    return labs( i );
 }
 
 /*********************************************************************
  *                  atan   (NTDLL.@)
  */
-double CDECL atan( double d )
+double CDECL NTDLL_atan( double d )
 {
-    return unix_funcs->atan( d );
+    return atan( d );
 }
 
 /*********************************************************************
  *                  ceil   (NTDLL.@)
  */
-double CDECL ceil( double d )
+double CDECL NTDLL_ceil( double d )
 {
-    return unix_funcs->ceil( d );
+    return ceil( d );
 }
 
 /*********************************************************************
  *                  cos   (NTDLL.@)
  */
-double CDECL cos( double d )
+double CDECL NTDLL_cos( double d )
 {
-    return unix_funcs->cos( d );
+    return cos( d );
 }
 
 /*********************************************************************
  *                  fabs   (NTDLL.@)
  */
-double CDECL fabs( double d )
+double CDECL NTDLL_fabs( double d )
 {
-    return unix_funcs->fabs( d );
+    return fabs( d );
 }
 
 /*********************************************************************
  *                  floor   (NTDLL.@)
  */
-double CDECL floor( double d )
+double CDECL NTDLL_floor( double d )
 {
-    return unix_funcs->floor( d );
+    return floor( d );
 }
 
 /*********************************************************************
  *                  log   (NTDLL.@)
  */
-double CDECL log( double d )
+double CDECL NTDLL_log( double d )
 {
-    return unix_funcs->log( d );
+    return log( d );
 }
 
 /*********************************************************************
  *                  pow   (NTDLL.@)
  */
-double CDECL pow( double x, double y )
+double CDECL NTDLL_pow( double x, double y )
 {
-    return unix_funcs->pow( x, y );
+    return pow( x, y );
 }
 
 /*********************************************************************
  *                  sin   (NTDLL.@)
  */
-double CDECL sin( double d )
+double CDECL NTDLL_sin( double d )
 {
-    return unix_funcs->sin( d );
+    return sin( d );
 }
 
 /*********************************************************************
  *                  sqrt   (NTDLL.@)
  */
-double CDECL sqrt( double d )
+double CDECL NTDLL_sqrt( double d )
 {
-    return unix_funcs->sqrt( d );
+    return sqrt( d );
 }
 
 /*********************************************************************
  *                  tan   (NTDLL.@)
  */
-double CDECL tan( double d )
+double CDECL NTDLL_tan( double d )
 {
-    return unix_funcs->tan( d );
+    return tan( d );
 }
 
-#if (defined(__GNUC__) || defined(__clang__)) && defined(__i386__)
+#if defined(__GNUC__) && defined(__i386__)
 
 #define FPU_DOUBLE(var) double var; \
     __asm__ __volatile__( "fstpl %0;fwait" : "=m" (var) : )
@@ -161,58 +179,58 @@ double CDECL tan( double d )
 /*********************************************************************
  *		_CIcos (NTDLL.@)
  */
-double CDECL _CIcos(void)
+double CDECL NTDLL__CIcos(void)
 {
     FPU_DOUBLE(x);
-    return cos(x);
+    return NTDLL_cos(x);
 }
 
 /*********************************************************************
  *		_CIlog (NTDLL.@)
  */
-double CDECL _CIlog(void)
+double CDECL NTDLL__CIlog(void)
 {
     FPU_DOUBLE(x);
-    return log(x);
+    return NTDLL_log(x);
 }
 
 /*********************************************************************
  *		_CIpow (NTDLL.@)
  */
-double CDECL _CIpow(void)
+double CDECL NTDLL__CIpow(void)
 {
     FPU_DOUBLES(x,y);
-    return pow(x,y);
+    return NTDLL_pow(x,y);
 }
 
 /*********************************************************************
  *		_CIsin (NTDLL.@)
  */
-double CDECL _CIsin(void)
+double CDECL NTDLL__CIsin(void)
 {
     FPU_DOUBLE(x);
-    return sin(x);
+    return NTDLL_sin(x);
 }
 
 /*********************************************************************
  *		_CIsqrt (NTDLL.@)
  */
-double CDECL _CIsqrt(void)
+double CDECL NTDLL__CIsqrt(void)
 {
     FPU_DOUBLE(x);
-    return sqrt(x);
+    return NTDLL_sqrt(x);
 }
 
 /*********************************************************************
  *                  _ftol   (NTDLL.@)
  */
-LONGLONG CDECL _ftol(void)
+LONGLONG CDECL NTDLL__ftol(void)
 {
     FPU_DOUBLE(x);
     return (LONGLONG)x;
 }
 
-#endif /* (defined(__GNUC__) || defined(__clang__)) && defined(__i386__) */
+#endif /* defined(__GNUC__) && defined(__i386__) */
 
 static void
 NTDLL_mergesort( void *arr, void *barr, size_t elemsize, int(__cdecl *compar)(const void *, const void *),
@@ -247,8 +265,8 @@ NTDLL_mergesort( void *arr, void *barr, size_t elemsize, int(__cdecl *compar)(co
 /*********************************************************************
  *                  qsort   (NTDLL.@)
  */
-void __cdecl qsort( void *base, size_t nmemb, size_t size,
-                    int (__cdecl *compar)(const void *, const void *) )
+void __cdecl NTDLL_qsort( void *base, size_t nmemb, size_t size,
+                          int(__cdecl *compar)(const void *, const void *) )
 {
     void *secondarr;
     if (nmemb < 2 || size == 0) return;
@@ -260,8 +278,9 @@ void __cdecl qsort( void *base, size_t nmemb, size_t size,
 /*********************************************************************
  *                  bsearch   (NTDLL.@)
  */
-void * __cdecl bsearch( const void *key, const void *base, size_t nmemb,
-                        size_t size, int (__cdecl *compar)(const void *, const void *) )
+void * __cdecl
+NTDLL_bsearch( const void *key, const void *base, size_t nmemb,
+               size_t size, int (__cdecl *compar)(const void *, const void *) )
 {
     ssize_t min = 0;
     ssize_t max = nmemb - 1;
@@ -559,6 +578,18 @@ ULONG WINAPIV EtwTraceMessage( TRACEHANDLE handle, ULONG flags, LPGUID guid, /*U
     return ret;
 }
 
+NTSTATUS WINAPI NtCreateLowBoxToken(HANDLE *token_handle, HANDLE existing_token_handle, ACCESS_MASK desired_access,
+                                    OBJECT_ATTRIBUTES *object_attributes, SID *package_sid, ULONG capability_count,
+                                    SID_AND_ATTRIBUTES *capabilities, ULONG handle_count, HANDLE *handle)
+{
+    FIXME("(%p, %p, %x, %p, %p, %u, %p, %u, %p): stub\n", token_handle, existing_token_handle, desired_access,
+            object_attributes, package_sid, capability_count, capabilities, handle_count, handle);
+
+    /* We need to return a NULL handle since later it will be passed to CloseHandle and that must not fail */
+    *token_handle = NULL;
+    return STATUS_SUCCESS;
+}
+
 /*********************************************************************
  *                  ApiSetQueryApiSetPresence   (NTDLL.@)
  */
diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
index dc3eb73e97..978919146c 100644
--- a/dlls/ntdll/nt.c
+++ b/dlls/ntdll/nt.c
@@ -21,30 +21,2505 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_SYSCTL_H
+# include <sys/sysctl.h>
+#endif
+#ifdef HAVE_MACHINE_CPU_H
+# include <machine/cpu.h>
+#endif
+#ifdef HAVE_MACH_MACHINE_H
+# include <mach/machine.h>
+#endif
+#ifdef HAVE_IOKIT_IOKITLIB_H
+# include <CoreFoundation/CoreFoundation.h>
+# include <IOKit/IOKitLib.h>
+# include <IOKit/pwr_mgt/IOPM.h>
+# include <IOKit/pwr_mgt/IOPMLib.h>
+# include <IOKit/ps/IOPowerSources.h>
+#endif
+
+#include <ctype.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+#include <time.h>
+
+#ifdef sun
+/* FIXME:  Unfortunately swapctl can't be used with largefile.... */
+# undef _FILE_OFFSET_BITS
+# define _FILE_OFFSET_BITS 32
+# ifdef HAVE_SYS_RESOURCE_H
+#  include <sys/resource.h>
+# endif
+# ifdef HAVE_SYS_STAT_H
+#  include <sys/stat.h>
+# endif
+# include <sys/swap.h>
+#endif
+
+#define NONAMELESSUNION
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "wine/debug.h"
+#include "windef.h"
+#include "winternl.h"
+#include "ntdll_misc.h"
+#include "wine/server.h"
+#include "ddk/wdm.h"
+
+#ifdef __APPLE__
+#include <mach/mach.h>
+#include <mach/mach_init.h>
+#include <mach/mach_host.h>
+#include <mach/vm_map.h>
+#endif
+
+WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
+
+#include "pshpack1.h"
+
+struct smbios_prologue {
+    BYTE calling_method;
+    BYTE major_version;
+    BYTE minor_version;
+    BYTE revision;
+    DWORD length;
+};
+
+struct smbios_header {
+    BYTE type;
+    BYTE length;
+    WORD handle;
+};
+
+struct smbios_bios {
+    struct smbios_header hdr;
+    BYTE vendor;
+    BYTE version;
+    WORD start;
+    BYTE date;
+    BYTE size;
+    UINT64 characteristics;
+    BYTE characteristics_ext[2];
+    BYTE system_bios_major_release;
+    BYTE system_bios_minor_release;
+    BYTE ec_firmware_major_release;
+    BYTE ec_firmware_minor_release;
+};
+
+struct smbios_system {
+    struct smbios_header hdr;
+    BYTE vendor;
+    BYTE product;
+    BYTE version;
+    BYTE serial;
+    BYTE uuid[16];
+    BYTE wake_up_type;
+    BYTE sku_number;
+    BYTE family;
+};
+
+struct smbios_board {
+    struct smbios_header hdr;
+    BYTE vendor;
+    BYTE product;
+    BYTE version;
+    BYTE serial;
+};
+
+struct smbios_chassis {
+    struct smbios_header hdr;
+    BYTE vendor;
+    BYTE type;
+    BYTE version;
+    BYTE serial;
+    BYTE asset_tag;
+    BYTE boot_state;
+    BYTE power_supply_state;
+    BYTE thermal_state;
+    BYTE security_status;
+};
+
+#include "poppack.h"
+
+/* Firmware table providers */
+#define ACPI 0x41435049
+#define FIRM 0x4649524D
+#define RSMB 0x52534D42
+
+/*
+ *	Token
+ */
+
+/******************************************************************************
+ *  NtDuplicateToken		[NTDLL.@]
+ *  ZwDuplicateToken		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtDuplicateToken(
+        IN HANDLE ExistingToken,
+        IN ACCESS_MASK DesiredAccess,
+        IN POBJECT_ATTRIBUTES ObjectAttributes,
+        IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
+        IN TOKEN_TYPE TokenType,
+        OUT PHANDLE NewToken)
+{
+    NTSTATUS status;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    TRACE("(%p,0x%08x,%s,0x%08x,0x%08x,%p)\n",
+          ExistingToken, DesiredAccess, debugstr_ObjectAttributes(ObjectAttributes),
+          ImpersonationLevel, TokenType, NewToken);
+
+    if ((status = alloc_object_attributes( ObjectAttributes, &objattr, &len ))) return status;
+
+    if (ObjectAttributes && ObjectAttributes->SecurityQualityOfService)
+    {
+        SECURITY_QUALITY_OF_SERVICE *SecurityQOS = ObjectAttributes->SecurityQualityOfService;
+        TRACE("ObjectAttributes->SecurityQualityOfService = {%d, %d, %d, %s}\n",
+            SecurityQOS->Length, SecurityQOS->ImpersonationLevel,
+            SecurityQOS->ContextTrackingMode,
+            SecurityQOS->EffectiveOnly ? "TRUE" : "FALSE");
+        ImpersonationLevel = SecurityQOS->ImpersonationLevel;
+    }
+
+    SERVER_START_REQ( duplicate_token )
+    {
+        req->handle              = wine_server_obj_handle( ExistingToken );
+        req->access              = DesiredAccess;
+        req->primary             = (TokenType == TokenPrimary);
+        req->impersonation_level = ImpersonationLevel;
+        wine_server_add_data( req, objattr, len );
+        status = wine_server_call( req );
+        if (!status) *NewToken = wine_server_ptr_handle( reply->new_handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return status;
+}
+
+/******************************************************************************
+ *  NtOpenProcessToken		[NTDLL.@]
+ *  ZwOpenProcessToken		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenProcessToken(
+	HANDLE ProcessHandle,
+	DWORD DesiredAccess,
+	HANDLE *TokenHandle)
+{
+    return NtOpenProcessTokenEx( ProcessHandle, DesiredAccess, 0, TokenHandle );
+}
+
+/******************************************************************************
+ *  NtOpenProcessTokenEx   [NTDLL.@]
+ *  ZwOpenProcessTokenEx   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenProcessTokenEx( HANDLE process, DWORD access, DWORD attributes,
+                                      HANDLE *handle )
+{
+    NTSTATUS ret;
+
+    TRACE("(%p,0x%08x,0x%08x,%p)\n", process, access, attributes, handle);
+
+    SERVER_START_REQ( open_token )
+    {
+        req->handle     = wine_server_obj_handle( process );
+        req->access     = access;
+        req->attributes = attributes;
+        req->flags      = 0;
+        ret = wine_server_call( req );
+        if (!ret) *handle = wine_server_ptr_handle( reply->token );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtOpenThreadToken		[NTDLL.@]
+ *  ZwOpenThreadToken		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenThreadToken(
+	HANDLE ThreadHandle,
+	DWORD DesiredAccess,
+	BOOLEAN OpenAsSelf,
+	HANDLE *TokenHandle)
+{
+    return NtOpenThreadTokenEx( ThreadHandle, DesiredAccess, OpenAsSelf, 0, TokenHandle );
+}
+
+/******************************************************************************
+ *  NtOpenThreadTokenEx   [NTDLL.@]
+ *  ZwOpenThreadTokenEx   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenThreadTokenEx( HANDLE thread, DWORD access, BOOLEAN as_self, DWORD attributes,
+                                     HANDLE *handle )
+{
+    NTSTATUS ret;
+
+    TRACE("(%p,0x%08x,%u,0x%08x,%p)\n", thread, access, as_self, attributes, handle );
+
+    SERVER_START_REQ( open_token )
+    {
+        req->handle     = wine_server_obj_handle( thread );
+        req->access     = access;
+        req->attributes = attributes;
+        req->flags      = OPEN_TOKEN_THREAD;
+        if (as_self) req->flags |= OPEN_TOKEN_AS_SELF;
+        ret = wine_server_call( req );
+        if (!ret) *handle = wine_server_ptr_handle( reply->token );
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+/******************************************************************************
+ *  NtAdjustPrivilegesToken		[NTDLL.@]
+ *  ZwAdjustPrivilegesToken		[NTDLL.@]
+ *
+ * FIXME: parameters unsafe
+ */
+NTSTATUS WINAPI NtAdjustPrivilegesToken(
+	IN HANDLE TokenHandle,
+	IN BOOLEAN DisableAllPrivileges,
+	IN PTOKEN_PRIVILEGES NewState,
+	IN DWORD BufferLength,
+	OUT PTOKEN_PRIVILEGES PreviousState,
+	OUT PDWORD ReturnLength)
+{
+    NTSTATUS ret;
+
+    TRACE("(%p,0x%08x,%p,0x%08x,%p,%p)\n",
+        TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
+
+    SERVER_START_REQ( adjust_token_privileges )
+    {
+        req->handle = wine_server_obj_handle( TokenHandle );
+        req->disable_all = DisableAllPrivileges;
+        req->get_modified_state = (PreviousState != NULL);
+        if (!DisableAllPrivileges)
+        {
+            wine_server_add_data( req, NewState->Privileges,
+                                  NewState->PrivilegeCount * sizeof(NewState->Privileges[0]) );
+        }
+        if (PreviousState && BufferLength >= FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ))
+            wine_server_set_reply( req, PreviousState->Privileges,
+                                   BufferLength - FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ) );
+        ret = wine_server_call( req );
+        if (PreviousState)
+        {
+            if (ReturnLength) *ReturnLength = reply->len + FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges );
+            PreviousState->PrivilegeCount = reply->len / sizeof(LUID_AND_ATTRIBUTES);
+        }
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+/******************************************************************************
+*  NtQueryInformationToken		[NTDLL.@]
+*  ZwQueryInformationToken		[NTDLL.@]
+*
+* NOTES
+*  Buffer for TokenUser:
+*   0x00 TOKEN_USER the PSID field points to the SID
+*   0x08 SID
+*
+*/
+NTSTATUS WINAPI NtQueryInformationToken(
+	HANDLE token,
+	TOKEN_INFORMATION_CLASS tokeninfoclass,
+	PVOID tokeninfo,
+	ULONG tokeninfolength,
+	PULONG retlen )
+{
+    static const ULONG info_len [] =
+    {
+        0,
+        0,    /* TokenUser */
+        0,    /* TokenGroups */
+        0,    /* TokenPrivileges */
+        0,    /* TokenOwner */
+        0,    /* TokenPrimaryGroup */
+        0,    /* TokenDefaultDacl */
+        sizeof(TOKEN_SOURCE), /* TokenSource */
+        sizeof(TOKEN_TYPE),  /* TokenType */
+        sizeof(SECURITY_IMPERSONATION_LEVEL), /* TokenImpersonationLevel */
+        sizeof(TOKEN_STATISTICS), /* TokenStatistics */
+        0,    /* TokenRestrictedSids */
+        sizeof(DWORD), /* TokenSessionId */
+        0,    /* TokenGroupsAndPrivileges */
+        0,    /* TokenSessionReference */
+        0,    /* TokenSandBoxInert */
+        0,    /* TokenAuditPolicy */
+        0,    /* TokenOrigin */
+        sizeof(TOKEN_ELEVATION_TYPE), /* TokenElevationType */
+        0,    /* TokenLinkedToken */
+        sizeof(TOKEN_ELEVATION), /* TokenElevation */
+        0,    /* TokenHasRestrictions */
+        0,    /* TokenAccessInformation */
+        0,    /* TokenVirtualizationAllowed */
+        sizeof(DWORD), /* TokenVirtualizationEnabled */
+        sizeof(TOKEN_MANDATORY_LABEL) + sizeof(SID), /* TokenIntegrityLevel [sizeof(SID) includes one SubAuthority] */
+        0,    /* TokenUIAccess */
+        0,    /* TokenMandatoryPolicy */
+        0,    /* TokenLogonSid */
+        sizeof(DWORD), /* TokenIsAppContainer */
+        0,    /* TokenCapabilities */
+        sizeof(TOKEN_APPCONTAINER_INFORMATION) + sizeof(SID), /* TokenAppContainerSid */
+        0,    /* TokenAppContainerNumber */
+        0,    /* TokenUserClaimAttributes*/
+        0,    /* TokenDeviceClaimAttributes */
+        0,    /* TokenRestrictedUserClaimAttributes */
+        0,    /* TokenRestrictedDeviceClaimAttributes */
+        0,    /* TokenDeviceGroups */
+        0,    /* TokenRestrictedDeviceGroups */
+        0,    /* TokenSecurityAttributes */
+        0,    /* TokenIsRestricted */
+        0     /* TokenProcessTrustLevel */
+    };
+
+    ULONG len = 0;
+    NTSTATUS status = STATUS_SUCCESS;
+
+    TRACE("(%p,%d,%p,%d,%p)\n",
+          token,tokeninfoclass,tokeninfo,tokeninfolength,retlen);
+
+    if (tokeninfoclass < MaxTokenInfoClass)
+        len = info_len[tokeninfoclass];
+
+    if (retlen) *retlen = len;
+
+    if (tokeninfolength < len)
+        return STATUS_BUFFER_TOO_SMALL;
+
+    switch (tokeninfoclass)
+    {
+    case TokenUser:
+        SERVER_START_REQ( get_token_sid )
+        {
+            TOKEN_USER * tuser = tokeninfo;
+            PSID sid = tuser + 1;
+            DWORD sid_len = tokeninfolength < sizeof(TOKEN_USER) ? 0 : tokeninfolength - sizeof(TOKEN_USER);
+
+            req->handle = wine_server_obj_handle( token );
+            req->which_sid = tokeninfoclass;
+            wine_server_set_reply( req, sid, sid_len );
+            status = wine_server_call( req );
+            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_USER);
+            if (status == STATUS_SUCCESS)
+            {
+                tuser->User.Sid = sid;
+                tuser->User.Attributes = 0;
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenGroups:
+    {
+        void *buffer;
+
+        /* reply buffer is always shorter than output one */
+        buffer = tokeninfolength ? RtlAllocateHeap(GetProcessHeap(), 0, tokeninfolength) : NULL;
+
+        SERVER_START_REQ( get_token_groups )
+        {
+            TOKEN_GROUPS *groups = tokeninfo;
+
+            req->handle = wine_server_obj_handle( token );
+            wine_server_set_reply( req, buffer, tokeninfolength );
+            status = wine_server_call( req );
+            if (status == STATUS_BUFFER_TOO_SMALL)
+            {
+                if (retlen) *retlen = reply->user_len;
+            }
+            else if (status == STATUS_SUCCESS)
+            {
+                struct token_groups *tg = buffer;
+                unsigned int *attr = (unsigned int *)(tg + 1);
+                ULONG i;
+                const int non_sid_portion = (sizeof(struct token_groups) + tg->count * sizeof(unsigned int));
+                SID *sids = (SID *)((char *)tokeninfo + FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ));
+
+                if (retlen) *retlen = reply->user_len;
+
+                groups->GroupCount = tg->count;
+                memcpy( sids, (char *)buffer + non_sid_portion,
+                        reply->user_len - FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ));
+
+                for (i = 0; i < tg->count; i++)
+                {
+                    groups->Groups[i].Attributes = attr[i];
+                    groups->Groups[i].Sid = sids;
+                    sids = (SID *)((char *)sids + RtlLengthSid(sids));
+                }
+             }
+             else if (retlen) *retlen = 0;
+        }
+        SERVER_END_REQ;
+
+        RtlFreeHeap(GetProcessHeap(), 0, buffer);
+        break;
+    }
+    case TokenPrimaryGroup:
+        SERVER_START_REQ( get_token_sid )
+        {
+            TOKEN_PRIMARY_GROUP *tgroup = tokeninfo;
+            PSID sid = tgroup + 1;
+            DWORD sid_len = tokeninfolength < sizeof(TOKEN_PRIMARY_GROUP) ? 0 : tokeninfolength - sizeof(TOKEN_PRIMARY_GROUP);
+
+            req->handle = wine_server_obj_handle( token );
+            req->which_sid = tokeninfoclass;
+            wine_server_set_reply( req, sid, sid_len );
+            status = wine_server_call( req );
+            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_PRIMARY_GROUP);
+            if (status == STATUS_SUCCESS)
+                tgroup->PrimaryGroup = sid;
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenPrivileges:
+        SERVER_START_REQ( get_token_privileges )
+        {
+            TOKEN_PRIVILEGES *tpriv = tokeninfo;
+            req->handle = wine_server_obj_handle( token );
+            if (tpriv && tokeninfolength > FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ))
+                wine_server_set_reply( req, tpriv->Privileges, tokeninfolength - FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ) );
+            status = wine_server_call( req );
+            if (retlen) *retlen = FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ) + reply->len;
+            if (tpriv) tpriv->PrivilegeCount = reply->len / sizeof(LUID_AND_ATTRIBUTES);
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenOwner:
+        SERVER_START_REQ( get_token_sid )
+        {
+            TOKEN_OWNER *towner = tokeninfo;
+            PSID sid = towner + 1;
+            DWORD sid_len = tokeninfolength < sizeof(TOKEN_OWNER) ? 0 : tokeninfolength - sizeof(TOKEN_OWNER);
+
+            req->handle = wine_server_obj_handle( token );
+            req->which_sid = tokeninfoclass;
+            wine_server_set_reply( req, sid, sid_len );
+            status = wine_server_call( req );
+            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_OWNER);
+            if (status == STATUS_SUCCESS)
+                towner->Owner = sid;
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenImpersonationLevel:
+        SERVER_START_REQ( get_token_impersonation_level )
+        {
+            SECURITY_IMPERSONATION_LEVEL *impersonation_level = tokeninfo;
+            req->handle = wine_server_obj_handle( token );
+            status = wine_server_call( req );
+            if (status == STATUS_SUCCESS)
+                *impersonation_level = reply->impersonation_level;
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenStatistics:
+        SERVER_START_REQ( get_token_statistics )
+        {
+            TOKEN_STATISTICS *statistics = tokeninfo;
+            req->handle = wine_server_obj_handle( token );
+            status = wine_server_call( req );
+            if (status == STATUS_SUCCESS)
+            {
+                statistics->TokenId.LowPart  = reply->token_id.low_part;
+                statistics->TokenId.HighPart = reply->token_id.high_part;
+                statistics->AuthenticationId.LowPart  = 0; /* FIXME */
+                statistics->AuthenticationId.HighPart = 0; /* FIXME */
+                statistics->ExpirationTime.u.HighPart = 0x7fffffff;
+                statistics->ExpirationTime.u.LowPart  = 0xffffffff;
+                statistics->TokenType = reply->primary ? TokenPrimary : TokenImpersonation;
+                statistics->ImpersonationLevel = reply->impersonation_level;
+
+                /* kernel information not relevant to us */
+                statistics->DynamicCharged = 0;
+                statistics->DynamicAvailable = 0;
+
+                statistics->GroupCount = reply->group_count;
+                statistics->PrivilegeCount = reply->privilege_count;
+                statistics->ModifiedId.LowPart  = reply->modified_id.low_part;
+                statistics->ModifiedId.HighPart = reply->modified_id.high_part;
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenType:
+        SERVER_START_REQ( get_token_statistics )
+        {
+            TOKEN_TYPE *token_type = tokeninfo;
+            req->handle = wine_server_obj_handle( token );
+            status = wine_server_call( req );
+            if (status == STATUS_SUCCESS)
+                *token_type = reply->primary ? TokenPrimary : TokenImpersonation;
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenDefaultDacl:
+        SERVER_START_REQ( get_token_default_dacl )
+        {
+            TOKEN_DEFAULT_DACL *default_dacl = tokeninfo;
+            ACL *acl = (ACL *)(default_dacl + 1);
+            DWORD acl_len;
+
+            if (tokeninfolength < sizeof(TOKEN_DEFAULT_DACL)) acl_len = 0;
+            else acl_len = tokeninfolength - sizeof(TOKEN_DEFAULT_DACL);
+
+            req->handle = wine_server_obj_handle( token );
+            wine_server_set_reply( req, acl, acl_len );
+            status = wine_server_call( req );
+
+            if (retlen) *retlen = reply->acl_len + sizeof(TOKEN_DEFAULT_DACL);
+            if (status == STATUS_SUCCESS)
+            {
+                if (reply->acl_len)
+                    default_dacl->DefaultDacl = acl;
+                else
+                    default_dacl->DefaultDacl = NULL;
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenElevationType:
+        {
+            TOKEN_ELEVATION_TYPE *elevation_type = tokeninfo;
+            FIXME("QueryInformationToken( ..., TokenElevationType, ...) semi-stub\n");
+            *elevation_type = TokenElevationTypeFull;
+        }
+        break;
+    case TokenElevation:
+        {
+            TOKEN_ELEVATION *elevation = tokeninfo;
+            FIXME("QueryInformationToken( ..., TokenElevation, ...) semi-stub\n");
+            elevation->TokenIsElevated = TRUE;
+        }
+        break;
+    case TokenSessionId:
+        {
+            *((DWORD*)tokeninfo) = 0;
+            FIXME("QueryInformationToken( ..., TokenSessionId, ...) semi-stub\n");
+        }
+        break;
+    case TokenVirtualizationEnabled:
+        {
+            *(DWORD *)tokeninfo = 0;
+            TRACE("QueryInformationToken( ..., TokenVirtualizationEnabled, ...) semi-stub\n");
+        }
+        break;
+    case TokenIntegrityLevel:
+        {
+            /* report always "S-1-16-12288" (high mandatory level) for now */
+            static const SID high_level = {SID_REVISION, 1, {SECURITY_MANDATORY_LABEL_AUTHORITY},
+                                                            {SECURITY_MANDATORY_HIGH_RID}};
+
+            TOKEN_MANDATORY_LABEL *tml = tokeninfo;
+            PSID psid = tml + 1;
+
+            tml->Label.Sid = psid;
+            tml->Label.Attributes = SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED;
+            memcpy(psid, &high_level, sizeof(SID));
+        }
+        break;
+    case TokenAppContainerSid:
+        {
+            TOKEN_APPCONTAINER_INFORMATION *container = tokeninfo;
+            FIXME("QueryInformationToken( ..., TokenAppContainerSid, ...) semi-stub\n");
+            container->TokenAppContainer = NULL;
+        }
+        break;
+    case TokenIsAppContainer:
+        {
+            TRACE("TokenIsAppContainer semi-stub\n");
+            *(DWORD*)tokeninfo = 0;
+            break;
+        }
+    case TokenLogonSid:
+        SERVER_START_REQ( get_token_sid )
+        {
+            TOKEN_GROUPS * groups = tokeninfo;
+            PSID sid = groups + 1;
+            DWORD sid_len = tokeninfolength < sizeof(TOKEN_GROUPS) ? 0 : tokeninfolength - sizeof(TOKEN_GROUPS);
+
+            req->handle = wine_server_obj_handle( token );
+            req->which_sid = tokeninfoclass;
+            wine_server_set_reply( req, sid, sid_len );
+            status = wine_server_call( req );
+            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_GROUPS);
+            if (status == STATUS_SUCCESS)
+            {
+                groups->GroupCount = 1;
+                groups->Groups[0].Sid = sid;
+                groups->Groups[0].Attributes = 0;
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    default:
+        {
+            ERR("Unhandled Token Information class %d!\n", tokeninfoclass);
+            return STATUS_NOT_IMPLEMENTED;
+        }
+    }
+    return status;
+}
+
+/******************************************************************************
+*  NtSetInformationToken		[NTDLL.@]
+*  ZwSetInformationToken		[NTDLL.@]
+*/
+NTSTATUS WINAPI NtSetInformationToken(
+        HANDLE TokenHandle,
+        TOKEN_INFORMATION_CLASS TokenInformationClass,
+        PVOID TokenInformation,
+        ULONG TokenInformationLength)
+{
+    NTSTATUS ret = STATUS_NOT_IMPLEMENTED;
+
+    TRACE("%p %d %p %u\n", TokenHandle, TokenInformationClass,
+           TokenInformation, TokenInformationLength);
+
+    switch (TokenInformationClass)
+    {
+    case TokenDefaultDacl:
+        if (TokenInformationLength < sizeof(TOKEN_DEFAULT_DACL))
+        {
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+            break;
+        }
+        if (!TokenInformation)
+        {
+            ret = STATUS_ACCESS_VIOLATION;
+            break;
+        }
+        SERVER_START_REQ( set_token_default_dacl )
+        {
+            ACL *acl = ((TOKEN_DEFAULT_DACL *)TokenInformation)->DefaultDacl;
+            WORD size;
+
+            if (acl) size = acl->AclSize;
+            else size = 0;
+
+            req->handle = wine_server_obj_handle( TokenHandle );
+            wine_server_add_data( req, acl, size );
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        break;
+    case TokenSessionId:
+        if (TokenInformationLength < sizeof(DWORD))
+        {
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+            break;
+        }
+        if (!TokenInformation)
+        {
+            ret = STATUS_ACCESS_VIOLATION;
+            break;
+        }
+        FIXME("TokenSessionId stub!\n");
+        ret = STATUS_SUCCESS;
+        break;
+    case TokenIntegrityLevel:
+        FIXME("TokenIntegrityLevel stub!\n");
+        ret = STATUS_SUCCESS;
+        break;
+    default:
+        FIXME("unimplemented class %u\n", TokenInformationClass);
+        break;
+    }
+
+    return ret;
+}
+
+/******************************************************************************
+*  NtAdjustGroupsToken		[NTDLL.@]
+*  ZwAdjustGroupsToken		[NTDLL.@]
+*/
+NTSTATUS WINAPI NtAdjustGroupsToken(
+        HANDLE TokenHandle,
+        BOOLEAN ResetToDefault,
+        PTOKEN_GROUPS NewState,
+        ULONG BufferLength,
+        PTOKEN_GROUPS PreviousState,
+        PULONG ReturnLength)
+{
+    FIXME("%p %d %p %u %p %p\n", TokenHandle, ResetToDefault,
+          NewState, BufferLength, PreviousState, ReturnLength);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+*  NtPrivilegeCheck		[NTDLL.@]
+*  ZwPrivilegeCheck		[NTDLL.@]
+*/
+NTSTATUS WINAPI NtPrivilegeCheck(
+    HANDLE ClientToken,
+    PPRIVILEGE_SET RequiredPrivileges,
+    PBOOLEAN Result)
+{
+    NTSTATUS status;
+    SERVER_START_REQ( check_token_privileges )
+    {
+        req->handle = wine_server_obj_handle( ClientToken );
+        req->all_required = (RequiredPrivileges->Control & PRIVILEGE_SET_ALL_NECESSARY) != 0;
+        wine_server_add_data( req, RequiredPrivileges->Privilege,
+            RequiredPrivileges->PrivilegeCount * sizeof(RequiredPrivileges->Privilege[0]) );
+        wine_server_set_reply( req, RequiredPrivileges->Privilege,
+            RequiredPrivileges->PrivilegeCount * sizeof(RequiredPrivileges->Privilege[0]) );
+
+        status = wine_server_call( req );
+
+        if (status == STATUS_SUCCESS)
+            *Result = reply->has_privileges != 0;
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/*
+ *	ports
+ */
+
+/******************************************************************************
+ *  NtCreatePort		[NTDLL.@]
+ *  ZwCreatePort		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtCreatePort(PHANDLE PortHandle,POBJECT_ATTRIBUTES ObjectAttributes,
+                             ULONG MaxConnectInfoLength,ULONG MaxDataLength,PULONG reserved)
+{
+  FIXME("(%p,%p,%u,%u,%p),stub!\n",PortHandle,ObjectAttributes,
+        MaxConnectInfoLength,MaxDataLength,reserved);
+  return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtConnectPort		[NTDLL.@]
+ *  ZwConnectPort		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtConnectPort(
+        PHANDLE PortHandle,
+        PUNICODE_STRING PortName,
+        PSECURITY_QUALITY_OF_SERVICE SecurityQos,
+        PLPC_SECTION_WRITE WriteSection,
+        PLPC_SECTION_READ ReadSection,
+        PULONG MaximumMessageLength,
+        PVOID ConnectInfo,
+        PULONG pConnectInfoLength)
+{
+    FIXME("(%p,%s,%p,%p,%p,%p,%p,%p),stub!\n",
+          PortHandle,debugstr_w(PortName->Buffer),SecurityQos,
+          WriteSection,ReadSection,MaximumMessageLength,ConnectInfo,
+          pConnectInfoLength);
+    if (ConnectInfo && pConnectInfoLength)
+        TRACE("\tMessage = %s\n",debugstr_an(ConnectInfo,*pConnectInfoLength));
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtSecureConnectPort                (NTDLL.@)
+ *  ZwSecureConnectPort                (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSecureConnectPort(
+        PHANDLE PortHandle,
+        PUNICODE_STRING PortName,
+        PSECURITY_QUALITY_OF_SERVICE SecurityQos,
+        PLPC_SECTION_WRITE WriteSection,
+        PSID pSid,
+        PLPC_SECTION_READ ReadSection,
+        PULONG MaximumMessageLength,
+        PVOID ConnectInfo,
+        PULONG pConnectInfoLength)
+{
+    FIXME("(%p,%s,%p,%p,%p,%p,%p,%p,%p),stub!\n",
+          PortHandle,debugstr_w(PortName->Buffer),SecurityQos,
+          WriteSection,pSid,ReadSection,MaximumMessageLength,ConnectInfo,
+          pConnectInfoLength);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtListenPort		[NTDLL.@]
+ *  ZwListenPort		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtListenPort(HANDLE PortHandle,PLPC_MESSAGE pLpcMessage)
+{
+  FIXME("(%p,%p),stub!\n",PortHandle,pLpcMessage);
+  return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtAcceptConnectPort	[NTDLL.@]
+ *  ZwAcceptConnectPort	[NTDLL.@]
+ */
+NTSTATUS WINAPI NtAcceptConnectPort(
+        PHANDLE PortHandle,
+        ULONG PortIdentifier,
+        PLPC_MESSAGE pLpcMessage,
+        BOOLEAN Accept,
+        PLPC_SECTION_WRITE WriteSection,
+        PLPC_SECTION_READ ReadSection)
+{
+  FIXME("(%p,%u,%p,%d,%p,%p),stub!\n",
+        PortHandle,PortIdentifier,pLpcMessage,Accept,WriteSection,ReadSection);
+  return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtCompleteConnectPort	[NTDLL.@]
+ *  ZwCompleteConnectPort	[NTDLL.@]
+ */
+NTSTATUS WINAPI NtCompleteConnectPort(HANDLE PortHandle)
+{
+  FIXME("(%p),stub!\n",PortHandle);
+  return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtRegisterThreadTerminatePort	[NTDLL.@]
+ *  ZwRegisterThreadTerminatePort	[NTDLL.@]
+ */
+NTSTATUS WINAPI NtRegisterThreadTerminatePort(HANDLE PortHandle)
+{
+  FIXME("(%p),stub!\n",PortHandle);
+  return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtRequestWaitReplyPort		[NTDLL.@]
+ *  ZwRequestWaitReplyPort		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtRequestWaitReplyPort(
+        HANDLE PortHandle,
+        PLPC_MESSAGE pLpcMessageIn,
+        PLPC_MESSAGE pLpcMessageOut)
+{
+  FIXME("(%p,%p,%p),stub!\n",PortHandle,pLpcMessageIn,pLpcMessageOut);
+  if(pLpcMessageIn)
+  {
+    TRACE("Message to send:\n");
+    TRACE("\tDataSize            = %u\n",pLpcMessageIn->DataSize);
+    TRACE("\tMessageSize         = %u\n",pLpcMessageIn->MessageSize);
+    TRACE("\tMessageType         = %u\n",pLpcMessageIn->MessageType);
+    TRACE("\tVirtualRangesOffset = %u\n",pLpcMessageIn->VirtualRangesOffset);
+    TRACE("\tClientId.UniqueProcess = %p\n",pLpcMessageIn->ClientId.UniqueProcess);
+    TRACE("\tClientId.UniqueThread  = %p\n",pLpcMessageIn->ClientId.UniqueThread);
+    TRACE("\tMessageId           = %lu\n",pLpcMessageIn->MessageId);
+    TRACE("\tSectionSize         = %lu\n",pLpcMessageIn->SectionSize);
+    TRACE("\tData                = %s\n",
+      debugstr_an((const char*)pLpcMessageIn->Data,pLpcMessageIn->DataSize));
+  }
+  return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtReplyWaitReceivePort	[NTDLL.@]
+ *  ZwReplyWaitReceivePort	[NTDLL.@]
+ */
+NTSTATUS WINAPI NtReplyWaitReceivePort(
+        HANDLE PortHandle,
+        PULONG PortIdentifier,
+        PLPC_MESSAGE ReplyMessage,
+        PLPC_MESSAGE Message)
+{
+  FIXME("(%p,%p,%p,%p),stub!\n",PortHandle,PortIdentifier,ReplyMessage,Message);
+  return STATUS_NOT_IMPLEMENTED;
+}
+
+/*
+ *	Misc
+ */
+
+ /******************************************************************************
+ *  NtSetIntervalProfile	[NTDLL.@]
+ *  ZwSetIntervalProfile	[NTDLL.@]
+ */
+NTSTATUS WINAPI NtSetIntervalProfile(
+        ULONG Interval,
+        KPROFILE_SOURCE Source)
+{
+    FIXME("%u,%d\n", Interval, Source);
+    return STATUS_SUCCESS;
+}
+
+SYSTEM_CPU_INFORMATION cpu_info = { 0 };
+
+/*******************************************************************************
+ * Architecture specific feature detection for CPUs
+ *
+ * This a set of mutually exclusive #if define()s each providing its own get_cpuinfo() to be called
+ * from fill_cpu_info();
+ */
+#if defined(__i386__) || defined(__x86_64__)
+
+#define AUTH	0x68747541	/* "Auth" */
+#define ENTI	0x69746e65	/* "enti" */
+#define CAMD	0x444d4163	/* "cAMD" */
+
+#define GENU	0x756e6547	/* "Genu" */
+#define INEI	0x49656e69	/* "ineI" */
+#define NTEL	0x6c65746e	/* "ntel" */
+
+extern void do_cpuid(unsigned int ax, unsigned int *p);
+
+#ifdef __i386__
+__ASM_GLOBAL_FUNC( do_cpuid,
+                   "pushl %esi\n\t"
+                   "pushl %ebx\n\t"
+                   "movl 12(%esp),%eax\n\t"
+                   "movl 16(%esp),%esi\n\t"
+                   "cpuid\n\t"
+                   "movl %eax,(%esi)\n\t"
+                   "movl %ebx,4(%esi)\n\t"
+                   "movl %ecx,8(%esi)\n\t"
+                   "movl %edx,12(%esi)\n\t"
+                   "popl %ebx\n\t"
+                   "popl %esi\n\t"
+                   "ret" )
+#else
+__ASM_GLOBAL_FUNC( do_cpuid,
+                   "pushq %rbx\n\t"
+                   "movl %edi,%eax\n\t"
+                   "cpuid\n\t"
+                   "movl %eax,(%rsi)\n\t"
+                   "movl %ebx,4(%rsi)\n\t"
+                   "movl %ecx,8(%rsi)\n\t"
+                   "movl %edx,12(%rsi)\n\t"
+                   "popq %rbx\n\t"
+                   "ret" )
+#endif
+
+#ifdef __i386__
+extern int have_cpuid(void);
+__ASM_GLOBAL_FUNC( have_cpuid,
+                   "pushfl\n\t"
+                   "pushfl\n\t"
+                   "movl (%esp),%ecx\n\t"
+                   "xorl $0x00200000,(%esp)\n\t"
+                   "popfl\n\t"
+                   "pushfl\n\t"
+                   "popl %eax\n\t"
+                   "popfl\n\t"
+                   "xorl %ecx,%eax\n\t"
+                   "andl $0x00200000,%eax\n\t"
+                   "ret" )
+#else
+static int have_cpuid(void)
+{
+    return 1;
+}
+#endif
+
+/* Detect if a SSE2 processor is capable of Denormals Are Zero (DAZ) mode.
+ *
+ * This function assumes you have already checked for SSE2/FXSAVE support. */
+static inline BOOL have_sse_daz_mode(void)
+{
+#ifdef __i386__
+    typedef struct DECLSPEC_ALIGN(16) _M128A {
+        ULONGLONG Low;
+        LONGLONG High;
+    } M128A;
+
+    typedef struct _XMM_SAVE_AREA32 {
+        WORD ControlWord;
+        WORD StatusWord;
+        BYTE TagWord;
+        BYTE Reserved1;
+        WORD ErrorOpcode;
+        DWORD ErrorOffset;
+        WORD ErrorSelector;
+        WORD Reserved2;
+        DWORD DataOffset;
+        WORD DataSelector;
+        WORD Reserved3;
+        DWORD MxCsr;
+        DWORD MxCsr_Mask;
+        M128A FloatRegisters[8];
+        M128A XmmRegisters[16];
+        BYTE Reserved4[96];
+    } XMM_SAVE_AREA32;
+
+    /* Intel says we need a zeroed 16-byte aligned buffer */
+    char buffer[512 + 16];
+    XMM_SAVE_AREA32 *state = (XMM_SAVE_AREA32 *)(((ULONG_PTR)buffer + 15) & ~15);
+    memset(buffer, 0, sizeof(buffer));
+
+    __asm__ __volatile__( "fxsave %0" : "=m" (*state) : "m" (*state) );
+
+    return (state->MxCsr_Mask & (1 << 6)) >> 6;
+#else /* all x86_64 processors include SSE2 with DAZ mode */
+    return TRUE;
+#endif
+}
+
+static inline void get_cpuinfo(SYSTEM_CPU_INFORMATION* info)
+{
+    unsigned int regs[4], regs2[4];
+
+#if defined(__i386__)
+    info->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
+#elif defined(__x86_64__)
+    info->Architecture = PROCESSOR_ARCHITECTURE_AMD64;
+#endif
+
+    /* We're at least a 386 */
+    info->FeatureSet = CPU_FEATURE_VME | CPU_FEATURE_X86 | CPU_FEATURE_PGE;
+    info->Level = 3;
+
+    if (!have_cpuid()) return;
+
+    do_cpuid(0x00000000, regs);  /* get standard cpuid level and vendor name */
+    if (regs[0]>=0x00000001)   /* Check for supported cpuid version */
+    {
+        do_cpuid(0x00000001, regs2); /* get cpu features */
+
+        if(regs2[3] & (1 << 3 )) info->FeatureSet |= CPU_FEATURE_PSE;
+        if(regs2[3] & (1 << 4 )) info->FeatureSet |= CPU_FEATURE_TSC;
+        if(regs2[3] & (1 << 6 )) info->FeatureSet |= CPU_FEATURE_PAE;
+        if(regs2[3] & (1 << 8 )) info->FeatureSet |= CPU_FEATURE_CX8;
+        if(regs2[3] & (1 << 11)) info->FeatureSet |= CPU_FEATURE_SEP;
+        if(regs2[3] & (1 << 12)) info->FeatureSet |= CPU_FEATURE_MTRR;
+        if(regs2[3] & (1 << 15)) info->FeatureSet |= CPU_FEATURE_CMOV;
+        if(regs2[3] & (1 << 16)) info->FeatureSet |= CPU_FEATURE_PAT;
+        if(regs2[3] & (1 << 23)) info->FeatureSet |= CPU_FEATURE_MMX;
+        if(regs2[3] & (1 << 24)) info->FeatureSet |= CPU_FEATURE_FXSR;
+        if(regs2[3] & (1 << 25)) info->FeatureSet |= CPU_FEATURE_SSE;
+        if(regs2[3] & (1 << 26)) info->FeatureSet |= CPU_FEATURE_SSE2;
+        if(regs2[2] & (1 << 0 )) info->FeatureSet |= CPU_FEATURE_SSE3;
+        if(regs2[2] & (1 << 13)) info->FeatureSet |= CPU_FEATURE_CX128;
+        if(regs2[2] & (1 << 27)) info->FeatureSet |= CPU_FEATURE_XSAVE;
+
+        if((regs2[3] & (1 << 26)) && (regs2[3] & (1 << 24)) && have_sse_daz_mode()) /* has SSE2 and FXSAVE/FXRSTOR */
+            info->FeatureSet |= CPU_FEATURE_DAZ;
+
+        if (regs[1] == AUTH && regs[3] == ENTI && regs[2] == CAMD)
+        {
+            info->Level = (regs2[0] >> 8) & 0xf; /* family */
+            if (info->Level == 0xf)  /* AMD says to add the extended family to the family if family is 0xf */
+                info->Level += (regs2[0] >> 20) & 0xff;
+
+            /* repack model and stepping to make a "revision" */
+            info->Revision  = ((regs2[0] >> 16) & 0xf) << 12; /* extended model */
+            info->Revision |= ((regs2[0] >> 4 ) & 0xf) << 8;  /* model          */
+            info->Revision |= regs2[0] & 0xf;                 /* stepping       */
+
+            do_cpuid(0x80000000, regs);  /* get vendor cpuid level */
+            if (regs[0] >= 0x80000001)
+            {
+                do_cpuid(0x80000001, regs2);  /* get vendor features */
+                if (regs2[2] & (1 << 2))   info->FeatureSet |= CPU_FEATURE_VIRT;
+                if (regs2[3] & (1 << 20))  info->FeatureSet |= CPU_FEATURE_NX;
+                if (regs2[3] & (1 << 27))  info->FeatureSet |= CPU_FEATURE_TSC;
+                if (regs2[3] & (1u << 31)) info->FeatureSet |= CPU_FEATURE_3DNOW;
+            }
+        }
+        else if (regs[1] == GENU && regs[3] == INEI && regs[2] == NTEL)
+        {
+            info->Level = ((regs2[0] >> 8) & 0xf) + ((regs2[0] >> 20) & 0xff); /* family + extended family */
+            if(info->Level == 15) info->Level = 6;
+
+            /* repack model and stepping to make a "revision" */
+            info->Revision  = ((regs2[0] >> 16) & 0xf) << 12; /* extended model */
+            info->Revision |= ((regs2[0] >> 4 ) & 0xf) << 8;  /* model          */
+            info->Revision |= regs2[0] & 0xf;                 /* stepping       */
+
+            if(regs2[2] & (1 << 5))  info->FeatureSet |= CPU_FEATURE_VIRT;
+            if(regs2[3] & (1 << 21)) info->FeatureSet |= CPU_FEATURE_DS;
+
+            do_cpuid(0x80000000, regs);  /* get vendor cpuid level */
+            if (regs[0] >= 0x80000001)
+            {
+                do_cpuid(0x80000001, regs2);  /* get vendor features */
+                if (regs2[3] & (1 << 20))  info->FeatureSet |= CPU_FEATURE_NX;
+                if (regs2[3] & (1 << 27))  info->FeatureSet |= CPU_FEATURE_TSC;
+            }
+        }
+        else
+        {
+            info->Level = (regs2[0] >> 8) & 0xf; /* family */
+
+            /* repack model and stepping to make a "revision" */
+            info->Revision = ((regs2[0] >> 4 ) & 0xf) << 8;  /* model    */
+            info->Revision |= regs2[0] & 0xf;                /* stepping */
+        }
+    }
+}
+
+#elif defined(__powerpc__) || defined(__ppc__)
+
+static inline void get_cpuinfo(SYSTEM_CPU_INFORMATION* info)
+{
+#ifdef __APPLE__
+    size_t valSize;
+    int value;
+
+    valSize = sizeof(value);
+    if (sysctlbyname("hw.cpusubtype", &value, &valSize, NULL, 0) == 0)
+    {
+        switch (value)
+        {
+            case CPU_SUBTYPE_POWERPC_601:
+            case CPU_SUBTYPE_POWERPC_602:       info->Level = 1;   break;
+            case CPU_SUBTYPE_POWERPC_603:       info->Level = 3;   break;
+            case CPU_SUBTYPE_POWERPC_603e:
+            case CPU_SUBTYPE_POWERPC_603ev:     info->Level = 6;   break;
+            case CPU_SUBTYPE_POWERPC_604:       info->Level = 4;   break;
+            case CPU_SUBTYPE_POWERPC_604e:      info->Level = 9;   break;
+            case CPU_SUBTYPE_POWERPC_620:       info->Level = 20;  break;
+            case CPU_SUBTYPE_POWERPC_750:       /* G3/G4 derive from 603 so ... */
+            case CPU_SUBTYPE_POWERPC_7400:
+            case CPU_SUBTYPE_POWERPC_7450:      info->Level = 6;   break;
+            case CPU_SUBTYPE_POWERPC_970:       info->Level = 9;
+                /* :o) user_shared_data->ProcessorFeatures[PF_ALTIVEC_INSTRUCTIONS_AVAILABLE] ;-) */
+                break;
+            default: break;
+        }
+    }
+#else
+    FIXME("CPU Feature detection not implemented.\n");
+#endif
+    info->Architecture = PROCESSOR_ARCHITECTURE_PPC;
+}
+
+#elif defined(__arm__)
+
+static inline void get_cpuinfo(SYSTEM_CPU_INFORMATION* info)
+{
+#ifdef linux
+    char line[512];
+    char *s, *value;
+    FILE *f = fopen("/proc/cpuinfo", "r");
+    if (f)
+    {
+        while (fgets(line, sizeof(line), f) != NULL)
+        {
+            /* NOTE: the ':' is the only character we can rely on */
+            if (!(value = strchr(line,':')))
+                continue;
+            /* terminate the valuename */
+            s = value - 1;
+            while ((s >= line) && isspace(*s)) s--;
+            *(s + 1) = '\0';
+            /* and strip leading spaces from value */
+            value += 1;
+            while (isspace(*value)) value++;
+            if ((s = strchr(value,'\n')))
+                *s='\0';
+            if (!_stricmp(line, "CPU architecture"))
+            {
+                if (isdigit(value[0]))
+                    info->Level = atoi(value);
+                continue;
+            }
+            if (!_stricmp(line, "CPU revision"))
+            {
+                if (isdigit(value[0]))
+                    info->Revision = atoi(value);
+                continue;
+            }
+            if (!_stricmp(line, "features"))
+            {
+                if (strstr(value, "vfpv3")) info->FeatureSet |= CPU_FEATURE_ARM_VFP_32;
+                if (strstr(value, "neon"))  info->FeatureSet |= CPU_FEATURE_ARM_NEON;
+                continue;
+            }
+        }
+        fclose(f);
+    }
+#elif defined(__FreeBSD__)
+    size_t valsize;
+    char buf[8];
+    int value;
+
+    valsize = sizeof(buf);
+    if (!sysctlbyname("hw.machine_arch", &buf, &valsize, NULL, 0) &&
+        sscanf(buf, "armv%i", &value) == 1)
+        info->Level = value;
+
+    valsize = sizeof(value);
+    if (!sysctlbyname("hw.floatingpoint", &value, &valsize, NULL, 0))
+        info->FeatureSet |= CPU_FEATURE_ARM_VFP_32;
+#else
+    FIXME("CPU Feature detection not implemented.\n");
+#endif
+    info->Architecture = PROCESSOR_ARCHITECTURE_ARM;
+}
+
+#elif defined(__aarch64__)
+
+static inline void get_cpuinfo(SYSTEM_CPU_INFORMATION* info)
+{
+#ifdef linux
+    char line[512];
+    char *s, *value;
+    FILE *f = fopen("/proc/cpuinfo", "r");
+    if (f)
+    {
+        while (fgets(line, sizeof(line), f) != NULL)
+        {
+            /* NOTE: the ':' is the only character we can rely on */
+            if (!(value = strchr(line,':')))
+                continue;
+            /* terminate the valuename */
+            s = value - 1;
+            while ((s >= line) && isspace(*s)) s--;
+            *(s + 1) = '\0';
+            /* and strip leading spaces from value */
+            value += 1;
+            while (isspace(*value)) value++;
+            if ((s = strchr(value,'\n')))
+                *s='\0';
+            if (!_stricmp(line, "CPU architecture"))
+            {
+                if (isdigit(value[0]))
+                    info->Level = atoi(value);
+                continue;
+            }
+            if (!_stricmp(line, "CPU revision"))
+            {
+                if (isdigit(value[0]))
+                    info->Revision = atoi(value);
+                continue;
+            }
+            if (!_stricmp(line, "Features"))
+            {
+                if (strstr(value, "crc32")) info->FeatureSet |= CPU_FEATURE_ARM_V8_CRC32;
+                if (strstr(value, "aes"))   info->FeatureSet |= CPU_FEATURE_ARM_V8_CRYPTO;
+                continue;
+            }
+        }
+        fclose(f);
+    }
+#else
+    FIXME("CPU Feature detection not implemented.\n");
+#endif
+    info->Level = max(info->Level, 8);
+    info->Architecture = PROCESSOR_ARCHITECTURE_ARM64;
+}
+
+#endif /* End architecture specific feature detection for CPUs */
+
+/******************************************************************
+ *		fill_cpu_info
+ *
+ * inits a couple of places with CPU related information:
+ * - cpu_info in this file
+ * - Peb->NumberOfProcessors
+ * - SharedUserData->ProcessFeatures[] array
+ */
+void fill_cpu_info(void)
+{
+    long num;
+
+#ifdef _SC_NPROCESSORS_ONLN
+    num = sysconf(_SC_NPROCESSORS_ONLN);
+    if (num < 1)
+    {
+        num = 1;
+        WARN("Failed to detect the number of processors.\n");
+    }
+#elif defined(CTL_HW) && defined(HW_NCPU)
+    int mib[2];
+    size_t len = sizeof(num);
+    mib[0] = CTL_HW;
+    mib[1] = HW_NCPU;
+    if (sysctl(mib, 2, &num, &len, NULL, 0) != 0)
+    {
+        num = 1;
+        WARN("Failed to detect the number of processors.\n");
+    }
+#else
+    num = 1;
+    FIXME("Detecting the number of processors is not supported.\n");
+#endif
+    NtCurrentTeb()->Peb->NumberOfProcessors = num;
+
+    get_cpuinfo(&cpu_info);
+
+    TRACE("<- CPU arch %d, level %d, rev %d, features 0x%x\n",
+          cpu_info.Architecture, cpu_info.Level, cpu_info.Revision, cpu_info.FeatureSet);
+}
+
+static BOOL grow_logical_proc_buf(SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata,
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *max_len)
+{
+    if (pdata)
+    {
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION *new_data;
+
+        *max_len *= 2;
+        new_data = RtlReAllocateHeap(GetProcessHeap(), 0, *pdata, *max_len*sizeof(*new_data));
+        if (!new_data)
+            return FALSE;
+
+        *pdata = new_data;
+    }
+    else
+    {
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *new_dataex;
+
+        *max_len *= 2;
+        new_dataex = RtlReAllocateHeap(GetProcessHeap(), HEAP_ZERO_MEMORY, *pdataex, *max_len*sizeof(*new_dataex));
+        if (!new_dataex)
+            return FALSE;
+
+        *pdataex = new_dataex;
+    }
+
+    return TRUE;
+}
+
+static DWORD log_proc_ex_size_plus(DWORD size)
+{
+    /* add SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.Relationship and .Size */
+    return sizeof(LOGICAL_PROCESSOR_RELATIONSHIP) + sizeof(DWORD) + size;
+}
+
+static DWORD count_bits(ULONG_PTR mask)
+{
+    DWORD count = 0;
+    while (mask > 0)
+    {
+        mask >>= 1;
+        count++;
+    }
+    return count;
+}
+
+/* Store package and core information for a logical processor. Parsing of processor
+ * data may happen in multiple passes; the 'id' parameter is then used to locate
+ * previously stored data. The type of data stored in 'id' depends on 'rel':
+ * - RelationProcessorPackage: package id ('CPU socket').
+ * - RelationProcessorCore: physical core number.
+ */
+static inline BOOL logical_proc_info_add_by_id(SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata,
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *len, DWORD *pmax_len,
+        LOGICAL_PROCESSOR_RELATIONSHIP rel, DWORD id, ULONG_PTR mask)
+{
+    if (pdata) {
+        DWORD i;
+
+        for (i=0; i<*len; i++)
+        {
+            if (rel == RelationProcessorPackage && (*pdata)[i].Relationship == rel && (*pdata)[i].u.Reserved[1] == id)
+            {
+                (*pdata)[i].ProcessorMask |= mask;
+                return TRUE;
+            }
+            else if (rel == RelationProcessorCore && (*pdata)[i].Relationship == rel && (*pdata)[i].u.Reserved[1] == id)
+                return TRUE;
+        }
+
+        while(*len == *pmax_len)
+        {
+            if (!grow_logical_proc_buf(pdata, NULL, pmax_len))
+                return FALSE;
+        }
+
+        (*pdata)[i].Relationship = rel;
+        (*pdata)[i].ProcessorMask = mask;
+        if (rel == RelationProcessorCore)
+            (*pdata)[i].u.ProcessorCore.Flags = count_bits(mask) > 1 ? LTP_PC_SMT : 0;
+        (*pdata)[i].u.Reserved[0] = 0;
+        (*pdata)[i].u.Reserved[1] = id;
+        *len = i+1;
+    }else{
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
+        DWORD ofs = 0;
+
+        while(ofs < *len)
+        {
+            dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
+            if (rel == RelationProcessorPackage && dataex->Relationship == rel && dataex->u.Processor.Reserved[1] == id)
+            {
+                dataex->u.Processor.GroupMask[0].Mask |= mask;
+                return TRUE;
+            }
+            else if (rel == RelationProcessorCore && dataex->Relationship == rel && dataex->u.Processor.Reserved[1] == id)
+            {
+                return TRUE;
+            }
+            ofs += dataex->Size;
+        }
+
+        /* TODO: For now, just one group. If more than 64 processors, then we
+         * need another group. */
+
+        while (ofs + log_proc_ex_size_plus(sizeof(PROCESSOR_RELATIONSHIP)) > *pmax_len)
+        {
+            if (!grow_logical_proc_buf(NULL, pdataex, pmax_len))
+                return FALSE;
+        }
+
+        dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
+
+        dataex->Relationship = rel;
+        dataex->Size = log_proc_ex_size_plus(sizeof(PROCESSOR_RELATIONSHIP));
+        if (rel == RelationProcessorCore)
+            dataex->u.Processor.Flags = count_bits(mask) > 1 ? LTP_PC_SMT : 0;
+        else
+            dataex->u.Processor.Flags = 0;
+        dataex->u.Processor.EfficiencyClass = 0;
+        dataex->u.Processor.GroupCount = 1;
+        dataex->u.Processor.GroupMask[0].Mask = mask;
+        dataex->u.Processor.GroupMask[0].Group = 0;
+        /* mark for future lookup */
+        dataex->u.Processor.Reserved[0] = 0;
+        dataex->u.Processor.Reserved[1] = id;
+
+        *len += dataex->Size;
+    }
+
+    return TRUE;
+}
+
+static inline BOOL logical_proc_info_add_cache(SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata,
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *len,
+        DWORD *pmax_len, ULONG_PTR mask, CACHE_DESCRIPTOR *cache)
+{
+    if (pdata)
+    {
+        DWORD i;
+
+        for (i=0; i<*len; i++)
+        {
+            if ((*pdata)[i].Relationship==RelationCache && (*pdata)[i].ProcessorMask==mask
+                    && (*pdata)[i].u.Cache.Level==cache->Level && (*pdata)[i].u.Cache.Type==cache->Type)
+                return TRUE;
+        }
+
+        while (*len == *pmax_len)
+            if (!grow_logical_proc_buf(pdata, NULL, pmax_len))
+                return FALSE;
+
+        (*pdata)[i].Relationship = RelationCache;
+        (*pdata)[i].ProcessorMask = mask;
+        (*pdata)[i].u.Cache = *cache;
+        *len = i+1;
+    }
+    else
+    {
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
+        DWORD ofs;
+
+        for (ofs = 0; ofs < *len; )
+        {
+            dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
+            if (dataex->Relationship == RelationCache && dataex->u.Cache.GroupMask.Mask == mask &&
+                    dataex->u.Cache.Level == cache->Level && dataex->u.Cache.Type == cache->Type)
+                return TRUE;
+            ofs += dataex->Size;
+        }
+
+        while (ofs + log_proc_ex_size_plus(sizeof(CACHE_RELATIONSHIP)) > *pmax_len)
+        {
+            if (!grow_logical_proc_buf(NULL, pdataex, pmax_len))
+                return FALSE;
+        }
+
+        dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
+
+        dataex->Relationship = RelationCache;
+        dataex->Size = log_proc_ex_size_plus(sizeof(CACHE_RELATIONSHIP));
+        dataex->u.Cache.Level = cache->Level;
+        dataex->u.Cache.Associativity = cache->Associativity;
+        dataex->u.Cache.LineSize = cache->LineSize;
+        dataex->u.Cache.CacheSize = cache->Size;
+        dataex->u.Cache.Type = cache->Type;
+        dataex->u.Cache.GroupMask.Mask = mask;
+        dataex->u.Cache.GroupMask.Group = 0;
+
+        *len += dataex->Size;
+    }
+
+    return TRUE;
+}
+
+static inline BOOL logical_proc_info_add_numa_node(SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata,
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *len, DWORD *pmax_len, ULONG_PTR mask,
+        DWORD node_id)
+{
+    if (pdata)
+    {
+        while (*len == *pmax_len)
+            if (!grow_logical_proc_buf(pdata, NULL, pmax_len))
+                return FALSE;
+
+        (*pdata)[*len].Relationship = RelationNumaNode;
+        (*pdata)[*len].ProcessorMask = mask;
+        (*pdata)[*len].u.NumaNode.NodeNumber = node_id;
+        (*len)++;
+    }
+    else
+    {
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
+
+        while (*len + log_proc_ex_size_plus(sizeof(NUMA_NODE_RELATIONSHIP)) > *pmax_len)
+        {
+            if (!grow_logical_proc_buf(NULL, pdataex, pmax_len))
+                return FALSE;
+        }
+
+        dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + *len);
+
+        dataex->Relationship = RelationNumaNode;
+        dataex->Size = log_proc_ex_size_plus(sizeof(NUMA_NODE_RELATIONSHIP));
+        dataex->u.NumaNode.NodeNumber = node_id;
+        dataex->u.NumaNode.GroupMask.Mask = mask;
+        dataex->u.NumaNode.GroupMask.Group = 0;
+
+        *len += dataex->Size;
+    }
+
+    return TRUE;
+}
+
+static inline BOOL logical_proc_info_add_group(SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex,
+        DWORD *len, DWORD *pmax_len, DWORD num_cpus, ULONG_PTR mask)
+{
+    SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
+
+    while (*len + log_proc_ex_size_plus(sizeof(GROUP_RELATIONSHIP)) > *pmax_len)
+    {
+        if (!grow_logical_proc_buf(NULL, pdataex, pmax_len))
+            return FALSE;
+    }
+
+    dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + *len);
+
+    dataex->Relationship = RelationGroup;
+    dataex->Size = log_proc_ex_size_plus(sizeof(GROUP_RELATIONSHIP));
+    dataex->u.Group.MaximumGroupCount = 1;
+    dataex->u.Group.ActiveGroupCount = 1;
+    dataex->u.Group.GroupInfo[0].MaximumProcessorCount = num_cpus;
+    dataex->u.Group.GroupInfo[0].ActiveProcessorCount = num_cpus;
+    dataex->u.Group.GroupInfo[0].ActiveProcessorMask = mask;
+
+    *len += dataex->Size;
+
+    return TRUE;
+}
+
+#ifdef linux
+/* Helper function for counting bitmap values as commonly used by the Linux kernel
+ * for storing CPU masks in sysfs. The format is comma separated lists of hex values
+ * each max 32-bit e.g. "00ff" or even "00,00000000,0000ffff".
+ *
+ * Example files include:
+ * - /sys/devices/system/cpu/cpu0/cache/index0/shared_cpu_map
+ * - /sys/devices/system/cpu/cpu0/topology/thread_siblings
+ */
+static BOOL sysfs_parse_bitmap(const char *filename, ULONG_PTR * const mask)
+{
+    FILE *f;
+    DWORD r;
+
+    f = fopen(filename, "r");
+    if (!f)
+        return FALSE;
+
+    while (!feof(f))
+    {
+        char op;
+        if (!fscanf(f, "%x%c ", &r, &op))
+            break;
+
+        *mask = (sizeof(ULONG_PTR)>sizeof(int) ? *mask<<(8*sizeof(DWORD)) : 0) + r;
+    }
+
+    fclose(f);
+    return TRUE;
+}
+
+/* Helper function for counting number of elements in interval lists as used by
+ * the Linux kernel. The format is comma separated list of intervals of which
+ * each interval has the format of "begin-end" where begin and end are decimal
+ * numbers. E.g. "0-7", "0-7,16-23"
+ *
+ * Example files include:
+ * - /sys/devices/system/cpu/online
+ * - /sys/devices/system/cpu/cpu0/cache/index0/shared_cpu_list
+ * - /sys/devices/system/cpu/cpu0/topology/thread_siblings_list.
+ */
+static BOOL sysfs_count_list_elements(const char *filename, DWORD *result)
+{
+    FILE *f;
+
+    f = fopen(filename, "r");
+    if (!f)
+        return FALSE;
+
+    while (!feof(f))
+    {
+        char op;
+        DWORD beg, end;
+
+        if (!fscanf(f, "%u%c ", &beg, &op))
+            break;
+
+        if(op == '-')
+            fscanf(f, "%u%c ", &end, &op);
+        else
+            end = beg;
+
+        *result += end - beg + 1;
+    }
+
+    fclose(f);
+    return TRUE;
+}
+
+/* for 'data', max_len is the array count. for 'dataex', max_len is in bytes */
+static NTSTATUS create_logical_proc_info(SYSTEM_LOGICAL_PROCESSOR_INFORMATION **data,
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **dataex, DWORD *max_len, DWORD relation)
+{
+    static const char core_info[] = "/sys/devices/system/cpu/cpu%u/topology/%s";
+    static const char cache_info[] = "/sys/devices/system/cpu/cpu%u/cache/index%u/%s";
+    static const char numa_info[] = "/sys/devices/system/node/node%u/cpumap";
+
+    FILE *fcpu_list, *fnuma_list, *f;
+    DWORD len = 0, beg, end, i, j, r, num_cpus = 0, max_cpus = 0;
+    char op, name[MAX_PATH];
+    ULONG_PTR all_cpus_mask = 0;
+
+    /* On systems with a large number of CPU cores (32 or 64 depending on 32-bit or 64-bit),
+     * we have issues parsing processor information:
+     * - ULONG_PTR masks as used in data structures can't hold all cores. Requires splitting
+     *   data appropriately into "processor groups". We are hard coding 1.
+     * - Thread affinity code in wineserver and our CPU parsing code here work independently.
+     *   So far the Windows mask applied directly to Linux, but process groups break that.
+     *   (NUMA systems you may have multiple non-full groups.)
+     */
+    if(sysfs_count_list_elements("/sys/devices/system/cpu/present", &max_cpus) && max_cpus > MAXIMUM_PROCESSORS)
+    {
+        FIXME("Improve CPU info reporting: system supports %u logical cores, but only %u supported!\n",
+                max_cpus, MAXIMUM_PROCESSORS);
+    }
+
+    fcpu_list = fopen("/sys/devices/system/cpu/online", "r");
+    if(!fcpu_list)
+        return STATUS_NOT_IMPLEMENTED;
+
+    while(!feof(fcpu_list))
+    {
+        if(!fscanf(fcpu_list, "%u%c ", &beg, &op))
+            break;
+        if(op == '-') fscanf(fcpu_list, "%u%c ", &end, &op);
+        else end = beg;
+
+        for(i=beg; i<=end; i++)
+        {
+            DWORD phys_core = 0;
+            ULONG_PTR thread_mask = 0;
+
+            if(i > 8*sizeof(ULONG_PTR))
+            {
+                FIXME("skipping logical processor %d\n", i);
+                continue;
+            }
+
+            if(relation == RelationAll || relation == RelationProcessorPackage)
+            {
+                sprintf(name, core_info, i, "physical_package_id");
+                f = fopen(name, "r");
+                if(f)
+                {
+                    fscanf(f, "%u", &r);
+                    fclose(f);
+                }
+                else r = 0;
+                if(!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorPackage, r, (ULONG_PTR)1 << i))
+                {
+                    fclose(fcpu_list);
+                    return STATUS_NO_MEMORY;
+                }
+            }
+
+            /* Sysfs enumerates logical cores (and not physical cores), but Windows enumerates
+             * by physical core. Upon enumerating a logical core in sysfs, we register a physical
+             * core and all its logical cores. In order to not report physical cores multiple
+             * times, we pass a unique physical core ID to logical_proc_info_add_by_id and let
+             * that call figure out any duplication.
+             * Obtain a unique physical core ID from the first element of thread_siblings_list.
+             * This list provides logical cores sharing the same physical core. The IDs are based
+             * on kernel cpu core numbering as opposed to a hardware core ID like provided through
+             * 'core_id', so are suitable as a unique ID.
+             */
+            if(relation == RelationAll || relation == RelationProcessorCore ||
+               relation == RelationNumaNode || relation == RelationGroup)
+            {
+                /* Mask of logical threads sharing same physical core in kernel core numbering. */
+                sprintf(name, core_info, i, "thread_siblings");
+                if(!sysfs_parse_bitmap(name, &thread_mask))
+                    thread_mask = 1<<i;
+
+                /* Needed later for NumaNode and Group. */
+                all_cpus_mask |= thread_mask;
+
+                if(relation == RelationAll || relation == RelationProcessorCore)
+                {
+                    sprintf(name, core_info, i, "thread_siblings_list");
+                    f = fopen(name, "r");
+                    if(f)
+                    {
+                        fscanf(f, "%d%c", &phys_core, &op);
+                        fclose(f);
+                    }
+                    else phys_core = i;
+
+                    if(!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorCore, phys_core, thread_mask))
+                    {
+                        fclose(fcpu_list);
+                        return STATUS_NO_MEMORY;
+                    }
+                }
+            }
+
+            if (relation == RelationAll || relation == RelationCache)
+            {
+                for(j=0; j<4; j++)
+                {
+                    CACHE_DESCRIPTOR cache;
+                    ULONG_PTR mask = 0;
+
+                    sprintf(name, cache_info, i, j, "shared_cpu_map");
+                    if(!sysfs_parse_bitmap(name, &mask)) continue;
+
+                    sprintf(name, cache_info, i, j, "level");
+                    f = fopen(name, "r");
+                    if(!f) continue;
+                    fscanf(f, "%u", &r);
+                    fclose(f);
+                    cache.Level = r;
+
+                    sprintf(name, cache_info, i, j, "ways_of_associativity");
+                    f = fopen(name, "r");
+                    if(!f) continue;
+                    fscanf(f, "%u", &r);
+                    fclose(f);
+                    cache.Associativity = r;
+
+                    sprintf(name, cache_info, i, j, "coherency_line_size");
+                    f = fopen(name, "r");
+                    if(!f) continue;
+                    fscanf(f, "%u", &r);
+                    fclose(f);
+                    cache.LineSize = r;
+
+                    sprintf(name, cache_info, i, j, "size");
+                    f = fopen(name, "r");
+                    if(!f) continue;
+                    fscanf(f, "%u%c", &r, &op);
+                    fclose(f);
+                    if(op != 'K')
+                        WARN("unknown cache size %u%c\n", r, op);
+                    cache.Size = (op=='K' ? r*1024 : r);
+
+                    sprintf(name, cache_info, i, j, "type");
+                    f = fopen(name, "r");
+                    if(!f) continue;
+                    fscanf(f, "%s", name);
+                    fclose(f);
+                    if(!memcmp(name, "Data", 5))
+                        cache.Type = CacheData;
+                    else if(!memcmp(name, "Instruction", 11))
+                        cache.Type = CacheInstruction;
+                    else
+                        cache.Type = CacheUnified;
+
+                    if(!logical_proc_info_add_cache(data, dataex, &len, max_len, mask, &cache))
+                    {
+                        fclose(fcpu_list);
+                        return STATUS_NO_MEMORY;
+                    }
+                }
+            }
+        }
+    }
+    fclose(fcpu_list);
+
+    num_cpus = count_bits(all_cpus_mask);
+
+    if(relation == RelationAll || relation == RelationNumaNode)
+    {
+        fnuma_list = fopen("/sys/devices/system/node/online", "r");
+        if(!fnuma_list)
+        {
+            if(!logical_proc_info_add_numa_node(data, dataex, &len, max_len, all_cpus_mask, 0))
+                return STATUS_NO_MEMORY;
+        }
+        else
+        {
+            while(!feof(fnuma_list))
+            {
+                if(!fscanf(fnuma_list, "%u%c ", &beg, &op))
+                    break;
+                if(op == '-') fscanf(fnuma_list, "%u%c ", &end, &op);
+                else end = beg;
+
+                for(i=beg; i<=end; i++)
+                {
+                    ULONG_PTR mask = 0;
+
+                    sprintf(name, numa_info, i);
+                    f = fopen(name, "r");
+                    if(!f) continue;
+                    while(!feof(f))
+                    {
+                        if(!fscanf(f, "%x%c ", &r, &op))
+                            break;
+                        mask = (sizeof(ULONG_PTR)>sizeof(int) ? mask<<(8*sizeof(DWORD)) : 0) + r;
+                    }
+                    fclose(f);
+
+                    if(!logical_proc_info_add_numa_node(data, dataex, &len, max_len, mask, i))
+                    {
+                        fclose(fnuma_list);
+                        return STATUS_NO_MEMORY;
+                    }
+                }
+            }
+            fclose(fnuma_list);
+        }
+    }
+
+    if(dataex && (relation == RelationAll || relation == RelationGroup))
+        logical_proc_info_add_group(dataex, &len, max_len, num_cpus, all_cpus_mask);
+
+    if(data)
+        *max_len = len * sizeof(**data);
+    else
+        *max_len = len;
+
+    return STATUS_SUCCESS;
+}
+#elif defined(__APPLE__)
+/* for 'data', max_len is the array count. for 'dataex', max_len is in bytes */
+static NTSTATUS create_logical_proc_info(SYSTEM_LOGICAL_PROCESSOR_INFORMATION **data,
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **dataex, DWORD *max_len, DWORD relation)
+{
+    DWORD pkgs_no, cores_no, lcpu_no, lcpu_per_core, cores_per_package, assoc, len = 0;
+    DWORD cache_ctrs[10] = {0};
+    ULONG_PTR all_cpus_mask = 0;
+    CACHE_DESCRIPTOR cache[10];
+    LONGLONG cache_size, cache_line_size, cache_sharing[10];
+    size_t size;
+    DWORD p,i,j,k;
+
+    if (relation != RelationAll)
+        FIXME("Relationship filtering not implemented: 0x%x\n", relation);
+
+    lcpu_no = NtCurrentTeb()->Peb->NumberOfProcessors;
+
+    size = sizeof(pkgs_no);
+    if(sysctlbyname("hw.packages", &pkgs_no, &size, NULL, 0))
+        pkgs_no = 1;
+
+    size = sizeof(cores_no);
+    if(sysctlbyname("hw.physicalcpu", &cores_no, &size, NULL, 0))
+        cores_no = lcpu_no;
+
+    TRACE("%u logical CPUs from %u physical cores across %u packages\n",
+            lcpu_no, cores_no, pkgs_no);
+
+    lcpu_per_core = lcpu_no / cores_no;
+    cores_per_package = cores_no / pkgs_no;
+
+    memset(cache, 0, sizeof(cache));
+    cache[1].Level = 1;
+    cache[1].Type = CacheInstruction;
+    cache[1].Associativity = 8; /* reasonable default */
+    cache[1].LineSize = 0x40; /* reasonable default */
+    cache[2].Level = 1;
+    cache[2].Type = CacheData;
+    cache[2].Associativity = 8;
+    cache[2].LineSize = 0x40;
+    cache[3].Level = 2;
+    cache[3].Type = CacheUnified;
+    cache[3].Associativity = 8;
+    cache[3].LineSize = 0x40;
+    cache[4].Level = 3;
+    cache[4].Type = CacheUnified;
+    cache[4].Associativity = 12;
+    cache[4].LineSize = 0x40;
+
+    size = sizeof(cache_line_size);
+    if(!sysctlbyname("hw.cachelinesize", &cache_line_size, &size, NULL, 0))
+    {
+        for(i=1; i<5; i++)
+            cache[i].LineSize = cache_line_size;
+    }
+
+    /* TODO: set actual associativity for all caches */
+    size = sizeof(assoc);
+    if(!sysctlbyname("machdep.cpu.cache.L2_associativity", &assoc, &size, NULL, 0))
+        cache[3].Associativity = assoc;
+
+    size = sizeof(cache_size);
+    if(!sysctlbyname("hw.l1icachesize", &cache_size, &size, NULL, 0))
+        cache[1].Size = cache_size;
+    size = sizeof(cache_size);
+    if(!sysctlbyname("hw.l1dcachesize", &cache_size, &size, NULL, 0))
+        cache[2].Size = cache_size;
+    size = sizeof(cache_size);
+    if(!sysctlbyname("hw.l2cachesize", &cache_size, &size, NULL, 0))
+        cache[3].Size = cache_size;
+    size = sizeof(cache_size);
+    if(!sysctlbyname("hw.l3cachesize", &cache_size, &size, NULL, 0))
+        cache[4].Size = cache_size;
+
+    size = sizeof(cache_sharing);
+    if(sysctlbyname("hw.cacheconfig", cache_sharing, &size, NULL, 0) < 0){
+        cache_sharing[1] = lcpu_per_core;
+        cache_sharing[2] = lcpu_per_core;
+        cache_sharing[3] = lcpu_per_core;
+        cache_sharing[4] = lcpu_no;
+    }else{
+        /* in cache[], indexes 1 and 2 are l1 caches */
+        cache_sharing[4] = cache_sharing[3];
+        cache_sharing[3] = cache_sharing[2];
+        cache_sharing[2] = cache_sharing[1];
+    }
+
+    for(p = 0; p < pkgs_no; ++p){
+        for(j = 0; j < cores_per_package && p * cores_per_package + j < cores_no; ++j){
+            ULONG_PTR mask = 0;
+            DWORD phys_core;
+
+            for(k = 0; k < lcpu_per_core; ++k)
+                mask |= (ULONG_PTR)1 << (j * lcpu_per_core + k);
+
+            all_cpus_mask |= mask;
+
+            /* add to package */
+            if(!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorPackage, p, mask))
+                return STATUS_NO_MEMORY;
+
+            /* add new core */
+            phys_core = p * cores_per_package + j;
+            if(!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorCore, phys_core, mask))
+                return STATUS_NO_MEMORY;
+
+            for(i = 1; i < 5; ++i){
+                if(cache_ctrs[i] == 0 && cache[i].Size > 0){
+                    mask = 0;
+                    for(k = 0; k < cache_sharing[i]; ++k)
+                        mask |= (ULONG_PTR)1 << (j * lcpu_per_core + k);
+
+                    if(!logical_proc_info_add_cache(data, dataex, &len, max_len, mask, &cache[i]))
+                        return STATUS_NO_MEMORY;
+                }
+
+                cache_ctrs[i] += lcpu_per_core;
+
+                if(cache_ctrs[i] == cache_sharing[i])
+                    cache_ctrs[i] = 0;
+            }
+        }
+    }
+
+    /* OSX doesn't support NUMA, so just make one NUMA node for all CPUs */
+    if(!logical_proc_info_add_numa_node(data, dataex, &len, max_len, all_cpus_mask, 0))
+        return STATUS_NO_MEMORY;
+
+    if(dataex)
+        logical_proc_info_add_group(dataex, &len, max_len, lcpu_no, all_cpus_mask);
+
+    if(data)
+        *max_len = len * sizeof(**data);
+    else
+        *max_len = len;
+
+    return STATUS_SUCCESS;
+}
+#else
+static NTSTATUS create_logical_proc_info(SYSTEM_LOGICAL_PROCESSOR_INFORMATION **data,
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **dataex, DWORD *max_len, DWORD relation)
+{
+    FIXME("stub\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+#endif
+
+#ifdef linux
+
+static inline void copy_smbios_string(char **buffer, char *s, size_t len)
+{
+    if (!len) return;
+    memcpy(*buffer, s, len + 1);
+    *buffer += len + 1;
+}
+
+static size_t get_smbios_string(const char *path, char *str, size_t size)
+{
+    FILE *file;
+    size_t len;
+
+    if (!(file = fopen(path, "r")))
+        return 0;
+
+    len = fread(str, 1, size - 1, file);
+    fclose(file);
+
+    if (len >= 1 && str[len - 1] == '\n')
+        len--;
+
+    str[len] = 0;
+
+    return len;
+}
+
+static void get_system_uuid( GUID *uuid )
+{
+    static const unsigned char hex[] =
+    {
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x00 */
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x10 */
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x20 */
+        0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,        /* 0x30 */
+        0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,  /* 0x40 */
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x50 */
+        0,10,11,12,13,14,15                     /* 0x60 */
+    };
+    int fd;
+
+    memset( uuid, 0xff, sizeof(*uuid) );
+    if ((fd = open( "/var/lib/dbus/machine-id", O_RDONLY )) != -1)
+    {
+        unsigned char buf[32], *p = buf;
+        if (read( fd, buf, sizeof(buf) ) == sizeof(buf))
+        {
+            uuid->Data1 = hex[p[6]] << 28 | hex[p[7]] << 24 | hex[p[4]] << 20 | hex[p[5]] << 16 |
+                          hex[p[2]] << 12 | hex[p[3]] << 8  | hex[p[0]] << 4  | hex[p[1]];
+
+            uuid->Data2 = hex[p[10]] << 12 | hex[p[11]] << 8 | hex[p[8]]  << 4 | hex[p[9]];
+            uuid->Data3 = hex[p[14]] << 12 | hex[p[15]] << 8 | hex[p[12]] << 4 | hex[p[13]];
+
+            uuid->Data4[0] = hex[p[16]] << 4 | hex[p[17]];
+            uuid->Data4[1] = hex[p[18]] << 4 | hex[p[19]];
+            uuid->Data4[2] = hex[p[20]] << 4 | hex[p[21]];
+            uuid->Data4[3] = hex[p[22]] << 4 | hex[p[23]];
+            uuid->Data4[4] = hex[p[24]] << 4 | hex[p[25]];
+            uuid->Data4[5] = hex[p[26]] << 4 | hex[p[27]];
+            uuid->Data4[6] = hex[p[28]] << 4 | hex[p[29]];
+            uuid->Data4[7] = hex[p[30]] << 4 | hex[p[31]];
+        }
+        close( fd );
+    }
+}
+
+static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG available_len, ULONG *required_len)
+{
+    switch (sfti->ProviderSignature)
+    {
+    case RSMB:
+        {
+            char bios_vendor[128], bios_version[128], bios_date[128];
+            size_t bios_vendor_len, bios_version_len, bios_date_len;
+            char system_vendor[128], system_product[128], system_version[128], system_serial[128];
+            size_t system_vendor_len, system_product_len, system_version_len, system_serial_len;
+            char system_sku[128], system_family[128];
+            size_t system_sku_len, system_family_len;
+            char board_vendor[128], board_product[128], board_version[128], board_serial[128];
+            size_t board_vendor_len, board_product_len, board_version_len, board_serial_len;
+            char chassis_vendor[128], chassis_version[128], chassis_serial[128], chassis_asset_tag[128];
+            char chassis_type[11] = "2"; /* unknown */
+            size_t chassis_vendor_len, chassis_version_len, chassis_serial_len, chassis_asset_tag_len;
+            char *buffer = (char*)sfti->TableBuffer;
+            BYTE string_count;
+            struct smbios_prologue *prologue;
+            struct smbios_bios *bios;
+            struct smbios_system *system;
+            struct smbios_board *board;
+            struct smbios_chassis *chassis;
+
+#define S(s) s, sizeof(s)
+            bios_vendor_len = get_smbios_string("/sys/class/dmi/id/bios_vendor", S(bios_vendor));
+            bios_version_len = get_smbios_string("/sys/class/dmi/id/bios_version", S(bios_version));
+            bios_date_len = get_smbios_string("/sys/class/dmi/id/bios_date", S(bios_date));
+            system_vendor_len = get_smbios_string("/sys/class/dmi/id/sys_vendor", S(system_vendor));
+            system_product_len = get_smbios_string("/sys/class/dmi/id/product_name", S(system_product));
+            system_version_len = get_smbios_string("/sys/class/dmi/id/product_version", S(system_version));
+            system_serial_len = get_smbios_string("/sys/class/dmi/id/product_serial", S(system_serial));
+            system_sku_len = get_smbios_string("/sys/class/dmi/id/product_sku", S(system_sku));
+            system_family_len = get_smbios_string("/sys/class/dmi/id/product_family", S(system_family));
+            board_vendor_len = get_smbios_string("/sys/class/dmi/id/board_vendor", S(board_vendor));
+            board_product_len = get_smbios_string("/sys/class/dmi/id/board_name", S(board_product));
+            board_version_len = get_smbios_string("/sys/class/dmi/id/board_version", S(board_version));
+            board_serial_len = get_smbios_string("/sys/class/dmi/id/board_serial", S(board_serial));
+            chassis_vendor_len = get_smbios_string("/sys/class/dmi/id/chassis_vendor", S(chassis_vendor));
+            chassis_version_len = get_smbios_string("/sys/class/dmi/id/chassis_version", S(chassis_version));
+            chassis_serial_len = get_smbios_string("/sys/class/dmi/id/chassis_serial", S(chassis_serial));
+            chassis_asset_tag_len = get_smbios_string("/sys/class/dmi/id/chassis_tag", S(chassis_asset_tag));
+            get_smbios_string("/sys/class/dmi/id/chassis_type", S(chassis_type));
+#undef S
+
+            *required_len = sizeof(struct smbios_prologue);
+
+#define L(l) (l + (l ? 1 : 0))
+            *required_len += sizeof(struct smbios_bios);
+            *required_len += max(L(bios_vendor_len) + L(bios_version_len) + L(bios_date_len) + 1, 2);
+
+            *required_len += sizeof(struct smbios_system);
+            *required_len += max(L(system_vendor_len) + L(system_product_len) + L(system_version_len) +
+                                 L(system_serial_len) + L(system_sku_len) + L(system_family_len) + 1, 2);
+
+            *required_len += sizeof(struct smbios_board);
+            *required_len += max(L(board_vendor_len) + L(board_product_len) + L(board_version_len) + L(board_serial_len) + 1, 2);
+
+            *required_len += sizeof(struct smbios_chassis);
+            *required_len += max(L(chassis_vendor_len) + L(chassis_version_len) + L(chassis_serial_len) +
+                                 L(chassis_asset_tag_len) + 1, 2);
+#undef L
+
+            sfti->TableBufferLength = *required_len;
+
+            *required_len += FIELD_OFFSET(SYSTEM_FIRMWARE_TABLE_INFORMATION, TableBuffer);
+
+            if (available_len < *required_len)
+                return STATUS_BUFFER_TOO_SMALL;
+
+            prologue = (struct smbios_prologue*)buffer;
+            prologue->calling_method = 0;
+            prologue->major_version = 2;
+            prologue->minor_version = 4;
+            prologue->revision = 0;
+            prologue->length = sfti->TableBufferLength - sizeof(struct smbios_prologue);
+            buffer += sizeof(struct smbios_prologue);
+
+            string_count = 0;
+            bios = (struct smbios_bios*)buffer;
+            bios->hdr.type = 0;
+            bios->hdr.length = sizeof(struct smbios_bios);
+            bios->hdr.handle = 0;
+            bios->vendor = bios_vendor_len ? ++string_count : 0;
+            bios->version = bios_version_len ? ++string_count : 0;
+            bios->start = 0;
+            bios->date = bios_date_len ? ++string_count : 0;
+            bios->size = 0;
+            bios->characteristics = 0x4; /* not supported */
+            bios->characteristics_ext[0] = 0;
+            bios->characteristics_ext[1] = 0;
+            bios->system_bios_major_release = 0xFF; /* not supported */
+            bios->system_bios_minor_release = 0xFF; /* not supported */
+            bios->ec_firmware_major_release = 0xFF; /* not supported */
+            bios->ec_firmware_minor_release = 0xFF; /* not supported */
+            buffer += sizeof(struct smbios_bios);
+
+            copy_smbios_string(&buffer, bios_vendor, bios_vendor_len);
+            copy_smbios_string(&buffer, bios_version, bios_version_len);
+            copy_smbios_string(&buffer, bios_date, bios_date_len);
+            if (!string_count) *buffer++ = 0;
+            *buffer++ = 0;
 
-#define NONAMELESSUNION
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "wine/debug.h"
-#include "windef.h"
-#include "winternl.h"
-#include "ntdll_misc.h"
-#include "wine/server.h"
-#include "ddk/wdm.h"
+            string_count = 0;
+            system = (struct smbios_system*)buffer;
+            system->hdr.type = 1;
+            system->hdr.length = sizeof(struct smbios_system);
+            system->hdr.handle = 0;
+            system->vendor = system_vendor_len ? ++string_count : 0;
+            system->product = system_product_len ? ++string_count : 0;
+            system->version = system_version_len ? ++string_count : 0;
+            system->serial = system_serial_len ? ++string_count : 0;
+            get_system_uuid( (GUID *)system->uuid );
+            system->wake_up_type = 0x02; /* unknown */
+            system->sku_number = system_sku_len ? ++string_count : 0;
+            system->family = system_family_len ? ++string_count : 0;
+            buffer += sizeof(struct smbios_system);
 
-WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
+            copy_smbios_string(&buffer, system_vendor, system_vendor_len);
+            copy_smbios_string(&buffer, system_product, system_product_len);
+            copy_smbios_string(&buffer, system_version, system_version_len);
+            copy_smbios_string(&buffer, system_serial, system_serial_len);
+            copy_smbios_string(&buffer, system_sku, system_sku_len);
+            copy_smbios_string(&buffer, system_family, system_family_len);
+            if (!string_count) *buffer++ = 0;
+            *buffer++ = 0;
 
-/*
- *	Token
- */
+            string_count = 0;
+            board = (struct smbios_board*)buffer;
+            board->hdr.type = 2;
+            board->hdr.length = sizeof(struct smbios_board);
+            board->hdr.handle = 0;
+            board->vendor = board_vendor_len ? ++string_count : 0;
+            board->product = board_product_len ? ++string_count : 0;
+            board->version = board_version_len ? ++string_count : 0;
+            board->serial = board_serial_len ? ++string_count : 0;
+            buffer += sizeof(struct smbios_board);
 
-/*
- *	Misc
- */
+            copy_smbios_string(&buffer, board_vendor, board_vendor_len);
+            copy_smbios_string(&buffer, board_product, board_product_len);
+            copy_smbios_string(&buffer, board_version, board_version_len);
+            copy_smbios_string(&buffer, board_serial, board_serial_len);
+            if (!string_count) *buffer++ = 0;
+            *buffer++ = 0;
+
+            string_count = 0;
+            chassis = (struct smbios_chassis*)buffer;
+            chassis->hdr.type = 3;
+            chassis->hdr.length = sizeof(struct smbios_chassis);
+            chassis->hdr.handle = 0;
+            chassis->vendor = chassis_vendor_len ? ++string_count : 0;
+            chassis->type = atoi(chassis_type);
+            chassis->version = chassis_version_len ? ++string_count : 0;
+            chassis->serial = chassis_serial_len ? ++string_count : 0;
+            chassis->asset_tag = chassis_asset_tag_len ? ++string_count : 0;
+            chassis->boot_state = 0x02; /* unknown */
+            chassis->power_supply_state = 0x02; /* unknown */
+            chassis->thermal_state = 0x02; /* unknown */
+            chassis->security_status = 0x02; /* unknown */
+            buffer += sizeof(struct smbios_chassis);
+
+            copy_smbios_string(&buffer, chassis_vendor, chassis_vendor_len);
+            copy_smbios_string(&buffer, chassis_version, chassis_version_len);
+            copy_smbios_string(&buffer, chassis_serial, chassis_serial_len);
+            copy_smbios_string(&buffer, chassis_asset_tag, chassis_asset_tag_len);
+            if (!string_count) *buffer++ = 0;
+            *buffer++ = 0;
+
+            return STATUS_SUCCESS;
+        }
+    default:
+        {
+            FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION provider %08x\n", sfti->ProviderSignature);
+            return STATUS_NOT_IMPLEMENTED;
+        }
+    }
+}
+
+#elif defined(__APPLE__)
+static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG available_len, ULONG *required_len)
+{
+    switch (sfti->ProviderSignature)
+    {
+    case RSMB:
+    {
+        io_service_t service;
+        CFDataRef data;
+        const UInt8 *ptr;
+        CFIndex len;
+        struct smbios_prologue *prologue;
+        BYTE major_version = 2, minor_version = 0;
+
+        if (!(service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleSMBIOS"))))
+        {
+            WARN("can't find AppleSMBIOS service\n");
+            return STATUS_NO_MEMORY;
+        }
+
+        if (!(data = IORegistryEntryCreateCFProperty(service, CFSTR("SMBIOS-EPS"), kCFAllocatorDefault, 0)))
+        {
+            WARN("can't find SMBIOS entry point\n");
+            IOObjectRelease(service);
+            return STATUS_NO_MEMORY;
+        }
+
+        len = CFDataGetLength(data);
+        ptr = CFDataGetBytePtr(data);
+        if (len >= 8 && !memcmp(ptr, "_SM_", 4))
+        {
+            major_version = ptr[6];
+            minor_version = ptr[7];
+        }
+        CFRelease(data);
+
+        if (!(data = IORegistryEntryCreateCFProperty(service, CFSTR("SMBIOS"), kCFAllocatorDefault, 0)))
+        {
+            WARN("can't find SMBIOS table\n");
+            IOObjectRelease(service);
+            return STATUS_NO_MEMORY;
+        }
+
+        len = CFDataGetLength(data);
+        ptr = CFDataGetBytePtr(data);
+        sfti->TableBufferLength = sizeof(*prologue) + len;
+        *required_len = sfti->TableBufferLength + FIELD_OFFSET(SYSTEM_FIRMWARE_TABLE_INFORMATION, TableBuffer);
+        if (available_len < *required_len)
+        {
+            CFRelease(data);
+            IOObjectRelease(service);
+            return STATUS_BUFFER_TOO_SMALL;
+        }
+
+        prologue = (struct smbios_prologue *)sfti->TableBuffer;
+        prologue->calling_method = 0;
+        prologue->major_version = major_version;
+        prologue->minor_version = minor_version;
+        prologue->revision = 0;
+        prologue->length = sfti->TableBufferLength - sizeof(*prologue);
+
+        memcpy(sfti->TableBuffer + sizeof(*prologue), ptr, len);
+
+        CFRelease(data);
+        IOObjectRelease(service);
+        return STATUS_SUCCESS;
+    }
+    default:
+    {
+        FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION provider %08x\n", sfti->ProviderSignature);
+        return STATUS_NOT_IMPLEMENTED;
+    }
+    }
+}
+#else
+
+static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG available_len, ULONG *required_len)
+{
+    FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION\n");
+    sfti->TableBufferLength = 0;
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif
+
+static void get_performance_info( SYSTEM_PERFORMANCE_INFORMATION *info )
+{
+    unsigned long long totalram = 0, freeram = 0, totalswap = 0, freeswap = 0;
+    FILE *fp;
+
+    memset( info, 0, sizeof(*info) );
+
+    if ((fp = fopen("/proc/uptime", "r")))
+    {
+        double uptime, idle_time;
+
+        fscanf(fp, "%lf %lf", &uptime, &idle_time);
+        fclose(fp);
+        info->IdleTime.QuadPart = 10000000 * idle_time;
+    }
+    else
+    {
+        static ULONGLONG idle;
+        /* many programs expect IdleTime to change so fake change */
+        info->IdleTime.QuadPart = ++idle;
+    }
+
+#ifdef linux
+    if ((fp = fopen("/proc/meminfo", "r")))
+    {
+        unsigned long long value;
+        char line[64];
+
+        while (fgets(line, sizeof(line), fp))
+        {
+            if(sscanf(line, "MemTotal: %llu kB", &value) == 1)
+                totalram += value * 1024;
+            else if(sscanf(line, "MemFree: %llu kB", &value) == 1)
+                freeram += value * 1024;
+            else if(sscanf(line, "SwapTotal: %llu kB", &value) == 1)
+                totalswap += value * 1024;
+            else if(sscanf(line, "SwapFree: %llu kB", &value) == 1)
+                freeswap += value * 1024;
+            else if (sscanf(line, "Buffers: %llu", &value))
+                freeram += value * 1024;
+            else if (sscanf(line, "Cached: %llu", &value))
+                freeram += value * 1024;
+        }
+        fclose(fp);
+    }
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || \
+    defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+    {
+#ifdef __APPLE__
+        unsigned int val;
+#else
+        unsigned long val;
+#endif
+        int mib[2];
+        size_t size_sys;
+
+        mib[0] = CTL_HW;
+#ifdef HW_MEMSIZE
+        {
+            uint64_t val64;
+            mib[1] = HW_MEMSIZE;
+            size_sys = sizeof(val64);
+            if (!sysctl(mib, 2, &val64, &size_sys, NULL, 0) && size_sys == sizeof(val64)) totalram = val64;
+        }
+#endif
+
+#ifdef HAVE_MACH_MACH_H
+        {
+            host_name_port_t host = mach_host_self();
+            mach_msg_type_number_t count;
+#ifdef HOST_VM_INFO64_COUNT
+            vm_statistics64_data_t vm_stat;
+
+            count = HOST_VM_INFO64_COUNT;
+            if (host_statistics64(host, HOST_VM_INFO64, (host_info64_t)&vm_stat, &count) == KERN_SUCCESS)
+                freeram = (vm_stat.free_count + vm_stat.inactive_count) * (ULONGLONG)page_size;
+#endif
+            if (!totalram)
+            {
+                host_basic_info_data_t info;
+                count = HOST_BASIC_INFO_COUNT;
+                if (host_info(host, HOST_BASIC_INFO, (host_info_t)&info, &count) == KERN_SUCCESS)
+                    totalram = info.max_mem;
+            }
+            mach_port_deallocate(mach_task_self(), host);
+        }
+#endif
+
+        if (!totalram)
+        {
+            mib[1] = HW_PHYSMEM;
+            size_sys = sizeof(val);
+            if (!sysctl(mib, 2, &val, &size_sys, NULL, 0) && size_sys == sizeof(val)) totalram = val;
+        }
+        if (!freeram)
+        {
+            mib[1] = HW_USERMEM;
+            size_sys = sizeof(val);
+            if (!sysctl(mib, 2, &val, &size_sys, NULL, 0) && size_sys == sizeof(val)) freeram = val;
+        }
+#ifdef VM_SWAPUSAGE
+        {
+            struct xsw_usage swap;
+            mib[0] = CTL_VM;
+            mib[1] = VM_SWAPUSAGE;
+            size_sys = sizeof(swap);
+            if (!sysctl(mib, 2, &swap, &size_sys, NULL, 0) && size_sys == sizeof(swap))
+            {
+                totalswap = swap.xsu_total;
+                freeswap = swap.xsu_avail;
+            }
+        }
+#endif
+    }
+#elif defined( sun )
+    {
+        struct anoninfo swapinf;
+        int rval;
+        totalram = sysconf(_SC_PHYS_PAGES) * (ULONGLONG)page_size;
+        freeram = sysconf(_SC_AVPHYS_PAGES) * (ULONGLONG)page_size;
+        rval = swapctl(SC_AINFO, &swapinf);
+        if (rval > -1)
+        {
+            totalswap = swapinf.ani_max * (ULONGLONG)page_size;
+            freeswap = swapinf.ani_free * (ULONGLONG)page_size;
+        }
+    }
+#endif
+    info->AvailablePages      = freeram / page_size;
+    info->TotalCommittedPages = (totalram + totalswap - freeram - freeswap) / page_size;
+    info->TotalCommitLimit    = (totalram + totalswap) / page_size;
+}
 
 /***********************************************************************
  * RtlIsProcessorFeaturePresent [NTDLL.@]
@@ -54,6 +2529,556 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
     return feature < PROCESSOR_FEATURE_MAX && user_shared_data->ProcessorFeatures[feature];
 }
 
+/******************************************************************************
+ * NtQuerySystemInformation [NTDLL.@]
+ * ZwQuerySystemInformation [NTDLL.@]
+ *
+ * ARGUMENTS:
+ *  SystemInformationClass	Index to a certain information structure
+ *	SystemTimeAdjustmentInformation	SYSTEM_TIME_ADJUSTMENT
+ *	SystemCacheInformation		SYSTEM_CACHE_INFORMATION
+ *	SystemConfigurationInformation	CONFIGURATION_INFORMATION
+ *	observed (class/len):
+ *		0x0/0x2c
+ *		0x12/0x18
+ *		0x2/0x138
+ *		0x8/0x600
+ *              0x25/0xc
+ *  SystemInformation	caller supplies storage for the information structure
+ *  Length		size of the structure
+ *  ResultLength	Data written
+ */
+NTSTATUS WINAPI NtQuerySystemInformation(
+	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
+	OUT PVOID SystemInformation,
+	IN ULONG Length,
+	OUT PULONG ResultLength)
+{
+    NTSTATUS    ret = STATUS_SUCCESS;
+    ULONG       len = 0;
+
+    TRACE("(0x%08x,%p,0x%08x,%p)\n",
+          SystemInformationClass,SystemInformation,Length,ResultLength);
+
+    switch (SystemInformationClass)
+    {
+    case SystemBasicInformation:
+        {
+            SYSTEM_BASIC_INFORMATION sbi;
+
+            virtual_get_system_info( &sbi );
+            len = sizeof(sbi);
+
+            if ( Length == len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, &sbi, len);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        break;
+    case SystemCpuInformation:
+        if (Length >= (len = sizeof(cpu_info)))
+        {
+            if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+            else memcpy(SystemInformation, &cpu_info, len);
+        }
+        else ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case SystemPerformanceInformation:
+        {
+            SYSTEM_PERFORMANCE_INFORMATION spi;
+            static BOOL fixme_written = FALSE;
+
+            get_performance_info( &spi );
+            len = sizeof(spi);
+
+            if (Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, &spi, len);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+            if(!fixme_written) {
+                FIXME("info_class SYSTEM_PERFORMANCE_INFORMATION\n");
+                fixme_written = TRUE;
+            }
+        }
+        break;
+    case SystemTimeOfDayInformation:
+        {
+            SYSTEM_TIMEOFDAY_INFORMATION sti;
+
+            memset(&sti, 0 , sizeof(sti));
+
+            /* liKeSystemTime, liExpTimeZoneBias, uCurrentTimeZoneId */
+            sti.liKeBootTime.QuadPart = server_start_time;
+
+            if (Length <= sizeof(sti))
+            {
+                len = Length;
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, &sti, Length);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        break;
+    case SystemProcessInformation:
+        {
+            SYSTEM_PROCESS_INFORMATION* spi = SystemInformation;
+            SYSTEM_PROCESS_INFORMATION* last = NULL;
+            HANDLE hSnap = 0;
+            WCHAR procname[1024];
+            WCHAR* exename;
+            DWORD wlen = 0;
+            DWORD procstructlen = 0;
+
+            SERVER_START_REQ( create_snapshot )
+            {
+                req->flags      = SNAP_PROCESS | SNAP_THREAD;
+                req->attributes = 0;
+                if (!(ret = wine_server_call( req )))
+                    hSnap = wine_server_ptr_handle( reply->handle );
+            }
+            SERVER_END_REQ;
+            len = 0;
+            while (ret == STATUS_SUCCESS)
+            {
+                SERVER_START_REQ( next_process )
+                {
+                    req->handle = wine_server_obj_handle( hSnap );
+                    req->reset = (len == 0);
+                    wine_server_set_reply( req, procname, sizeof(procname)-sizeof(WCHAR) );
+                    if (!(ret = wine_server_call( req )))
+                    {
+                        /* Make sure procname is 0 terminated */
+                        procname[wine_server_reply_size(reply) / sizeof(WCHAR)] = 0;
+
+                        /* Get only the executable name, not the path */
+                        if ((exename = wcsrchr(procname, '\\')) != NULL) exename++;
+                        else exename = procname;
+
+                        wlen = (wcslen(exename) + 1) * sizeof(WCHAR);
+
+                        procstructlen = sizeof(*spi) + wlen + ((reply->threads - 1) * sizeof(SYSTEM_THREAD_INFORMATION));
+
+                        if (Length >= len + procstructlen)
+                        {
+                            /* ftCreationTime, ftUserTime, ftKernelTime;
+                             * vmCounters, ioCounters
+                             */
+ 
+                            memset(spi, 0, sizeof(*spi));
+
+                            spi->NextEntryOffset = procstructlen - wlen;
+                            spi->dwThreadCount = reply->threads;
+
+                            /* spi->pszProcessName will be set later on */
+
+                            spi->dwBasePriority = reply->priority;
+                            spi->UniqueProcessId = UlongToHandle(reply->pid);
+                            spi->ParentProcessId = UlongToHandle(reply->ppid);
+                            spi->HandleCount = reply->handles;
+
+                            /* spi->ti will be set later on */
+
+                        }
+                        len += procstructlen;
+                    }
+                }
+                SERVER_END_REQ;
+ 
+                if (ret != STATUS_SUCCESS)
+                {
+                    if (ret == STATUS_NO_MORE_FILES) ret = STATUS_SUCCESS;
+                    break;
+                }
+
+                if (Length >= len)
+                {
+                    int     i, j;
+
+                    /* set thread info */
+                    i = j = 0;
+                    while (ret == STATUS_SUCCESS)
+                    {
+                        SERVER_START_REQ( next_thread )
+                        {
+                            req->handle = wine_server_obj_handle( hSnap );
+                            req->reset = (j == 0);
+                            if (!(ret = wine_server_call( req )))
+                            {
+                                j++;
+                                if (UlongToHandle(reply->pid) == spi->UniqueProcessId)
+                                {
+                                    /* ftKernelTime, ftUserTime, ftCreateTime;
+                                     * dwTickCount, dwStartAddress
+                                     */
+
+                                    memset(&spi->ti[i], 0, sizeof(spi->ti));
+
+                                    spi->ti[i].CreateTime.QuadPart = 0xdeadbeef;
+                                    spi->ti[i].ClientId.UniqueProcess = UlongToHandle(reply->pid);
+                                    spi->ti[i].ClientId.UniqueThread  = UlongToHandle(reply->tid);
+                                    spi->ti[i].dwCurrentPriority = reply->base_pri + reply->delta_pri;
+                                    spi->ti[i].dwBasePriority = reply->base_pri;
+                                    i++;
+                                }
+                            }
+                        }
+                        SERVER_END_REQ;
+                    }
+                    if (ret == STATUS_NO_MORE_FILES) ret = STATUS_SUCCESS;
+
+                    /* now append process name */
+                    spi->ProcessName.Buffer = (WCHAR*)((char*)spi + spi->NextEntryOffset);
+                    spi->ProcessName.Length = wlen - sizeof(WCHAR);
+                    spi->ProcessName.MaximumLength = wlen;
+                    memcpy( spi->ProcessName.Buffer, exename, wlen );
+                    spi->NextEntryOffset += wlen;
+
+                    last = spi;
+                    spi = (SYSTEM_PROCESS_INFORMATION*)((char*)spi + spi->NextEntryOffset);
+                }
+            }
+            if (ret == STATUS_SUCCESS && last) last->NextEntryOffset = 0;
+            if (len > Length) ret = STATUS_INFO_LENGTH_MISMATCH;
+            if (hSnap) NtClose(hSnap);
+        }
+        break;
+    case SystemProcessorPerformanceInformation:
+        {
+            SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *sppi = NULL;
+            unsigned int cpus = 0;
+            int out_cpus = Length / sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
+
+            if (out_cpus == 0)
+            {
+                len = 0;
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+                break;
+            }
+            else
+#ifdef __APPLE__
+            {
+                processor_cpu_load_info_data_t *pinfo;
+                mach_msg_type_number_t info_count;
+
+                if (host_processor_info (mach_host_self (),
+                                         PROCESSOR_CPU_LOAD_INFO,
+                                         &cpus,
+                                         (processor_info_array_t*)&pinfo,
+                                         &info_count) == 0)
+                {
+                    int i;
+                    cpus = min(cpus,out_cpus);
+                    len = sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * cpus;
+                    sppi = RtlAllocateHeap(GetProcessHeap(), HEAP_ZERO_MEMORY, len);
+                    for (i = 0; i < cpus; i++)
+                    {
+                        sppi[i].IdleTime.QuadPart = pinfo[i].cpu_ticks[CPU_STATE_IDLE];
+                        sppi[i].KernelTime.QuadPart = pinfo[i].cpu_ticks[CPU_STATE_SYSTEM];
+                        sppi[i].UserTime.QuadPart = pinfo[i].cpu_ticks[CPU_STATE_USER];
+                    }
+                    vm_deallocate (mach_task_self (), (vm_address_t) pinfo, info_count * sizeof(natural_t));
+                }
+            }
+#else
+            {
+                FILE *cpuinfo = fopen("/proc/stat", "r");
+                if (cpuinfo)
+                {
+                    unsigned long clk_tck = sysconf(_SC_CLK_TCK);
+                    unsigned long usr,nice,sys,idle,remainder[8];
+                    int i, count;
+                    char name[32];
+                    char line[255];
+
+                    /* first line is combined usage */
+                    while (fgets(line,255,cpuinfo))
+                    {
+                        count = sscanf(line, "%s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu",
+                                       name, &usr, &nice, &sys, &idle,
+                                       &remainder[0], &remainder[1], &remainder[2], &remainder[3],
+                                       &remainder[4], &remainder[5], &remainder[6], &remainder[7]);
+
+                        if (count < 5 || strncmp( name, "cpu", 3 )) break;
+                        for (i = 0; i + 5 < count; ++i) sys += remainder[i];
+                        sys += idle;
+                        usr += nice;
+                        cpus = atoi( name + 3 ) + 1;
+                        if (cpus > out_cpus) break;
+                        len = sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * cpus;
+                        if (sppi)
+                            sppi = RtlReAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, sppi, len );
+                        else
+                            sppi = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, len );
+
+                        sppi[cpus-1].IdleTime.QuadPart   = (ULONGLONG)idle * 10000000 / clk_tck;
+                        sppi[cpus-1].KernelTime.QuadPart = (ULONGLONG)sys * 10000000 / clk_tck;
+                        sppi[cpus-1].UserTime.QuadPart   = (ULONGLONG)usr * 10000000 / clk_tck;
+                    }
+                    fclose(cpuinfo);
+                }
+            }
+#endif
+
+            if (cpus == 0)
+            {
+                static int i = 1;
+                unsigned int n;
+                cpus = min(NtCurrentTeb()->Peb->NumberOfProcessors, out_cpus);
+                len = sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * cpus;
+                sppi = RtlAllocateHeap(GetProcessHeap(), HEAP_ZERO_MEMORY, len);
+                FIXME("stub info_class SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION\n");
+                /* many programs expect these values to change so fake change */
+                for (n = 0; n < cpus; n++)
+                {
+                    sppi[n].KernelTime.QuadPart = 1 * i;
+                    sppi[n].UserTime.QuadPart   = 2 * i;
+                    sppi[n].IdleTime.QuadPart   = 3 * i;
+                }
+                i++;
+            }
+
+            if (Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, sppi, len);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+
+            RtlFreeHeap(GetProcessHeap(),0,sppi);
+        }
+        break;
+    case SystemModuleInformation:
+        /* FIXME: should be system-wide */
+        if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+        else ret = LdrQueryProcessModuleInformation( SystemInformation, Length, &len );
+        break;
+    case SystemHandleInformation:
+        {
+            struct handle_info *info;
+            DWORD i, num_handles;
+
+            if (Length < sizeof(SYSTEM_HANDLE_INFORMATION))
+            {
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+                break;
+            }
+
+            if (!SystemInformation)
+            {
+                ret = STATUS_ACCESS_VIOLATION;
+                break;
+            }
+
+            num_handles = (Length - FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle )) / sizeof(SYSTEM_HANDLE_ENTRY);
+            if (!(info = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*info) * num_handles )))
+                return STATUS_NO_MEMORY;
+
+            SERVER_START_REQ( get_system_handles )
+            {
+                wine_server_set_reply( req, info, sizeof(*info) * num_handles );
+                if (!(ret = wine_server_call( req )))
+                {
+                    SYSTEM_HANDLE_INFORMATION *shi = SystemInformation;
+                    shi->Count = wine_server_reply_size( req ) / sizeof(*info);
+                    len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle[shi->Count] );
+                    for (i = 0; i < shi->Count; i++)
+                    {
+                        memset( &shi->Handle[i], 0, sizeof(shi->Handle[i]) );
+                        shi->Handle[i].OwnerPid     = info[i].owner;
+                        shi->Handle[i].HandleValue  = info[i].handle;
+                        shi->Handle[i].AccessMask   = info[i].access;
+                        /* FIXME: Fill out ObjectType, HandleFlags, ObjectPointer */
+                    }
+                }
+                else if (ret == STATUS_BUFFER_TOO_SMALL)
+                {
+                    len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle[reply->count] );
+                    ret = STATUS_INFO_LENGTH_MISMATCH;
+                }
+            }
+            SERVER_END_REQ;
+
+            RtlFreeHeap( GetProcessHeap(), 0, info );
+        }
+        break;
+    case SystemCacheInformation:
+        {
+            SYSTEM_CACHE_INFORMATION sci;
+
+            memset(&sci, 0, sizeof(sci)); /* FIXME */
+            len = sizeof(sci);
+
+            if ( Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, &sci, len);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+            FIXME("info_class SYSTEM_CACHE_INFORMATION\n");
+        }
+        break;
+    case SystemInterruptInformation:
+        {
+            SYSTEM_INTERRUPT_INFORMATION sii;
+
+            memset(&sii, 0, sizeof(sii));
+            len = sizeof(sii);
+
+            if ( Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, &sii, len);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+            FIXME("info_class SYSTEM_INTERRUPT_INFORMATION\n");
+        }
+        break;
+    case SystemTimeAdjustmentInformation:
+        {
+            SYSTEM_TIME_ADJUSTMENT_QUERY query = { 156250, 156250, TRUE };
+
+            len = sizeof(query);
+            if (Length == len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, &query, len );
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        break;
+    case SystemKernelDebuggerInformation:
+        {
+            SYSTEM_KERNEL_DEBUGGER_INFORMATION skdi;
+
+            skdi.DebuggerEnabled = FALSE;
+            skdi.DebuggerNotPresent = TRUE;
+            len = sizeof(skdi);
+
+            if ( Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, &skdi, len);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        break;
+    case SystemRegistryQuotaInformation:
+        {
+	    /* Something to do with the size of the registry             *
+	     * Since we don't have a size limitation, fake it            *
+	     * This is almost certainly wrong.                           *
+	     * This sets each of the three words in the struct to 32 MB, *
+	     * which is enough to make the IE 5 installer happy.         */
+            SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;
+
+            srqi.RegistryQuotaAllowed = 0x2000000;
+            srqi.RegistryQuotaUsed = 0x200000;
+            srqi.Reserved1 = (void*)0x200000;
+            len = sizeof(srqi);
+
+            if ( Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else
+                {
+                    FIXME("SystemRegistryQuotaInformation: faking max registry size of 32 MB\n");
+                    memcpy( SystemInformation, &srqi, len);
+                }
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+	break;
+    case SystemLogicalProcessorInformation:
+        {
+            SYSTEM_LOGICAL_PROCESSOR_INFORMATION *buf;
+
+            /* Each logical processor may use up to 7 entries in returned table:
+             * core, numa node, package, L1i, L1d, L2, L3 */
+            len = 7 * NtCurrentTeb()->Peb->NumberOfProcessors;
+            buf = RtlAllocateHeap(GetProcessHeap(), 0, len * sizeof(*buf));
+            if(!buf)
+            {
+                ret = STATUS_NO_MEMORY;
+                break;
+            }
+
+            ret = create_logical_proc_info(&buf, NULL, &len, RelationAll);
+            if( ret != STATUS_SUCCESS )
+            {
+                RtlFreeHeap(GetProcessHeap(), 0, buf);
+                break;
+            }
+
+            if( Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else memcpy( SystemInformation, buf, len);
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+            RtlFreeHeap(GetProcessHeap(), 0, buf);
+        }
+        break;
+    case SystemRecommendedSharedDataAlignment:
+        {
+            len = sizeof(DWORD);
+            if (Length >= len)
+            {
+                if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+                else
+                {
+#ifdef __arm__
+                    *((DWORD *)SystemInformation) = 32;
+#else
+                    *((DWORD *)SystemInformation) = 64;
+#endif
+                }
+            }
+            else ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        break;
+    case SystemFirmwareTableInformation:
+        {
+            SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = (SYSTEM_FIRMWARE_TABLE_INFORMATION*)SystemInformation;
+            len = FIELD_OFFSET(SYSTEM_FIRMWARE_TABLE_INFORMATION, TableBuffer);
+            if (Length < len)
+            {
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+                break;
+            }
+
+            switch (sfti->Action)
+            {
+            case SystemFirmwareTable_Get:
+                ret = get_firmware_info(sfti, Length, &len);
+                break;
+            default:
+                len = 0;
+                ret = STATUS_NOT_IMPLEMENTED;
+                FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION action %d\n", sfti->Action);
+            }
+        }
+        break;
+    default:
+	FIXME("(0x%08x,%p,0x%08x,%p) stub\n",
+	      SystemInformationClass,SystemInformation,Length,ResultLength);
+
+        /* Several Information Classes are not implemented on Windows and return 2 different values 
+         * STATUS_NOT_IMPLEMENTED or STATUS_INVALID_INFO_CLASS
+         * in 95% of the cases it's STATUS_INVALID_INFO_CLASS, so use this as the default
+        */
+        ret = STATUS_INVALID_INFO_CLASS;
+    }
+
+    if (ResultLength) *ResultLength = len;
+
+    return ret;
+}
+
+
 /******************************************************************************
  * RtlGetNativeSystemInformation [NTDLL.@]
  */
@@ -73,6 +3098,573 @@ NTSTATUS WINAPI /* DECLSPEC_HOTPATCH */ RtlGetNativeSystemInformation(
     return NtQuerySystemInformation( SystemInformationClass, SystemInformation, Length, ResultLength );
 }
 
+/******************************************************************************
+ * NtQuerySystemInformationEx [NTDLL.@]
+ * ZwQuerySystemInformationEx [NTDLL.@]
+ */
+NTSTATUS WINAPI NtQuerySystemInformationEx(SYSTEM_INFORMATION_CLASS SystemInformationClass,
+    void *Query, ULONG QueryLength, void *SystemInformation, ULONG Length, ULONG *ResultLength)
+{
+    ULONG len = 0;
+    NTSTATUS ret = STATUS_NOT_IMPLEMENTED;
+
+    TRACE("(0x%08x,%p,%u,%p,%u,%p) stub\n", SystemInformationClass, Query, QueryLength, SystemInformation,
+        Length, ResultLength);
+
+    switch (SystemInformationClass) {
+    case SystemLogicalProcessorInformationEx:
+        {
+            SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *buf;
+
+            if (!Query || QueryLength < sizeof(DWORD))
+            {
+                ret = STATUS_INVALID_PARAMETER;
+                break;
+            }
+
+            len = 3 * sizeof(*buf);
+            buf = RtlAllocateHeap(GetProcessHeap(), 0, len);
+            if (!buf)
+            {
+                ret = STATUS_NO_MEMORY;
+                break;
+            }
+
+            ret = create_logical_proc_info(NULL, &buf, &len, *(DWORD*)Query);
+            if (ret != STATUS_SUCCESS)
+            {
+                RtlFreeHeap(GetProcessHeap(), 0, buf);
+                break;
+            }
+
+            if (Length >= len)
+            {
+                if (!SystemInformation)
+                    ret = STATUS_ACCESS_VIOLATION;
+                else
+                    memcpy(SystemInformation, buf, len);
+            }
+            else
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+
+            RtlFreeHeap(GetProcessHeap(), 0, buf);
+
+            break;
+        }
+    default:
+        FIXME("(0x%08x,%p,%u,%p,%u,%p) stub\n", SystemInformationClass, Query, QueryLength, SystemInformation,
+            Length, ResultLength);
+        break;
+    }
+
+    if (ResultLength)
+        *ResultLength = len;
+
+    return ret;
+}
+
+/******************************************************************************
+ * NtSetSystemInformation [NTDLL.@]
+ * ZwSetSystemInformation [NTDLL.@]
+ */
+NTSTATUS WINAPI NtSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG Length)
+{
+    FIXME("(0x%08x,%p,0x%08x) stub\n",SystemInformationClass,SystemInformation,Length);
+    return STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ *  NtCreatePagingFile		[NTDLL.@]
+ *  ZwCreatePagingFile		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtCreatePagingFile(
+	PUNICODE_STRING PageFileName,
+	PLARGE_INTEGER MinimumSize,
+	PLARGE_INTEGER MaximumSize,
+	PLARGE_INTEGER ActualSize)
+{
+    FIXME("(%p %p %p %p) stub\n", PageFileName, MinimumSize, MaximumSize, ActualSize);
+    return STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ *  NtDisplayString				[NTDLL.@]
+ *
+ * writes a string to the nt-textmode screen eg. during startup
+ */
+NTSTATUS WINAPI NtDisplayString ( PUNICODE_STRING string )
+{
+    STRING stringA;
+    NTSTATUS ret;
+
+    if (!(ret = RtlUnicodeStringToAnsiString( &stringA, string, TRUE )))
+    {
+        MESSAGE( "%.*s", stringA.Length, stringA.Buffer );
+        RtlFreeAnsiString( &stringA );
+    }
+    return ret;
+}
+
+/******************************************************************************
+ *  NtInitiatePowerAction                       [NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtInitiatePowerAction(
+	IN POWER_ACTION SystemAction,
+	IN SYSTEM_POWER_STATE MinSystemState,
+	IN ULONG Flags,
+	IN BOOLEAN Asynchronous)
+{
+        FIXME("(%d,%d,0x%08x,%d),stub\n",
+		SystemAction,MinSystemState,Flags,Asynchronous);
+        return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtSetThreadExecutionState                   [NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtSetThreadExecutionState( EXECUTION_STATE new_state, EXECUTION_STATE *old_state )
+{
+    static EXECUTION_STATE current =
+        ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED | ES_USER_PRESENT;
+    *old_state = current;
+
+    WARN( "(0x%x, %p): stub, harmless.\n", new_state, old_state );
+
+    if (!(current & ES_CONTINUOUS) || (new_state & ES_CONTINUOUS))
+        current = new_state;
+    return STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ *  NtCreatePowerRequest                        [NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtCreatePowerRequest( HANDLE *handle, COUNTED_REASON_CONTEXT *context )
+{
+    FIXME( "(%p, %p): stub\n", handle, context );
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtSetPowerRequest                           [NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtSetPowerRequest( HANDLE handle, POWER_REQUEST_TYPE type )
+{
+    FIXME( "(%p, %u): stub\n", handle, type );
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtClearPowerRequest                         [NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtClearPowerRequest( HANDLE handle, POWER_REQUEST_TYPE type )
+{
+    FIXME( "(%p, %u): stub\n", handle, type );
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#ifdef linux
+/* Fallback using /proc/cpuinfo for Linux systems without cpufreq. For
+ * most distributions on recent enough hardware, this is only likely to
+ * happen while running in virtualized environments such as QEMU. */
+static ULONG mhz_from_cpuinfo(void)
+{
+    char line[512];
+    char *s, *value;
+    double cmz = 0;
+    FILE* f = fopen("/proc/cpuinfo", "r");
+    if(f) {
+        while (fgets(line, sizeof(line), f) != NULL) {
+            if (!(value = strchr(line,':')))
+                continue;
+            s = value - 1;
+            while ((s >= line) && isspace(*s)) s--;
+            *(s + 1) = '\0';
+            value++;
+            if (!_stricmp(line, "cpu MHz")) {
+                sscanf(value, " %lf", &cmz);
+                break;
+            }
+        }
+        fclose(f);
+    }
+    return cmz;
+}
+#endif
+
+#ifdef linux
+
+static const char * get_sys_str(const char *path)
+{
+	static char s[16];
+	FILE *f = fopen(path, "r");
+	const char *ret = NULL;
+	if (f)
+	{
+		if (fgets(s, sizeof(s), f))
+			ret = s;
+		fclose(f);
+	}
+	return ret;
+}
+
+static int get_sys_int(const char *path, int def)
+{
+	const char *s = get_sys_str(path);
+	return s ? atoi(s) : def;
+}
+
+static NTSTATUS fill_battery_state(SYSTEM_BATTERY_STATE *bs)
+{
+	char path[64];
+	const char *s;
+	unsigned int i = 0;
+	LONG64 voltage; /* microvolts */
+
+	bs->AcOnLine = get_sys_int("/sys/class/power_supply/AC/online", 1);
+
+	for (;;)
+	{
+		sprintf(path, "/sys/class/power_supply/BAT%u/status", i);
+		s = get_sys_str(path);
+		if (!s) break;
+		bs->Charging |= (strcmp(s, "Charging\n") == 0);
+		bs->Discharging |= (strcmp(s, "Discharging\n") == 0);
+		bs->BatteryPresent = TRUE;
+		i++;
+	}
+
+	if (bs->BatteryPresent)
+	{
+		voltage = get_sys_int("/sys/class/power_supply/BAT0/voltage_now", 0);
+		bs->MaxCapacity = get_sys_int("/sys/class/power_supply/BAT0/charge_full", 0) * voltage / 1e9;
+		bs->RemainingCapacity = get_sys_int("/sys/class/power_supply/BAT0/charge_now", 0) * voltage / 1e9;
+		bs->Rate = -get_sys_int("/sys/class/power_supply/BAT0/current_now", 0) * voltage / 1e9;
+		if (!bs->Charging && (LONG)bs->Rate < 0)
+			bs->EstimatedTime = 3600 * bs->RemainingCapacity / -(LONG)bs->Rate;
+		else
+			bs->EstimatedTime = ~0u;
+	}
+
+	return STATUS_SUCCESS;
+}
+
+#elif defined(HAVE_IOKIT_IOKITLIB_H)
+
+static NTSTATUS fill_battery_state(SYSTEM_BATTERY_STATE *bs)
+{
+	CFArrayRef batteries;
+	CFDictionaryRef battery;
+	CFNumberRef prop;
+	uint32_t value, voltage;
+	CFTimeInterval remain;
+
+	if (IOPMCopyBatteryInfo( kIOMasterPortDefault, &batteries ) != kIOReturnSuccess)
+		return STATUS_ACCESS_DENIED;
+
+	if (CFArrayGetCount( batteries ) == 0)
+	{
+		/* Just assume we're on AC with no battery. */
+		bs->AcOnLine = TRUE;
+		return STATUS_SUCCESS;
+	}
+	/* Just use the first battery. */
+	battery = CFArrayGetValueAtIndex( batteries, 0 );
+
+	prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryFlagsKey) );
+	CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
+
+	if (value & kIOBatteryInstalled)
+		bs->BatteryPresent = TRUE;
+	else
+		/* Since we are executing code, we must have AC power. */
+		bs->AcOnLine = TRUE;
+	if (value & kIOBatteryChargerConnect)
+	{
+		bs->AcOnLine = TRUE;
+		if (value & kIOBatteryCharge)
+			bs->Charging = TRUE;
+	}
+	else
+		bs->Discharging = TRUE;
+
+	/* We'll need the voltage to be able to interpret the other values. */
+	prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryVoltageKey) );
+	CFNumberGetValue( prop, kCFNumberSInt32Type, &voltage );
+
+	prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryCapacityKey) );
+	CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
+	bs->MaxCapacity = value * voltage;
+	/* Apple uses "estimated time < 10:00" and "22%" for these, but we'll follow
+	 * Windows for now (5% and 33%). */
+	bs->DefaultAlert1 = bs->MaxCapacity / 20;
+	bs->DefaultAlert2 = bs->MaxCapacity / 3;
+
+	prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryCurrentChargeKey) );
+	CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
+	bs->RemainingCapacity = value * voltage;
+
+	prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryAmperageKey) );
+	CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
+	bs->Rate = value * voltage;
+
+	remain = IOPSGetTimeRemainingEstimate();
+	if (remain != kIOPSTimeRemainingUnknown && remain != kIOPSTimeRemainingUnlimited)
+		bs->EstimatedTime = (ULONG)remain;
+
+	CFRelease( batteries );
+	return STATUS_SUCCESS;
+}
+
+#else
+
+static NTSTATUS fill_battery_state(SYSTEM_BATTERY_STATE *bs)
+{
+	FIXME("SystemBatteryState not implemented on this platform\n");
+	return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif
+
+/******************************************************************************
+ *  NtPowerInformation				[NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtPowerInformation(
+	IN POWER_INFORMATION_LEVEL InformationLevel,
+	IN PVOID lpInputBuffer,
+	IN ULONG nInputBufferSize,
+	IN PVOID lpOutputBuffer,
+	IN ULONG nOutputBufferSize)
+{
+	TRACE("(%d,%p,%d,%p,%d)\n",
+		InformationLevel,lpInputBuffer,nInputBufferSize,lpOutputBuffer,nOutputBufferSize);
+	switch(InformationLevel) {
+		case SystemPowerCapabilities: {
+			PSYSTEM_POWER_CAPABILITIES PowerCaps = lpOutputBuffer;
+			FIXME("semi-stub: SystemPowerCapabilities\n");
+			if (nOutputBufferSize < sizeof(SYSTEM_POWER_CAPABILITIES))
+				return STATUS_BUFFER_TOO_SMALL;
+			/* FIXME: These values are based off a native XP desktop, should probably use APM/ACPI to get the 'real' values */
+			PowerCaps->PowerButtonPresent = TRUE;
+			PowerCaps->SleepButtonPresent = FALSE;
+			PowerCaps->LidPresent = FALSE;
+			PowerCaps->SystemS1 = TRUE;
+			PowerCaps->SystemS2 = FALSE;
+			PowerCaps->SystemS3 = FALSE;
+			PowerCaps->SystemS4 = TRUE;
+			PowerCaps->SystemS5 = TRUE;
+			PowerCaps->HiberFilePresent = TRUE;
+			PowerCaps->FullWake = TRUE;
+			PowerCaps->VideoDimPresent = FALSE;
+			PowerCaps->ApmPresent = FALSE;
+			PowerCaps->UpsPresent = FALSE;
+			PowerCaps->ThermalControl = FALSE;
+			PowerCaps->ProcessorThrottle = FALSE;
+			PowerCaps->ProcessorMinThrottle = 100;
+			PowerCaps->ProcessorMaxThrottle = 100;
+			PowerCaps->DiskSpinDown = TRUE;
+			PowerCaps->SystemBatteriesPresent = FALSE;
+			PowerCaps->BatteriesAreShortTerm = FALSE;
+			PowerCaps->BatteryScale[0].Granularity = 0;
+			PowerCaps->BatteryScale[0].Capacity = 0;
+			PowerCaps->BatteryScale[1].Granularity = 0;
+			PowerCaps->BatteryScale[1].Capacity = 0;
+			PowerCaps->BatteryScale[2].Granularity = 0;
+			PowerCaps->BatteryScale[2].Capacity = 0;
+			PowerCaps->AcOnLineWake = PowerSystemUnspecified;
+			PowerCaps->SoftLidWake = PowerSystemUnspecified;
+			PowerCaps->RtcWake = PowerSystemSleeping1;
+			PowerCaps->MinDeviceWakeState = PowerSystemUnspecified;
+			PowerCaps->DefaultLowLatencyWake = PowerSystemUnspecified;
+			return STATUS_SUCCESS;
+		}
+		case SystemBatteryState: {
+			if (nOutputBufferSize < sizeof(SYSTEM_BATTERY_STATE))
+				return STATUS_BUFFER_TOO_SMALL;
+			memset(lpOutputBuffer, 0, sizeof(SYSTEM_BATTERY_STATE));
+			return fill_battery_state(lpOutputBuffer);
+		}
+		case SystemExecutionState: {
+			PULONG ExecutionState = lpOutputBuffer;
+			WARN("semi-stub: SystemExecutionState\n"); /* Needed for .NET Framework, but using a FIXME is really noisy. */
+			if (lpInputBuffer != NULL)
+				return STATUS_INVALID_PARAMETER;
+			/* FIXME: The actual state should be the value set by SetThreadExecutionState which is not currently implemented. */
+			*ExecutionState = ES_USER_PRESENT;
+			return STATUS_SUCCESS;
+		}
+		case ProcessorInformation: {
+			const int cannedMHz = 1000; /* We fake a 1GHz processor if we can't conjure up real values */
+			PROCESSOR_POWER_INFORMATION* cpu_power = lpOutputBuffer;
+			int i, out_cpus;
+
+			if ((lpOutputBuffer == NULL) || (nOutputBufferSize == 0))
+				return STATUS_INVALID_PARAMETER;
+			out_cpus = NtCurrentTeb()->Peb->NumberOfProcessors;
+			if ((nOutputBufferSize / sizeof(PROCESSOR_POWER_INFORMATION)) < out_cpus)
+				return STATUS_BUFFER_TOO_SMALL;
+#if defined(linux)
+			{
+				char filename[128];
+				FILE* f;
+
+				for(i = 0; i < out_cpus; i++) {
+					sprintf(filename, "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_cur_freq", i);
+					f = fopen(filename, "r");
+					if (f && (fscanf(f, "%d", &cpu_power[i].CurrentMhz) == 1)) {
+						cpu_power[i].CurrentMhz /= 1000;
+						fclose(f);
+					}
+					else {
+						if(i == 0) {
+							cpu_power[0].CurrentMhz = mhz_from_cpuinfo();
+							if(cpu_power[0].CurrentMhz == 0)
+								cpu_power[0].CurrentMhz = cannedMHz;
+						}
+						else
+							cpu_power[i].CurrentMhz = cpu_power[0].CurrentMhz;
+						if(f) fclose(f);
+					}
+
+					sprintf(filename, "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", i);
+					f = fopen(filename, "r");
+					if (f && (fscanf(f, "%d", &cpu_power[i].MaxMhz) == 1)) {
+						cpu_power[i].MaxMhz /= 1000;
+						fclose(f);
+					}
+					else {
+						cpu_power[i].MaxMhz = cpu_power[i].CurrentMhz;
+						if(f) fclose(f);
+					}
+
+					sprintf(filename, "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_max_freq", i);
+					f = fopen(filename, "r");
+					if(f && (fscanf(f, "%d", &cpu_power[i].MhzLimit) == 1)) {
+						cpu_power[i].MhzLimit /= 1000;
+						fclose(f);
+					}
+					else
+					{
+						cpu_power[i].MhzLimit = cpu_power[i].MaxMhz;
+						if(f) fclose(f);
+					}
+
+					cpu_power[i].Number = i;
+					cpu_power[i].MaxIdleState = 0;     /* FIXME */
+					cpu_power[i].CurrentIdleState = 0; /* FIXME */
+				}
+			}
+#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__) || defined(__DragonFly__)
+			{
+				int num;
+				size_t valSize = sizeof(num);
+				if (sysctlbyname("hw.clockrate", &num, &valSize, NULL, 0))
+					num = cannedMHz;
+				for(i = 0; i < out_cpus; i++) {
+					cpu_power[i].CurrentMhz = num;
+					cpu_power[i].MaxMhz = num;
+					cpu_power[i].MhzLimit = num;
+					cpu_power[i].Number = i;
+					cpu_power[i].MaxIdleState = 0;     /* FIXME */
+					cpu_power[i].CurrentIdleState = 0; /* FIXME */
+				}
+			}
+#elif defined (__APPLE__)
+			{
+				size_t valSize;
+				unsigned long long currentMhz;
+				unsigned long long maxMhz;
+
+				valSize = sizeof(currentMhz);
+				if (!sysctlbyname("hw.cpufrequency", &currentMhz, &valSize, NULL, 0))
+					currentMhz /= 1000000;
+				else
+					currentMhz = cannedMHz;
+
+				valSize = sizeof(maxMhz);
+				if (!sysctlbyname("hw.cpufrequency_max", &maxMhz, &valSize, NULL, 0))
+					maxMhz /= 1000000;
+				else
+					maxMhz = currentMhz;
+
+				for(i = 0; i < out_cpus; i++) {
+					cpu_power[i].CurrentMhz = currentMhz;
+					cpu_power[i].MaxMhz = maxMhz;
+					cpu_power[i].MhzLimit = maxMhz;
+					cpu_power[i].Number = i;
+					cpu_power[i].MaxIdleState = 0;     /* FIXME */
+					cpu_power[i].CurrentIdleState = 0; /* FIXME */
+				}
+			}
+#else
+			for(i = 0; i < out_cpus; i++) {
+				cpu_power[i].CurrentMhz = cannedMHz;
+				cpu_power[i].MaxMhz = cannedMHz;
+				cpu_power[i].MhzLimit = cannedMHz;
+				cpu_power[i].Number = i;
+				cpu_power[i].MaxIdleState = 0; /* FIXME */
+				cpu_power[i].CurrentIdleState = 0; /* FIXME */
+			}
+			WARN("Unable to detect CPU MHz for this platform. Reporting %d MHz.\n", cannedMHz);
+#endif
+			for(i = 0; i < out_cpus; i++) {
+				TRACE("cpu_power[%d] = %u %u %u %u %u %u\n", i, cpu_power[i].Number,
+					  cpu_power[i].MaxMhz, cpu_power[i].CurrentMhz, cpu_power[i].MhzLimit,
+					  cpu_power[i].MaxIdleState, cpu_power[i].CurrentIdleState);
+			}
+			return STATUS_SUCCESS;
+		}
+		default:
+			/* FIXME: Needed by .NET Framework */
+			WARN("Unimplemented NtPowerInformation action: %d\n", InformationLevel);
+			return STATUS_NOT_IMPLEMENTED;
+	}
+}
+
+/******************************************************************************
+ *  NtShutdownSystem				[NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtShutdownSystem(SHUTDOWN_ACTION Action)
+{
+    FIXME("%d\n",Action);
+    return STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ *  NtAllocateLocallyUniqueId (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAllocateLocallyUniqueId(PLUID Luid)
+{
+    NTSTATUS status;
+
+    TRACE("%p\n", Luid);
+
+    if (!Luid)
+        return STATUS_ACCESS_VIOLATION;
+
+    SERVER_START_REQ( allocate_locally_unique_id )
+    {
+        status = wine_server_call( req );
+        if (!status)
+        {
+            Luid->LowPart = reply->luid.low_part;
+            Luid->HighPart = reply->luid.high_part;
+        }
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
+
 /******************************************************************************
  *        VerSetConditionMask   (NTDLL.@)
  */
@@ -103,3 +3695,31 @@ ULONGLONG WINAPI VerSetConditionMask( ULONGLONG dwlConditionMask, DWORD dwTypeBi
 	dwlConditionMask |= dwConditionMask << 0*3;
     return dwlConditionMask;
 }
+
+/******************************************************************************
+ *  NtAccessCheckAndAuditAlarm   (NTDLL.@)
+ *  ZwAccessCheckAndAuditAlarm   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAccessCheckAndAuditAlarm(PUNICODE_STRING SubsystemName, HANDLE HandleId, PUNICODE_STRING ObjectTypeName,
+                                           PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor,
+                                           ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation,
+                                           PACCESS_MASK GrantedAccess, PBOOLEAN AccessStatus, PBOOLEAN GenerateOnClose)
+{
+    FIXME("(%s, %p, %s, %p, 0x%08x, %p, %d, %p, %p, %p), stub\n", debugstr_us(SubsystemName), HandleId,
+          debugstr_us(ObjectTypeName), SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation,
+          GrantedAccess, AccessStatus, GenerateOnClose);
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtSystemDebugControl   (NTDLL.@)
+ *  ZwSystemDebugControl   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSystemDebugControl(SYSDBG_COMMAND command, PVOID inbuffer, ULONG inbuflength, PVOID outbuffer,
+                                     ULONG outbuflength, PULONG retlength)
+{
+    FIXME("(%d, %p, %d, %p, %d, %p), stub\n", command, inbuffer, inbuflength, outbuffer, outbuflength, retlength);
+
+    return STATUS_NOT_IMPLEMENTED;
+}
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 2a95dddf20..e995328f28 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -66,10 +66,10 @@
 # @ stub KiFastSystemCall
 # @ stub KiFastSystemCallRet
 # @ stub KiIntSystemCall
-@ stdcall -norelay KiRaiseUserExceptionDispatcher()
-@ stdcall -norelay KiUserApcDispatcher(ptr long long long ptr)
+@ stub KiRaiseUserExceptionDispatcher
+@ stub KiUserApcDispatcher
 @ stub KiUserCallbackDispatcher
-@ stdcall -norelay KiUserExceptionDispatcher(ptr ptr)
+@ stub KiUserExceptionDispatcher
 # @ stub LdrAccessOutOfProcessResource
 @ stdcall LdrAccessResource(long ptr ptr ptr)
 @ stdcall LdrAddDllDirectory(ptr ptr)
@@ -123,316 +123,315 @@
 @ extern NlsAnsiCodePage
 @ extern NlsMbCodePageTag
 @ extern NlsMbOemCodePageTag
-@ stdcall -syscall NtAcceptConnectPort(ptr long ptr long ptr ptr)
-@ stdcall -syscall NtAccessCheck(ptr long long ptr ptr ptr ptr ptr)
-@ stdcall -syscall NtAccessCheckAndAuditAlarm(ptr long ptr ptr ptr long ptr long ptr ptr ptr)
+@ stdcall NtAcceptConnectPort(ptr long ptr long ptr ptr)
+@ stdcall NtAccessCheck(ptr long long ptr ptr ptr ptr ptr)
+@ stdcall NtAccessCheckAndAuditAlarm(ptr long ptr ptr ptr long ptr long ptr ptr ptr)
 # @ stub NtAccessCheckByType
 # @ stub NtAccessCheckByTypeAndAuditAlarm
 # @ stub NtAccessCheckByTypeResultList
 # @ stub NtAccessCheckByTypeResultListAndAuditAlarm
 # @ stub NtAccessCheckByTypeResultListAndAuditAlarmByHandle
-@ stdcall -syscall NtAddAtom(ptr long ptr)
+@ stdcall NtAddAtom(ptr long ptr)
 # @ stub NtAddBootEntry
-@ stdcall -syscall NtAdjustGroupsToken(long long ptr long ptr ptr)
-@ stdcall -syscall NtAdjustPrivilegesToken(long long ptr long ptr ptr)
-@ stdcall -syscall NtAlertResumeThread(long ptr)
-@ stdcall -syscall NtAlertThread(long)
-@ stdcall -syscall NtAllocateLocallyUniqueId(ptr)
+@ stdcall NtAdjustGroupsToken(long long ptr long ptr ptr)
+@ stdcall NtAdjustPrivilegesToken(long long ptr long ptr ptr)
+@ stdcall NtAlertResumeThread(long ptr)
+@ stdcall NtAlertThread(long)
+@ stdcall NtAllocateLocallyUniqueId(ptr)
 # @ stub NtAllocateUserPhysicalPages
-@ stdcall -syscall NtAllocateUuids(ptr ptr ptr ptr)
-@ stdcall -syscall NtAllocateVirtualMemory(long ptr long ptr long long)
-@ stdcall -syscall NtAreMappedFilesTheSame(ptr ptr)
-@ stdcall -syscall NtAssignProcessToJobObject(long long)
+@ stdcall NtAllocateUuids(ptr ptr ptr ptr)
+@ stdcall NtAllocateVirtualMemory(long ptr long ptr long long)
+@ stdcall NtAreMappedFilesTheSame(ptr ptr)
+@ stdcall NtAssignProcessToJobObject(long long)
 @ stub NtCallbackReturn
 # @ stub NtCancelDeviceWakeupRequest
-@ stdcall -syscall NtCancelIoFile(long ptr)
-@ stdcall -syscall NtCancelIoFileEx(long ptr ptr)
-@ stdcall -syscall NtCancelTimer(long ptr)
-@ stdcall -syscall NtClearEvent(long)
-@ stdcall -syscall NtClearPowerRequest(long long)
-@ stdcall -syscall NtClose(long)
+@ stdcall NtCancelIoFile(long ptr)
+@ stdcall NtCancelIoFileEx(long ptr ptr)
+@ stdcall NtCancelTimer(long ptr)
+@ stdcall NtClearEvent(long)
+@ stdcall NtClearPowerRequest(long long)
+@ stdcall NtClose(long)
 @ stub NtCloseObjectAuditAlarm
 # @ stub NtCompactKeys
 # @ stub NtCompareTokens
-@ stdcall -syscall NtCompleteConnectPort(ptr)
+@ stdcall NtCompleteConnectPort(ptr)
 # @ stub NtCompressKey
-@ stdcall -syscall NtConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr)
-@ stdcall -syscall NtContinue(ptr long)
+@ stdcall NtConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr)
+@ stub NtContinue
 # @ stub NtCreateDebugObject
-@ stdcall -syscall NtCreateDirectoryObject(ptr long ptr)
-@ stdcall -syscall NtCreateEvent(ptr long ptr long long)
+@ stdcall NtCreateDirectoryObject(ptr long ptr)
+@ stdcall NtCreateEvent(ptr long ptr long long)
 @ stub NtCreateEventPair
-@ stdcall -syscall NtCreateFile(ptr long ptr ptr ptr long long long long ptr long)
-@ stdcall -syscall NtCreateIoCompletion(ptr long ptr long)
-@ stdcall -syscall NtCreateJobObject(ptr long ptr)
+@ stdcall NtCreateFile(ptr long ptr ptr ptr long long long long ptr long)
+@ stdcall NtCreateIoCompletion(ptr long ptr long)
+@ stdcall NtCreateJobObject(ptr long ptr)
 # @ stub NtCreateJobSet
-@ stdcall -syscall NtCreateKey(ptr long ptr long ptr long ptr)
-@ stdcall -syscall NtCreateKeyTransacted(ptr long ptr long ptr long long ptr)
-@ stdcall -syscall NtCreateKeyedEvent(ptr long ptr long)
-@ stdcall -syscall NtCreateLowBoxToken(ptr long long ptr ptr long ptr long ptr)
-@ stdcall -syscall NtCreateMailslotFile(ptr long ptr ptr long long long ptr)
-@ stdcall -syscall NtCreateMutant(ptr long ptr long)
-@ stdcall -syscall NtCreateNamedPipeFile(ptr long ptr ptr long long long long long long long long long ptr)
-@ stdcall -syscall NtCreatePagingFile(ptr ptr ptr ptr)
-@ stdcall -syscall NtCreatePort(ptr ptr long long ptr)
-@ stdcall -syscall NtCreatePowerRequest(ptr ptr)
+@ stdcall NtCreateKey(ptr long ptr long ptr long ptr)
+@ stdcall NtCreateKeyTransacted(ptr long ptr long ptr long long ptr)
+@ stdcall NtCreateKeyedEvent(ptr long ptr long)
+@ stdcall NtCreateLowBoxToken(ptr long long ptr ptr long ptr long ptr)
+@ stdcall NtCreateMailslotFile(ptr long ptr ptr long long long ptr)
+@ stdcall NtCreateMutant(ptr long ptr long)
+@ stdcall NtCreateNamedPipeFile(ptr long ptr ptr long long long long long long long long long ptr)
+@ stdcall NtCreatePagingFile(ptr ptr ptr ptr)
+@ stdcall NtCreatePort(ptr ptr long long ptr)
+@ stdcall NtCreatePowerRequest(ptr ptr)
 @ stub NtCreateProcess
 # @ stub NtCreateProcessEx
 @ stub NtCreateProfile
-@ stdcall -syscall NtCreateSection(ptr long ptr ptr long long long)
-@ stdcall -syscall NtCreateSemaphore(ptr long ptr long long)
-@ stdcall -syscall NtCreateSymbolicLinkObject(ptr long ptr ptr)
+@ stdcall NtCreateSection(ptr long ptr ptr long long long)
+@ stdcall NtCreateSemaphore(ptr long ptr long long)
+@ stdcall NtCreateSymbolicLinkObject(ptr long ptr ptr)
 @ stub NtCreateThread
-@ stdcall -syscall NtCreateThreadEx(ptr long ptr long ptr ptr long long long long ptr)
-@ stdcall -syscall NtCreateTimer(ptr long ptr long)
+@ stdcall NtCreateThreadEx(ptr long ptr long ptr ptr long long long long ptr)
+@ stdcall NtCreateTimer(ptr long ptr long)
 @ stub NtCreateToken
-@ stdcall -syscall NtCreateUserProcess(ptr ptr long long ptr ptr long long ptr ptr ptr)
 # @ stub NtCreateWaitablePort
 @ stdcall -arch=win32,arm64 NtCurrentTeb()
 # @ stub NtDebugActiveProcess
 # @ stub NtDebugContinue
-@ stdcall -syscall NtDelayExecution(long ptr)
-@ stdcall -syscall NtDeleteAtom(long)
+@ stdcall NtDelayExecution(long ptr)
+@ stdcall NtDeleteAtom(long)
 # @ stub NtDeleteBootEntry
-@ stdcall -syscall NtDeleteFile(ptr)
-@ stdcall -syscall NtDeleteKey(long)
+@ stdcall NtDeleteFile(ptr)
+@ stdcall NtDeleteKey(long)
 # @ stub NtDeleteObjectAuditAlarm
-@ stdcall -syscall NtDeleteValueKey(long ptr)
-@ stdcall -syscall NtDeviceIoControlFile(long long ptr ptr ptr long ptr long ptr long)
-@ stdcall -syscall NtDisplayString(ptr)
-@ stdcall -syscall NtDuplicateObject(long long long ptr long long long)
-@ stdcall -syscall NtDuplicateToken(long long ptr long long ptr)
+@ stdcall NtDeleteValueKey(long ptr)
+@ stdcall NtDeviceIoControlFile(long long ptr ptr ptr long ptr long ptr long)
+@ stdcall NtDisplayString(ptr)
+@ stdcall NtDuplicateObject(long long long ptr long long long)
+@ stdcall NtDuplicateToken(long long ptr long long ptr)
 # @ stub NtEnumerateBootEntries
 @ stub NtEnumerateBus
-@ stdcall -syscall NtEnumerateKey(long long long ptr long ptr)
+@ stdcall NtEnumerateKey(long long long ptr long ptr)
 # @ stub NtEnumerateSystemEnvironmentValuesEx
-@ stdcall -syscall NtEnumerateValueKey(long long long ptr long ptr)
+@ stdcall NtEnumerateValueKey(long long long ptr long ptr)
 @ stub NtExtendSection
 # @ stub NtFilterToken
-@ stdcall -syscall NtFindAtom(ptr long ptr)
-@ stdcall -syscall NtFlushBuffersFile(long ptr)
-@ stdcall -syscall NtFlushInstructionCache(long ptr long)
-@ stdcall -syscall NtFlushKey(long)
-@ stdcall -syscall NtFlushProcessWriteBuffers()
-@ stdcall -syscall NtFlushVirtualMemory(long ptr ptr long)
+@ stdcall NtFindAtom(ptr long ptr)
+@ stdcall NtFlushBuffersFile(long ptr)
+@ stdcall NtFlushInstructionCache(long ptr long)
+@ stdcall NtFlushKey(long)
+@ stdcall NtFlushProcessWriteBuffers()
+@ stdcall NtFlushVirtualMemory(long ptr ptr long)
 @ stub NtFlushWriteBuffer
 # @ stub NtFreeUserPhysicalPages
-@ stdcall -syscall NtFreeVirtualMemory(long ptr ptr long)
-@ stdcall -syscall NtFsControlFile(long long ptr ptr ptr long ptr long ptr long)
-@ stdcall -norelay -syscall NtGetContextThread(long ptr)
-@ stdcall -syscall NtGetCurrentProcessorNumber()
+@ stdcall NtFreeVirtualMemory(long ptr ptr long)
+@ stdcall NtFsControlFile(long long ptr ptr ptr long ptr long ptr long)
+@ stdcall -norelay NtGetContextThread(long ptr)
+@ stdcall NtGetCurrentProcessorNumber()
 # @ stub NtGetDevicePowerState
 @ stdcall NtGetNlsSectionPtr(long long long ptr ptr)
 @ stub NtGetPlugPlayEvent
 @ stdcall NtGetTickCount()
-@ stdcall -syscall NtGetWriteWatch(long long ptr long ptr ptr ptr)
-@ stdcall -syscall NtImpersonateAnonymousToken(long)
+@ stdcall NtGetWriteWatch(long long ptr long ptr ptr ptr)
+@ stdcall NtImpersonateAnonymousToken(long)
 @ stub NtImpersonateClientOfPort
 @ stub NtImpersonateThread
 @ stub NtInitializeRegistry
-@ stdcall -syscall NtInitiatePowerAction (long long long long)
-@ stdcall -syscall NtIsProcessInJob(long long)
+@ stdcall NtInitiatePowerAction (long long long long)
+@ stdcall NtIsProcessInJob(long long)
 # @ stub NtIsSystemResumeAutomatic
-@ stdcall -syscall NtListenPort(ptr ptr)
-@ stdcall -syscall NtLoadDriver(ptr)
-@ stdcall -syscall NtLoadKey2(ptr ptr long)
-@ stdcall -syscall NtLoadKey(ptr ptr)
-@ stdcall -syscall NtLockFile(long long ptr ptr ptr ptr ptr ptr long long)
+@ stdcall NtListenPort(ptr ptr)
+@ stdcall NtLoadDriver(ptr)
+@ stdcall NtLoadKey2(ptr ptr long)
+@ stdcall NtLoadKey(ptr ptr)
+@ stdcall NtLockFile(long long ptr ptr ptr ptr ptr ptr long long)
 # @ stub NtLockProductActivationKeys
 # @ stub NtLockRegistryKey
-@ stdcall -syscall NtLockVirtualMemory(long ptr ptr long)
+@ stdcall NtLockVirtualMemory(long ptr ptr long)
 # @ stub NtMakePermanentObject
-@ stdcall -syscall NtMakeTemporaryObject(long)
+@ stdcall NtMakeTemporaryObject(long)
 # @ stub NtMapUserPhysicalPages
 # @ stub NtMapUserPhysicalPagesScatter
-@ stdcall -syscall NtMapViewOfSection(long long ptr long long ptr ptr long long long)
+@ stdcall NtMapViewOfSection(long long ptr long long ptr ptr long long long)
 # @ stub NtModifyBootEntry
-@ stdcall -syscall NtNotifyChangeDirectoryFile(long long ptr ptr ptr ptr long long long)
-@ stdcall -syscall NtNotifyChangeKey(long long ptr ptr ptr long long ptr long long)
-@ stdcall -syscall NtNotifyChangeMultipleKeys(long long ptr long ptr ptr ptr long long ptr long long)
-@ stdcall -syscall NtOpenDirectoryObject(ptr long ptr)
-@ stdcall -syscall NtOpenEvent(ptr long ptr)
+@ stdcall NtNotifyChangeDirectoryFile(long long ptr ptr ptr ptr long long long)
+@ stdcall NtNotifyChangeKey(long long ptr ptr ptr long long ptr long long)
+@ stdcall NtNotifyChangeMultipleKeys(long long ptr long ptr ptr ptr long long ptr long long)
+@ stdcall NtOpenDirectoryObject(ptr long ptr)
+@ stdcall NtOpenEvent(ptr long ptr)
 @ stub NtOpenEventPair
-@ stdcall -syscall NtOpenFile(ptr long ptr ptr long long)
-@ stdcall -syscall NtOpenIoCompletion(ptr long ptr)
-@ stdcall -syscall NtOpenJobObject(ptr long ptr)
-@ stdcall -syscall NtOpenKey(ptr long ptr)
-@ stdcall -syscall NtOpenKeyEx(ptr long ptr long)
-@ stdcall -syscall NtOpenKeyTransacted(ptr long ptr long)
-@ stdcall -syscall NtOpenKeyTransactedEx(ptr long ptr long long)
-@ stdcall -syscall NtOpenKeyedEvent(ptr long ptr)
-@ stdcall -syscall NtOpenMutant(ptr long ptr)
+@ stdcall NtOpenFile(ptr long ptr ptr long long)
+@ stdcall NtOpenIoCompletion(ptr long ptr)
+@ stdcall NtOpenJobObject(ptr long ptr)
+@ stdcall NtOpenKey(ptr long ptr)
+@ stdcall NtOpenKeyEx(ptr long ptr long)
+@ stdcall NtOpenKeyTransacted(ptr long ptr long)
+@ stdcall NtOpenKeyTransactedEx(ptr long ptr long long)
+@ stdcall NtOpenKeyedEvent(ptr long ptr)
+@ stdcall NtOpenMutant(ptr long ptr)
 @ stub NtOpenObjectAuditAlarm
-@ stdcall -syscall NtOpenProcess(ptr long ptr ptr)
-@ stdcall -syscall NtOpenProcessToken(long long ptr)
-@ stdcall -syscall NtOpenProcessTokenEx(long long long ptr)
-@ stdcall -syscall NtOpenSection(ptr long ptr)
-@ stdcall -syscall NtOpenSemaphore(ptr long ptr)
-@ stdcall -syscall NtOpenSymbolicLinkObject (ptr long ptr)
-@ stdcall -syscall NtOpenThread(ptr long ptr ptr)
-@ stdcall -syscall NtOpenThreadToken(long long long ptr)
-@ stdcall -syscall NtOpenThreadTokenEx(long long long long ptr)
-@ stdcall -syscall NtOpenTimer(ptr long ptr)
+@ stdcall NtOpenProcess(ptr long ptr ptr)
+@ stdcall NtOpenProcessToken(long long ptr)
+@ stdcall NtOpenProcessTokenEx(long long long ptr)
+@ stdcall NtOpenSection(ptr long ptr)
+@ stdcall NtOpenSemaphore(ptr long ptr)
+@ stdcall NtOpenSymbolicLinkObject (ptr long ptr)
+@ stdcall NtOpenThread(ptr long ptr ptr)
+@ stdcall NtOpenThreadToken(long long long ptr)
+@ stdcall NtOpenThreadTokenEx(long long long long ptr)
+@ stdcall NtOpenTimer(ptr long ptr)
 @ stub NtPlugPlayControl
-@ stdcall -syscall NtPowerInformation(long ptr long ptr long)
-@ stdcall -syscall NtPrivilegeCheck(ptr ptr ptr)
+@ stdcall NtPowerInformation(long ptr long ptr long)
+@ stdcall NtPrivilegeCheck(ptr ptr ptr)
 @ stub NtPrivilegeObjectAuditAlarm
 @ stub NtPrivilegedServiceAuditAlarm
-@ stdcall -syscall NtProtectVirtualMemory(long ptr ptr long ptr)
-@ stdcall -syscall NtPulseEvent(long ptr)
-@ stdcall -syscall NtQueryAttributesFile(ptr ptr)
+@ stdcall NtProtectVirtualMemory(long ptr ptr long ptr)
+@ stdcall NtPulseEvent(long ptr)
+@ stdcall NtQueryAttributesFile(ptr ptr)
 # @ stub NtQueryBootEntryOrder
 # @ stub NtQueryBootOptions
 # @ stub NtQueryDebugFilterState
-@ stdcall -syscall NtQueryDefaultLocale(long ptr)
-@ stdcall -syscall NtQueryDefaultUILanguage(ptr)
-@ stdcall -syscall NtQueryDirectoryFile(long long ptr ptr ptr ptr long long long ptr long)
-@ stdcall -syscall NtQueryDirectoryObject(long ptr long long long ptr ptr)
-@ stdcall -syscall NtQueryEaFile(long ptr ptr long long ptr long ptr long)
-@ stdcall -syscall NtQueryEvent(long long ptr long ptr)
-@ stdcall -syscall NtQueryFullAttributesFile(ptr ptr)
-@ stdcall -syscall NtQueryInformationAtom(long long ptr long ptr)
-@ stdcall -syscall NtQueryInformationFile(long ptr ptr long long)
-@ stdcall -syscall NtQueryInformationJobObject(long long ptr long ptr)
+@ stdcall NtQueryDefaultLocale(long ptr)
+@ stdcall NtQueryDefaultUILanguage(ptr)
+@ stdcall NtQueryDirectoryFile(long long ptr ptr ptr ptr long long long ptr long)
+@ stdcall NtQueryDirectoryObject(long ptr long long long ptr ptr)
+@ stdcall NtQueryEaFile(long ptr ptr long long ptr long ptr long)
+@ stdcall NtQueryEvent(long long ptr long ptr)
+@ stdcall NtQueryFullAttributesFile(ptr ptr)
+@ stdcall NtQueryInformationAtom(long long ptr long ptr)
+@ stdcall NtQueryInformationFile(long ptr ptr long long)
+@ stdcall NtQueryInformationJobObject(long long ptr long ptr)
 @ stub NtQueryInformationPort
-@ stdcall -syscall NtQueryInformationProcess(long long ptr long ptr)
-@ stdcall -syscall NtQueryInformationThread(long long ptr long ptr)
-@ stdcall -syscall NtQueryInformationToken(long long ptr long ptr)
-@ stdcall -syscall NtQueryInstallUILanguage(ptr)
+@ stdcall NtQueryInformationProcess(long long ptr long ptr)
+@ stdcall NtQueryInformationThread(long long ptr long ptr)
+@ stdcall NtQueryInformationToken(long long ptr long ptr)
+@ stdcall NtQueryInstallUILanguage(ptr)
 @ stub NtQueryIntervalProfile
-@ stdcall -syscall NtQueryIoCompletion(long long ptr long ptr)
-@ stdcall -syscall NtQueryKey(long long ptr long ptr)
-@ stdcall -syscall NtQueryLicenseValue(ptr ptr ptr long ptr)
-@ stdcall -syscall NtQueryMultipleValueKey(long ptr long ptr long ptr)
-@ stdcall -syscall NtQueryMutant(long long ptr long ptr)
-@ stdcall -syscall NtQueryObject(long long ptr long ptr)
+@ stdcall NtQueryIoCompletion(long long ptr long ptr)
+@ stdcall NtQueryKey (long long ptr long ptr)
+@ stdcall NtQueryLicenseValue(ptr ptr ptr long ptr)
+@ stdcall NtQueryMultipleValueKey(long ptr long ptr long ptr)
+@ stdcall NtQueryMutant(long long ptr long ptr)
+@ stdcall NtQueryObject(long long ptr long ptr)
 @ stub NtQueryOpenSubKeys
-@ stdcall -syscall NtQueryPerformanceCounter(ptr ptr)
+@ stdcall NtQueryPerformanceCounter(ptr ptr)
 # @ stub NtQueryPortInformationProcess
 # @ stub NtQueryQuotaInformationFile
-@ stdcall -syscall NtQuerySection(long long ptr long ptr)
-@ stdcall -syscall NtQuerySecurityObject(long long ptr long ptr)
-@ stdcall -syscall NtQuerySemaphore (long long ptr long ptr)
-@ stdcall -syscall NtQuerySymbolicLinkObject(long ptr ptr)
-@ stdcall -syscall NtQuerySystemEnvironmentValue(ptr ptr long ptr)
-@ stdcall -syscall NtQuerySystemEnvironmentValueEx(ptr ptr ptr ptr ptr)
-@ stdcall -syscall NtQuerySystemInformation(long ptr long ptr)
-@ stdcall -syscall NtQuerySystemInformationEx(long ptr long ptr long ptr)
-@ stdcall -syscall NtQuerySystemTime(ptr)
-@ stdcall -syscall NtQueryTimer(ptr long ptr long ptr)
-@ stdcall -syscall NtQueryTimerResolution(ptr ptr ptr)
-@ stdcall -syscall NtQueryValueKey(long ptr long ptr long ptr)
-@ stdcall -syscall NtQueryVirtualMemory(long ptr long ptr long ptr)
-@ stdcall -syscall NtQueryVolumeInformationFile(long ptr ptr long long)
-@ stdcall -syscall NtQueueApcThread(long ptr long long long)
-@ stdcall -syscall NtRaiseException(ptr ptr long)
-@ stdcall -syscall NtRaiseHardError(long long ptr ptr long ptr)
-@ stdcall -syscall NtReadFile(long long ptr ptr ptr ptr long ptr ptr)
-@ stdcall -syscall NtReadFileScatter(long long ptr ptr ptr ptr long ptr ptr)
+@ stdcall NtQuerySection(long long ptr long ptr)
+@ stdcall NtQuerySecurityObject(long long ptr long ptr)
+@ stdcall NtQuerySemaphore (long long ptr long ptr)
+@ stdcall NtQuerySymbolicLinkObject(long ptr ptr)
+@ stdcall NtQuerySystemEnvironmentValue(ptr ptr long ptr)
+@ stdcall NtQuerySystemEnvironmentValueEx(ptr ptr ptr ptr ptr)
+@ stdcall NtQuerySystemInformation(long ptr long ptr)
+@ stdcall NtQuerySystemInformationEx(long ptr long ptr long ptr)
+@ stdcall NtQuerySystemTime(ptr)
+@ stdcall NtQueryTimer(ptr long ptr long ptr)
+@ stdcall NtQueryTimerResolution(ptr ptr ptr)
+@ stdcall NtQueryValueKey(long ptr long ptr long ptr)
+@ stdcall NtQueryVirtualMemory(long ptr long ptr long ptr)
+@ stdcall NtQueryVolumeInformationFile(long ptr ptr long long)
+@ stdcall NtQueueApcThread(long ptr long long long)
+@ stdcall NtRaiseException(ptr ptr long)
+@ stdcall NtRaiseHardError(long long ptr ptr long ptr)
+@ stdcall NtReadFile(long long ptr ptr ptr ptr long ptr ptr)
+@ stdcall NtReadFileScatter(long long ptr ptr ptr ptr long ptr ptr)
 @ stub NtReadRequestData
-@ stdcall -syscall NtReadVirtualMemory(long ptr ptr long ptr)
+@ stdcall NtReadVirtualMemory(long ptr ptr long ptr)
 @ stub NtRegisterNewDevice
-@ stdcall -syscall NtRegisterThreadTerminatePort(ptr)
-@ stdcall -syscall NtReleaseKeyedEvent(long ptr long ptr)
-@ stdcall -syscall NtReleaseMutant(long ptr)
+@ stdcall NtRegisterThreadTerminatePort(ptr)
+@ stdcall NtReleaseKeyedEvent(long ptr long ptr)
+@ stdcall NtReleaseMutant(long ptr)
 @ stub NtReleaseProcessMutant
-@ stdcall -syscall NtReleaseSemaphore(long long ptr)
-@ stdcall -syscall NtRemoveIoCompletion(ptr ptr ptr ptr ptr)
-@ stdcall -syscall NtRemoveIoCompletionEx(ptr ptr long ptr ptr long)
+@ stdcall NtReleaseSemaphore(long long ptr)
+@ stdcall NtRemoveIoCompletion(ptr ptr ptr ptr ptr)
+@ stdcall NtRemoveIoCompletionEx(ptr ptr long ptr ptr long)
 # @ stub NtRemoveProcessDebug
-@ stdcall -syscall NtRenameKey(long ptr)
-@ stdcall -syscall NtReplaceKey(ptr long ptr)
+@ stdcall NtRenameKey(long ptr)
+@ stdcall NtReplaceKey(ptr long ptr)
 @ stub NtReplyPort
-@ stdcall -syscall NtReplyWaitReceivePort(ptr ptr ptr ptr)
+@ stdcall NtReplyWaitReceivePort(ptr ptr ptr ptr)
 @ stub NtReplyWaitReceivePortEx
 @ stub NtReplyWaitReplyPort
 # @ stub NtRequestDeviceWakeup
 @ stub NtRequestPort
-@ stdcall -syscall NtRequestWaitReplyPort(ptr ptr ptr)
+@ stdcall NtRequestWaitReplyPort(ptr ptr ptr)
 # @ stub NtRequestWakeupLatency
-@ stdcall -syscall NtResetEvent(long ptr)
-@ stdcall -syscall NtResetWriteWatch(long ptr long)
-@ stdcall -syscall NtRestoreKey(long long long)
-@ stdcall -syscall NtResumeProcess(long)
-@ stdcall -syscall NtResumeThread(long ptr)
-@ stdcall -syscall NtSaveKey(long long)
+@ stdcall NtResetEvent(long ptr)
+@ stdcall NtResetWriteWatch(long ptr long)
+@ stdcall NtRestoreKey(long long long)
+@ stdcall NtResumeProcess(long)
+@ stdcall NtResumeThread(long ptr)
+@ stdcall NtSaveKey(long long)
 # @ stub NtSaveKeyEx
 # @ stub NtSaveMergedKeys
-@ stdcall -syscall NtSecureConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr ptr)
+@ stdcall NtSecureConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr ptr)
 # @ stub NtSetBootEntryOrder
 # @ stub NtSetBootOptions
-@ stdcall -syscall NtSetContextThread(long ptr)
+@ stdcall NtSetContextThread(long ptr)
 @ stub NtSetDebugFilterState
 @ stub NtSetDefaultHardErrorPort
-@ stdcall -syscall NtSetDefaultLocale(long long)
-@ stdcall -syscall NtSetDefaultUILanguage(long)
-@ stdcall -syscall NtSetEaFile(long ptr ptr long)
-@ stdcall -syscall NtSetEvent(long ptr)
+@ stdcall NtSetDefaultLocale(long long)
+@ stdcall NtSetDefaultUILanguage(long)
+@ stdcall NtSetEaFile(long ptr ptr long)
+@ stdcall NtSetEvent(long ptr)
 # @ stub NtSetEventBoostPriority
 @ stub NtSetHighEventPair
 @ stub NtSetHighWaitLowEventPair
 @ stub NtSetHighWaitLowThread
 # @ stub NtSetInformationDebugObject
-@ stdcall -syscall NtSetInformationFile(long ptr ptr long long)
-@ stdcall -syscall NtSetInformationJobObject(long long ptr long)
-@ stdcall -syscall NtSetInformationKey(long long ptr long)
-@ stdcall -syscall NtSetInformationObject(long long ptr long)
-@ stdcall -syscall NtSetInformationProcess(long long ptr long)
-@ stdcall -syscall NtSetInformationThread(long long ptr long)
-@ stdcall -syscall NtSetInformationToken(long long ptr long)
-@ stdcall -syscall NtSetIntervalProfile(long long)
-@ stdcall -syscall NtSetIoCompletion(ptr long long long long)
-@ stdcall -syscall NtSetLdtEntries(long int64 long int64)
+@ stdcall NtSetInformationFile(long ptr ptr long long)
+@ stdcall NtSetInformationJobObject(long long ptr long)
+@ stdcall NtSetInformationKey(long long ptr long)
+@ stdcall NtSetInformationObject(long long ptr long)
+@ stdcall NtSetInformationProcess(long long ptr long)
+@ stdcall NtSetInformationThread(long long ptr long)
+@ stdcall NtSetInformationToken(long long ptr long)
+@ stdcall NtSetIntervalProfile(long long)
+@ stdcall NtSetIoCompletion(ptr long long long long)
+@ stdcall NtSetLdtEntries(long int64 long int64)
 @ stub NtSetLowEventPair
 @ stub NtSetLowWaitHighEventPair
 @ stub NtSetLowWaitHighThread
-@ stdcall -syscall NtSetPowerRequest(long long)
+@ stdcall NtSetPowerRequest(long long)
 # @ stub NtSetQuotaInformationFile
-@ stdcall -syscall NtSetSecurityObject(long long ptr)
+@ stdcall NtSetSecurityObject(long long ptr)
 @ stub NtSetSystemEnvironmentValue
 # @ stub NtSetSystemEnvironmentValueEx
-@ stdcall -syscall NtSetSystemInformation(long ptr long)
+@ stdcall NtSetSystemInformation(long ptr long)
 @ stub NtSetSystemPowerState
-@ stdcall -syscall NtSetSystemTime(ptr ptr)
-@ stdcall -syscall NtSetThreadExecutionState(long ptr)
-@ stdcall -syscall NtSetTimer(long ptr ptr ptr long long ptr)
-@ stdcall -syscall NtSetTimerResolution(long long ptr)
+@ stdcall NtSetSystemTime(ptr ptr)
+@ stdcall NtSetThreadExecutionState(long ptr)
+@ stdcall NtSetTimer(long ptr ptr ptr long long ptr)
+@ stdcall NtSetTimerResolution(long long ptr)
 # @ stub NtSetUuidSeed
-@ stdcall -syscall NtSetValueKey(long ptr long long ptr long)
-@ stdcall -syscall NtSetVolumeInformationFile(long ptr ptr long long)
-@ stdcall -syscall NtShutdownSystem(long)
-@ stdcall -syscall NtSignalAndWaitForSingleObject(long long long ptr)
+@ stdcall NtSetValueKey(long ptr long long ptr long)
+@ stdcall NtSetVolumeInformationFile(long ptr ptr long long)
+@ stdcall NtShutdownSystem(long)
+@ stdcall NtSignalAndWaitForSingleObject(long long long ptr)
 @ stub NtStartProfile
 @ stub NtStopProfile
-@ stdcall -syscall NtSuspendProcess(long)
-@ stdcall -syscall NtSuspendThread(long ptr)
-@ stdcall -syscall NtSystemDebugControl(long ptr long ptr long ptr)
-@ stdcall -syscall NtTerminateJobObject(long long)
-@ stdcall -syscall NtTerminateProcess(long long)
-@ stdcall -syscall NtTerminateThread(long long)
+@ stdcall NtSuspendProcess(long)
+@ stdcall NtSuspendThread(long ptr)
+@ stdcall NtSystemDebugControl(long ptr long ptr long ptr)
+@ stdcall NtTerminateJobObject(long long)
+@ stdcall NtTerminateProcess(long long)
+@ stdcall NtTerminateThread(long long)
 @ stub NtTestAlert
 # @ stub NtTraceEvent
 # @ stub NtTranslateFilePath
-@ stdcall -syscall NtUnloadDriver(ptr)
-@ stdcall -syscall NtUnloadKey(ptr)
+@ stdcall NtUnloadDriver(ptr)
+@ stdcall NtUnloadKey(ptr)
 @ stub NtUnloadKeyEx
-@ stdcall -syscall NtUnlockFile(long ptr ptr ptr ptr)
-@ stdcall -syscall NtUnlockVirtualMemory(long ptr ptr long)
-@ stdcall -syscall NtUnmapViewOfSection(long ptr)
+@ stdcall NtUnlockFile(long ptr ptr ptr ptr)
+@ stdcall NtUnlockVirtualMemory(long ptr ptr long)
+@ stdcall NtUnmapViewOfSection(long ptr)
 @ stub NtVdmControl
 @ stub NtW32Call
 # @ stub NtWaitForDebugEvent
-@ stdcall -syscall NtWaitForKeyedEvent(long ptr long ptr)
-@ stdcall -syscall NtWaitForMultipleObjects(long ptr long long ptr)
+@ stdcall NtWaitForKeyedEvent(long ptr long ptr)
+@ stdcall NtWaitForMultipleObjects(long ptr long long ptr)
 @ stub NtWaitForProcessMutant
-@ stdcall -syscall NtWaitForSingleObject(long long ptr)
+@ stdcall NtWaitForSingleObject(long long ptr)
 @ stub NtWaitHighEventPair
 @ stub NtWaitLowEventPair
-@ stdcall -syscall NtWriteFile(long long ptr ptr ptr ptr long ptr ptr)
-@ stdcall -syscall NtWriteFileGather(long long ptr ptr ptr ptr long ptr ptr)
+@ stdcall NtWriteFile(long long ptr ptr ptr ptr long ptr ptr)
+@ stdcall NtWriteFileGather(long long ptr ptr ptr ptr long ptr ptr)
 @ stub NtWriteRequestData
-@ stdcall -syscall NtWriteVirtualMemory(long ptr ptr long ptr)
-@ stdcall -syscall NtYieldExecution()
+@ stdcall NtWriteVirtualMemory(long ptr ptr long ptr)
+@ stdcall NtYieldExecution()
 @ stub PfxFindPrefix
 @ stub PfxInitialize
 @ stub PfxInsertPrefix
@@ -446,7 +445,7 @@
 @ stdcall RtlAcquireSRWLockExclusive(ptr)
 @ stdcall RtlAcquireSRWLockShared(ptr)
 @ stdcall RtlActivateActivationContext(long ptr ptr)
-@ stdcall RtlActivateActivationContextEx(long ptr ptr ptr)
+@ stub RtlActivateActivationContextEx
 @ stub RtlActivateActivationContextUnsafeFast
 @ stdcall RtlAddAccessAllowedAce(ptr long long ptr)
 @ stdcall RtlAddAccessAllowedAceEx(ptr long long long ptr)
@@ -1029,7 +1028,6 @@
 @ stdcall RtlUpperChar(long)
 @ stdcall RtlUpperString(ptr ptr)
 @ stub RtlUsageHeap
-@ stdcall -norelay RtlUserThreadStart(ptr ptr)
 @ cdecl -i386 -norelay RtlUshortByteSwap() NTDLL_RtlUshortByteSwap
 @ stdcall RtlValidAcl(ptr)
 @ stdcall RtlValidRelativeSecurityDescriptor(ptr long long)
@@ -1112,326 +1110,322 @@
 @ stdcall WinSqmIsOptedIn()
 @ stdcall WinSqmSetDWORD(ptr long long)
 @ stdcall WinSqmStartSession(ptr long long)
-@ stdcall -private -syscall ZwAcceptConnectPort(ptr long ptr long ptr ptr) NtAcceptConnectPort
-@ stdcall -private -syscall ZwAccessCheck(ptr long long ptr ptr ptr ptr ptr) NtAccessCheck
-@ stdcall -private -syscall ZwAccessCheckAndAuditAlarm(ptr long ptr ptr ptr long ptr long ptr ptr ptr) NtAccessCheckAndAuditAlarm
+@ stdcall -private ZwAcceptConnectPort(ptr long ptr long ptr ptr) NtAcceptConnectPort
+@ stdcall -private ZwAccessCheck(ptr long long ptr ptr ptr ptr ptr) NtAccessCheck
+@ stdcall -private ZwAccessCheckAndAuditAlarm(ptr long ptr ptr ptr long ptr long ptr ptr ptr) NtAccessCheckAndAuditAlarm
 # @ stub ZwAccessCheckByType
 # @ stub ZwAccessCheckByTypeAndAuditAlarm
 # @ stub ZwAccessCheckByTypeResultList
 # @ stub ZwAccessCheckByTypeResultListAndAuditAlarm
 # @ stub ZwAccessCheckByTypeResultListAndAuditAlarmByHandle
-@ stdcall -private -syscall ZwAddAtom(ptr long ptr) NtAddAtom
+@ stdcall -private ZwAddAtom(ptr long ptr) NtAddAtom
 # @ stub ZwAddBootEntry
-@ stdcall -private -syscall ZwAdjustGroupsToken(long long ptr long ptr ptr) NtAdjustGroupsToken
-@ stdcall -private -syscall ZwAdjustPrivilegesToken(long long ptr long ptr ptr) NtAdjustPrivilegesToken
-@ stdcall -private -syscall ZwAlertResumeThread(long ptr) NtAlertResumeThread
-@ stdcall -private -syscall ZwAlertThread(long) NtAlertThread
-@ stdcall -private -syscall ZwAllocateLocallyUniqueId(ptr) NtAllocateLocallyUniqueId
+@ stdcall -private ZwAdjustGroupsToken(long long ptr long ptr ptr) NtAdjustGroupsToken
+@ stdcall -private ZwAdjustPrivilegesToken(long long ptr long ptr ptr) NtAdjustPrivilegesToken
+@ stdcall -private ZwAlertResumeThread(long ptr) NtAlertResumeThread
+@ stdcall -private ZwAlertThread(long) NtAlertThread
+@ stdcall -private ZwAllocateLocallyUniqueId(ptr) NtAllocateLocallyUniqueId
 # @ stub ZwAllocateUserPhysicalPages
-@ stdcall -private -syscall ZwAllocateUuids(ptr ptr ptr ptr) NtAllocateUuids
-@ stdcall -private -syscall ZwAllocateVirtualMemory(long ptr long ptr long long) NtAllocateVirtualMemory
-@ stdcall -private -syscall ZwAreMappedFilesTheSame(ptr ptr) NtAreMappedFilesTheSame
-@ stdcall -private -syscall ZwAssignProcessToJobObject(long long) NtAssignProcessToJobObject
+@ stdcall -private ZwAllocateUuids(ptr ptr ptr ptr) NtAllocateUuids
+@ stdcall -private ZwAllocateVirtualMemory(long ptr long ptr long long) NtAllocateVirtualMemory
+@ stdcall -private ZwAreMappedFilesTheSame(ptr ptr) NtAreMappedFilesTheSame
+@ stdcall -private ZwAssignProcessToJobObject(long long) NtAssignProcessToJobObject
 @ stub ZwCallbackReturn
 # @ stub ZwCancelDeviceWakeupRequest
-@ stdcall -private -syscall ZwCancelIoFile(long ptr) NtCancelIoFile
-@ stdcall -private -syscall ZwCancelIoFileEx(long ptr ptr) NtCancelIoFileEx
-@ stdcall -private -syscall ZwCancelTimer(long ptr) NtCancelTimer
-@ stdcall -private -syscall ZwClearEvent(long) NtClearEvent
-@ stdcall -private -syscall ZwClearPowerRequest(long long) NtClearPowerRequest
-@ stdcall -private -syscall ZwClose(long) NtClose
+@ stdcall -private ZwCancelIoFile(long ptr) NtCancelIoFile
+@ stdcall -private ZwCancelIoFileEx(long ptr ptr) NtCancelIoFileEx
+@ stdcall -private ZwCancelTimer(long ptr) NtCancelTimer
+@ stdcall -private ZwClearEvent(long) NtClearEvent
+@ stdcall -private ZwClearPowerRequest(long long) NtClearPowerRequest
+@ stdcall -private ZwClose(long) NtClose
 @ stub ZwCloseObjectAuditAlarm
 # @ stub ZwCompactKeys
 # @ stub ZwCompareTokens
-@ stdcall -private -syscall ZwCompleteConnectPort(ptr) NtCompleteConnectPort
+@ stdcall -private ZwCompleteConnectPort(ptr) NtCompleteConnectPort
 # @ stub ZwCompressKey
-@ stdcall -private -syscall ZwConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr) NtConnectPort
-@ stdcall -private -syscall ZwContinue(ptr long) NtContinue
+@ stdcall -private ZwConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr) NtConnectPort
+@ stub ZwContinue
 # @ stub ZwCreateDebugObject
-@ stdcall -private -syscall ZwCreateDirectoryObject(ptr long ptr) NtCreateDirectoryObject
-@ stdcall -private -syscall ZwCreateEvent(ptr long ptr long long) NtCreateEvent
+@ stdcall -private ZwCreateDirectoryObject(ptr long ptr) NtCreateDirectoryObject
+@ stdcall -private ZwCreateEvent(ptr long ptr long long) NtCreateEvent
 @ stub ZwCreateEventPair
-@ stdcall -private -syscall ZwCreateFile(ptr long ptr ptr ptr long long long long ptr long) NtCreateFile
-@ stdcall -private -syscall ZwCreateIoCompletion(ptr long ptr long) NtCreateIoCompletion
-@ stdcall -private -syscall ZwCreateJobObject(ptr long ptr) NtCreateJobObject
+@ stdcall -private ZwCreateFile(ptr long ptr ptr ptr long long long long ptr long) NtCreateFile
+@ stdcall -private ZwCreateIoCompletion(ptr long ptr long) NtCreateIoCompletion
+@ stdcall -private ZwCreateJobObject(ptr long ptr) NtCreateJobObject
 # @ stub ZwCreateJobSet
-@ stdcall -private -syscall ZwCreateKey(ptr long ptr long ptr long ptr) NtCreateKey
-@ stdcall -private -syscall ZwCreateKeyTransacted(ptr long ptr long ptr long long ptr) NtCreateKeyTransacted
-@ stdcall -private -syscall ZwCreateKeyedEvent(ptr long ptr long) NtCreateKeyedEvent
-@ stdcall -private -syscall ZwCreateLowBoxToken(ptr long long ptr ptr long ptr long ptr) NtCreateLowBoxToken
-@ stdcall -private -syscall ZwCreateMailslotFile(ptr long ptr ptr long long long ptr) NtCreateMailslotFile
-@ stdcall -private -syscall ZwCreateMutant(ptr long ptr long) NtCreateMutant
-@ stdcall -private -syscall ZwCreateNamedPipeFile(ptr long ptr ptr long long long long long long long long long ptr) NtCreateNamedPipeFile
-@ stdcall -private -syscall ZwCreatePagingFile(ptr ptr ptr ptr) NtCreatePagingFile
-@ stdcall -private -syscall ZwCreatePort(ptr ptr long long ptr) NtCreatePort
-@ stdcall -private -syscall ZwCreatePowerRequest(ptr ptr) NtCreatePowerRequest
+@ stdcall -private ZwCreateKey(ptr long ptr long ptr long ptr) NtCreateKey
+@ stdcall -private ZwCreateKeyTransacted(ptr long ptr long ptr long long ptr) NtCreateKeyTransacted
+@ stdcall -private ZwCreateKeyedEvent(ptr long ptr long) NtCreateKeyedEvent
+@ stdcall -private ZwCreateMailslotFile(ptr long ptr ptr long long long ptr) NtCreateMailslotFile
+@ stdcall -private ZwCreateMutant(ptr long ptr long) NtCreateMutant
+@ stdcall -private ZwCreateNamedPipeFile(ptr long ptr ptr long long long long long long long long long ptr) NtCreateNamedPipeFile
+@ stdcall -private ZwCreatePagingFile(ptr ptr ptr ptr) NtCreatePagingFile
+@ stdcall -private ZwCreatePort(ptr ptr long long ptr) NtCreatePort
+@ stdcall -private ZwCreatePowerRequest(ptr ptr) NtCreatePowerRequest
 @ stub ZwCreateProcess
 # @ stub ZwCreateProcessEx
 @ stub ZwCreateProfile
-@ stdcall -private -syscall ZwCreateSection(ptr long ptr ptr long long long) NtCreateSection
-@ stdcall -private -syscall ZwCreateSemaphore(ptr long ptr long long) NtCreateSemaphore
-@ stdcall -private -syscall ZwCreateSymbolicLinkObject(ptr long ptr ptr) NtCreateSymbolicLinkObject
+@ stdcall -private ZwCreateSection(ptr long ptr ptr long long long) NtCreateSection
+@ stdcall -private ZwCreateSemaphore(ptr long ptr long long) NtCreateSemaphore
+@ stdcall -private ZwCreateSymbolicLinkObject(ptr long ptr ptr) NtCreateSymbolicLinkObject
 @ stub ZwCreateThread
-@ stdcall -private -syscall ZwCreateThreadEx(ptr long ptr long ptr ptr long long long long ptr) NtCreateThreadEx
-@ stdcall -private -syscall ZwCreateTimer(ptr long ptr long) NtCreateTimer
+@ stdcall -private ZwCreateTimer(ptr long ptr long) NtCreateTimer
 @ stub ZwCreateToken
-@ stdcall -private -syscall ZwCreateUserProcess(ptr ptr long long ptr ptr long long ptr ptr ptr) NtCreateUserProcess
 # @ stub ZwCreateWaitablePort
 # @ stub ZwDebugActiveProcess
 # @ stub ZwDebugContinue
-@ stdcall -private -syscall ZwDelayExecution(long ptr) NtDelayExecution
-@ stdcall -private -syscall ZwDeleteAtom(long) NtDeleteAtom
+@ stdcall -private ZwDelayExecution(long ptr) NtDelayExecution
+@ stdcall -private ZwDeleteAtom(long) NtDeleteAtom
 # @ stub ZwDeleteBootEntry
-@ stdcall -private -syscall ZwDeleteFile(ptr) NtDeleteFile
-@ stdcall -private -syscall ZwDeleteKey(long) NtDeleteKey
+@ stdcall -private ZwDeleteFile(ptr) NtDeleteFile
+@ stdcall -private ZwDeleteKey(long) NtDeleteKey
 # @ stub ZwDeleteObjectAuditAlarm
-@ stdcall -private -syscall ZwDeleteValueKey(long ptr) NtDeleteValueKey
-@ stdcall -private -syscall ZwDeviceIoControlFile(long long ptr ptr ptr long ptr long ptr long) NtDeviceIoControlFile
-@ stdcall -private -syscall ZwDisplayString(ptr) NtDisplayString
-@ stdcall -private -syscall ZwDuplicateObject(long long long ptr long long long) NtDuplicateObject
-@ stdcall -private -syscall ZwDuplicateToken(long long ptr long long ptr) NtDuplicateToken
+@ stdcall -private ZwDeleteValueKey(long ptr) NtDeleteValueKey
+@ stdcall -private ZwDeviceIoControlFile(long long ptr ptr ptr long ptr long ptr long) NtDeviceIoControlFile
+@ stdcall -private ZwDisplayString(ptr) NtDisplayString
+@ stdcall -private ZwDuplicateObject(long long long ptr long long long) NtDuplicateObject
+@ stdcall -private ZwDuplicateToken(long long ptr long long ptr) NtDuplicateToken
 # @ stub ZwEnumerateBootEntries
 @ stub ZwEnumerateBus
-@ stdcall -private -syscall ZwEnumerateKey(long long long ptr long ptr) NtEnumerateKey
+@ stdcall -private ZwEnumerateKey(long long long ptr long ptr) NtEnumerateKey
 # @ stub ZwEnumerateSystemEnvironmentValuesEx
-@ stdcall -private -syscall ZwEnumerateValueKey(long long long ptr long ptr) NtEnumerateValueKey
+@ stdcall -private ZwEnumerateValueKey(long long long ptr long ptr) NtEnumerateValueKey
 @ stub ZwExtendSection
 # @ stub ZwFilterToken
-@ stdcall -private -syscall ZwFindAtom(ptr long ptr) NtFindAtom
-@ stdcall -private -syscall ZwFlushBuffersFile(long ptr) NtFlushBuffersFile
-@ stdcall -private -syscall ZwFlushInstructionCache(long ptr long) NtFlushInstructionCache
-@ stdcall -private -syscall ZwFlushKey(long) NtFlushKey
-@ stdcall -private -syscall ZwFlushProcessWriteBuffers() NtFlushProcessWriteBuffers
-@ stdcall -private -syscall ZwFlushVirtualMemory(long ptr ptr long) NtFlushVirtualMemory
+@ stdcall -private ZwFindAtom(ptr long ptr) NtFindAtom
+@ stdcall -private ZwFlushBuffersFile(long ptr) NtFlushBuffersFile
+@ stdcall -private ZwFlushInstructionCache(long ptr long) NtFlushInstructionCache
+@ stdcall -private ZwFlushKey(long) NtFlushKey
+@ stdcall -private ZwFlushVirtualMemory(long ptr ptr long) NtFlushVirtualMemory
 @ stub ZwFlushWriteBuffer
 # @ stub ZwFreeUserPhysicalPages
-@ stdcall -private -syscall ZwFreeVirtualMemory(long ptr ptr long) NtFreeVirtualMemory
-@ stdcall -private -syscall ZwFsControlFile(long long ptr ptr ptr long ptr long ptr long) NtFsControlFile
-@ stdcall -private -norelay -syscall ZwGetContextThread(long ptr) NtGetContextThread
-@ stdcall -private -syscall ZwGetCurrentProcessorNumber() NtGetCurrentProcessorNumber
+@ stdcall -private ZwFreeVirtualMemory(long ptr ptr long) NtFreeVirtualMemory
+@ stdcall -private ZwFsControlFile(long long ptr ptr ptr long ptr long ptr long) NtFsControlFile
+@ stdcall -private -norelay ZwGetContextThread(long ptr) NtGetContextThread
+@ stdcall -private ZwGetCurrentProcessorNumber() NtGetCurrentProcessorNumber
 # @ stub ZwGetDevicePowerState
 @ stdcall -private ZwGetNlsSectionPtr(long long long ptr ptr) NtGetNlsSectionPtr
 @ stub ZwGetPlugPlayEvent
 @ stdcall -private ZwGetTickCount() NtGetTickCount
-@ stdcall -private -syscall ZwGetWriteWatch(long long ptr long ptr ptr ptr) NtGetWriteWatch
-@ stdcall -private -syscall ZwImpersonateAnonymousToken(long) NtImpersonateAnonymousToken
+@ stdcall -private ZwGetWriteWatch(long long ptr long ptr ptr ptr) NtGetWriteWatch
+@ stdcall -private ZwImpersonateAnonymousToken(long) NtImpersonateAnonymousToken
 @ stub ZwImpersonateClientOfPort
 @ stub ZwImpersonateThread
 @ stub ZwInitializeRegistry
-@ stdcall -private -syscall ZwInitiatePowerAction(long long long long) NtInitiatePowerAction
-@ stdcall -private -syscall ZwIsProcessInJob(long long) NtIsProcessInJob
+@ stdcall -private ZwInitiatePowerAction(long long long long) NtInitiatePowerAction
+@ stdcall -private ZwIsProcessInJob(long long) NtIsProcessInJob
 # @ stub ZwIsSystemResumeAutomatic
-@ stdcall -private -syscall ZwListenPort(ptr ptr) NtListenPort
-@ stdcall -private -syscall ZwLoadDriver(ptr) NtLoadDriver
-@ stdcall -private -syscall ZwLoadKey2(ptr ptr long) NtLoadKey2
-@ stdcall -private -syscall ZwLoadKey(ptr ptr) NtLoadKey
-@ stdcall -private -syscall ZwLockFile(long long ptr ptr ptr ptr ptr ptr long long) NtLockFile
+@ stdcall -private ZwListenPort(ptr ptr) NtListenPort
+@ stdcall -private ZwLoadDriver(ptr) NtLoadDriver
+@ stdcall -private ZwLoadKey2(ptr ptr long) NtLoadKey2
+@ stdcall -private ZwLoadKey(ptr ptr) NtLoadKey
+@ stdcall -private ZwLockFile(long long ptr ptr ptr ptr ptr ptr long long) NtLockFile
 # @ stub ZwLockProductActivationKeys
 # @ stub ZwLockRegistryKey
-@ stdcall -private -syscall ZwLockVirtualMemory(long ptr ptr long) NtLockVirtualMemory
+@ stdcall -private ZwLockVirtualMemory(long ptr ptr long) NtLockVirtualMemory
 # @ stub ZwMakePermanentObject
-@ stdcall -private -syscall ZwMakeTemporaryObject(long) NtMakeTemporaryObject
+@ stdcall -private ZwMakeTemporaryObject(long) NtMakeTemporaryObject
 # @ stub ZwMapUserPhysicalPages
 # @ stub ZwMapUserPhysicalPagesScatter
-@ stdcall -private -syscall ZwMapViewOfSection(long long ptr long long ptr ptr long long long) NtMapViewOfSection
+@ stdcall -private ZwMapViewOfSection(long long ptr long long ptr ptr long long long) NtMapViewOfSection
 # @ stub ZwModifyBootEntry
-@ stdcall -private -syscall ZwNotifyChangeDirectoryFile(long long ptr ptr ptr ptr long long long) NtNotifyChangeDirectoryFile
-@ stdcall -private -syscall ZwNotifyChangeKey(long long ptr ptr ptr long long ptr long long) NtNotifyChangeKey
-@ stdcall -private -syscall ZwNotifyChangeMultipleKeys(long long ptr long ptr ptr ptr long long ptr long long) NtNotifyChangeMultipleKeys
-@ stdcall -private -syscall ZwOpenDirectoryObject(ptr long ptr) NtOpenDirectoryObject
-@ stdcall -private -syscall ZwOpenEvent(ptr long ptr) NtOpenEvent
+@ stdcall -private ZwNotifyChangeDirectoryFile(long long ptr ptr ptr ptr long long long) NtNotifyChangeDirectoryFile
+@ stdcall -private ZwNotifyChangeKey(long long ptr ptr ptr long long ptr long long) NtNotifyChangeKey
+@ stdcall -private ZwNotifyChangeMultipleKeys(long long ptr long ptr ptr ptr long long ptr long long) NtNotifyChangeMultipleKeys
+@ stdcall -private ZwOpenDirectoryObject(ptr long ptr) NtOpenDirectoryObject
+@ stdcall -private ZwOpenEvent(ptr long ptr) NtOpenEvent
 @ stub ZwOpenEventPair
-@ stdcall -private -syscall ZwOpenFile(ptr long ptr ptr long long) NtOpenFile
-@ stdcall -private -syscall ZwOpenIoCompletion(ptr long ptr) NtOpenIoCompletion
-@ stdcall -private -syscall ZwOpenJobObject(ptr long ptr) NtOpenJobObject
-@ stdcall -private -syscall ZwOpenKey(ptr long ptr) NtOpenKey
-@ stdcall -private -syscall ZwOpenKeyEx(ptr long ptr long) NtOpenKeyEx
-@ stdcall -private -syscall ZwOpenKeyTransacted(ptr long ptr long) NtOpenKeyTransacted
-@ stdcall -private -syscall ZwOpenKeyTransactedEx(ptr long ptr long long) NtOpenKeyTransactedEx
-@ stdcall -private -syscall ZwOpenKeyedEvent(ptr long ptr) NtOpenKeyedEvent
-@ stdcall -private -syscall ZwOpenMutant(ptr long ptr) NtOpenMutant
+@ stdcall -private ZwOpenFile(ptr long ptr ptr long long) NtOpenFile
+@ stdcall -private ZwOpenIoCompletion(ptr long ptr) NtOpenIoCompletion
+@ stdcall -private ZwOpenJobObject(ptr long ptr) NtOpenJobObject
+@ stdcall -private ZwOpenKey(ptr long ptr) NtOpenKey
+@ stdcall -private ZwOpenKeyEx(ptr long ptr long) NtOpenKeyEx
+@ stdcall -private ZwOpenKeyTransacted(ptr long ptr long) NtOpenKeyTransacted
+@ stdcall -private ZwOpenKeyTransactedEx(ptr long ptr long long) NtOpenKeyTransactedEx
+@ stdcall -private ZwOpenKeyedEvent(ptr long ptr) NtOpenKeyedEvent
+@ stdcall -private ZwOpenMutant(ptr long ptr) NtOpenMutant
 @ stub ZwOpenObjectAuditAlarm
-@ stdcall -private -syscall ZwOpenProcess(ptr long ptr ptr) NtOpenProcess
-@ stdcall -private -syscall ZwOpenProcessToken(long long ptr) NtOpenProcessToken
-@ stdcall -private -syscall ZwOpenProcessTokenEx(long long long ptr) NtOpenProcessTokenEx
-@ stdcall -private -syscall ZwOpenSection(ptr long ptr) NtOpenSection
-@ stdcall -private -syscall ZwOpenSemaphore(ptr long ptr) NtOpenSemaphore
-@ stdcall -private -syscall ZwOpenSymbolicLinkObject (ptr long ptr) NtOpenSymbolicLinkObject
-@ stdcall -private -syscall ZwOpenThread(ptr long ptr ptr) NtOpenThread
-@ stdcall -private -syscall ZwOpenThreadToken(long long long ptr) NtOpenThreadToken
-@ stdcall -private -syscall ZwOpenThreadTokenEx(long long long long ptr) NtOpenThreadTokenEx
-@ stdcall -private -syscall ZwOpenTimer(ptr long ptr) NtOpenTimer
+@ stdcall -private ZwOpenProcess(ptr long ptr ptr) NtOpenProcess
+@ stdcall -private ZwOpenProcessToken(long long ptr) NtOpenProcessToken
+@ stdcall -private ZwOpenProcessTokenEx(long long long ptr) NtOpenProcessTokenEx
+@ stdcall -private ZwOpenSection(ptr long ptr) NtOpenSection
+@ stdcall -private ZwOpenSemaphore(ptr long ptr) NtOpenSemaphore
+@ stdcall -private ZwOpenSymbolicLinkObject (ptr long ptr) NtOpenSymbolicLinkObject
+@ stdcall -private ZwOpenThread(ptr long ptr ptr) NtOpenThread
+@ stdcall -private ZwOpenThreadToken(long long long ptr) NtOpenThreadToken
+@ stdcall -private ZwOpenThreadTokenEx(long long long long ptr) NtOpenThreadTokenEx
+@ stdcall -private ZwOpenTimer(ptr long ptr) NtOpenTimer
 @ stub ZwPlugPlayControl
-@ stdcall -private -syscall ZwPowerInformation(long ptr long ptr long) NtPowerInformation
-@ stdcall -private -syscall ZwPrivilegeCheck(ptr ptr ptr) NtPrivilegeCheck
+@ stdcall -private ZwPowerInformation(long ptr long ptr long) NtPowerInformation
+@ stdcall -private ZwPrivilegeCheck(ptr ptr ptr) NtPrivilegeCheck
 @ stub ZwPrivilegeObjectAuditAlarm
 @ stub ZwPrivilegedServiceAuditAlarm
-@ stdcall -private -syscall ZwProtectVirtualMemory(long ptr ptr long ptr) NtProtectVirtualMemory
-@ stdcall -private -syscall ZwPulseEvent(long ptr) NtPulseEvent
-@ stdcall -private -syscall ZwQueryAttributesFile(ptr ptr) NtQueryAttributesFile
+@ stdcall -private ZwProtectVirtualMemory(long ptr ptr long ptr) NtProtectVirtualMemory
+@ stdcall -private ZwPulseEvent(long ptr) NtPulseEvent
+@ stdcall -private ZwQueryAttributesFile(ptr ptr) NtQueryAttributesFile
 # @ stub ZwQueryBootEntryOrder
 # @ stub ZwQueryBootOptions
 # @ stub ZwQueryDebugFilterState
-@ stdcall -private -syscall ZwQueryDefaultLocale(long ptr) NtQueryDefaultLocale
-@ stdcall -private -syscall ZwQueryDefaultUILanguage(ptr) NtQueryDefaultUILanguage
-@ stdcall -private -syscall ZwQueryDirectoryFile(long long ptr ptr ptr ptr long long long ptr long) NtQueryDirectoryFile
-@ stdcall -private -syscall ZwQueryDirectoryObject(long ptr long long long ptr ptr) NtQueryDirectoryObject
-@ stdcall -private -syscall ZwQueryEaFile(long ptr ptr long long ptr long ptr long) NtQueryEaFile
-@ stdcall -private -syscall ZwQueryEvent(long long ptr long ptr) NtQueryEvent
-@ stdcall -private -syscall ZwQueryFullAttributesFile(ptr ptr) NtQueryFullAttributesFile
-@ stdcall -private -syscall ZwQueryInformationAtom(long long ptr long ptr) NtQueryInformationAtom
-@ stdcall -private -syscall ZwQueryInformationFile(long ptr ptr long long) NtQueryInformationFile
-@ stdcall -private -syscall ZwQueryInformationJobObject(long long ptr long ptr) NtQueryInformationJobObject
+@ stdcall -private ZwQueryDefaultLocale(long ptr) NtQueryDefaultLocale
+@ stdcall -private ZwQueryDefaultUILanguage(ptr) NtQueryDefaultUILanguage
+@ stdcall -private ZwQueryDirectoryFile(long long ptr ptr ptr ptr long long long ptr long) NtQueryDirectoryFile
+@ stdcall -private ZwQueryDirectoryObject(long ptr long long long ptr ptr) NtQueryDirectoryObject
+@ stdcall -private ZwQueryEaFile(long ptr ptr long long ptr long ptr long) NtQueryEaFile
+@ stdcall -private ZwQueryEvent(long long ptr long ptr) NtQueryEvent
+@ stdcall -private ZwQueryFullAttributesFile(ptr ptr) NtQueryFullAttributesFile
+@ stdcall -private ZwQueryInformationAtom(long long ptr long ptr) NtQueryInformationAtom
+@ stdcall -private ZwQueryInformationFile(long ptr ptr long long) NtQueryInformationFile
+@ stdcall -private ZwQueryInformationJobObject(long long ptr long ptr) NtQueryInformationJobObject
 @ stub ZwQueryInformationPort
-@ stdcall -private -syscall ZwQueryInformationProcess(long long ptr long ptr) NtQueryInformationProcess
-@ stdcall -private -syscall ZwQueryInformationThread(long long ptr long ptr) NtQueryInformationThread
-@ stdcall -private -syscall ZwQueryInformationToken(long long ptr long ptr) NtQueryInformationToken
-@ stdcall -private -syscall ZwQueryInstallUILanguage(ptr) NtQueryInstallUILanguage
+@ stdcall -private ZwQueryInformationProcess(long long ptr long ptr) NtQueryInformationProcess
+@ stdcall -private ZwQueryInformationThread(long long ptr long ptr) NtQueryInformationThread
+@ stdcall -private ZwQueryInformationToken(long long ptr long ptr) NtQueryInformationToken
+@ stdcall -private ZwQueryInstallUILanguage(ptr) NtQueryInstallUILanguage
 @ stub ZwQueryIntervalProfile
-@ stdcall -private -syscall ZwQueryIoCompletion(long long ptr long ptr) NtQueryIoCompletion
-@ stdcall -private -syscall ZwQueryKey(long long ptr long ptr) NtQueryKey
-@ stdcall -private -syscall ZwQueryLicenseValue(ptr ptr ptr long ptr) NtQueryLicenseValue
-@ stdcall -private -syscall ZwQueryMultipleValueKey(long ptr long ptr long ptr) NtQueryMultipleValueKey
-@ stdcall -private -syscall ZwQueryMutant(long long ptr long ptr) NtQueryMutant
-@ stdcall -private -syscall ZwQueryObject(long long ptr long ptr) NtQueryObject
+@ stdcall -private ZwQueryIoCompletion(long long ptr long ptr) NtQueryIoCompletion
+@ stdcall -private ZwQueryKey(long long ptr long ptr) NtQueryKey
+@ stdcall -private ZwQueryLicenseValue(ptr ptr ptr long ptr) NtQueryLicenseValue
+@ stdcall -private ZwQueryMultipleValueKey(long ptr long ptr long ptr) NtQueryMultipleValueKey
+@ stdcall -private ZwQueryMutant(long long ptr long ptr) NtQueryMutant
+@ stdcall -private ZwQueryObject(long long ptr long ptr) NtQueryObject
 @ stub ZwQueryOpenSubKeys
-@ stdcall -private -syscall ZwQueryPerformanceCounter(ptr ptr) NtQueryPerformanceCounter
+@ stdcall -private ZwQueryPerformanceCounter(ptr ptr) NtQueryPerformanceCounter
 # @ stub ZwQueryPortInformationProcess
 # @ stub ZwQueryQuotaInformationFile
-@ stdcall -private -syscall ZwQuerySection(long long ptr long ptr) NtQuerySection
-@ stdcall -private -syscall ZwQuerySecurityObject(long long ptr long ptr) NtQuerySecurityObject
-@ stdcall -private -syscall ZwQuerySemaphore(long long ptr long ptr) NtQuerySemaphore
-@ stdcall -private -syscall ZwQuerySymbolicLinkObject(long ptr ptr) NtQuerySymbolicLinkObject
-@ stdcall -private -syscall ZwQuerySystemEnvironmentValue(ptr ptr long ptr) NtQuerySystemEnvironmentValue
-@ stdcall -private -syscall ZwQuerySystemEnvironmentValueEx(ptr ptr ptr ptr ptr) NtQuerySystemEnvironmentValueEx
-@ stdcall -private -syscall ZwQuerySystemInformation(long ptr long ptr) NtQuerySystemInformation
-@ stdcall -private -syscall ZwQuerySystemInformationEx(long ptr long ptr long ptr) NtQuerySystemInformationEx
-@ stdcall -private -syscall ZwQuerySystemTime(ptr) NtQuerySystemTime
-@ stdcall -private -syscall ZwQueryTimer(ptr long ptr long ptr) NtQueryTimer
-@ stdcall -private -syscall ZwQueryTimerResolution(ptr ptr ptr) NtQueryTimerResolution
-@ stdcall -private -syscall ZwQueryValueKey(long ptr long ptr long ptr) NtQueryValueKey
-@ stdcall -private -syscall ZwQueryVirtualMemory(long ptr long ptr long ptr) NtQueryVirtualMemory
-@ stdcall -private -syscall ZwQueryVolumeInformationFile(long ptr ptr long long) NtQueryVolumeInformationFile
-@ stdcall -private -syscall ZwQueueApcThread(long ptr long long long) NtQueueApcThread
-@ stdcall -private -syscall ZwRaiseException(ptr ptr long) NtRaiseException
-@ stdcall -private -syscall ZwRaiseHardError(long long ptr ptr long ptr) NtRaiseHardError
-@ stdcall -private -syscall ZwReadFile(long long ptr ptr ptr ptr long ptr ptr) NtReadFile
-@ stdcall -private -syscall ZwReadFileScatter(long long ptr ptr ptr ptr long ptr ptr) NtReadFileScatter
+@ stdcall -private ZwQuerySection(long long ptr long ptr) NtQuerySection
+@ stdcall -private ZwQuerySecurityObject(long long ptr long ptr) NtQuerySecurityObject
+@ stdcall -private ZwQuerySemaphore(long long ptr long ptr) NtQuerySemaphore
+@ stdcall -private ZwQuerySymbolicLinkObject(long ptr ptr) NtQuerySymbolicLinkObject
+@ stdcall -private ZwQuerySystemEnvironmentValue(ptr ptr long ptr) NtQuerySystemEnvironmentValue
+@ stdcall -private ZwQuerySystemEnvironmentValueEx(ptr ptr ptr ptr ptr) NtQuerySystemEnvironmentValueEx
+@ stdcall -private ZwQuerySystemInformation(long ptr long ptr) NtQuerySystemInformation
+@ stdcall -private ZwQuerySystemInformationEx(long ptr long ptr long ptr) NtQuerySystemInformationEx
+@ stdcall -private ZwQuerySystemTime(ptr) NtQuerySystemTime
+@ stdcall -private ZwQueryTimer(ptr long ptr long ptr) NtQueryTimer
+@ stdcall -private ZwQueryTimerResolution(ptr ptr ptr) NtQueryTimerResolution
+@ stdcall -private ZwQueryValueKey(long ptr long ptr long ptr) NtQueryValueKey
+@ stdcall -private ZwQueryVirtualMemory(long ptr long ptr long ptr) NtQueryVirtualMemory
+@ stdcall -private ZwQueryVolumeInformationFile(long ptr ptr long long) NtQueryVolumeInformationFile
+@ stdcall -private ZwQueueApcThread(long ptr long long long) NtQueueApcThread
+@ stdcall -private ZwRaiseException(ptr ptr long) NtRaiseException
+@ stdcall -private ZwRaiseHardError(long long ptr ptr long ptr) NtRaiseHardError
+@ stdcall -private ZwReadFile(long long ptr ptr ptr ptr long ptr ptr) NtReadFile
+@ stdcall -private ZwReadFileScatter(long long ptr ptr ptr ptr long ptr ptr) NtReadFileScatter
 @ stub ZwReadRequestData
-@ stdcall -private -syscall ZwReadVirtualMemory(long ptr ptr long ptr) NtReadVirtualMemory
+@ stdcall -private ZwReadVirtualMemory(long ptr ptr long ptr) NtReadVirtualMemory
 @ stub ZwRegisterNewDevice
-@ stdcall -private -syscall ZwRegisterThreadTerminatePort(ptr) NtRegisterThreadTerminatePort
-@ stdcall -private -syscall ZwReleaseKeyedEvent(long ptr long ptr) NtReleaseKeyedEvent
-@ stdcall -private -syscall ZwReleaseMutant(long ptr) NtReleaseMutant
+@ stdcall -private ZwRegisterThreadTerminatePort(ptr) NtRegisterThreadTerminatePort
+@ stdcall -private ZwReleaseKeyedEvent(long ptr long ptr) NtReleaseKeyedEvent
+@ stdcall -private ZwReleaseMutant(long ptr) NtReleaseMutant
 @ stub ZwReleaseProcessMutant
-@ stdcall -private -syscall ZwReleaseSemaphore(long long ptr) NtReleaseSemaphore
-@ stdcall -private -syscall ZwRemoveIoCompletion(ptr ptr ptr ptr ptr) NtRemoveIoCompletion
-@ stdcall -private -syscall ZwRemoveIoCompletionEx(ptr ptr long ptr ptr long) NtRemoveIoCompletionEx
+@ stdcall -private ZwReleaseSemaphore(long long ptr) NtReleaseSemaphore
+@ stdcall -private ZwRemoveIoCompletion(ptr ptr ptr ptr ptr) NtRemoveIoCompletion
+@ stdcall -private ZwRemoveIoCompletionEx(ptr ptr long ptr ptr long) NtRemoveIoCompletionEx
 # @ stub ZwRemoveProcessDebug
-@ stdcall -private -syscall ZwRenameKey(long ptr) NtRenameKey
-@ stdcall -private -syscall ZwReplaceKey(ptr long ptr) NtReplaceKey
+@ stdcall -private ZwRenameKey(long ptr) NtRenameKey
+@ stdcall -private ZwReplaceKey(ptr long ptr) NtReplaceKey
 @ stub ZwReplyPort
-@ stdcall -private -syscall ZwReplyWaitReceivePort(ptr ptr ptr ptr) NtReplyWaitReceivePort
+@ stdcall -private ZwReplyWaitReceivePort(ptr ptr ptr ptr) NtReplyWaitReceivePort
 @ stub ZwReplyWaitReceivePortEx
 @ stub ZwReplyWaitReplyPort
 # @ stub ZwRequestDeviceWakeup
 @ stub ZwRequestPort
-@ stdcall -private -syscall ZwRequestWaitReplyPort(ptr ptr ptr) NtRequestWaitReplyPort
+@ stdcall -private ZwRequestWaitReplyPort(ptr ptr ptr) NtRequestWaitReplyPort
 # @ stub ZwRequestWakeupLatency
-@ stdcall -private -syscall ZwResetEvent(long ptr) NtResetEvent
-@ stdcall -private -syscall ZwResetWriteWatch(long ptr long) NtResetWriteWatch
-@ stdcall -private -syscall ZwRestoreKey(long long long) NtRestoreKey
-@ stdcall -private -syscall ZwResumeProcess(long) NtResumeProcess
-@ stdcall -private -syscall ZwResumeThread(long ptr) NtResumeThread
-@ stdcall -private -syscall ZwSaveKey(long long) NtSaveKey
+@ stdcall -private ZwResetEvent(long ptr) NtResetEvent
+@ stdcall -private ZwResetWriteWatch(long ptr long) NtResetWriteWatch
+@ stdcall -private ZwRestoreKey(long long long) NtRestoreKey
+@ stdcall -private ZwResumeProcess(long) NtResumeProcess
+@ stdcall -private ZwResumeThread(long ptr) NtResumeThread
+@ stdcall -private ZwSaveKey(long long) NtSaveKey
 # @ stub ZwSaveKeyEx
 # @ stub ZwSaveMergedKeys
-@ stdcall -private -syscall ZwSecureConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr ptr) NtSecureConnectPort
+@ stdcall -private ZwSecureConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr ptr) NtSecureConnectPort
 # @ stub ZwSetBootEntryOrder
 # @ stub ZwSetBootOptions
-@ stdcall -private -syscall ZwSetContextThread(long ptr) NtSetContextThread
+@ stdcall -private ZwSetContextThread(long ptr) NtSetContextThread
 @ stub ZwSetDebugFilterState
 @ stub ZwSetDefaultHardErrorPort
-@ stdcall -private -syscall ZwSetDefaultLocale(long long) NtSetDefaultLocale
-@ stdcall -private -syscall ZwSetDefaultUILanguage(long) NtSetDefaultUILanguage
-@ stdcall -private -syscall ZwSetEaFile(long ptr ptr long) NtSetEaFile
-@ stdcall -private -syscall ZwSetEvent(long ptr) NtSetEvent
+@ stdcall -private ZwSetDefaultLocale(long long) NtSetDefaultLocale
+@ stdcall -private ZwSetDefaultUILanguage(long) NtSetDefaultUILanguage
+@ stdcall -private ZwSetEaFile(long ptr ptr long) NtSetEaFile
+@ stdcall -private ZwSetEvent(long ptr) NtSetEvent
 # @ stub ZwSetEventBoostPriority
 @ stub ZwSetHighEventPair
 @ stub ZwSetHighWaitLowEventPair
 @ stub ZwSetHighWaitLowThread
 # @ stub ZwSetInformationDebugObject
-@ stdcall -private -syscall ZwSetInformationFile(long ptr ptr long long) NtSetInformationFile
-@ stdcall -private -syscall ZwSetInformationJobObject(long long ptr long) NtSetInformationJobObject
-@ stdcall -private -syscall ZwSetInformationKey(long long ptr long) NtSetInformationKey
-@ stdcall -private -syscall ZwSetInformationObject(long long ptr long) NtSetInformationObject
-@ stdcall -private -syscall ZwSetInformationProcess(long long ptr long) NtSetInformationProcess
-@ stdcall -private -syscall ZwSetInformationThread(long long ptr long) NtSetInformationThread
-@ stdcall -private -syscall ZwSetInformationToken(long long ptr long) NtSetInformationToken
-@ stdcall -private -syscall ZwSetIntervalProfile(long long) NtSetIntervalProfile
-@ stdcall -private -syscall ZwSetIoCompletion(ptr long long long long) NtSetIoCompletion
-@ stdcall -private -syscall ZwSetLdtEntries(long int64 long int64) NtSetLdtEntries
+@ stdcall -private ZwSetInformationFile(long ptr ptr long long) NtSetInformationFile
+@ stdcall -private ZwSetInformationJobObject(long long ptr long) NtSetInformationJobObject
+@ stdcall -private ZwSetInformationKey(long long ptr long) NtSetInformationKey
+@ stdcall -private ZwSetInformationObject(long long ptr long) NtSetInformationObject
+@ stdcall -private ZwSetInformationProcess(long long ptr long) NtSetInformationProcess
+@ stdcall -private ZwSetInformationThread(long long ptr long) NtSetInformationThread
+@ stdcall -private ZwSetInformationToken(long long ptr long) NtSetInformationToken
+@ stdcall -private ZwSetIntervalProfile(long long) NtSetIntervalProfile
+@ stdcall -private ZwSetIoCompletion(ptr long long long long) NtSetIoCompletion
+@ stdcall -private ZwSetLdtEntries(long int64 long int64) NtSetLdtEntries
 @ stub ZwSetLowEventPair
 @ stub ZwSetLowWaitHighEventPair
 @ stub ZwSetLowWaitHighThread
-@ stdcall -private -syscall ZwSetPowerRequest(long long) NtSetPowerRequest
+@ stdcall -private ZwSetPowerRequest(long long) NtSetPowerRequest
 # @ stub ZwSetQuotaInformationFile
-@ stdcall -private -syscall ZwSetSecurityObject(long long ptr) NtSetSecurityObject
+@ stdcall -private ZwSetSecurityObject(long long ptr) NtSetSecurityObject
 @ stub ZwSetSystemEnvironmentValue
 # @ stub ZwSetSystemEnvironmentValueEx
-@ stdcall -private -syscall ZwSetSystemInformation(long ptr long) NtSetSystemInformation
+@ stdcall -private ZwSetSystemInformation(long ptr long) NtSetSystemInformation
 @ stub ZwSetSystemPowerState
-@ stdcall -private -syscall ZwSetSystemTime(ptr ptr) NtSetSystemTime
-@ stdcall -private -syscall ZwSetThreadExecutionState(long ptr) NtSetThreadExecutionState
-@ stdcall -private -syscall ZwSetTimer(long ptr ptr ptr long long ptr) NtSetTimer
-@ stdcall -private -syscall ZwSetTimerResolution(long long ptr) NtSetTimerResolution
+@ stdcall -private ZwSetSystemTime(ptr ptr) NtSetSystemTime
+@ stdcall ZwSetThreadExecutionState(long ptr) NtSetThreadExecutionState
+@ stdcall -private ZwSetTimer(long ptr ptr ptr long long ptr) NtSetTimer
+@ stdcall -private ZwSetTimerResolution(long long ptr) NtSetTimerResolution
 # @ stub ZwSetUuidSeed
-@ stdcall -private -syscall ZwSetValueKey(long ptr long long ptr long) NtSetValueKey
-@ stdcall -private -syscall ZwSetVolumeInformationFile(long ptr ptr long long) NtSetVolumeInformationFile
-@ stdcall -private -syscall ZwShutdownSystem(long) NtShutdownSystem
-@ stdcall -private -syscall ZwSignalAndWaitForSingleObject(long long long ptr) NtSignalAndWaitForSingleObject
+@ stdcall -private ZwSetValueKey(long ptr long long ptr long) NtSetValueKey
+@ stdcall -private ZwSetVolumeInformationFile(long ptr ptr long long) NtSetVolumeInformationFile
+@ stdcall -private ZwShutdownSystem(long) NtShutdownSystem
+@ stdcall -private ZwSignalAndWaitForSingleObject(long long long ptr) NtSignalAndWaitForSingleObject
 @ stub ZwStartProfile
 @ stub ZwStopProfile
-@ stdcall -private -syscall ZwSuspendProcess(long) NtSuspendProcess
-@ stdcall -private -syscall ZwSuspendThread(long ptr) NtSuspendThread
-@ stdcall -private -syscall ZwSystemDebugControl(long ptr long ptr long ptr) NtSystemDebugControl
-@ stdcall -private -syscall ZwTerminateJobObject(long long) NtTerminateJobObject
-@ stdcall -private -syscall ZwTerminateProcess(long long) NtTerminateProcess
-@ stdcall -private -syscall ZwTerminateThread(long long) NtTerminateThread
+@ stdcall -private ZwSuspendProcess(long) NtSuspendProcess
+@ stdcall -private ZwSuspendThread(long ptr) NtSuspendThread
+@ stdcall -private ZwSystemDebugControl(long ptr long ptr long ptr) NtSystemDebugControl
+@ stdcall -private ZwTerminateJobObject(long long) NtTerminateJobObject
+@ stdcall -private ZwTerminateProcess(long long) NtTerminateProcess
+@ stdcall -private ZwTerminateThread(long long) NtTerminateThread
 @ stub ZwTestAlert
 # @ stub ZwTraceEvent
 # @ stub ZwTranslateFilePath
-@ stdcall -private -syscall ZwUnloadDriver(ptr) NtUnloadDriver
-@ stdcall -private -syscall ZwUnloadKey(ptr) NtUnloadKey
+@ stdcall -private ZwUnloadDriver(ptr) NtUnloadDriver
+@ stdcall -private ZwUnloadKey(ptr) NtUnloadKey
 @ stub ZwUnloadKeyEx
-@ stdcall -private -syscall ZwUnlockFile(long ptr ptr ptr ptr) NtUnlockFile
-@ stdcall -private -syscall ZwUnlockVirtualMemory(long ptr ptr long) NtUnlockVirtualMemory
-@ stdcall -private -syscall ZwUnmapViewOfSection(long ptr) NtUnmapViewOfSection
+@ stdcall -private ZwUnlockFile(long ptr ptr ptr ptr) NtUnlockFile
+@ stdcall -private ZwUnlockVirtualMemory(long ptr ptr long) NtUnlockVirtualMemory
+@ stdcall -private ZwUnmapViewOfSection(long ptr) NtUnmapViewOfSection
 @ stub ZwVdmControl
 @ stub ZwW32Call
 # @ stub ZwWaitForDebugEvent
-@ stdcall -private -syscall ZwWaitForKeyedEvent(long ptr long ptr) NtWaitForKeyedEvent
-@ stdcall -private -syscall ZwWaitForMultipleObjects(long ptr long long ptr) NtWaitForMultipleObjects
+@ stdcall -private ZwWaitForKeyedEvent(long ptr long ptr) NtWaitForKeyedEvent
+@ stdcall -private ZwWaitForMultipleObjects(long ptr long long ptr) NtWaitForMultipleObjects
 @ stub ZwWaitForProcessMutant
-@ stdcall -private -syscall ZwWaitForSingleObject(long long ptr) NtWaitForSingleObject
+@ stdcall -private ZwWaitForSingleObject(long long ptr) NtWaitForSingleObject
 @ stub ZwWaitHighEventPair
 @ stub ZwWaitLowEventPair
-@ stdcall -private -syscall ZwWriteFile(long long ptr ptr ptr ptr long ptr ptr) NtWriteFile
-@ stdcall -private -syscall ZwWriteFileGather(long long ptr ptr ptr ptr long ptr ptr) NtWriteFileGather
+@ stdcall -private ZwWriteFile(long long ptr ptr ptr ptr long ptr ptr) NtWriteFile
+@ stdcall -private ZwWriteFileGather(long long ptr ptr ptr ptr long ptr ptr) NtWriteFileGather
 @ stub ZwWriteRequestData
-@ stdcall -private -syscall ZwWriteVirtualMemory(long ptr ptr long ptr) NtWriteVirtualMemory
-@ stdcall -private -syscall ZwYieldExecution() NtYieldExecution
-@ cdecl -private -arch=i386 _CIcos()
-@ cdecl -private -arch=i386 _CIlog()
-@ cdecl -private -arch=i386 _CIpow()
-@ cdecl -private -arch=i386 _CIsin()
-@ cdecl -private -arch=i386 _CIsqrt()
+@ stdcall -private ZwWriteVirtualMemory(long ptr ptr long ptr) NtWriteVirtualMemory
+@ stdcall -private ZwYieldExecution() NtYieldExecution
+@ cdecl -private -arch=i386 _CIcos() NTDLL__CIcos
+@ cdecl -private -arch=i386 _CIlog() NTDLL__CIlog
+@ cdecl -private -arch=i386 _CIpow() NTDLL__CIpow
+@ cdecl -private -arch=i386 _CIsin() NTDLL__CIsin
+@ cdecl -private -arch=i386 _CIsqrt() NTDLL__CIsqrt
 @ stdcall -arch=x86_64 __C_specific_handler(ptr long ptr ptr)
 @ cdecl -arch=arm,x86_64 -norelay __chkstk()
-@ cdecl __isascii(long)
-@ cdecl __iscsym(long)
-@ cdecl __iscsymf(long)
-@ cdecl __toascii(long)
+@ cdecl __isascii(long) NTDLL___isascii
+@ cdecl __iscsym(long) NTDLL___iscsym
+@ cdecl __iscsymf(long) NTDLL___iscsymf
+@ cdecl __toascii(long) NTDLL___toascii
 @ cdecl -arch=i386 -ret64 _alldiv(int64 int64)
 @ cdecl -arch=i386 -norelay _alldvrm(int64 int64)
 @ cdecl -arch=i386 -ret64 _allmul(int64 int64)
@@ -1446,7 +1440,7 @@
 @ stdcall -arch=i386 -ret64 _aullshr(int64 long)
 @ cdecl -arch=i386 -norelay _chkstk()
 @ stub _fltused
-@ cdecl -arch=i386 -ret64 _ftol()
+@ cdecl -arch=i386 -ret64 _ftol() NTDLL__ftol
 @ cdecl _i64toa(int64 ptr long)
 @ cdecl _i64tow(int64 ptr long)
 @ cdecl _itoa(long ptr long)
@@ -1459,7 +1453,7 @@
 @ cdecl _memicmp(str str long)
 @ varargs _snprintf(ptr long str) NTDLL__snprintf
 @ varargs _snprintf_s(ptr long long str)
-@ varargs _snwprintf(ptr long wstr)
+@ varargs _snwprintf(ptr long wstr) NTDLL__snwprintf
 @ varargs _snwprintf_s(ptr long long wstr)
 @ varargs _swprintf(ptr wstr) NTDLL_swprintf
 @ cdecl _splitpath(str ptr ptr ptr ptr)
@@ -1468,110 +1462,110 @@
 @ cdecl _strlwr(str)
 @ cdecl _strnicmp(str str long)
 @ cdecl _strupr(str)
-@ cdecl _tolower(long)
-@ cdecl _toupper(long)
+@ cdecl _tolower(long) NTDLL__tolower
+@ cdecl _toupper(long) NTDLL__toupper
 @ cdecl _ui64toa(int64 ptr long)
 @ cdecl _ui64tow(int64 ptr long)
 @ cdecl _ultoa(long ptr long)
 @ cdecl _ultow(long ptr long)
-@ cdecl -norelay _vsnprintf(ptr long str ptr)
+@ cdecl -norelay _vsnprintf(ptr long str ptr) NTDLL__vsnprintf
 @ cdecl _vsnprintf_s(ptr long str ptr)
-@ cdecl _vsnwprintf(ptr long wstr ptr)
+@ cdecl _vsnwprintf(ptr long wstr ptr) NTDLL__vsnwprintf
 @ cdecl _vsnwprintf_s(ptr long long wstr ptr)
-@ cdecl _vswprintf(ptr wstr ptr)
-@ cdecl _wcsicmp(wstr wstr)
-@ cdecl _wcslwr(wstr)
-@ cdecl _wcsnicmp(wstr wstr long)
-@ cdecl _wcsupr(wstr)
+@ cdecl _vswprintf(ptr wstr ptr) NTDLL__vswprintf
+@ cdecl _wcsicmp(wstr wstr) NTDLL__wcsicmp
+@ cdecl _wcslwr(wstr) NTDLL__wcslwr
+@ cdecl _wcsnicmp(wstr wstr long) NTDLL__wcsnicmp
+@ cdecl _wcsupr(wstr) NTDLL__wcsupr
 @ cdecl _wtoi(wstr)
 @ cdecl -ret64 _wtoi64(wstr)
 @ cdecl _wtol(wstr)
-@ cdecl abs(long)
-@ cdecl atan(double)
-@ cdecl atoi(str)
-@ cdecl atol(str)
-@ cdecl bsearch(ptr ptr long long ptr)
-@ cdecl ceil(double)
-@ cdecl cos(double)
-@ cdecl fabs(double)
-@ cdecl floor(double)
-@ cdecl isalnum(long)
-@ cdecl isalpha(long)
-@ cdecl iscntrl(long)
-@ cdecl isdigit(long)
-@ cdecl isgraph(long)
-@ cdecl islower(long)
-@ cdecl isprint(long)
-@ cdecl ispunct(long)
-@ cdecl isspace(long)
-@ cdecl isupper(long)
-@ cdecl iswalpha(long)
-@ cdecl iswctype(long long)
-@ cdecl iswdigit(long)
-@ cdecl iswlower(long)
-@ cdecl iswspace(long)
-@ cdecl iswxdigit(long)
-@ cdecl isxdigit(long)
-@ cdecl labs(long) abs
-@ cdecl log(double)
-@ cdecl mbstowcs(ptr str long)
-@ cdecl memchr(ptr long long)
-@ cdecl memcmp(ptr ptr long)
-@ cdecl memcpy(ptr ptr long)
-@ cdecl memmove(ptr ptr long)
-@ cdecl memset(ptr long long)
-@ cdecl pow(double double)
-@ cdecl qsort(ptr long long ptr)
-@ cdecl sin(double)
+@ cdecl abs(long) NTDLL_abs
+@ cdecl atan(double) NTDLL_atan
+@ cdecl atoi(str) NTDLL_atoi
+@ cdecl atol(str) NTDLL_atol
+@ cdecl bsearch(ptr ptr long long ptr) NTDLL_bsearch
+@ cdecl ceil(double) NTDLL_ceil
+@ cdecl cos(double) NTDLL_cos
+@ cdecl fabs(double) NTDLL_fabs
+@ cdecl floor(double) NTDLL_floor
+@ cdecl isalnum(long) NTDLL_isalnum
+@ cdecl isalpha(long) NTDLL_isalpha
+@ cdecl iscntrl(long) NTDLL_iscntrl
+@ cdecl isdigit(long) NTDLL_isdigit
+@ cdecl isgraph(long) NTDLL_isgraph
+@ cdecl islower(long) NTDLL_islower
+@ cdecl isprint(long) NTDLL_isprint
+@ cdecl ispunct(long) NTDLL_ispunct
+@ cdecl isspace(long) NTDLL_isspace
+@ cdecl isupper(long) NTDLL_isupper
+@ cdecl iswalpha(long) NTDLL_iswalpha
+@ cdecl iswctype(long long) NTDLL_iswctype
+@ cdecl iswdigit(long) NTDLL_iswdigit
+@ cdecl iswlower(long) NTDLL_iswlower
+@ cdecl iswspace(long) NTDLL_iswspace
+@ cdecl iswxdigit(long) NTDLL_iswxdigit
+@ cdecl isxdigit(long) NTDLL_isxdigit
+@ cdecl labs(long) NTDLL_labs
+@ cdecl log(double) NTDLL_log
+@ cdecl mbstowcs(ptr str long) NTDLL_mbstowcs
+@ cdecl memchr(ptr long long) NTDLL_memchr
+@ cdecl memcmp(ptr ptr long) NTDLL_memcmp
+@ cdecl memcpy(ptr ptr long) NTDLL_memcpy
+@ cdecl memmove(ptr ptr long) NTDLL_memmove
+@ cdecl memset(ptr long long) NTDLL_memset
+@ cdecl pow(double double) NTDLL_pow
+@ cdecl qsort(ptr long long ptr) NTDLL_qsort
+@ cdecl sin(double) NTDLL_sin
 @ varargs sprintf(ptr str) NTDLL_sprintf
 @ varargs sprintf_s(ptr long str)
-@ cdecl sqrt(double)
-@ varargs sscanf(str str)
-@ cdecl strcat(str str)
-@ cdecl strchr(str long)
-@ cdecl strcmp(str str)
-@ cdecl strcpy(ptr str)
-@ cdecl strcspn(str str)
-@ cdecl strlen(str)
-@ cdecl strncat(str str long)
-@ cdecl strncmp(str str long)
-@ cdecl strncpy(ptr str long)
-@ cdecl strnlen(ptr long)
-@ cdecl strpbrk(str str)
-@ cdecl strrchr(str long)
-@ cdecl strspn(str str)
-@ cdecl strstr(str str)
-@ cdecl strtol(str ptr long)
-@ cdecl strtoul(str ptr long)
+@ cdecl sqrt(double) NTDLL_sqrt
+@ varargs sscanf(str str) NTDLL_sscanf
+@ cdecl strcat(str str) NTDLL_strcat
+@ cdecl strchr(str long) NTDLL_strchr
+@ cdecl strcmp(str str) NTDLL_strcmp
+@ cdecl strcpy(ptr str) NTDLL_strcpy
+@ cdecl strcspn(str str) NTDLL_strcspn
+@ cdecl strlen(str) NTDLL_strlen
+@ cdecl strncat(str str long) NTDLL_strncat
+@ cdecl strncmp(str str long) NTDLL_strncmp
+@ cdecl strncpy(ptr str long) NTDLL_strncpy
+@ cdecl strnlen(ptr long) NTDLL_strnlen
+@ cdecl strpbrk(str str) NTDLL_strpbrk
+@ cdecl strrchr(str long) NTDLL_strrchr
+@ cdecl strspn(str str) NTDLL_strspn
+@ cdecl strstr(str str) NTDLL_strstr
+@ cdecl strtol(str ptr long) NTDLL_strtol
+@ cdecl strtoul(str ptr long) NTDLL_strtoul
 @ varargs swprintf(ptr wstr) NTDLL_swprintf
 @ varargs swprintf_s(ptr long wstr)
-@ cdecl tan(double)
-@ cdecl tolower(long)
-@ cdecl toupper(long)
-@ cdecl towlower(long)
-@ cdecl towupper(long)
+@ cdecl tan(double) NTDLL_tan
+@ cdecl tolower(long) NTDLL_tolower
+@ cdecl toupper(long) NTDLL_toupper
+@ cdecl towlower(long) NTDLL_towlower
+@ cdecl towupper(long) NTDLL_towupper
 @ stdcall vDbgPrintEx(long long str ptr)
 @ stdcall vDbgPrintExWithPrefix(str long long str ptr)
-@ cdecl vsprintf(ptr str ptr)
+@ cdecl vsprintf(ptr str ptr) NTDLL_vsprintf
 @ cdecl vsprintf_s(ptr long str ptr)
 @ cdecl vswprintf_s(ptr long wstr ptr)
-@ cdecl wcscat(wstr wstr)
-@ cdecl wcschr(wstr long)
-@ cdecl wcscmp(wstr wstr)
-@ cdecl wcscpy(ptr wstr)
-@ cdecl wcscspn(wstr wstr)
-@ cdecl wcslen(wstr)
-@ cdecl wcsncat(wstr wstr long)
-@ cdecl wcsncmp(wstr wstr long)
-@ cdecl wcsncpy(ptr wstr long)
-@ cdecl wcspbrk(wstr wstr)
-@ cdecl wcsrchr(wstr long)
-@ cdecl wcsspn(wstr wstr)
-@ cdecl wcsstr(wstr wstr)
-@ cdecl wcstok(wstr wstr)
-@ cdecl wcstol(wstr ptr long)
-@ cdecl wcstombs(ptr ptr long)
-@ cdecl wcstoul(wstr ptr long)
+@ cdecl wcscat(wstr wstr) NTDLL_wcscat
+@ cdecl wcschr(wstr long) NTDLL_wcschr
+@ cdecl wcscmp(wstr wstr) NTDLL_wcscmp
+@ cdecl wcscpy(ptr wstr) NTDLL_wcscpy
+@ cdecl wcscspn(wstr wstr) NTDLL_wcscspn
+@ cdecl wcslen(wstr) NTDLL_wcslen
+@ cdecl wcsncat(wstr wstr long) NTDLL_wcsncat
+@ cdecl wcsncmp(wstr wstr long) NTDLL_wcsncmp
+@ cdecl wcsncpy(ptr wstr long) NTDLL_wcsncpy
+@ cdecl wcspbrk(wstr wstr) NTDLL_wcspbrk
+@ cdecl wcsrchr(wstr long) NTDLL_wcsrchr
+@ cdecl wcsspn(wstr wstr) NTDLL_wcsspn
+@ cdecl wcsstr(wstr wstr) NTDLL_wcsstr
+@ cdecl wcstok(wstr wstr) NTDLL_wcstok
+@ cdecl wcstol(wstr ptr long) NTDLL_wcstol
+@ cdecl wcstombs(ptr ptr long) NTDLL_wcstombs
+@ cdecl wcstoul(wstr ptr long) NTDLL_wcstoul
 
 ##################
 # Wine extensions
@@ -1587,7 +1581,6 @@
 @ cdecl wine_server_send_fd(long)
 @ cdecl __wine_make_process_system()
 @ cdecl __wine_set_unix_funcs(long ptr)
-@ extern __wine_syscall_dispatcher
 @ extern -arch=i386 __wine_ldt_copy
 
 # Debugging
@@ -1600,13 +1593,16 @@
 @ cdecl __wine_locked_recvmsg(long ptr long)
 
 # Version
-@ cdecl wine_get_version()
-@ cdecl wine_get_build_id()
-@ cdecl wine_get_host_version(ptr ptr)
+@ cdecl wine_get_version() NTDLL_wine_get_version
+@ cdecl wine_get_build_id() NTDLL_wine_get_build_id
+@ cdecl wine_get_host_version(ptr ptr) NTDLL_wine_get_host_version
 
 # Codepages
 @ cdecl __wine_get_unix_codepage()
 
+# signal handling
+@ cdecl __wine_set_signal_handler(long ptr)
+
 # Filesystem
-@ cdecl wine_nt_to_unix_file_name(ptr ptr ptr long)
-@ cdecl wine_unix_to_nt_file_name(str ptr ptr)
+@ cdecl wine_nt_to_unix_file_name(ptr ptr long long)
+@ cdecl wine_unix_to_nt_file_name(ptr ptr)
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index a97dadb2a5..9e1f6e20fc 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -20,7 +20,9 @@
 #define __WINE_NTDLL_MISC_H
 
 #include <stdarg.h>
+#include <signal.h>
 #include <sys/types.h>
+#include <pthread.h>
 
 #include "windef.h"
 #include "winnt.h"
@@ -38,15 +40,33 @@
 
 #define MAX_NT_PATH_LENGTH 277
 
+#define MAX_DOS_DRIVES 26
+
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
 static const UINT_PTR page_size = 0x1000;
 #else
 extern UINT_PTR page_size DECLSPEC_HIDDEN;
 #endif
 
+struct drive_info
+{
+    dev_t dev;
+    ino_t ino;
+};
+
+extern NTSTATUS close_handle( HANDLE ) DECLSPEC_HIDDEN;
+extern ULONG_PTR get_system_affinity_mask(void) DECLSPEC_HIDDEN;
+
 /* exceptions */
+extern void wait_suspend( CONTEXT *context ) DECLSPEC_HIDDEN;
+extern NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, int first_chance, CONTEXT *context ) DECLSPEC_HIDDEN;
 extern LONG call_vectored_handlers( EXCEPTION_RECORD *rec, CONTEXT *context ) DECLSPEC_HIDDEN;
 extern void DECLSPEC_NORETURN raise_status( NTSTATUS status, EXCEPTION_RECORD *rec ) DECLSPEC_HIDDEN;
+extern NTSTATUS context_to_server( context_t *to, const CONTEXT *from ) DECLSPEC_HIDDEN;
+extern NTSTATUS context_from_server( CONTEXT *to, const context_t *from ) DECLSPEC_HIDDEN;
+extern NTSTATUS set_thread_context( HANDLE handle, const context_t *context, BOOL *self ) DECLSPEC_HIDDEN;
+extern NTSTATUS get_thread_context( HANDLE handle, context_t *context, unsigned int flags, BOOL *self ) DECLSPEC_HIDDEN;
+extern NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
 extern LONG WINAPI call_unhandled_exception_filter( PEXCEPTION_POINTERS eptr ) DECLSPEC_HIDDEN;
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
@@ -55,19 +75,66 @@ extern RUNTIME_FUNCTION *lookup_function_info( ULONG_PTR pc, ULONG_PTR *base, LD
 
 /* debug helpers */
 extern LPCSTR debugstr_us( const UNICODE_STRING *str ) DECLSPEC_HIDDEN;
+extern LPCSTR debugstr_ObjectAttributes(const OBJECT_ATTRIBUTES *oa) DECLSPEC_HIDDEN;
 
 /* init routines */
+extern SIZE_T signal_stack_size DECLSPEC_HIDDEN;
+extern SIZE_T signal_stack_mask DECLSPEC_HIDDEN;
+extern void signal_init_threading(void) DECLSPEC_HIDDEN;
+extern NTSTATUS signal_alloc_thread( TEB *teb ) DECLSPEC_HIDDEN;
+extern void signal_free_thread( TEB *teb ) DECLSPEC_HIDDEN;
+extern void signal_init_thread( TEB *teb ) DECLSPEC_HIDDEN;
+extern void signal_init_process(void) DECLSPEC_HIDDEN;
+extern void signal_start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend ) DECLSPEC_HIDDEN;
+extern void signal_start_process( LPTHREAD_START_ROUTINE entry, BOOL suspend ) DECLSPEC_HIDDEN;
+extern void DECLSPEC_NORETURN signal_exit_thread( int status ) DECLSPEC_HIDDEN;
+extern void DECLSPEC_NORETURN signal_exit_process( int status ) DECLSPEC_HIDDEN;
 extern void version_init(void) DECLSPEC_HIDDEN;
 extern void debug_init(void) DECLSPEC_HIDDEN;
+extern TEB *thread_init(void) DECLSPEC_HIDDEN;
 extern void actctx_init(void) DECLSPEC_HIDDEN;
+extern void virtual_init(void) DECLSPEC_HIDDEN;
+extern void fill_cpu_info(void) DECLSPEC_HIDDEN;
 extern void heap_set_debug_flags( HANDLE handle ) DECLSPEC_HIDDEN;
 extern void init_unix_codepage(void) DECLSPEC_HIDDEN;
 extern void init_locale( HMODULE module ) DECLSPEC_HIDDEN;
-extern void init_user_process_params(void) DECLSPEC_HIDDEN;
+extern void init_user_process_params( SIZE_T data_size ) DECLSPEC_HIDDEN;
+extern char **build_envp( const WCHAR *envW ) DECLSPEC_HIDDEN;
 extern NTSTATUS restart_process( RTL_USER_PROCESS_PARAMETERS *params, NTSTATUS status ) DECLSPEC_HIDDEN;
 
+extern int __wine_main_argc;
+extern char **__wine_main_argv;
+extern WCHAR **__wine_main_wargv;
+
 /* server support */
+extern const char *build_dir DECLSPEC_HIDDEN;
+extern const char *data_dir DECLSPEC_HIDDEN;
+extern const char *config_dir DECLSPEC_HIDDEN;
+extern timeout_t server_start_time DECLSPEC_HIDDEN;
+extern unsigned int server_cpus DECLSPEC_HIDDEN;
 extern BOOL is_wow64 DECLSPEC_HIDDEN;
+extern NTSTATUS exec_wineloader( char **argv, int socketfd, const pe_image_info_t *pe_info ) DECLSPEC_HIDDEN;
+extern void server_init_process(void) DECLSPEC_HIDDEN;
+extern void server_init_process_done(void) DECLSPEC_HIDDEN;
+extern size_t server_init_thread( void *entry_point, BOOL *suspend ) DECLSPEC_HIDDEN;
+extern void DECLSPEC_NORETURN abort_thread( int status ) DECLSPEC_HIDDEN;
+extern void DECLSPEC_NORETURN exit_thread( int status ) DECLSPEC_HIDDEN;
+extern sigset_t server_block_set DECLSPEC_HIDDEN;
+extern unsigned int server_call_unlocked( void *req_ptr ) DECLSPEC_HIDDEN;
+extern void server_enter_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset ) DECLSPEC_HIDDEN;
+extern void server_leave_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset ) DECLSPEC_HIDDEN;
+extern unsigned int server_select( const select_op_t *select_op, data_size_t size, UINT flags,
+                                   timeout_t abs_timeout, CONTEXT *context, RTL_CRITICAL_SECTION *cs, user_apc_t *user_apc ) DECLSPEC_HIDDEN;
+extern unsigned int server_wait( const select_op_t *select_op, data_size_t size,
+                                 UINT flags, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
+extern unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call, apc_result_t *result ) DECLSPEC_HIDDEN;
+extern int server_remove_fd_from_cache( HANDLE handle ) DECLSPEC_HIDDEN;
+extern int server_get_unix_fd( HANDLE handle, unsigned int access, int *unix_fd,
+                               int *needs_close, enum server_fd_type *type, unsigned int *options ) DECLSPEC_HIDDEN;
+extern int server_pipe( int fd[2] ) DECLSPEC_HIDDEN;
+extern NTSTATUS alloc_object_attributes( const OBJECT_ATTRIBUTES *attr, struct object_attributes **ret,
+                                         data_size_t *ret_len ) DECLSPEC_HIDDEN;
+extern NTSTATUS validate_open_object_attributes( const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
 
 /* module handling */
 extern LIST_ENTRY tls_links DECLSPEC_HIDDEN;
@@ -82,10 +149,83 @@ extern const WCHAR system_dir[] DECLSPEC_HIDDEN;
 extern const WCHAR syswow64_dir[] DECLSPEC_HIDDEN;
 
 extern const struct unix_funcs *unix_funcs DECLSPEC_HIDDEN;
+extern void (WINAPI *kernel32_start_process)(LPTHREAD_START_ROUTINE,void*) DECLSPEC_HIDDEN;
 
+/* Device IO */
+extern NTSTATUS CDROM_DeviceIoControl(HANDLE hDevice, 
+                                      HANDLE hEvent, PIO_APC_ROUTINE UserApcRoutine,
+                                      PVOID UserApcContext, 
+                                      PIO_STATUS_BLOCK piosb, 
+                                      ULONG IoControlCode,
+                                      LPVOID lpInBuffer, DWORD nInBufferSize,
+                                      LPVOID lpOutBuffer, DWORD nOutBufferSize) DECLSPEC_HIDDEN;
+extern NTSTATUS COMM_DeviceIoControl(HANDLE hDevice, 
+                                     HANDLE hEvent, PIO_APC_ROUTINE UserApcRoutine,
+                                     PVOID UserApcContext, 
+                                     PIO_STATUS_BLOCK piosb, 
+                                     ULONG IoControlCode,
+                                     LPVOID lpInBuffer, DWORD nInBufferSize,
+                                     LPVOID lpOutBuffer, DWORD nOutBufferSize) DECLSPEC_HIDDEN;
+extern NTSTATUS TAPE_DeviceIoControl(HANDLE hDevice, 
+                                     HANDLE hEvent, PIO_APC_ROUTINE UserApcRoutine,
+                                     PVOID UserApcContext, 
+                                     PIO_STATUS_BLOCK piosb, 
+                                     ULONG IoControlCode,
+                                     LPVOID lpInBuffer, DWORD nInBufferSize,
+                                     LPVOID lpOutBuffer, DWORD nOutBufferSize) DECLSPEC_HIDDEN;
+extern NTSTATUS COMM_FlushBuffersFile( int fd ) DECLSPEC_HIDDEN;
+
+/* file I/O */
+struct stat;
+extern NTSTATUS FILE_GetNtStatus(void) DECLSPEC_HIDDEN;
+extern int get_file_info( const char *path, struct stat *st, ULONG *attr ) DECLSPEC_HIDDEN;
+extern NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
+                                FILE_INFORMATION_CLASS class ) DECLSPEC_HIDDEN;
+extern NTSTATUS server_get_unix_name( HANDLE handle, ANSI_STRING *unix_name ) DECLSPEC_HIDDEN;
 extern void init_directories(void) DECLSPEC_HIDDEN;
+extern BOOL DIR_is_hidden_file( const UNICODE_STRING *name ) DECLSPEC_HIDDEN;
+extern NTSTATUS DIR_unmount_device( HANDLE handle ) DECLSPEC_HIDDEN;
+extern NTSTATUS DIR_get_unix_cwd( char **cwd ) DECLSPEC_HIDDEN;
+extern unsigned int DIR_get_drives_info( struct drive_info info[MAX_DOS_DRIVES] ) DECLSPEC_HIDDEN;
+extern NTSTATUS file_id_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, ANSI_STRING *unix_name_ret ) DECLSPEC_HIDDEN;
+extern NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, ANSI_STRING *unix_name_ret,
+                                           UINT disposition ) DECLSPEC_HIDDEN;
 
+/* virtual memory */
+extern NTSTATUS virtual_alloc( PVOID *ret, unsigned short zero_bits_64, SIZE_T *size_ptr,
+                               ULONG type, ULONG protect ) DECLSPEC_HIDDEN;
+extern NTSTATUS virtual_map_section( HANDLE handle, PVOID *addr_ptr, unsigned short zero_bits_64, SIZE_T commit_size,
+                                     const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr, ULONG alloc_type,
+                                     ULONG protect, pe_image_info_t *image_info ) DECLSPEC_HIDDEN;
+extern void virtual_get_system_info( SYSTEM_BASIC_INFORMATION *info ) DECLSPEC_HIDDEN;
+extern NTSTATUS virtual_create_builtin_view( void *base ) DECLSPEC_HIDDEN;
+extern TEB * virtual_alloc_first_teb(void) DECLSPEC_HIDDEN;
+extern NTSTATUS virtual_alloc_teb( TEB **teb ) DECLSPEC_HIDDEN;
+extern void virtual_free_teb( TEB *teb ) DECLSPEC_HIDDEN;
+extern NTSTATUS virtual_alloc_thread_stack( INITIAL_TEB *stack, SIZE_T reserve_size,
+                                            SIZE_T commit_size, SIZE_T *pthread_size ) DECLSPEC_HIDDEN;
+extern void virtual_clear_thread_stack( void *stack_end ) DECLSPEC_HIDDEN;
+extern int virtual_handle_stack_fault( void *addr ) DECLSPEC_HIDDEN;
+extern BOOL virtual_is_valid_code_address( const void *addr, SIZE_T size ) DECLSPEC_HIDDEN;
+extern NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack ) DECLSPEC_HIDDEN;
+extern unsigned int virtual_locked_server_call( void *req_ptr ) DECLSPEC_HIDDEN;
+extern ssize_t virtual_locked_read( int fd, void *addr, size_t size ) DECLSPEC_HIDDEN;
+extern ssize_t virtual_locked_pread( int fd, void *addr, size_t size, off_t offset ) DECLSPEC_HIDDEN;
+extern BOOL virtual_check_buffer_for_read( const void *ptr, SIZE_T size ) DECLSPEC_HIDDEN;
+extern BOOL virtual_check_buffer_for_write( void *ptr, SIZE_T size ) DECLSPEC_HIDDEN;
+extern SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size ) DECLSPEC_HIDDEN;
+extern NTSTATUS virtual_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size ) DECLSPEC_HIDDEN;
+extern void VIRTUAL_SetForceExec( BOOL enable ) DECLSPEC_HIDDEN;
+extern void virtual_release_address_space(void) DECLSPEC_HIDDEN;
+extern void virtual_set_large_address_space(void) DECLSPEC_HIDDEN;
+extern void virtual_fill_image_information( const pe_image_info_t *pe_info,
+                                            SECTION_IMAGE_INFORMATION *info ) DECLSPEC_HIDDEN;
 extern struct _KUSER_SHARED_DATA *user_shared_data DECLSPEC_HIDDEN;
+extern HANDLE user_shared_data_init_done(void) DECLSPEC_HIDDEN;
+
+/* completion */
+extern NTSTATUS NTDLL_AddCompletion( HANDLE hFile, ULONG_PTR CompletionValue,
+                                     NTSTATUS CompletionStatus, ULONG Information, BOOL async) DECLSPEC_HIDDEN;
 
 /* locale */
 extern LCID user_lcid, system_lcid;
@@ -110,9 +250,43 @@ enum loadorder
 
 extern enum loadorder get_load_order( const WCHAR *app_name, const UNICODE_STRING *nt_name ) DECLSPEC_HIDDEN;
 
-#ifndef _WIN64
-static inline TEB64 *NtCurrentTeb64(void) { return (TEB64 *)NtCurrentTeb()->GdiBatchCount; }
-#endif
+struct debug_info
+{
+    unsigned int str_pos;       /* current position in strings buffer */
+    unsigned int out_pos;       /* current position in output buffer */
+    char         strings[1024]; /* buffer for temporary strings */
+    char         output[1024];  /* current output line */
+};
+
+/* thread private data, stored in NtCurrentTeb()->GdiTebBatch */
+struct ntdll_thread_data
+{
+    struct debug_info *debug_info;    /* info for debugstr functions */
+    void              *start_stack;   /* stack for thread startup */
+    int                request_fd;    /* fd for sending server requests */
+    int                reply_fd;      /* fd for receiving server replies */
+    int                wait_fd[2];    /* fd for sleeping server requests */
+    BOOL               wow64_redir;   /* Wow64 filesystem redirection flag */
+    pthread_t          pthread_id;    /* pthread thread id */
+};
+
+C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
+
+static inline struct ntdll_thread_data *ntdll_get_thread_data(void)
+{
+    return (struct ntdll_thread_data *)&NtCurrentTeb()->GdiTebBatch;
+}
+
+static inline int get_unix_exit_code( NTSTATUS status )
+{
+    /* prevent a nonzero exit code to end up truncated to zero in unix */
+    if (status && !(status & 0xff)) return 1;
+    return status;
+}
+
+extern mode_t FILE_umask DECLSPEC_HIDDEN;
+extern HANDLE keyed_event DECLSPEC_HIDDEN;
+extern SYSTEM_CPU_INFORMATION cpu_info DECLSPEC_HIDDEN;
 
 #define HASH_STRING_ALGORITHM_DEFAULT  0
 #define HASH_STRING_ALGORITHM_X65599   1
@@ -125,6 +299,51 @@ void     WINAPI LdrInitializeThunk(CONTEXT*,void**,ULONG_PTR,ULONG_PTR);
 #define InterlockedCompareExchange64(dest,xchg,cmp) RtlInterlockedCompareExchange64(dest,xchg,cmp)
 #endif
 
+/* string functions */
+int    __cdecl NTDLL_tolower( int c );
+int    __cdecl _stricmp( LPCSTR str1, LPCSTR str2 );
+int    __cdecl NTDLL__wcsicmp( LPCWSTR str1, LPCWSTR str2 );
+int    __cdecl NTDLL__wcsnicmp( LPCWSTR str1, LPCWSTR str2, size_t n );
+int    __cdecl NTDLL_wcscmp( LPCWSTR str1, LPCWSTR str2 );
+int    __cdecl NTDLL_wcsncmp( LPCWSTR str1, LPCWSTR str2, size_t n );
+WCHAR  __cdecl NTDLL_towlower( WCHAR ch );
+WCHAR  __cdecl NTDLL_towupper( WCHAR ch );
+LPWSTR __cdecl NTDLL__wcslwr( LPWSTR str );
+LPWSTR __cdecl NTDLL__wcsupr( LPWSTR str );
+LPWSTR __cdecl NTDLL_wcscpy( LPWSTR dst, LPCWSTR src );
+LPWSTR __cdecl NTDLL_wcscat( LPWSTR dst, LPCWSTR src );
+LPWSTR __cdecl NTDLL_wcschr( LPCWSTR str, WCHAR ch );
+size_t __cdecl NTDLL_wcslen( LPCWSTR str );
+size_t __cdecl NTDLL_wcscspn( LPCWSTR str, LPCWSTR reject );
+LPWSTR __cdecl NTDLL_wcsncat( LPWSTR s1, LPCWSTR s2, size_t n );
+LPWSTR __cdecl NTDLL_wcsncpy( LPWSTR s1, LPCWSTR s2, size_t n );
+LPWSTR __cdecl NTDLL_wcspbrk( LPCWSTR str, LPCWSTR accept );
+LPWSTR __cdecl NTDLL_wcsrchr( LPCWSTR str, WCHAR ch );
+size_t __cdecl NTDLL_wcsspn( LPCWSTR str, LPCWSTR accept );
+LPWSTR __cdecl NTDLL_wcsstr( LPCWSTR str, LPCWSTR sub );
+LPWSTR __cdecl NTDLL_wcstok( LPWSTR str, LPCWSTR delim );
+LONG   __cdecl NTDLL_wcstol( LPCWSTR s, LPWSTR *end, INT base );
+ULONG  __cdecl NTDLL_wcstoul( LPCWSTR s, LPWSTR *end, INT base );
+int    WINAPIV NTDLL_swprintf( WCHAR *str, const WCHAR *format, ... );
+int    WINAPIV _snwprintf_s( WCHAR *str, SIZE_T size, SIZE_T len, const WCHAR *format, ... );
+
+#define wcsicmp(s1,s2) NTDLL__wcsicmp(s1,s2)
+#define wcsnicmp(s1,s2,n) NTDLL__wcsnicmp(s1,s2,n)
+#define towupper(c) NTDLL_towupper(c)
+#define wcslwr(s) NTDLL__wcslwr(s)
+#define wcsupr(s) NTDLL__wcsupr(s)
+#define wcscpy(d,s) NTDLL_wcscpy(d,s)
+#define wcscat(d,s) NTDLL_wcscat(d,s)
+#define wcschr(s,c) NTDLL_wcschr(s,c)
+#define wcspbrk(s,a) NTDLL_wcspbrk(s,a)
+#define wcsrchr(s,c) NTDLL_wcsrchr(s,c)
+#define wcstoul(s,e,b) NTDLL_wcstoul(s,e,b)
+#define wcslen(s) NTDLL_wcslen(s)
+#define wcscspn(s,r) NTDLL_wcscspn(s,r)
+#define wcsspn(s,a) NTDLL_wcsspn(s,a)
+#define wcscmp(s1,s2) NTDLL_wcscmp(s1,s2)
+#define wcsncmp(s1,s2,n) NTDLL_wcsncmp(s1,s2,n)
+
 /* convert from straight ASCII to Unicode without depending on the current codepage */
 static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
 {
diff --git a/dlls/ntdll/om.c b/dlls/ntdll/om.c
new file mode 100644
index 0000000000..0d66867496
--- /dev/null
+++ b/dlls/ntdll/om.c
@@ -0,0 +1,737 @@
+/*
+ *	Object management functions
+ *
+ * Copyright 1999, 2000 Juergen Schmied
+ * Copyright 2005 Vitaliy Margolen
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "wine/debug.h"
+#include "windef.h"
+#include "winternl.h"
+#include "ntdll_misc.h"
+#include "wine/server.h"
+#include "wine/exception.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
+
+
+/*
+ *	Generic object functions
+ */
+
+/******************************************************************************
+ * NtQueryObject [NTDLL.@]
+ * ZwQueryObject [NTDLL.@]
+ */
+NTSTATUS WINAPI NtQueryObject(IN HANDLE handle,
+                              IN OBJECT_INFORMATION_CLASS info_class,
+                              OUT PVOID ptr, IN ULONG len, OUT PULONG used_len)
+{
+    NTSTATUS status;
+
+    TRACE("(%p,0x%08x,%p,0x%08x,%p)\n", handle, info_class, ptr, len, used_len);
+
+    if (used_len) *used_len = 0;
+
+    switch (info_class)
+    {
+    case ObjectBasicInformation:
+        {
+            POBJECT_BASIC_INFORMATION p = ptr;
+
+            if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+            SERVER_START_REQ( get_object_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                status = wine_server_call( req );
+                if (status == STATUS_SUCCESS)
+                {
+                    memset( p, 0, sizeof(*p) );
+                    p->GrantedAccess = reply->access;
+                    p->PointerCount = reply->ref_count;
+                    p->HandleCount = reply->handle_count;
+                    if (used_len) *used_len = sizeof(*p);
+                }
+            }
+            SERVER_END_REQ;
+        }
+        break;
+    case ObjectNameInformation:
+        {
+            OBJECT_NAME_INFORMATION* p = ptr;
+            ANSI_STRING unix_name;
+
+            /* first try as a file object */
+
+            if (!(status = server_get_unix_name( handle, &unix_name )))
+            {
+                UNICODE_STRING nt_name;
+
+                if (!(status = wine_unix_to_nt_file_name( &unix_name, &nt_name )))
+                {
+                    if (len < sizeof(*p))
+                        status = STATUS_INFO_LENGTH_MISMATCH;
+                    else if (len < sizeof(*p) + nt_name.MaximumLength)
+                        status = STATUS_BUFFER_OVERFLOW;
+                    else
+                    {
+                        p->Name.Buffer = (WCHAR *)(p + 1);
+                        p->Name.Length = nt_name.Length;
+                        p->Name.MaximumLength = nt_name.MaximumLength;
+                        memcpy( p->Name.Buffer, nt_name.Buffer, nt_name.MaximumLength );
+                    }
+                    if (used_len) *used_len = sizeof(*p) + nt_name.MaximumLength;
+                    RtlFreeUnicodeString( &nt_name );
+                }
+                RtlFreeAnsiString( &unix_name );
+                break;
+            }
+            else if (status != STATUS_OBJECT_TYPE_MISMATCH) break;
+
+            /* not a file, treat as a generic object */
+
+            SERVER_START_REQ( get_object_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                if (len > sizeof(*p)) wine_server_set_reply( req, p + 1, len - sizeof(*p) );
+                status = wine_server_call( req );
+                if (status == STATUS_SUCCESS)
+                {
+                    if (!reply->total)  /* no name */
+                    {
+                        if (sizeof(*p) > len) status = STATUS_INFO_LENGTH_MISMATCH;
+                        else memset( p, 0, sizeof(*p) );
+                        if (used_len) *used_len = sizeof(*p);
+                    }
+                    else if (sizeof(*p) + reply->total + sizeof(WCHAR) > len)
+                    {
+                        if (used_len) *used_len = sizeof(*p) + reply->total + sizeof(WCHAR);
+                        status = STATUS_INFO_LENGTH_MISMATCH;
+                    }
+                    else
+                    {
+                        ULONG res = wine_server_reply_size( reply );
+                        p->Name.Buffer = (WCHAR *)(p + 1);
+                        p->Name.Length = res;
+                        p->Name.MaximumLength = res + sizeof(WCHAR);
+                        p->Name.Buffer[res / sizeof(WCHAR)] = 0;
+                        if (used_len) *used_len = sizeof(*p) + p->Name.MaximumLength;
+                    }
+                }
+            }
+            SERVER_END_REQ;
+        }
+        break;
+    case ObjectTypeInformation:
+        {
+            OBJECT_TYPE_INFORMATION *p = ptr;
+
+            SERVER_START_REQ( get_object_type )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                if (len > sizeof(*p)) wine_server_set_reply( req, p + 1, len - sizeof(*p) );
+                status = wine_server_call( req );
+                if (status == STATUS_SUCCESS)
+                {
+                    if (!reply->total)  /* no name */
+                    {
+                        if (sizeof(*p) > len) status = STATUS_INFO_LENGTH_MISMATCH;
+                        else memset( p, 0, sizeof(*p) );
+                        if (used_len) *used_len = sizeof(*p);
+                    }
+                    else if (sizeof(*p) + reply->total + sizeof(WCHAR) > len)
+                    {
+                        if (used_len) *used_len = sizeof(*p) + reply->total + sizeof(WCHAR);
+                        status = STATUS_INFO_LENGTH_MISMATCH;
+                    }
+                    else
+                    {
+                        ULONG res = wine_server_reply_size( reply );
+                        p->TypeName.Buffer = (WCHAR *)(p + 1);
+                        p->TypeName.Length = res;
+                        p->TypeName.MaximumLength = res + sizeof(WCHAR);
+                        p->TypeName.Buffer[res / sizeof(WCHAR)] = 0;
+                        if (used_len) *used_len = sizeof(*p) + p->TypeName.MaximumLength;
+                    }
+                }
+            }
+            SERVER_END_REQ;
+        }
+        break;
+    case ObjectDataInformation:
+        {
+            OBJECT_DATA_INFORMATION* p = ptr;
+
+            if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+            SERVER_START_REQ( set_handle_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags  = 0;
+                req->mask   = 0;
+                status = wine_server_call( req );
+                if (status == STATUS_SUCCESS)
+                {
+                    p->InheritHandle = (reply->old_flags & HANDLE_FLAG_INHERIT) != 0;
+                    p->ProtectFromClose = (reply->old_flags & HANDLE_FLAG_PROTECT_FROM_CLOSE) != 0;
+                    if (used_len) *used_len = sizeof(*p);
+                }
+            }
+            SERVER_END_REQ;
+        }
+        break;
+    default:
+        FIXME("Unsupported information class %u\n", info_class);
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    return status;
+}
+
+/******************************************************************
+ *		NtSetInformationObject [NTDLL.@]
+ *		ZwSetInformationObject [NTDLL.@]
+ *
+ */
+NTSTATUS WINAPI NtSetInformationObject(IN HANDLE handle,
+                                       IN OBJECT_INFORMATION_CLASS info_class,
+                                       IN PVOID ptr, IN ULONG len)
+{
+    NTSTATUS status;
+
+    TRACE("(%p,0x%08x,%p,0x%08x)\n", handle, info_class, ptr, len);
+
+    switch (info_class)
+    {
+    case ObjectDataInformation:
+        {
+            OBJECT_DATA_INFORMATION* p = ptr;
+
+            if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+            SERVER_START_REQ( set_handle_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags  = 0;
+                req->mask   = HANDLE_FLAG_INHERIT | HANDLE_FLAG_PROTECT_FROM_CLOSE;
+                if (p->InheritHandle)    req->flags |= HANDLE_FLAG_INHERIT;
+                if (p->ProtectFromClose) req->flags |= HANDLE_FLAG_PROTECT_FROM_CLOSE;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        break;
+    default:
+        FIXME("Unsupported information class %u\n", info_class);
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    return status;
+}
+
+/******************************************************************************
+ *  NtQuerySecurityObject	[NTDLL.@]
+ *
+ * An ntdll analogue to GetKernelObjectSecurity().
+ *
+ */
+NTSTATUS WINAPI
+NtQuerySecurityObject(
+	IN HANDLE Object,
+	IN SECURITY_INFORMATION RequestedInformation,
+	OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
+	IN ULONG Length,
+	OUT PULONG ResultLength)
+{
+    PISECURITY_DESCRIPTOR_RELATIVE psd = pSecurityDescriptor;
+    NTSTATUS status;
+    unsigned int buffer_size = 512;
+    BOOLEAN need_more_memory;
+
+    TRACE("(%p,0x%08x,%p,0x%08x,%p)\n",
+	Object, RequestedInformation, pSecurityDescriptor, Length, ResultLength);
+
+    do
+    {
+        char *buffer = RtlAllocateHeap(GetProcessHeap(), 0, buffer_size);
+        if (!buffer)
+            return STATUS_NO_MEMORY;
+
+        need_more_memory = FALSE;
+
+        SERVER_START_REQ( get_security_object )
+        {
+            req->handle = wine_server_obj_handle( Object );
+            req->security_info = RequestedInformation;
+            wine_server_set_reply( req, buffer, buffer_size );
+            status = wine_server_call( req );
+            if (status == STATUS_SUCCESS)
+            {
+                struct security_descriptor *sd = (struct security_descriptor *)buffer;
+                if (reply->sd_len)
+                {
+                    *ResultLength = sizeof(SECURITY_DESCRIPTOR_RELATIVE) +
+                        sd->owner_len + sd->group_len + sd->sacl_len + sd->dacl_len;
+                    if (Length >= *ResultLength)
+                    {
+                        psd->Revision = SECURITY_DESCRIPTOR_REVISION;
+                        psd->Sbz1 = 0;
+                        psd->Control = sd->control | SE_SELF_RELATIVE;
+                        psd->Owner = sd->owner_len ? sizeof(SECURITY_DESCRIPTOR_RELATIVE) : 0;
+                        psd->Group = sd->group_len ? sizeof(SECURITY_DESCRIPTOR_RELATIVE) + sd->owner_len : 0;
+                        psd->Sacl = sd->sacl_len ? sizeof(SECURITY_DESCRIPTOR_RELATIVE) + sd->owner_len + sd->group_len : 0;
+                        psd->Dacl = sd->dacl_len ? sizeof(SECURITY_DESCRIPTOR_RELATIVE) + sd->owner_len + sd->group_len + sd->sacl_len : 0;
+                        /* owner, group, sacl and dacl are the same type as in the server
+                         * and in the same order so we copy the memory in one block */
+                        memcpy((char *)pSecurityDescriptor + sizeof(SECURITY_DESCRIPTOR_RELATIVE),
+                               buffer + sizeof(struct security_descriptor),
+                               sd->owner_len + sd->group_len + sd->sacl_len + sd->dacl_len);
+                    }
+                    else
+                        status = STATUS_BUFFER_TOO_SMALL;
+                }
+                else
+                {
+                    *ResultLength = sizeof(SECURITY_DESCRIPTOR_RELATIVE);
+                    if (Length >= *ResultLength)
+                    {
+                        memset(psd, 0, sizeof(*psd));
+                        psd->Revision = SECURITY_DESCRIPTOR_REVISION;
+                        psd->Control = SE_SELF_RELATIVE;
+                    }
+                    else
+                        status = STATUS_BUFFER_TOO_SMALL;
+                }
+            }
+            else if (status == STATUS_BUFFER_TOO_SMALL)
+            {
+                buffer_size = reply->sd_len;
+                need_more_memory = TRUE;
+            }
+        }
+        SERVER_END_REQ;
+        RtlFreeHeap(GetProcessHeap(), 0, buffer);
+    } while (need_more_memory);
+
+    return status;
+}
+
+
+/******************************************************************************
+ *  NtDuplicateObject		[NTDLL.@]
+ *  ZwDuplicateObject		[NTDLL.@]
+ */
+NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source,
+                                   HANDLE dest_process, PHANDLE dest,
+                                   ACCESS_MASK access, ULONG attributes, ULONG options )
+{
+    NTSTATUS ret;
+    SERVER_START_REQ( dup_handle )
+    {
+        req->src_process = wine_server_obj_handle( source_process );
+        req->src_handle  = wine_server_obj_handle( source );
+        req->dst_process = wine_server_obj_handle( dest_process );
+        req->access      = access;
+        req->attributes  = attributes;
+        req->options     = options;
+
+        if (!(ret = wine_server_call( req )))
+        {
+            if (dest) *dest = wine_server_ptr_handle( reply->handle );
+            if (reply->closed && reply->self)
+            {
+                int fd = server_remove_fd_from_cache( source );
+                if (fd != -1) close( fd );
+            }
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+static LONG WINAPI invalid_handle_exception_handler( EXCEPTION_POINTERS *eptr )
+{
+    EXCEPTION_RECORD *rec = eptr->ExceptionRecord;
+    return (rec->ExceptionCode == EXCEPTION_INVALID_HANDLE) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
+}
+
+/* Everquest 2 / Pirates of the Burning Sea hooks NtClose, so we need a wrapper */
+NTSTATUS close_handle( HANDLE handle )
+{
+    NTSTATUS ret;
+    int fd = server_remove_fd_from_cache( handle );
+
+    SERVER_START_REQ( close_handle )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    if (fd != -1) close( fd );
+
+    if (ret == STATUS_INVALID_HANDLE && handle && NtCurrentTeb()->Peb->BeingDebugged)
+    {
+        __TRY
+        {
+            EXCEPTION_RECORD record;
+            record.ExceptionCode    = EXCEPTION_INVALID_HANDLE;
+            record.ExceptionFlags   = 0;
+            record.ExceptionRecord  = NULL;
+            record.ExceptionAddress = NULL;
+            record.NumberParameters = 0;
+            RtlRaiseException( &record );
+        }
+        __EXCEPT(invalid_handle_exception_handler)
+        {
+        }
+        __ENDTRY
+    }
+
+    return ret;
+}
+
+/**************************************************************************
+ *                 NtClose				[NTDLL.@]
+ *
+ * Close a handle reference to an object.
+ * 
+ * PARAMS
+ *  Handle [I] handle to close
+ *
+ * RETURNS
+ *  Success: ERROR_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtClose( HANDLE Handle )
+{
+    return close_handle( Handle );
+}
+
+/*
+ *	Directory functions
+ */
+
+/**************************************************************************
+ * NtOpenDirectoryObject [NTDLL.@]
+ * ZwOpenDirectoryObject [NTDLL.@]
+ *
+ * Open a namespace directory object.
+ * 
+ * PARAMS
+ *  DirectoryHandle  [O] Destination for the new directory handle
+ *  DesiredAccess    [I] Desired access to the directory
+ *  ObjectAttributes [I] Structure describing the directory
+ *
+ * RETURNS
+ *  Success: ERROR_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtOpenDirectoryObject( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr)
+{
+    NTSTATUS ret;
+
+    if (!handle) return STATUS_ACCESS_VIOLATION;
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    TRACE("(%p,0x%08x,%s)\n", handle, access, debugstr_ObjectAttributes(attr));
+
+    SERVER_START_REQ(open_directory)
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtCreateDirectoryObject	[NTDLL.@]
+ *  ZwCreateDirectoryObject	[NTDLL.@]
+ *
+ * Create a namespace directory object.
+ * 
+ * PARAMS
+ *  DirectoryHandle  [O] Destination for the new directory handle
+ *  DesiredAccess    [I] Desired access to the directory
+ *  ObjectAttributes [I] Structure describing the directory
+ *
+ * RETURNS
+ *  Success: ERROR_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtCreateDirectoryObject(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess,
+                                        OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if (!DirectoryHandle) return STATUS_ACCESS_VIOLATION;
+    TRACE("(%p,0x%08x,%s)\n", DirectoryHandle, DesiredAccess, debugstr_ObjectAttributes(attr));
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ(create_directory)
+    {
+        req->access = DesiredAccess;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        *DirectoryHandle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+/******************************************************************************
+ * NtQueryDirectoryObject [NTDLL.@]
+ * ZwQueryDirectoryObject [NTDLL.@]
+ *
+ * Read information from a namespace directory.
+ * 
+ * PARAMS
+ *  handle        [I]   Handle to a directory object
+ *  buffer        [O]   Buffer to hold the read data
+ *  size          [I]   Size of the buffer in bytes
+ *  single_entry  [I]   If TRUE, return a single entry, if FALSE, return as many as fit in the buffer
+ *  restart       [I]   If TRUE, start scanning from the start, if FALSE, scan from Context
+ *  context       [I/O] Indicates what point of the directory the scan is at
+ *  ret_size      [O]   Caller supplied storage for the number of bytes written (or NULL)
+ *
+ * RETURNS
+ *  Success: ERROR_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtQueryDirectoryObject(HANDLE handle, PDIRECTORY_BASIC_INFORMATION buffer,
+                                       ULONG size, BOOLEAN single_entry, BOOLEAN restart,
+                                       PULONG context, PULONG ret_size)
+{
+    NTSTATUS ret;
+
+    if (restart) *context = 0;
+
+    if (single_entry)
+    {
+        if (size <= sizeof(*buffer) + 2*sizeof(WCHAR)) return STATUS_BUFFER_OVERFLOW;
+
+        SERVER_START_REQ( get_directory_entry )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->index = *context;
+            wine_server_set_reply( req, buffer + 1, size - sizeof(*buffer) - 2*sizeof(WCHAR) );
+            if (!(ret = wine_server_call( req )))
+            {
+                buffer->ObjectName.Buffer = (WCHAR *)(buffer + 1);
+                buffer->ObjectName.Length = reply->name_len;
+                buffer->ObjectName.MaximumLength = reply->name_len + sizeof(WCHAR);
+                buffer->ObjectTypeName.Buffer = (WCHAR *)(buffer + 1) + reply->name_len/sizeof(WCHAR) + 1;
+                buffer->ObjectTypeName.Length = wine_server_reply_size( reply ) - reply->name_len;
+                buffer->ObjectTypeName.MaximumLength = buffer->ObjectTypeName.Length + sizeof(WCHAR);
+                /* make room for the terminating null */
+                memmove( buffer->ObjectTypeName.Buffer, buffer->ObjectTypeName.Buffer - 1,
+                         buffer->ObjectTypeName.Length );
+                buffer->ObjectName.Buffer[buffer->ObjectName.Length/sizeof(WCHAR)] = 0;
+                buffer->ObjectTypeName.Buffer[buffer->ObjectTypeName.Length/sizeof(WCHAR)] = 0;
+                (*context)++;
+            }
+        }
+        SERVER_END_REQ;
+        if (ret_size)
+            *ret_size = buffer->ObjectName.MaximumLength + buffer->ObjectTypeName.MaximumLength + sizeof(*buffer);
+    }
+    else
+    {
+        FIXME("multiple entries not implemented\n");
+        ret = STATUS_NOT_IMPLEMENTED;
+    }
+
+    return ret;
+}
+
+/*
+ *	Link objects
+ */
+
+/******************************************************************************
+ *  NtOpenSymbolicLinkObject	[NTDLL.@]
+ *  ZwOpenSymbolicLinkObject	[NTDLL.@]
+ *
+ * Open a namespace symbolic link object.
+ * 
+ * PARAMS
+ *  LinkHandle       [O] Destination for the new symbolic link handle
+ *  DesiredAccess    [I] Desired access to the symbolic link
+ *  ObjectAttributes [I] Structure describing the symbolic link
+ *
+ * RETURNS
+ *  Success: ERROR_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtOpenSymbolicLinkObject( HANDLE *handle, ACCESS_MASK access,
+                                          const OBJECT_ATTRIBUTES *attr)
+{
+    NTSTATUS ret;
+
+    TRACE("(%p,0x%08x,%s)\n", handle, access, debugstr_ObjectAttributes(attr));
+
+    if (!handle) return STATUS_ACCESS_VIOLATION;
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    SERVER_START_REQ(open_symlink)
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtCreateSymbolicLinkObject	[NTDLL.@]
+ *  ZwCreateSymbolicLinkObject	[NTDLL.@]
+ *
+ * Open a namespace symbolic link object.
+ * 
+ * PARAMS
+ *  SymbolicLinkHandle [O] Destination for the new symbolic link handle
+ *  DesiredAccess      [I] Desired access to the symbolic link
+ *  ObjectAttributes   [I] Structure describing the symbolic link
+ *  TargetName         [I] Name of the target symbolic link points to
+ *
+ * RETURNS
+ *  Success: ERROR_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtCreateSymbolicLinkObject(OUT PHANDLE SymbolicLinkHandle,IN ACCESS_MASK DesiredAccess,
+	                                   POBJECT_ATTRIBUTES attr, PUNICODE_STRING TargetName)
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if (!SymbolicLinkHandle || !attr || !TargetName) return STATUS_ACCESS_VIOLATION;
+    if (!TargetName->Buffer) return STATUS_INVALID_PARAMETER;
+
+    TRACE("(%p,0x%08x,%s -> %s)\n", SymbolicLinkHandle, DesiredAccess,
+          debugstr_ObjectAttributes(attr), debugstr_us(TargetName));
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ(create_symlink)
+    {
+        req->access = DesiredAccess;
+        wine_server_add_data( req, objattr, len );
+        wine_server_add_data(req, TargetName->Buffer, TargetName->Length);
+        ret = wine_server_call( req );
+        *SymbolicLinkHandle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+/******************************************************************************
+ *  NtQuerySymbolicLinkObject	[NTDLL.@]
+ *  ZwQuerySymbolicLinkObject	[NTDLL.@]
+ *
+ * Query a namespace symbolic link object target name.
+ *
+ * PARAMS
+ *  handle     [I] Handle to a symbolic link object
+ *  target     [O] Destination for the symbolic link target
+ *  length     [O] Size of returned data
+ *
+ * RETURNS
+ *  Success: ERROR_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtQuerySymbolicLinkObject( HANDLE handle, PUNICODE_STRING target, PULONG length )
+{
+    NTSTATUS ret;
+
+    TRACE("(%p,%p,%p)\n", handle, target, length );
+
+    if (!target) return STATUS_ACCESS_VIOLATION;
+
+    SERVER_START_REQ(query_symlink)
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (target->MaximumLength >= sizeof(WCHAR))
+            wine_server_set_reply( req, target->Buffer, target->MaximumLength - sizeof(WCHAR) );
+        if (!(ret = wine_server_call( req )))
+        {
+            target->Length = wine_server_reply_size(reply);
+            target->Buffer[target->Length / sizeof(WCHAR)] = 0;
+            if (length) *length = reply->total + sizeof(WCHAR);
+        }
+        else if (length && ret == STATUS_BUFFER_TOO_SMALL) *length = reply->total + sizeof(WCHAR);
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtAllocateUuids   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtAllocateUuids( ULARGE_INTEGER *time, ULONG *delta, ULONG *sequence, UCHAR *seed )
+{
+    FIXME("(%p,%p,%p,%p), stub.\n", time, delta, sequence, seed);
+    return STATUS_SUCCESS;
+}
+
+/**************************************************************************
+ *  NtMakeTemporaryObject	[NTDLL.@]
+ *  ZwMakeTemporaryObject	[NTDLL.@]
+ *
+ * Make a permanent object temporary.
+ *
+ * PARAMS
+ *  Handle [I] handle to permanent object
+ *
+ * RETURNS
+ *  Success: STATUS_SUCCESS.
+ *  Failure: An NTSTATUS error code.
+ */
+NTSTATUS WINAPI NtMakeTemporaryObject( HANDLE Handle )
+{
+    FIXME("(%p), stub.\n", Handle);
+    return STATUS_SUCCESS;
+}
diff --git a/dlls/ntdll/path.c b/dlls/ntdll/path.c
index 5f2d379071..acf622e8b8 100644
--- a/dlls/ntdll/path.c
+++ b/dlls/ntdll/path.c
@@ -19,14 +19,25 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <sys/types.h>
+#include <errno.h>
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winioctl.h"
 #include "wine/debug.h"
+#include "wine/library.h"
 #include "ntdll_misc.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(file);
@@ -37,6 +48,189 @@ static const WCHAR UncPfxW[] = {'U','N','C','\\',0};
 
 #define IS_SEPARATOR(ch)  ((ch) == '\\' || (ch) == '/')
 
+/***********************************************************************
+ *           remove_last_componentA
+ *
+ * Remove the last component of the path. Helper for find_drive_rootA.
+ */
+static inline unsigned int remove_last_componentA( const char *path, unsigned int len )
+{
+    int level = 0;
+
+    while (level < 1)
+    {
+        /* find start of the last path component */
+        unsigned int prev = len;
+        if (prev <= 1) break;  /* reached root */
+        while (prev > 1 && path[prev - 1] != '/') prev--;
+        /* does removing it take us up a level? */
+        if (len - prev != 1 || path[prev] != '.')  /* not '.' */
+        {
+            if (len - prev == 2 && path[prev] == '.' && path[prev+1] == '.')  /* is it '..'? */
+                level--;
+            else
+                level++;
+        }
+        /* strip off trailing slashes */
+        while (prev > 1 && path[prev - 1] == '/') prev--;
+        len = prev;
+    }
+    return len;
+}
+
+
+/***********************************************************************
+ *           find_drive_rootA
+ *
+ * Find a drive for which the root matches the beginning of the given path.
+ * This can be used to translate a Unix path into a drive + DOS path.
+ * Return value is the drive, or -1 on error. On success, ppath is modified
+ * to point to the beginning of the DOS path.
+ */
+static NTSTATUS find_drive_rootA( LPCSTR *ppath, unsigned int len, int *drive_ret )
+{
+    /* Starting with the full path, check if the device and inode match any of
+     * the wine 'drives'. If not then remove the last path component and try
+     * again. If the last component was a '..' then skip a normal component
+     * since it's a directory that's ascended back out of.
+     */
+    int drive;
+    char *buffer;
+    const char *path = *ppath;
+    struct stat st;
+    struct drive_info info[MAX_DOS_DRIVES];
+
+    /* get device and inode of all drives */
+    if (!DIR_get_drives_info( info )) return STATUS_OBJECT_PATH_NOT_FOUND;
+
+    /* strip off trailing slashes */
+    while (len > 1 && path[len - 1] == '/') len--;
+
+    /* make a copy of the path */
+    if (!(buffer = RtlAllocateHeap( GetProcessHeap(), 0, len + 1 ))) return STATUS_NO_MEMORY;
+    memcpy( buffer, path, len );
+    buffer[len] = 0;
+
+    for (;;)
+    {
+        if (!stat( buffer, &st ) && S_ISDIR( st.st_mode ))
+        {
+            /* Find the drive */
+            for (drive = 0; drive < MAX_DOS_DRIVES; drive++)
+            {
+                if ((info[drive].dev == st.st_dev) && (info[drive].ino == st.st_ino))
+                {
+                    if (len == 1) len = 0;  /* preserve root slash in returned path */
+                    TRACE( "%s -> drive %c:, root=%s, name=%s\n",
+                           debugstr_a(path), 'A' + drive, debugstr_a(buffer), debugstr_a(path + len));
+                    *ppath += len;
+                    *drive_ret = drive;
+                    RtlFreeHeap( GetProcessHeap(), 0, buffer );
+                    return STATUS_SUCCESS;
+                }
+            }
+        }
+        if (len <= 1) break;  /* reached root */
+        len = remove_last_componentA( buffer, len );
+        buffer[len] = 0;
+    }
+    RtlFreeHeap( GetProcessHeap(), 0, buffer );
+    return STATUS_OBJECT_PATH_NOT_FOUND;
+}
+
+
+/***********************************************************************
+ *           remove_last_componentW
+ *
+ * Remove the last component of the path. Helper for find_drive_rootW.
+ */
+static inline int remove_last_componentW( const WCHAR *path, int len )
+{
+    int level = 0;
+
+    while (level < 1)
+    {
+        /* find start of the last path component */
+        int prev = len;
+        if (prev <= 1) break;  /* reached root */
+        while (prev > 1 && !IS_SEPARATOR(path[prev - 1])) prev--;
+        /* does removing it take us up a level? */
+        if (len - prev != 1 || path[prev] != '.')  /* not '.' */
+        {
+            if (len - prev == 2 && path[prev] == '.' && path[prev+1] == '.')  /* is it '..'? */
+                level--;
+            else
+                level++;
+        }
+        /* strip off trailing slashes */
+        while (prev > 1 && IS_SEPARATOR(path[prev - 1])) prev--;
+        len = prev;
+    }
+    return len;
+}
+
+
+/***********************************************************************
+ *           find_drive_rootW
+ *
+ * Find a drive for which the root matches the beginning of the given path.
+ * This can be used to translate a Unix path into a drive + DOS path.
+ * Return value is the drive, or -1 on error. On success, ppath is modified
+ * to point to the beginning of the DOS path.
+ */
+static int find_drive_rootW( LPCWSTR *ppath )
+{
+    /* Starting with the full path, check if the device and inode match any of
+     * the wine 'drives'. If not then remove the last path component and try
+     * again. If the last component was a '..' then skip a normal component
+     * since it's a directory that's ascended back out of.
+     */
+    int drive, lenA, lenW;
+    char *buffer, *p;
+    const WCHAR *path = *ppath;
+    struct stat st;
+    struct drive_info info[MAX_DOS_DRIVES];
+
+    /* get device and inode of all drives */
+    if (!DIR_get_drives_info( info )) return -1;
+
+    /* strip off trailing slashes */
+    lenW = wcslen(path);
+    while (lenW > 1 && IS_SEPARATOR(path[lenW - 1])) lenW--;
+
+    /* convert path to Unix encoding */
+    if (!(buffer = RtlAllocateHeap( GetProcessHeap(), 0, lenW * 3 + 1 ))) return -1;
+
+    for (;;)
+    {
+        lenA = ntdll_wcstoumbs( path, lenW, buffer, lenW * 3, FALSE );
+        buffer[lenA] = 0;
+        for (p = buffer; *p; p++) if (*p == '\\') *p = '/';
+
+        if (!stat( buffer, &st ) && S_ISDIR( st.st_mode ))
+        {
+            /* Find the drive */
+            for (drive = 0; drive < MAX_DOS_DRIVES; drive++)
+            {
+                if ((info[drive].dev == st.st_dev) && (info[drive].ino == st.st_ino))
+                {
+                    if (lenW == 1) lenW = 0;  /* preserve root slash in returned path */
+                    TRACE( "%s -> drive %c:, root=%s, name=%s\n",
+                           debugstr_w(path), 'A' + drive, debugstr_a(buffer), debugstr_w(path + lenW));
+                    *ppath += lenW;
+                    RtlFreeHeap( GetProcessHeap(), 0, buffer );
+                    return drive;
+                }
+            }
+        }
+        if (lenW <= 1) break;  /* reached root */
+        lenW = remove_last_componentW( path, lenW );
+    }
+    RtlFreeHeap( GetProcessHeap(), 0, buffer );
+    return -1;
+}
+
+
 /***********************************************************************
  *             RtlDetermineDosPathNameType_U   (NTDLL.@)
  */
@@ -544,35 +738,19 @@ static ULONG get_full_path_helper(LPCWSTR name, LPWSTR buffer, ULONG size)
     case ABSOLUTE_PATH:         /* \xxx    */
         if (name[0] == '/')  /* may be a Unix path */
         {
-            char *unix_name;
-            WCHAR *nt_str;
-            SIZE_T buflen;
-            NTSTATUS status;
-
-            unix_name = RtlAllocateHeap( GetProcessHeap(), 0, 3 * wcslen(name) + 1 );
-            ntdll_wcstoumbs( name, wcslen(name) + 1, unix_name, 3 * wcslen(name) + 1, FALSE );
-            buflen = strlen(unix_name) + 10;
-            for (;;)
+            const WCHAR *ptr = name;
+            int drive = find_drive_rootW( &ptr );
+            if (drive != -1)
             {
-                if (!(nt_str = RtlAllocateHeap( GetProcessHeap(), 0, buflen * sizeof(WCHAR) ))) break;
-                status = unix_funcs->unix_to_nt_file_name( unix_name, nt_str, &buflen );
-                if (status != STATUS_BUFFER_TOO_SMALL) break;
-                RtlFreeHeap( GetProcessHeap(), 0, nt_str );
-            }
-            RtlFreeHeap( GetProcessHeap(), 0, unix_name );
-            if (!status && buflen > 6 && nt_str[5] == ':')
-            {
-                reqsize = (buflen - 4) * sizeof(WCHAR);
-                if (reqsize <= size)
-                {
-                    memcpy( buffer, nt_str + 4, reqsize );
-                    collapse_path( buffer, 3 );
-                    reqsize -= sizeof(WCHAR);
-                }
-                RtlFreeHeap( GetProcessHeap(), 0, nt_str );
-                goto done;
+                reqsize = 3 * sizeof(WCHAR);
+                tmp[0] = 'A' + drive;
+                tmp[1] = ':';
+                tmp[2] = '\\';
+                ins_str = tmp;
+                mark = 3;
+                dep = ptr - name;
+                break;
             }
-            RtlFreeHeap( GetProcessHeap(), 0, nt_str );
         }
         if (cd->Buffer[1] == ':')
         {
@@ -897,7 +1075,88 @@ NTSTATUS WINAPI RtlSetCurrentDirectory_U(const UNICODE_STRING* dir)
 /******************************************************************
  *           wine_unix_to_nt_file_name  (NTDLL.@) Not a Windows API
  */
-NTSTATUS CDECL wine_unix_to_nt_file_name( const char *name, WCHAR *buffer, SIZE_T *size )
+NTSTATUS CDECL wine_unix_to_nt_file_name( const ANSI_STRING *name, UNICODE_STRING *nt )
 {
-    return unix_funcs->unix_to_nt_file_name( name, buffer, size );
+    static const WCHAR prefixW[] = {'\\','?','?','\\','A',':','\\'};
+    static const WCHAR unix_prefixW[] = {'\\','?','?','\\','u','n','i','x'};
+    unsigned int lenW, lenA = name->Length;
+    const char *path = name->Buffer;
+    char *cwd;
+    WCHAR *p;
+    NTSTATUS status;
+    int drive;
+
+    if (!lenA || path[0] != '/')
+    {
+        char *newcwd, *end;
+        size_t size;
+
+        if ((status = DIR_get_unix_cwd( &cwd )) != STATUS_SUCCESS) return status;
+
+        size = strlen(cwd) + lenA + 1;
+        if (!(newcwd = RtlReAllocateHeap( GetProcessHeap(), 0, cwd, size )))
+        {
+            status = STATUS_NO_MEMORY;
+            goto done;
+        }
+        cwd = newcwd;
+        end = cwd + strlen(cwd);
+        if (end > cwd && end[-1] != '/') *end++ = '/';
+        memcpy( end, path, lenA );
+        lenA += end - cwd;
+        path = cwd;
+
+        status = find_drive_rootA( &path, lenA, &drive );
+        lenA -= (path - cwd);
+    }
+    else
+    {
+        cwd = NULL;
+        status = find_drive_rootA( &path, lenA, &drive );
+        lenA -= (path - name->Buffer);
+    }
+
+    if (status != STATUS_SUCCESS)
+    {
+        if (status == STATUS_OBJECT_PATH_NOT_FOUND)
+        {
+            nt->Buffer = RtlAllocateHeap( GetProcessHeap(), 0,
+                                          (lenA + 1) * sizeof(WCHAR) + sizeof(unix_prefixW) );
+            if (nt->Buffer == NULL)
+            {
+                status = STATUS_NO_MEMORY;
+                goto done;
+            }
+            memcpy( nt->Buffer, unix_prefixW, sizeof(unix_prefixW) );
+            lenW = ARRAY_SIZE( unix_prefixW );
+            lenW += ntdll_umbstowcs( path, lenA, nt->Buffer + lenW, lenA );
+            nt->Buffer[lenW] = 0;
+            nt->Length = lenW * sizeof(WCHAR);
+            nt->MaximumLength = nt->Length + sizeof(WCHAR);
+            for (p = nt->Buffer + ARRAY_SIZE( unix_prefixW ); *p; p++) if (*p == '/') *p = '\\';
+            status = STATUS_SUCCESS;
+        }
+        goto done;
+    }
+    while (lenA && path[0] == '/') { lenA--; path++; }
+
+    if (!(nt->Buffer = RtlAllocateHeap( GetProcessHeap(), 0,
+                                        (lenA + 1) * sizeof(WCHAR) + sizeof(prefixW) )))
+    {
+        status = STATUS_NO_MEMORY;
+        goto done;
+    }
+
+    memcpy( nt->Buffer, prefixW, sizeof(prefixW) );
+    nt->Buffer[4] += drive;
+    lenW = ARRAY_SIZE( prefixW );
+    lenW += ntdll_umbstowcs( path, lenA, nt->Buffer + lenW, lenA );
+    nt->Buffer[lenW] = 0;
+    nt->Length = lenW * sizeof(WCHAR);
+    nt->MaximumLength = nt->Length + sizeof(WCHAR);
+    for (p = nt->Buffer + ARRAY_SIZE( prefixW ); *p; p++) if (*p == '/') *p = '\\';
+
+done:
+    RtlFreeHeap( GetProcessHeap(), 0, cwd );
+    return status;
 }
diff --git a/dlls/ntdll/printf.c b/dlls/ntdll/printf.c
index 9f14633a2c..2542c1deb7 100644
--- a/dlls/ntdll/printf.c
+++ b/dlls/ntdll/printf.c
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <ctype.h>
 #include <stdarg.h>
@@ -35,28 +38,581 @@ WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
 static const SIZE_T size_max = ~(SIZE_T)0 >> 1;
 
+/* FIXME: convert sizes to SIZE_T etc. */
+
+typedef struct pf_output_t
+{
+    SIZE_T used;
+    SIZE_T len;
+    BOOL unicode;
+    union {
+        LPWSTR W;
+        LPSTR  A;
+    } buf;
+} pf_output;
+
 typedef struct pf_flags_t
 {
-    enum { LEN_DEFAULT, LEN_SHORT, LEN_LONG } IntegerLength;
-    BOOLEAN IntegerDouble, IntegerNative, LeftAlign, Alternate, PadZero, WideString;
+    char Sign, LeftAlign, Alternate, PadZero;
     int FieldLength, Precision;
-    char Sign, Format;
+    char IntegerLength, IntegerDouble, IntegerNative;
+    char WideString;
+    char Format;
 } pf_flags;
 
+/*
+ * writes a string of characters to the output
+ * returns -1 if the string doesn't fit in the output buffer
+ * return the length of the string if all characters were written
+ */
+static inline int pf_output_stringW( pf_output *out, LPCWSTR str, int len )
+{
+    SIZE_T space = out->len - out->used;
+
+    if( len < 0 )
+        len = wcslen( str );
+    if( out->unicode )
+    {
+        LPWSTR p = out->buf.W + out->used;
+
+        if (!out->buf.W)
+        {
+            out->used += len;
+            return len;
+        }
+        if( space >= len )
+        {
+            memcpy( p, str, len*sizeof(WCHAR) );
+            out->used += len;
+            return len;
+        }
+        if( space > 0 )
+        {
+            memcpy( p, str, space*sizeof(WCHAR) );
+            out->used += space;
+        }
+    }
+    else
+    {
+        LPSTR p = out->buf.A + out->used;
+        ULONG n;
+
+        RtlUnicodeToMultiByteSize( &n, str, len * sizeof(WCHAR) );
+
+        if (!out->buf.A)
+        {
+            out->used += n;
+            return len;
+        }
+        if( space >= n )
+        {
+            RtlUnicodeToMultiByteN( p, n, NULL, str, len * sizeof(WCHAR) );
+            out->used += n;
+            return len;
+        }
+        if (space > 0)
+        {
+            RtlUnicodeToMultiByteN( p, space, NULL, str, len * sizeof(WCHAR) );
+            out->used += space;
+        }
+    }
+    return -1;
+}
+
+static inline int pf_output_stringA( pf_output *out, LPCSTR str, int len )
+{
+    SIZE_T space = out->len - out->used;
+
+    if( len < 0 )
+        len = strlen( str );
+    if( !out->unicode )
+    {
+        LPSTR p = out->buf.A + out->used;
+
+        if (!out->buf.A)
+        {
+            out->used += len;
+            return len;
+        }
+        if( space >= len )
+        {
+            memcpy( p, str, len );
+            out->used += len;
+            return len;
+        }
+        if( space > 0 )
+        {
+            memcpy( p, str, space );
+            out->used += space;
+        }
+    }
+    else
+    {
+        LPWSTR p = out->buf.W + out->used;
+        ULONG n;
+
+        RtlMultiByteToUnicodeSize( &n, str, len );
+
+        if (!out->buf.W)
+        {
+            out->used += n / sizeof(WCHAR);
+            return len;
+        }
+        if (space >= n / sizeof(WCHAR))
+        {
+            RtlMultiByteToUnicodeN( p, n, NULL, str, len );
+            out->used += n / sizeof(WCHAR);
+            return len;
+        }
+        if (space > 0)
+        {
+            RtlMultiByteToUnicodeN( p, space * sizeof(WCHAR), NULL, str, len );
+            out->used += space;
+        }
+    }
+    return -1;
+}
+
+/* pf_fill: takes care of signs, alignment, zero and field padding */
+static inline int pf_fill( pf_output *out, int len, pf_flags *flags, char left )
+{
+    int i, r = 0;
+
+    if( flags->Sign && !( flags->Format == 'd' || flags->Format == 'i' ) )
+        flags->Sign = 0;
+
+    if( left && flags->Sign )
+    {
+        flags->FieldLength--;
+        if( flags->PadZero )
+            r = pf_output_stringA( out, &flags->Sign, 1 );
+    }
+
+    if( ( !left &&  flags->LeftAlign ) ||
+        (  left && !flags->LeftAlign ))
+    {
+        for( i=0; (i<(flags->FieldLength-len)) && (r>=0); i++ )
+        {
+            if( left && flags->PadZero )
+                r = pf_output_stringA( out, "0", 1 );
+            else
+                r = pf_output_stringA( out, " ", 1 );
+        }
+    }
+
+    if (left && flags->Sign && !flags->PadZero && r >= 0)
+        r = pf_output_stringA( out, &flags->Sign, 1 );
+
+    return r;
+}
+
+static inline int pf_output_format_W( pf_output *out, LPCWSTR str,
+                                      int len, pf_flags *flags )
+{
+    int r = 0;
+
+    if (len < 0)
+    {
+        /* Do not search past the length specified by the precision. */
+        if (flags->Precision >= 0)
+        {
+            for (len = 0; len < flags->Precision; len++) if (!str[len]) break;
+        }
+        else len = wcslen( str );
+    }
+
+    if (flags->Precision >= 0 && flags->Precision < len)
+        len = flags->Precision;
+
+    r = pf_fill( out, len, flags, 1 );
+
+    if( r>=0 )
+        r = pf_output_stringW( out, str, len );
+
+    if( r>=0 )
+        r = pf_fill( out, len, flags, 0 );
+
+    return r;
+}
+
+static inline int pf_output_format_A( pf_output *out, LPCSTR str,
+                                      int len, pf_flags *flags )
+{
+    int r = 0;
 
-#include "printf.h"
-#define PRINTF_WIDE
-#include "printf.h"
-#undef PRINTF_WIDE
+    if (len < 0)
+    {
+        /* Do not search past the length specified by the precision. */
+        if (flags->Precision >= 0)
+        {
+            for (len = 0; len < flags->Precision; len++) if (!str[len]) break;
+        }
+        else len = strlen( str );
+    }
+
+    if (flags->Precision >= 0 && flags->Precision < len)
+        len = flags->Precision;
+
+    r = pf_fill( out, len, flags, 1 );
+
+    if( r>=0 )
+        r = pf_output_stringA( out, str, len );
+
+    if( r>=0 )
+        r = pf_fill( out, len, flags, 0 );
+
+    return r;
+}
+
+static int pf_handle_string_format( pf_output *out, const void* str, int len,
+                             pf_flags *flags, BOOL capital_letter)
+{
+     if(str == NULL)  /* catch NULL pointer */
+        return pf_output_format_A( out, "(null)", -1, flags);
+
+     /* prefixes take priority over %c,%s vs. %C,%S, so we handle them first */
+    if(flags->WideString || flags->IntegerLength == 'l')
+        return pf_output_format_W( out, str, len, flags);
+    if(flags->IntegerLength == 'h')
+        return pf_output_format_A( out, str, len, flags);
+
+    /* %s,%c ->  chars in ansi functions & wchars in unicode
+     * %S,%C -> wchars in ansi functions &  chars in unicode */
+    if( capital_letter == out->unicode) /* either both TRUE or both FALSE */
+        return pf_output_format_A( out, str, len, flags);
+    else
+        return pf_output_format_W( out, str, len, flags);
+}
+
+/* pf_integer_conv:  prints x to buf, including alternate formats and
+   additional precision digits, but not field characters or the sign */
+static void pf_integer_conv( char *buf, pf_flags *flags, LONGLONG x )
+{
+    unsigned int base;
+    const char *digits;
+    int i, j, k;
+
+    if( flags->Format == 'o' )
+        base = 8;
+    else if( flags->Format == 'x' || flags->Format == 'X' )
+        base = 16;
+    else
+        base = 10;
+
+    if( flags->Format == 'X' )
+        digits = "0123456789ABCDEFX";
+    else
+        digits = "0123456789abcdefx";
+
+    if( x < 0 && ( flags->Format == 'd' || flags->Format == 'i' ) )
+    {
+        x = -x;
+        flags->Sign = '-';
+    }
+
+    i = 0;
+    if( x == 0 )
+    {
+        flags->Alternate = 0;
+        if( flags->Precision )
+            buf[i++] = '0';
+    }
+    else
+        while( x != 0 )
+        {
+            j = (ULONGLONG) x % base;
+            x = (ULONGLONG) x / base;
+            buf[i++] = digits[j];
+        }
+    k = flags->Precision - i;
+    while( k-- > 0 )
+        buf[i++] = '0';
+    if( flags->Alternate )
+    {
+        if( base == 16 )
+        {
+            buf[i++] = digits[16];
+            buf[i++] = '0';
+        }
+        else if( base == 8 && buf[i-1] != '0' )
+            buf[i++] = '0';
+    }
+
+    /* Adjust precision so pf_fill won't truncate the number later */
+    flags->Precision = i;
+
+    buf[i] = '\0';
+    j = 0;
+    while(--i > j) {
+        char tmp = buf[j];
+        buf[j] = buf[i];
+        buf[i] = tmp;
+        j++;
+    }
+}
+
+static inline BOOL isDigit(WCHAR c)
+{
+    return c >= '0' && c <= '9';
+}
 
 /*********************************************************************
- *                  _vsnprintf   (NTDLL.@)
+ *  pf_vsnprintf  (INTERNAL)
+ *
+ *  implements both A and W vsnprintf functions
  */
-int CDECL _vsnprintf( char *str, size_t len, const char *format, __ms_va_list args )
+static int pf_vsnprintf( pf_output *out, const WCHAR *format, __ms_va_list valist )
 {
-    pf_output_a out = { str, len };
-    int r = pf_vsnprintf_a( &out, format, args );
+    int r;
+    LPCWSTR q, p = format;
+    pf_flags flags;
+
+    while (*p)
+    {
+        q = wcschr( p, '%' );
+
+        /* there are no % characters left: output the rest of the string */
+        if( !q )
+        {
+            r = pf_output_stringW(out, p, -1);
+            if( r<0 )
+                return r;
+            p += r;
+            continue;
+        }
+
+        /* there are characters before the %: output them */
+        if( q != p )
+        {
+            r = pf_output_stringW(out, p, q - p);
+            if( r<0 )
+                return r;
+            p = q;
+        }
+
+        /* we must be at a % now, skip over it */
+        assert( *p == '%' );
+        p++;
+
+        /* output a single % character */
+        if( *p == '%' )
+        {
+            r = pf_output_stringW(out, p++, 1);
+            if( r<0 )
+                return r;
+            continue;
+        }
+
+        /* parse the flags */
+        memset( &flags, 0, sizeof flags );
+        while (*p)
+        {
+            if( *p == '+' || *p == ' ' )
+            {
+                if ( flags.Sign != '+' )
+                    flags.Sign = *p;
+            }
+            else if( *p == '-' )
+                flags.LeftAlign = *p;
+            else if( *p == '0' )
+                flags.PadZero = *p;
+            else if( *p == '#' )
+                flags.Alternate = *p;
+            else
+                break;
+            p++;
+        }
+
+        /* deal with the field width specifier */
+        flags.FieldLength = 0;
+        if( *p == '*' )
+        {
+            flags.FieldLength = va_arg( valist, int );
+            if (flags.FieldLength < 0)
+            {
+                flags.LeftAlign = '-';
+                flags.FieldLength = -flags.FieldLength;
+            }
+            p++;
+        }
+        else while( isDigit(*p) )
+        {
+            flags.FieldLength *= 10;
+            flags.FieldLength += *p++ - '0';
+        }
+
+        /* deal with precision */
+        flags.Precision = -1;
+        if( *p == '.' )
+        {
+            flags.Precision = 0;
+            p++;
+            if( *p == '*' )
+            {
+                flags.Precision = va_arg( valist, int );
+                p++;
+            }
+            else while( isDigit(*p) )
+            {
+                flags.Precision *= 10;
+                flags.Precision += *p++ - '0';
+            }
+        }
+
+        /* deal with integer width modifier */
+        while( *p )
+        {
+            if (*p == 'l' && *(p+1) == 'l')
+            {
+                flags.IntegerDouble++;
+                p += 2;
+            }
+            else if( *p == 'h' || *p == 'l' || *p == 'L' )
+            {
+                flags.IntegerLength = *p;
+                p++;
+            }
+            else if( *p == 'I' )
+            {
+                if( *(p+1) == '6' && *(p+2) == '4' )
+                {
+                    flags.IntegerDouble++;
+                    p += 3;
+                }
+                else if( *(p+1) == '3' && *(p+2) == '2' )
+                    p += 3;
+                else if( p[1] && strchr( "diouxX", p[1] ) )
+                {
+                    if( sizeof(void *) == 8 )
+                        flags.IntegerDouble = *p;
+                    p++;
+                }
+                else if( isDigit(*(p+1)) || *(p+1) == 0 )
+                    break;
+                else
+                    p++;
+            }
+            else if( *p == 'w' )
+                flags.WideString = *p++;
+            else if ((*p == 'z' || *p == 't') && p[1] && strchr("diouxX", p[1]))
+                flags.IntegerNative = *p++;
+            else if (*p == 'j')
+            {
+                flags.IntegerDouble++;
+                p++;
+            }
+            else if( *p == 'F' )
+                p++; /* ignore */
+            else
+                break;
+        }
+
+        flags.Format = *p;
+        r = 0;
+
+        if (flags.Format == '$')
+        {
+            FIXME("Positional parameters are not supported (%s)\n", wine_dbgstr_w(format));
+            return -1;
+        }
+        /* output a string */
+        if(  flags.Format == 's' || flags.Format == 'S' )
+            r = pf_handle_string_format( out, va_arg(valist, const void*), -1,
+                                         &flags, (flags.Format == 'S') );
+
+        /* output a single character */
+        else if( flags.Format == 'c' || flags.Format == 'C' )
+        {
+            INT ch = va_arg( valist, int );
+
+            r = pf_handle_string_format( out, &ch, 1, &flags, (flags.Format == 'C') );
+        }
+
+        /* output a pointer */
+        else if( flags.Format == 'p' )
+        {
+            char pointer[32];
+            void *ptr = va_arg( valist, void * );
+            int prec = flags.Precision;
+            flags.Format = 'X';
+            flags.PadZero = '0';
+            flags.Precision = 2*sizeof(void*);
+            pf_integer_conv( pointer, &flags, (ULONG_PTR)ptr );
+            flags.PadZero = 0;
+            flags.Precision = prec;
+            r = pf_output_format_A( out, pointer, -1, &flags );
+        }
+
+        /* deal with %n */
+        else if( flags.Format == 'n' )
+        {
+            int *x = va_arg(valist, int *);
+            *x = out->used;
+        }
+        else if( flags.Format && strchr("diouxX", flags.Format ))
+        {
+            char number[40], *x = number;
+            int max_len;
+
+            /* 0 padding is added after '0x' if Alternate flag is in use */
+            if((flags.Format=='x' || flags.Format=='X') && flags.PadZero && flags.Alternate
+                    && !flags.LeftAlign && flags.Precision<flags.FieldLength-2)
+                flags.Precision = flags.FieldLength - 2;
+
+            max_len = (flags.FieldLength>flags.Precision ? flags.FieldLength : flags.Precision) + 10;
+            if(max_len > ARRAY_SIZE(number))
+                if (!(x = RtlAllocateHeap( GetProcessHeap(), 0, max_len ))) return -1;
+
+            if(flags.IntegerDouble || (flags.IntegerNative && sizeof(void*) == 8))
+                pf_integer_conv( x, &flags, va_arg(valist, LONGLONG) );
+            else if(flags.Format=='d' || flags.Format=='i')
+                pf_integer_conv( x, &flags, flags.IntegerLength!='h' ?
+                                 va_arg(valist, int) : (short)va_arg(valist, int) );
+            else
+                pf_integer_conv( x, &flags, flags.IntegerLength!='h' ?
+                                 (unsigned int)va_arg(valist, int) : (unsigned short)va_arg(valist, int) );
+
+            r = pf_output_format_A( out, x, -1, &flags );
+            if( x != number )
+                RtlFreeHeap( GetProcessHeap(), 0, x );
+        }
+        else
+            continue;
+
+        if( r<0 )
+            return r;
+        p++;
+    }
+
+    /* check we reached the end, and null terminate the string */
+    assert( *p == 0 );
+    return out->used;
+}
+
 
+/*********************************************************************
+ *                  _vsnprintf   (NTDLL.@)
+ */
+int CDECL NTDLL__vsnprintf( char *str, SIZE_T len, const char *format, __ms_va_list args )
+{
+    DWORD sz;
+    LPWSTR formatW = NULL;
+    pf_output out;
+    int r;
+
+    out.unicode = FALSE;
+    out.buf.A = str;
+    out.used = 0;
+    out.len = len;
+
+    if (format)
+    {
+        RtlMultiByteToUnicodeSize( &sz, format, strlen(format) + 1 );
+        if (!(formatW = RtlAllocateHeap( GetProcessHeap(), 0, sz ))) return -1;
+        RtlMultiByteToUnicodeN( formatW, sz, NULL, format, strlen(format) + 1 );
+    }
+    r = pf_vsnprintf( &out, formatW, args );
+    RtlFreeHeap( GetProcessHeap(), 0, formatW );
     if (out.used < len) str[out.used] = 0;
     return r;
 }
@@ -65,11 +621,17 @@ int CDECL _vsnprintf( char *str, size_t len, const char *format, __ms_va_list ar
 /***********************************************************************
  *                  _vsnwprintf   (NTDLL.@)
  */
-int CDECL _vsnwprintf( WCHAR *str, size_t len, const WCHAR *format, __ms_va_list args )
+int CDECL NTDLL__vsnwprintf( WCHAR *str, SIZE_T len, const WCHAR *format, __ms_va_list args )
 {
-    pf_output_w out = { str, len };
-    int r = pf_vsnprintf_w( &out, format, args );
+    pf_output out;
+    int r;
 
+    out.unicode = TRUE;
+    out.buf.W = str;
+    out.used = 0;
+    out.len = len;
+
+    r = pf_vsnprintf( &out, format, args );
     if (out.used < len) str[out.used] = 0;
     return r;
 }
@@ -78,13 +640,13 @@ int CDECL _vsnwprintf( WCHAR *str, size_t len, const WCHAR *format, __ms_va_list
 /*********************************************************************
  *                  _snprintf   (NTDLL.@)
  */
-int WINAPIV NTDLL__snprintf( char *str, size_t len, const char *format, ... )
+int WINAPIV NTDLL__snprintf( char *str, SIZE_T len, const char *format, ... )
 {
     int ret;
     __ms_va_list valist;
 
     __ms_va_start( valist, format );
-    ret = _vsnprintf( str, len, format, valist );
+    ret = NTDLL__vsnprintf( str, len, format, valist );
     __ms_va_end( valist );
     return ret;
 }
@@ -93,13 +655,13 @@ int WINAPIV NTDLL__snprintf( char *str, size_t len, const char *format, ... )
 /***********************************************************************
  *                  _snwprintf   (NTDLL.@)
  */
-int WINAPIV _snwprintf( WCHAR *str, size_t len, const WCHAR *format, ... )
+int WINAPIV NTDLL__snwprintf( WCHAR *str, SIZE_T len, const WCHAR *format, ... )
 {
     int ret;
     __ms_va_list valist;
 
     __ms_va_start(valist, format);
-    ret = _vsnwprintf( str, len, format, valist );
+    ret = NTDLL__vsnwprintf( str, len, format, valist );
     __ms_va_end(valist);
     return ret;
 }
@@ -108,11 +670,26 @@ int WINAPIV _snwprintf( WCHAR *str, size_t len, const WCHAR *format, ... )
 /*********************************************************************
  *                  _vsnprintf_s   (NTDLL.@)
  */
-int CDECL _vsnprintf_s( char *str, size_t size, size_t len, const char *format, __ms_va_list args )
+int CDECL _vsnprintf_s( char *str, SIZE_T size, SIZE_T len, const char *format, __ms_va_list args )
 {
-    pf_output_a out = { str, min( size, len ) };
-    int r = pf_vsnprintf_a( &out, format, args );
-
+    DWORD sz;
+    LPWSTR formatW = NULL;
+    pf_output out;
+    int r;
+
+    out.unicode = FALSE;
+    out.buf.A = str;
+    out.used = 0;
+    out.len = min( size, len );
+
+    if (format)
+    {
+        RtlMultiByteToUnicodeSize( &sz, format, strlen(format) + 1 );
+        if (!(formatW = RtlAllocateHeap( GetProcessHeap(), 0, sz ))) return -1;
+        RtlMultiByteToUnicodeN( formatW, sz, NULL, format, strlen(format) + 1 );
+    }
+    r = pf_vsnprintf( &out, formatW, args );
+    RtlFreeHeap( GetProcessHeap(), 0, formatW );
     if (out.used < size) str[out.used] = 0;
     else str[0] = 0;
     if (r == size) r = -1;
@@ -123,11 +700,17 @@ int CDECL _vsnprintf_s( char *str, size_t size, size_t len, const char *format,
 /***********************************************************************
  *                  _vsnwprintf_s   (NTDLL.@)
  */
-int CDECL _vsnwprintf_s( WCHAR *str, size_t size, size_t len, const WCHAR *format, __ms_va_list args )
+int CDECL _vsnwprintf_s( WCHAR *str, SIZE_T size, SIZE_T len, const WCHAR *format, __ms_va_list args )
 {
-    pf_output_w out = { str, min( size, len ) };
-    int r = pf_vsnprintf_w( &out, format, args );
+    pf_output out;
+    int r;
+
+    out.unicode = TRUE;
+    out.buf.W = str;
+    out.used = 0;
+    out.len = min( size, len );
 
+    r = pf_vsnprintf( &out, format, args );
     if (out.used < size) str[out.used] = 0;
     else str[0] = 0;
     if (r == size) r = -1;
@@ -138,7 +721,7 @@ int CDECL _vsnwprintf_s( WCHAR *str, size_t size, size_t len, const WCHAR *forma
 /*********************************************************************
  *                  _snprintf_s   (NTDLL.@)
  */
-int WINAPIV _snprintf_s( char *str, size_t size, size_t len, const char *format, ... )
+int WINAPIV _snprintf_s( char *str, SIZE_T size, SIZE_T len, const char *format, ... )
 {
     int ret;
     __ms_va_list valist;
@@ -153,7 +736,7 @@ int WINAPIV _snprintf_s( char *str, size_t size, size_t len, const char *format,
 /*********************************************************************
  *                  _snwprintf_s   (NTDLL.@)
  */
-int WINAPIV _snwprintf_s( WCHAR *str, size_t size, size_t len, const WCHAR *format, ... )
+int WINAPIV _snwprintf_s( WCHAR *str, SIZE_T size, SIZE_T len, const WCHAR *format, ... )
 {
     int ret;
     __ms_va_list valist;
@@ -168,16 +751,16 @@ int WINAPIV _snwprintf_s( WCHAR *str, size_t size, size_t len, const WCHAR *form
 /*********************************************************************
  *                  vsprintf   (NTDLL.@)
  */
-int CDECL vsprintf( char *str, const char *format, __ms_va_list args )
+int CDECL NTDLL_vsprintf( char *str, const char *format, __ms_va_list args )
 {
-    return _vsnprintf( str, size_max, format, args );
+    return NTDLL__vsnprintf( str, size_max, format, args );
 }
 
 
 /*********************************************************************
  *                  vsprintf_s   (NTDLL.@)
  */
-int CDECL vsprintf_s( char *str, size_t size, const char *format, __ms_va_list args )
+int CDECL vsprintf_s( char *str, SIZE_T size, const char *format, __ms_va_list args )
 {
     return _vsnprintf_s( str, size, size, format, args );
 }
@@ -186,16 +769,16 @@ int CDECL vsprintf_s( char *str, size_t size, const char *format, __ms_va_list a
 /*********************************************************************
  *                  _vswprintf   (NTDLL.@)
  */
-int CDECL _vswprintf( WCHAR *str, const WCHAR *format, __ms_va_list args )
+int CDECL NTDLL__vswprintf( WCHAR *str, const WCHAR *format, __ms_va_list args )
 {
-    return _vsnwprintf( str, size_max, format, args );
+    return NTDLL__vsnwprintf( str, size_max, format, args );
 }
 
 
 /*********************************************************************
  *                  vswprintf_s   (NTDLL.@)
  */
-int CDECL vswprintf_s( WCHAR *str, size_t size, const WCHAR *format, __ms_va_list args )
+int CDECL vswprintf_s( WCHAR *str, SIZE_T size, const WCHAR *format, __ms_va_list args )
 {
     return _vsnwprintf_s( str, size, size, format, args );
 }
@@ -210,7 +793,7 @@ int WINAPIV NTDLL_sprintf( char *str, const char *format, ... )
     __ms_va_list valist;
 
     __ms_va_start( valist, format );
-    ret = _vsnprintf( str, size_max, format, valist );
+    ret = NTDLL__vsnprintf( str, size_max, format, valist );
     __ms_va_end( valist );
     return ret;
 }
@@ -219,7 +802,7 @@ int WINAPIV NTDLL_sprintf( char *str, const char *format, ... )
 /*********************************************************************
  *                  sprintf_s   (NTDLL.@)
  */
-int WINAPIV sprintf_s( char *str, size_t size, const char *format, ... )
+int WINAPIV sprintf_s( char *str, SIZE_T size, const char *format, ... )
 {
     int ret;
     __ms_va_list valist;
@@ -240,7 +823,7 @@ int WINAPIV NTDLL_swprintf( WCHAR *str, const WCHAR *format, ... )
     __ms_va_list valist;
 
     __ms_va_start(valist, format);
-    ret = _vsnwprintf( str, size_max, format, valist );
+    ret = NTDLL__vsnwprintf( str, size_max, format, valist );
     __ms_va_end(valist);
     return ret;
 }
@@ -249,7 +832,7 @@ int WINAPIV NTDLL_swprintf( WCHAR *str, const WCHAR *format, ... )
 /***********************************************************************
  *                  swprintf_s   (NTDLL.@)
  */
-int WINAPIV swprintf_s( WCHAR *str, size_t size, const WCHAR *format, ... )
+int WINAPIV swprintf_s( WCHAR *str, SIZE_T size, const WCHAR *format, ... )
 {
     int ret;
     __ms_va_list valist;
diff --git a/dlls/ntdll/printf.h b/dlls/ntdll/printf.h
deleted file mode 100644
index 9f7bad767f..0000000000
--- a/dlls/ntdll/printf.h
+++ /dev/null
@@ -1,513 +0,0 @@
-/*
- * ntdll printf functions
- *
- * Copyright 1999, 2009 Alexandre Julliard
- * Copyright 2000 Jon Griffiths
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#ifdef PRINTF_WIDE
-#define APICHAR wchar_t
-#define APISTR(str) L"" str
-#define FUNC_NAME(func) func ## _w
-#else
-#define APICHAR char
-#define APISTR(str) str
-#define FUNC_NAME(func) func ## _a
-#endif
-
-typedef struct
-{
-    APICHAR *buf;
-    SIZE_T   len;
-    SIZE_T   used;
-} FUNC_NAME(pf_output);
-
-/*
- * writes a string of characters to the output
- * returns -1 if the string doesn't fit in the output buffer
- * return the length of the string if all characters were written
- */
-static int FUNC_NAME(pf_output_wstr)( FUNC_NAME(pf_output) *out, const WCHAR *str, int len )
-{
-    SIZE_T space = out->len - out->used;
-    APICHAR *p = out->buf + out->used;
-    ULONG n;
-
-    if (len < 0) len = wcslen( str );
-
-#ifdef PRINTF_WIDE
-    n = len;
-    if (out->buf) memcpy( p, str, min( n, space ) * sizeof(WCHAR) );
-#else
-    RtlUnicodeToMultiByteSize( &n, str, len * sizeof(WCHAR) );
-    if (out->buf) RtlUnicodeToMultiByteN( p, min( n, space ), NULL, str, len * sizeof(WCHAR) );
-#endif
-    if (out->buf && space < n)  /* overflow */
-    {
-        out->used = out->len;
-        return -1;
-    }
-    out->used += n;
-    return len;
-}
-
-static int FUNC_NAME(pf_output_str)( FUNC_NAME(pf_output) *out, const char *str, int len )
-{
-    SIZE_T space = out->len - out->used;
-    APICHAR *p = out->buf + out->used;
-    ULONG n;
-
-    if (len < 0) len = strlen( str );
-
-#ifdef PRINTF_WIDE
-    RtlMultiByteToUnicodeSize( &n, str, len );
-    n /= sizeof(WCHAR);
-    if (out->buf) RtlMultiByteToUnicodeN( p, min( n, space ) * sizeof(WCHAR), NULL, str, len );
-#else
-    n = len;
-    if (out->buf) memcpy( p, str, min( n, space ));
-#endif
-    if (out->buf && space < n)  /* overflow */
-    {
-        out->used = out->len;
-        return -1;
-    }
-    out->used += n;
-    return len;
-}
-
-static int FUNC_NAME(pf_output_string)( FUNC_NAME(pf_output) *out, const APICHAR *str, int len )
-{
-#ifdef PRINTF_WIDE
-    return FUNC_NAME(pf_output_wstr)( out, str, len );
-#else
-    return FUNC_NAME(pf_output_str)( out, str, len );
-#endif
-}
-
-/* pf_fill: takes care of signs, alignment, zero and field padding */
-static int FUNC_NAME(pf_fill_left)( FUNC_NAME(pf_output) *out, int len, pf_flags *flags )
-{
-    int i, r = 0;
-
-    if (flags->Sign && !(flags->Format == 'd' || flags->Format == 'i')) flags->Sign = 0;
-
-    if (flags->Sign)
-    {
-        APICHAR ch = flags->Sign;
-        flags->FieldLength--;
-        if (flags->PadZero) r = FUNC_NAME(pf_output_string)( out, &ch, 1 );
-    }
-    if (!flags->LeftAlign)
-    {
-        APICHAR ch = flags->PadZero ? '0' : ' ';
-        for (i = 0; i < flags->FieldLength - len && r >= 0; i++)
-            r = FUNC_NAME(pf_output_string)( out, &ch, 1 );
-    }
-    if (flags->Sign && !flags->PadZero && r >= 0)
-    {
-        APICHAR ch = flags->Sign;
-        r = FUNC_NAME(pf_output_string)( out, &ch, 1 );
-    }
-    return r;
-}
-
-static int FUNC_NAME(pf_fill_right)( FUNC_NAME(pf_output) *out, int len, pf_flags *flags )
-{
-    int i, r = 0;
-    APICHAR ch = ' ';
-
-    if (!flags->LeftAlign) return 0;
-
-    for (i = 0; i < flags->FieldLength - len && r >= 0; i++)
-        r = FUNC_NAME(pf_output_string)( out, &ch, 1 );
-    return r;
-}
-
-static int FUNC_NAME(pf_output_format_wstr)( FUNC_NAME(pf_output) *out, const wchar_t *str, int len,
-                                             pf_flags *flags )
-{
-    int r = 0;
-
-    if (len < 0)
-    {
-        /* Do not search past the length specified by the precision. */
-        if (flags->Precision >= 0)
-        {
-            for (len = 0; len < flags->Precision; len++) if (!str[len]) break;
-        }
-        else len = wcslen( str );
-    }
-
-    if (flags->Precision >= 0 && flags->Precision < len) len = flags->Precision;
-
-    r = FUNC_NAME(pf_fill_left)( out, len, flags );
-    if (r >= 0) r = FUNC_NAME(pf_output_wstr)( out, str, len );
-    if (r >= 0) r = FUNC_NAME(pf_fill_right)( out, len, flags );
-    return r;
-}
-
-static int FUNC_NAME(pf_output_format_str)( FUNC_NAME(pf_output) *out, const char *str, int len,
-                                            pf_flags *flags )
-{
-    int r = 0;
-
-    if (len < 0)
-    {
-        /* Do not search past the length specified by the precision. */
-        if (flags->Precision >= 0)
-        {
-            for (len = 0; len < flags->Precision; len++) if (!str[len]) break;
-        }
-        else len = strlen(str);
-    }
-
-    if (flags->Precision >= 0 && flags->Precision < len) len = flags->Precision;
-
-    r = FUNC_NAME(pf_fill_left)( out, len, flags );
-    if (r >= 0) r = FUNC_NAME(pf_output_str)( out, str, len );
-    if (r >= 0) r = FUNC_NAME(pf_fill_right)( out, len, flags );
-    return r;
-}
-
-static int FUNC_NAME(pf_output_format)( FUNC_NAME(pf_output) *out, const APICHAR *str, int len,
-                                        pf_flags *flags )
-{
-#ifdef PRINTF_WIDE
-    return FUNC_NAME(pf_output_format_wstr)( out, str, len, flags );
-#else
-    return FUNC_NAME(pf_output_format_str)( out, str, len, flags );
-#endif
-}
-
-static int FUNC_NAME(pf_handle_string_format)( FUNC_NAME(pf_output) *out, const void* str, int len,
-                                               pf_flags *flags, BOOL inverted )
-{
-     if (str == NULL)  /* catch NULL pointer */
-         return FUNC_NAME(pf_output_format)( out, APISTR("(null)"), -1, flags );
-
-     /* prefixes take priority over %c,%s vs. %C,%S, so we handle them first */
-    if (flags->WideString || flags->IntegerLength == LEN_LONG)
-        return FUNC_NAME(pf_output_format_wstr)( out, str, len, flags );
-    if (flags->IntegerLength == LEN_SHORT)
-        return FUNC_NAME(pf_output_format_str)( out, str, len, flags );
-
-    /* %s,%c ->  chars in ansi functions & wchars in unicode
-     * %S,%C -> wchars in ansi functions &  chars in unicode */
-    if (!inverted) return FUNC_NAME(pf_output_format)( out, str, len, flags);
-#ifdef PRINTF_WIDE
-    return FUNC_NAME(pf_output_format_str)( out, str, len, flags );
-#else
-    return FUNC_NAME(pf_output_format_wstr)( out, str, len, flags );
-#endif
-}
-
-/* pf_integer_conv:  prints x to buf, including alternate formats and
-   additional precision digits, but not field characters or the sign */
-static void FUNC_NAME(pf_integer_conv)( APICHAR *buf, pf_flags *flags, LONGLONG x )
-{
-    unsigned int base;
-    const APICHAR *digits;
-    int i, j, k;
-
-    if( flags->Format == 'o' )
-        base = 8;
-    else if( flags->Format == 'x' || flags->Format == 'X' )
-        base = 16;
-    else
-        base = 10;
-
-    if( flags->Format == 'X' )
-        digits = APISTR("0123456789ABCDEFX");
-    else
-        digits = APISTR("0123456789abcdefx");
-
-    if( x < 0 && ( flags->Format == 'd' || flags->Format == 'i' ) )
-    {
-        x = -x;
-        flags->Sign = '-';
-    }
-
-    i = 0;
-    if( x == 0 )
-    {
-        flags->Alternate = FALSE;
-        if( flags->Precision )
-            buf[i++] = '0';
-    }
-    else
-        while( x != 0 )
-        {
-            j = (ULONGLONG) x % base;
-            x = (ULONGLONG) x / base;
-            buf[i++] = digits[j];
-        }
-    k = flags->Precision - i;
-    while( k-- > 0 )
-        buf[i++] = '0';
-    if( flags->Alternate )
-    {
-        if( base == 16 )
-        {
-            buf[i++] = digits[16];
-            buf[i++] = '0';
-        }
-        else if( base == 8 && buf[i-1] != '0' )
-            buf[i++] = '0';
-    }
-
-    /* Adjust precision so pf_fill won't truncate the number later */
-    flags->Precision = i;
-
-    buf[i] = '\0';
-    j = 0;
-    while(--i > j) {
-        APICHAR tmp = buf[j];
-        buf[j] = buf[i];
-        buf[i] = tmp;
-        j++;
-    }
-}
-
-static int FUNC_NAME(pf_vsnprintf)( FUNC_NAME(pf_output) *out, const APICHAR *format, __ms_va_list valist )
-{
-    int r;
-    const APICHAR *q, *p = format;
-    pf_flags flags;
-
-    while (*p)
-    {
-        for (q = p; *q; q++) if (*q == '%') break;
-
-        if (q != p)
-        {
-            r = FUNC_NAME(pf_output_string)(out, p, q - p);
-            if (r < 0) return r;
-            p = q;
-            if (!*p) break;
-        }
-        p++;
-
-        /* output a single % character */
-        if( *p == '%' )
-        {
-            r = FUNC_NAME(pf_output_string)(out, p++, 1);
-            if( r<0 )
-                return r;
-            continue;
-        }
-
-        /* parse the flags */
-        memset( &flags, 0, sizeof flags );
-        while (*p)
-        {
-            if( *p == '+' || *p == ' ' )
-            {
-                if ( flags.Sign != '+' )
-                    flags.Sign = *p;
-            }
-            else if( *p == '-' )
-                flags.LeftAlign = TRUE;
-            else if( *p == '0' )
-                flags.PadZero = TRUE;
-            else if( *p == '#' )
-                flags.Alternate = TRUE;
-            else
-                break;
-            p++;
-        }
-
-        /* deal with the field width specifier */
-        flags.FieldLength = 0;
-        if( *p == '*' )
-        {
-            flags.FieldLength = va_arg( valist, int );
-            if (flags.FieldLength < 0)
-            {
-                flags.LeftAlign = TRUE;
-                flags.FieldLength = -flags.FieldLength;
-            }
-            p++;
-        }
-        else while (*p >= '0' && *p <= '9')
-        {
-            flags.FieldLength *= 10;
-            flags.FieldLength += *p++ - '0';
-        }
-
-        /* deal with precision */
-        flags.Precision = -1;
-        if( *p == '.' )
-        {
-            flags.Precision = 0;
-            p++;
-            if( *p == '*' )
-            {
-                flags.Precision = va_arg( valist, int );
-                p++;
-            }
-            else while (*p >= '0' && *p <= '9')
-            {
-                flags.Precision *= 10;
-                flags.Precision += *p++ - '0';
-            }
-        }
-
-        /* deal with integer width modifier */
-        while( *p )
-        {
-            if (*p == 'l' && *(p+1) == 'l')
-            {
-                flags.IntegerDouble = TRUE;
-                p += 2;
-            }
-            else if( *p == 'l' )
-            {
-                flags.IntegerLength = LEN_LONG;
-                p++;
-            }
-            else if( *p == 'L' )
-            {
-                p++;
-            }
-            else if( *p == 'h')
-            {
-                flags.IntegerLength = LEN_SHORT;
-                p++;
-            }
-            else if( *p == 'I' )
-            {
-                if( *(p+1) == '6' && *(p+2) == '4' )
-                {
-                    flags.IntegerDouble = TRUE;
-                    p += 3;
-                }
-                else if( *(p+1) == '3' && *(p+2) == '2' )
-                    p += 3;
-                else if( p[1] && strchr( "diouxX", p[1] ) )
-                {
-                    if( sizeof(void *) == 8 )
-                        flags.IntegerDouble = TRUE;
-                    p++;
-                }
-                else if ((p[1] >= '0' && p[1] <= '9') || !p[1])
-                    break;
-                else
-                    p++;
-            }
-            else if( *p == 'w' )
-            {
-                flags.WideString = TRUE;
-                p++;
-            }
-            else if ((*p == 'z' || *p == 't') && p[1] && strchr("diouxX", p[1]))
-            {
-                flags.IntegerNative = TRUE;
-                p++;
-            }
-            else if (*p == 'j')
-            {
-                flags.IntegerDouble = TRUE;
-                p++;
-            }
-            else if( *p == 'F' )
-                p++; /* ignore */
-            else
-                break;
-        }
-
-        flags.Format = *p;
-        r = 0;
-
-        if (flags.Format == '$')
-        {
-            FIXME("Positional parameters are not supported (%s)\n", FUNC_NAME(wine_dbgstr)(format));
-            return -1;
-        }
-        /* output a string */
-        if(  flags.Format == 's' || flags.Format == 'S' )
-            r = FUNC_NAME(pf_handle_string_format)( out, va_arg(valist, const void*), -1,
-                                                    &flags, (flags.Format == 'S') );
-
-        /* output a single character */
-        else if( flags.Format == 'c' || flags.Format == 'C' )
-        {
-            APICHAR ch = (APICHAR)va_arg( valist, int );
-            r = FUNC_NAME(pf_handle_string_format)( out, &ch, 1, &flags, (flags.Format == 'C') );
-        }
-
-        /* output a pointer */
-        else if( flags.Format == 'p' )
-        {
-            APICHAR pointer[32];
-            void *ptr = va_arg( valist, void * );
-            int prec = flags.Precision;
-            flags.Format = 'X';
-            flags.PadZero = TRUE;
-            flags.Precision = 2*sizeof(void*);
-            FUNC_NAME(pf_integer_conv)( pointer, &flags, (ULONG_PTR)ptr );
-            flags.PadZero = FALSE;
-            flags.Precision = prec;
-            r = FUNC_NAME(pf_output_format)( out, pointer, -1, &flags );
-        }
-
-        /* deal with %n */
-        else if( flags.Format == 'n' )
-        {
-            int *x = va_arg(valist, int *);
-            *x = out->used;
-        }
-        else if( flags.Format && strchr("diouxX", flags.Format ))
-        {
-            APICHAR number[40], *x = number;
-            int max_len;
-
-            /* 0 padding is added after '0x' if Alternate flag is in use */
-            if((flags.Format=='x' || flags.Format=='X') && flags.PadZero && flags.Alternate
-                    && !flags.LeftAlign && flags.Precision<flags.FieldLength-2)
-                flags.Precision = flags.FieldLength - 2;
-
-            max_len = (flags.FieldLength>flags.Precision ? flags.FieldLength : flags.Precision) + 10;
-            if(max_len > ARRAY_SIZE(number))
-                if (!(x = RtlAllocateHeap( GetProcessHeap(), 0, max_len * sizeof(*x) ))) return -1;
-
-            if(flags.IntegerDouble || (flags.IntegerNative && sizeof(void*) == 8))
-                FUNC_NAME(pf_integer_conv)( x, &flags, va_arg(valist, LONGLONG) );
-            else if(flags.Format=='d' || flags.Format=='i')
-                FUNC_NAME(pf_integer_conv)( x, &flags, flags.IntegerLength != LEN_SHORT ?
-                                            va_arg(valist, int) : (short)va_arg(valist, int) );
-            else
-                FUNC_NAME(pf_integer_conv)( x, &flags, flags.IntegerLength != LEN_SHORT ?
-                                 (unsigned int)va_arg(valist, int) : (unsigned short)va_arg(valist, int) );
-
-            r = FUNC_NAME(pf_output_format)( out, x, -1, &flags );
-            if( x != number )
-                RtlFreeHeap( GetProcessHeap(), 0, x );
-        }
-        else
-            continue;
-
-        if( r<0 )
-            return r;
-        p++;
-    }
-    return out->used;
-}
-
-#undef APICHAR
-#undef APISTR
-#undef FUNC_NAME
diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
index 77ba5b371e..1bef51b00b 100644
--- a/dlls/ntdll/process.c
+++ b/dlls/ntdll/process.c
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <errno.h>
 #include <fcntl.h>
 #include <stdarg.h>
@@ -26,7 +29,26 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+#ifdef HAVE_SYS_TIMES_H
+# include <sys/times.h>
+#endif
 #include <sys/types.h>
+#ifdef HAVE_SYS_WAIT_H
+# include <sys/wait.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef __APPLE__
+#include <CoreFoundation/CoreFoundation.h>
+#include <pthread.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -37,15 +59,46 @@
 #include "wine/exception.h"
 #include "wine/server.h"
 
+#ifdef HAVE_MACH_MACH_H
+#include <mach/mach.h>
+#endif
+
 WINE_DEFAULT_DEBUG_CHANNEL(process);
 
+static ULONG execute_flags = MEM_EXECUTE_OPTION_DISABLE | (sizeof(void *) > sizeof(int) ?
+                                                           MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION |
+                                                           MEM_EXECUTE_OPTION_PERMANENT : 0);
+
 static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
 
+static const char * const cpu_names[] = { "x86", "x86_64", "PowerPC", "ARM", "ARM64" };
+
 
 /*
  *	Process object
  */
 
+/******************************************************************************
+ *  NtTerminateProcess			[NTDLL.@]
+ *
+ *  Native applications must kill themselves when done
+ */
+NTSTATUS WINAPI NtTerminateProcess( HANDLE handle, LONG exit_code )
+{
+    NTSTATUS ret;
+    BOOL self;
+    SERVER_START_REQ( terminate_process )
+    {
+        req->handle    = wine_server_obj_handle( handle );
+        req->exit_code = exit_code;
+        ret = wine_server_call( req );
+        self = !ret && reply->self;
+    }
+    SERVER_END_REQ;
+    if (self && handle) _exit( get_unix_exit_code( exit_code ));
+    return ret;
+}
+
 /******************************************************************************
  *  RtlGetCurrentPeb  [NTDLL.@]
  *
@@ -72,6 +125,1374 @@ HANDLE CDECL __wine_make_process_system(void)
     return ret;
 }
 
+static UINT process_error_mode;
+
+#define UNIMPLEMENTED_INFO_CLASS(c) \
+    case c: \
+        FIXME("(process=%p) Unimplemented information class: " #c "\n", ProcessHandle); \
+        ret = STATUS_INVALID_INFO_CLASS; \
+        break
+
+ULONG_PTR get_system_affinity_mask(void)
+{
+    ULONG num_cpus = NtCurrentTeb()->Peb->NumberOfProcessors;
+    if (num_cpus >= sizeof(ULONG_PTR) * 8) return ~(ULONG_PTR)0;
+    return ((ULONG_PTR)1 << num_cpus) - 1;
+}
+
+#if defined(HAVE_MACH_MACH_H)
+
+static void fill_VM_COUNTERS(VM_COUNTERS* pvmi)
+{
+#if defined(MACH_TASK_BASIC_INFO)
+    struct mach_task_basic_info info;
+    mach_msg_type_number_t infoCount = MACH_TASK_BASIC_INFO_COUNT;
+    if(task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &infoCount) == KERN_SUCCESS)
+    {
+        pvmi->VirtualSize = info.resident_size + info.virtual_size;
+        pvmi->PagefileUsage = info.virtual_size;
+        pvmi->WorkingSetSize = info.resident_size;
+        pvmi->PeakWorkingSetSize = info.resident_size_max;
+    }
+#endif
+}
+
+#elif defined(linux)
+
+static void fill_VM_COUNTERS(VM_COUNTERS* pvmi)
+{
+    FILE *f;
+    char line[256];
+    unsigned long value;
+
+    f = fopen("/proc/self/status", "r");
+    if (!f) return;
+
+    while (fgets(line, sizeof(line), f))
+    {
+        if (sscanf(line, "VmPeak: %lu", &value))
+            pvmi->PeakVirtualSize = (ULONG64)value * 1024;
+        else if (sscanf(line, "VmSize: %lu", &value))
+            pvmi->VirtualSize = (ULONG64)value * 1024;
+        else if (sscanf(line, "VmHWM: %lu", &value))
+            pvmi->PeakWorkingSetSize = (ULONG64)value * 1024;
+        else if (sscanf(line, "VmRSS: %lu", &value))
+            pvmi->WorkingSetSize = (ULONG64)value * 1024;
+        else if (sscanf(line, "RssAnon: %lu", &value))
+            pvmi->PagefileUsage += (ULONG64)value * 1024;
+        else if (sscanf(line, "VmSwap: %lu", &value))
+            pvmi->PagefileUsage += (ULONG64)value * 1024;
+    }
+    pvmi->PeakPagefileUsage = pvmi->PagefileUsage;
+
+    fclose(f);
+}
+
+#else
+
+static void fill_VM_COUNTERS(VM_COUNTERS* pvmi)
+{
+    /* FIXME : real data */
+}
+
+#endif
+
+/******************************************************************************
+*  NtQueryInformationProcess		[NTDLL.@]
+*  ZwQueryInformationProcess		[NTDLL.@]
+*
+*/
+NTSTATUS WINAPI NtQueryInformationProcess(
+	IN HANDLE ProcessHandle,
+	IN PROCESSINFOCLASS ProcessInformationClass,
+	OUT PVOID ProcessInformation,
+	IN ULONG ProcessInformationLength,
+	OUT PULONG ReturnLength)
+{
+    NTSTATUS ret = STATUS_SUCCESS;
+    ULONG len = 0;
+
+    TRACE("(%p,0x%08x,%p,0x%08x,%p)\n",
+          ProcessHandle,ProcessInformationClass,
+          ProcessInformation,ProcessInformationLength,
+          ReturnLength);
+
+    switch (ProcessInformationClass) 
+    {
+    UNIMPLEMENTED_INFO_CLASS(ProcessQuotaLimits);
+    UNIMPLEMENTED_INFO_CLASS(ProcessBasePriority);
+    UNIMPLEMENTED_INFO_CLASS(ProcessRaisePriority);
+    UNIMPLEMENTED_INFO_CLASS(ProcessExceptionPort);
+    UNIMPLEMENTED_INFO_CLASS(ProcessAccessToken);
+    UNIMPLEMENTED_INFO_CLASS(ProcessLdtInformation);
+    UNIMPLEMENTED_INFO_CLASS(ProcessLdtSize);
+    UNIMPLEMENTED_INFO_CLASS(ProcessIoPortHandlers);
+    UNIMPLEMENTED_INFO_CLASS(ProcessPooledUsageAndLimits);
+    UNIMPLEMENTED_INFO_CLASS(ProcessWorkingSetWatch);
+    UNIMPLEMENTED_INFO_CLASS(ProcessUserModeIOPL);
+    UNIMPLEMENTED_INFO_CLASS(ProcessEnableAlignmentFaultFixup);
+    UNIMPLEMENTED_INFO_CLASS(ProcessWx86Information);
+    UNIMPLEMENTED_INFO_CLASS(ProcessPriorityBoost);
+    UNIMPLEMENTED_INFO_CLASS(ProcessDeviceMap);
+    UNIMPLEMENTED_INFO_CLASS(ProcessSessionInformation);
+    UNIMPLEMENTED_INFO_CLASS(ProcessForegroundInformation);
+    UNIMPLEMENTED_INFO_CLASS(ProcessLUIDDeviceMapsEnabled);
+    UNIMPLEMENTED_INFO_CLASS(ProcessBreakOnTermination);
+    UNIMPLEMENTED_INFO_CLASS(ProcessHandleTracing);
+
+    case ProcessBasicInformation:
+        {
+            PROCESS_BASIC_INFORMATION pbi;
+            const ULONG_PTR affinity_mask = get_system_affinity_mask();
+
+            if (ProcessInformationLength >= sizeof(PROCESS_BASIC_INFORMATION))
+            {
+                if (!ProcessInformation)
+                    ret = STATUS_ACCESS_VIOLATION;
+                else if (!ProcessHandle)
+                    ret = STATUS_INVALID_HANDLE;
+                else
+                {
+                    SERVER_START_REQ(get_process_info)
+                    {
+                        req->handle = wine_server_obj_handle( ProcessHandle );
+                        if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                        {
+                            pbi.ExitStatus = reply->exit_code;
+                            pbi.PebBaseAddress = wine_server_get_ptr( reply->peb );
+                            pbi.AffinityMask = reply->affinity & affinity_mask;
+                            pbi.BasePriority = reply->priority;
+                            pbi.UniqueProcessId = reply->pid;
+                            pbi.InheritedFromUniqueProcessId = reply->ppid;
+                        }
+                    }
+                    SERVER_END_REQ;
+
+                    memcpy(ProcessInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION));
+
+                    len = sizeof(PROCESS_BASIC_INFORMATION);
+                }
+
+                if (ProcessInformationLength > sizeof(PROCESS_BASIC_INFORMATION))
+                    ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+            else
+            {
+                len = sizeof(PROCESS_BASIC_INFORMATION);
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+        }
+        break;
+    case ProcessIoCounters:
+        {
+            IO_COUNTERS pii;
+
+            if (ProcessInformationLength >= sizeof(IO_COUNTERS))
+            {
+                if (!ProcessInformation)
+                    ret = STATUS_ACCESS_VIOLATION;
+                else if (!ProcessHandle)
+                    ret = STATUS_INVALID_HANDLE;
+                else
+                {
+                    /* FIXME : real data */
+                    memset(&pii, 0 , sizeof(IO_COUNTERS));
+
+                    memcpy(ProcessInformation, &pii, sizeof(IO_COUNTERS));
+
+                    len = sizeof(IO_COUNTERS);
+                }
+
+                if (ProcessInformationLength > sizeof(IO_COUNTERS))
+                    ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+            else
+            {
+                len = sizeof(IO_COUNTERS);
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+        }
+        break;
+    case ProcessVmCounters:
+        {
+            VM_COUNTERS pvmi;
+
+            /* older Windows versions don't have the PrivatePageCount field */
+            if (ProcessInformationLength >= FIELD_OFFSET(VM_COUNTERS,PrivatePageCount))
+            {
+                if (!ProcessInformation)
+                    ret = STATUS_ACCESS_VIOLATION;
+                else
+                {
+                    memset(&pvmi, 0 , sizeof(VM_COUNTERS));
+                    if (ProcessHandle == GetCurrentProcess())
+                        fill_VM_COUNTERS(&pvmi);
+                    else
+                    {
+                        SERVER_START_REQ(get_process_vm_counters)
+                        {
+                            req->handle = wine_server_obj_handle( ProcessHandle );
+                            if (!(ret = wine_server_call( req )))
+                            {
+                                pvmi.PeakVirtualSize = reply->peak_virtual_size;
+                                pvmi.VirtualSize = reply->virtual_size;
+                                pvmi.PeakWorkingSetSize = reply->peak_working_set_size;
+                                pvmi.WorkingSetSize = reply->working_set_size;
+                                pvmi.PagefileUsage = reply->pagefile_usage;
+                                pvmi.PeakPagefileUsage = reply->peak_pagefile_usage;
+                            }
+                        }
+                        SERVER_END_REQ;
+                        if (ret) break;
+                    }
+
+                    len = ProcessInformationLength;
+                    if (len != FIELD_OFFSET(VM_COUNTERS,PrivatePageCount)) len = sizeof(VM_COUNTERS);
+
+                    memcpy(ProcessInformation, &pvmi, min(ProcessInformationLength,sizeof(VM_COUNTERS)));
+                }
+
+                if (ProcessInformationLength != FIELD_OFFSET(VM_COUNTERS,PrivatePageCount) &&
+                    ProcessInformationLength != sizeof(VM_COUNTERS))
+                    ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+            else
+            {
+                len = sizeof(pvmi);
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+        }
+        break;
+    case ProcessTimes:
+        {
+            KERNEL_USER_TIMES pti = {{{0}}};
+
+            if (ProcessInformationLength >= sizeof(KERNEL_USER_TIMES))
+            {
+                if (!ProcessInformation)
+                    ret = STATUS_ACCESS_VIOLATION;
+                else if (!ProcessHandle)
+                    ret = STATUS_INVALID_HANDLE;
+                else
+                {
+                    long ticks = sysconf(_SC_CLK_TCK);
+                    struct tms tms;
+
+                    /* FIXME: user/kernel times only work for current process */
+                    if (ticks && times( &tms ) != -1)
+                    {
+                        pti.UserTime.QuadPart = (ULONGLONG)tms.tms_utime * 10000000 / ticks;
+                        pti.KernelTime.QuadPart = (ULONGLONG)tms.tms_stime * 10000000 / ticks;
+                    }
+
+                    SERVER_START_REQ(get_process_info)
+                    {
+                      req->handle = wine_server_obj_handle( ProcessHandle );
+                      if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                      {
+                          pti.CreateTime.QuadPart = reply->start_time;
+                          pti.ExitTime.QuadPart = reply->end_time;
+                      }
+                    }
+                    SERVER_END_REQ;
+
+                    memcpy(ProcessInformation, &pti, sizeof(KERNEL_USER_TIMES));
+                    len = sizeof(KERNEL_USER_TIMES);
+                }
+
+                if (ProcessInformationLength > sizeof(KERNEL_USER_TIMES))
+                    ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+            else
+            {
+                len = sizeof(KERNEL_USER_TIMES);
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+        }
+        break;
+    case ProcessDebugPort:
+        len = sizeof(DWORD_PTR);
+        if (ProcessInformationLength == len)
+        {
+            if (!ProcessInformation)
+                ret = STATUS_ACCESS_VIOLATION;
+            else if (!ProcessHandle)
+                ret = STATUS_INVALID_HANDLE;
+            else
+            {
+                SERVER_START_REQ(get_process_info)
+                {
+                    req->handle = wine_server_obj_handle( ProcessHandle );
+                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                    {
+                        *(DWORD_PTR *)ProcessInformation = reply->debugger_present ? ~(DWORD_PTR)0 : 0;
+                    }
+                }
+                SERVER_END_REQ;
+            }
+        }
+        else
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case ProcessDebugFlags:
+        len = sizeof(DWORD);
+        if (ProcessInformationLength == len)
+        {
+            if (!ProcessInformation)
+                ret = STATUS_ACCESS_VIOLATION;
+            else if (!ProcessHandle)
+                ret = STATUS_INVALID_HANDLE;
+            else
+            {
+                SERVER_START_REQ(get_process_info)
+                {
+                    req->handle = wine_server_obj_handle( ProcessHandle );
+                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                    {
+                        *(DWORD *)ProcessInformation = reply->debug_children;
+                    }
+                }
+                SERVER_END_REQ;
+            }
+        }
+        else
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case ProcessDefaultHardErrorMode:
+        len = sizeof(process_error_mode);
+        if (ProcessInformationLength == len)
+            memcpy(ProcessInformation, &process_error_mode, len);
+        else
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case ProcessDebugObjectHandle:
+        /* "These are not the debuggers you are looking for." *
+         * set it to 0 aka "no debugger" to satisfy copy protections */
+        len = sizeof(HANDLE);
+        if (ProcessInformationLength == len)
+        {
+            if (!ProcessInformation)
+                ret = STATUS_ACCESS_VIOLATION;
+            else if (!ProcessHandle)
+                ret = STATUS_INVALID_HANDLE;
+            else
+            {
+                memset(ProcessInformation, 0, ProcessInformationLength);
+                ret = STATUS_PORT_NOT_SET;
+            }
+        }
+        else
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case ProcessHandleCount:
+        if (ProcessInformationLength >= 4)
+        {
+            if (!ProcessInformation)
+                ret = STATUS_ACCESS_VIOLATION;
+            else if (!ProcessHandle)
+                ret = STATUS_INVALID_HANDLE;
+            else
+            {
+                memset(ProcessInformation, 0, 4);
+                len = 4;
+            }
+
+            if (ProcessInformationLength > 4)
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        else
+        {
+            len = 4;
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        break;
+
+    case ProcessAffinityMask:
+        len = sizeof(ULONG_PTR);
+        if (ProcessInformationLength == len)
+        {
+            const ULONG_PTR system_mask = get_system_affinity_mask();
+
+            SERVER_START_REQ(get_process_info)
+            {
+                req->handle = wine_server_obj_handle( ProcessHandle );
+                if (!(ret = wine_server_call( req )))
+                    *(ULONG_PTR *)ProcessInformation = reply->affinity & system_mask;
+            }
+            SERVER_END_REQ;
+        }
+        else ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
+    case ProcessWow64Information:
+        len = sizeof(ULONG_PTR);
+        if (ProcessInformationLength != len) ret = STATUS_INFO_LENGTH_MISMATCH;
+        else if (!ProcessInformation) ret = STATUS_ACCESS_VIOLATION;
+        else if(!ProcessHandle) ret = STATUS_INVALID_HANDLE;
+        else
+        {
+            ULONG_PTR val = 0;
+
+            if (ProcessHandle == GetCurrentProcess()) val = is_wow64;
+            else if (server_cpus & ((1 << CPU_x86_64) | (1 << CPU_ARM64)))
+            {
+                SERVER_START_REQ( get_process_info )
+                {
+                    req->handle = wine_server_obj_handle( ProcessHandle );
+                    if (!(ret = wine_server_call( req )))
+                        val = (reply->cpu != CPU_x86_64 && reply->cpu != CPU_ARM64);
+                }
+                SERVER_END_REQ;
+            }
+            *(ULONG_PTR *)ProcessInformation = val;
+        }
+        break;
+    case ProcessImageFileName:
+        /* FIXME: Should return a device path */
+    case ProcessImageFileNameWin32:
+        SERVER_START_REQ(get_dll_info)
+        {
+            UNICODE_STRING *image_file_name_str = ProcessInformation;
+
+            req->handle = wine_server_obj_handle( ProcessHandle );
+            req->base_address = 0; /* main module */
+            wine_server_set_reply( req, image_file_name_str ? image_file_name_str + 1 : NULL,
+                                   ProcessInformationLength > sizeof(UNICODE_STRING) ? ProcessInformationLength - sizeof(UNICODE_STRING) : 0 );
+            ret = wine_server_call( req );
+            if (ret == STATUS_BUFFER_TOO_SMALL) ret = STATUS_INFO_LENGTH_MISMATCH;
+
+            len = sizeof(UNICODE_STRING) + reply->filename_len;
+            if (ret == STATUS_SUCCESS)
+            {
+                image_file_name_str->MaximumLength = image_file_name_str->Length = reply->filename_len;
+                image_file_name_str->Buffer = (PWSTR)(image_file_name_str + 1);
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    case ProcessExecuteFlags:
+        len = sizeof(ULONG);
+        if (ProcessInformationLength == len)
+            *(ULONG *)ProcessInformation = execute_flags;
+        else
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case ProcessPriorityClass:
+        len = sizeof(PROCESS_PRIORITY_CLASS);
+        if (ProcessInformationLength == len)
+        {
+            if (!ProcessInformation)
+                ret = STATUS_ACCESS_VIOLATION;
+            else if (!ProcessHandle)
+                ret = STATUS_INVALID_HANDLE;
+            else
+            {
+                PROCESS_PRIORITY_CLASS *priority = ProcessInformation;
+
+                SERVER_START_REQ(get_process_info)
+                {
+                    req->handle = wine_server_obj_handle( ProcessHandle );
+                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                    {
+                        priority->PriorityClass = reply->priority;
+                        /* FIXME: Not yet supported by the wineserver */
+                        priority->Foreground = FALSE;
+                    }
+                }
+                SERVER_END_REQ;
+            }
+        }
+        else
+            ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case ProcessCookie:
+        FIXME("ProcessCookie (%p,%p,0x%08x,%p) stub\n",
+              ProcessHandle,ProcessInformation,
+              ProcessInformationLength,ReturnLength);
+
+        if(ProcessHandle == NtCurrentProcess())
+        {
+            len = sizeof(ULONG);
+            if (ProcessInformationLength == len)
+                *(ULONG *)ProcessInformation = 0;
+            else
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        else
+            ret = STATUS_INVALID_PARAMETER;
+        break;
+
+    case ProcessImageInformation:
+        len = sizeof(SECTION_IMAGE_INFORMATION);
+        if (ProcessInformationLength == len)
+        {
+            if (ProcessInformation)
+            {
+                pe_image_info_t pe_info;
+
+                SERVER_START_REQ( get_process_info )
+                {
+                    req->handle = wine_server_obj_handle( ProcessHandle );
+                    wine_server_set_reply( req, &pe_info, sizeof(pe_info) );
+                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                        virtual_fill_image_information( &pe_info, ProcessInformation );
+                }
+                SERVER_END_REQ;
+            }
+            else ret = STATUS_ACCESS_VIOLATION;
+        }
+        else ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
+    default:
+        FIXME("(%p,info_class=%d,%p,0x%08x,%p) Unknown information class\n",
+              ProcessHandle,ProcessInformationClass,
+              ProcessInformation,ProcessInformationLength,
+              ReturnLength);
+        ret = STATUS_INVALID_INFO_CLASS;
+        break;
+    }
+
+    if (ReturnLength) *ReturnLength = len;
+    
+    return ret;
+}
+
+/******************************************************************************
+ * NtSetInformationProcess [NTDLL.@]
+ * ZwSetInformationProcess [NTDLL.@]
+ */
+NTSTATUS WINAPI NtSetInformationProcess(
+	IN HANDLE ProcessHandle,
+	IN PROCESSINFOCLASS ProcessInformationClass,
+	IN PVOID ProcessInformation,
+	IN ULONG ProcessInformationLength)
+{
+    NTSTATUS ret = STATUS_SUCCESS;
+
+    switch (ProcessInformationClass)
+    {
+    case ProcessDefaultHardErrorMode:
+        if (ProcessInformationLength != sizeof(UINT)) return STATUS_INVALID_PARAMETER;
+        process_error_mode = *(UINT *)ProcessInformation;
+        break;
+    case ProcessAffinityMask:
+    {
+        const ULONG_PTR system_mask = get_system_affinity_mask();
+
+        if (ProcessInformationLength != sizeof(DWORD_PTR)) return STATUS_INVALID_PARAMETER;
+        if (*(PDWORD_PTR)ProcessInformation & ~system_mask)
+            return STATUS_INVALID_PARAMETER;
+        if (!*(PDWORD_PTR)ProcessInformation)
+            return STATUS_INVALID_PARAMETER;
+        SERVER_START_REQ( set_process_info )
+        {
+            req->handle   = wine_server_obj_handle( ProcessHandle );
+            req->affinity = *(PDWORD_PTR)ProcessInformation;
+            req->mask     = SET_PROCESS_INFO_AFFINITY;
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        break;
+    }
+    case ProcessPriorityClass:
+        if (ProcessInformationLength != sizeof(PROCESS_PRIORITY_CLASS))
+            return STATUS_INVALID_PARAMETER;
+        else
+        {
+            PROCESS_PRIORITY_CLASS* ppc = ProcessInformation;
+
+            SERVER_START_REQ( set_process_info )
+            {
+                req->handle   = wine_server_obj_handle( ProcessHandle );
+                /* FIXME Foreground isn't used */
+                req->priority = ppc->PriorityClass;
+                req->mask     = SET_PROCESS_INFO_PRIORITY;
+                ret = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        break;
+
+    case ProcessExecuteFlags:
+        if (is_win64 || ProcessInformationLength != sizeof(ULONG))
+            return STATUS_INVALID_PARAMETER;
+        else if (execute_flags & MEM_EXECUTE_OPTION_PERMANENT)
+            return STATUS_ACCESS_DENIED;
+        else
+        {
+            BOOL enable;
+            switch (*(ULONG *)ProcessInformation & (MEM_EXECUTE_OPTION_ENABLE|MEM_EXECUTE_OPTION_DISABLE))
+            {
+            case MEM_EXECUTE_OPTION_ENABLE:
+                enable = TRUE;
+                break;
+            case MEM_EXECUTE_OPTION_DISABLE:
+                enable = FALSE;
+                break;
+            default:
+                return STATUS_INVALID_PARAMETER;
+            }
+            execute_flags = *(ULONG *)ProcessInformation;
+            VIRTUAL_SetForceExec( enable );
+        }
+        break;
+
+    default:
+        FIXME("(%p,0x%08x,%p,0x%08x) stub\n",
+              ProcessHandle,ProcessInformationClass,ProcessInformation,
+              ProcessInformationLength);
+        ret = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    return ret;
+}
+
+/******************************************************************************
+ * NtFlushInstructionCache [NTDLL.@]
+ * ZwFlushInstructionCache [NTDLL.@]
+ */
+NTSTATUS WINAPI NtFlushInstructionCache( HANDLE handle, const void *addr, SIZE_T size )
+{
+#if defined(__x86_64__) || defined(__i386__)
+    /* no-op */
+#elif defined(HAVE___CLEAR_CACHE)
+    if (handle == GetCurrentProcess())
+    {
+        __clear_cache( (char *)addr, (char *)addr + size );
+    }
+    else
+    {
+        static int once;
+        if (!once++) FIXME( "%p %p %ld other process not supported\n", handle, addr, size );
+    }
+#else
+    static int once;
+    if (!once++) FIXME( "%p %p %ld\n", handle, addr, size );
+#endif
+    return STATUS_SUCCESS;
+}
+
+/**********************************************************************
+ * NtFlushProcessWriteBuffers [NTDLL.@]
+ */
+void WINAPI NtFlushProcessWriteBuffers(void)
+{
+    static int once = 0;
+    if (!once++) FIXME( "stub\n" );
+}
+
+/******************************************************************
+ *		NtOpenProcess [NTDLL.@]
+ *		ZwOpenProcess [NTDLL.@]
+ */
+NTSTATUS  WINAPI NtOpenProcess(PHANDLE handle, ACCESS_MASK access,
+                               const OBJECT_ATTRIBUTES* attr, const CLIENT_ID* cid)
+{
+    NTSTATUS    status;
+
+    SERVER_START_REQ( open_process )
+    {
+        req->pid        = HandleToULong(cid->UniqueProcess);
+        req->access     = access;
+        req->attributes = attr ? attr->Attributes : 0;
+        status = wine_server_call( req );
+        if (!status) *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************************
+ * NtResumeProcess
+ * ZwResumeProcess
+ */
+NTSTATUS WINAPI NtResumeProcess( HANDLE handle )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( resume_process )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+/******************************************************************************
+ * NtSuspendProcess
+ * ZwSuspendProcess
+ */
+NTSTATUS WINAPI NtSuspendProcess( HANDLE handle )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( suspend_process )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+
+/***********************************************************************
+ *           build_argv
+ *
+ * Build an argv array from a command-line.
+ * 'reserved' is the number of args to reserve before the first one.
+ */
+static char **build_argv( const UNICODE_STRING *cmdlineW, int reserved )
+{
+    int argc;
+    char **argv;
+    char *arg, *s, *d, *cmdline;
+    int in_quotes, bcount, len;
+
+    len = cmdlineW->Length / sizeof(WCHAR);
+    if (!(cmdline = RtlAllocateHeap( GetProcessHeap(), 0, len * 3 + 1 ))) return NULL;
+    len = ntdll_wcstoumbs( cmdlineW->Buffer, len, cmdline, len * 3, FALSE );
+    cmdline[len++] = 0;
+
+    argc = reserved + 1;
+    bcount = 0;
+    in_quotes = 0;
+    s = cmdline;
+    while (1)
+    {
+        if (*s == '\0' || ((*s == ' ' || *s == '\t') && !in_quotes))
+        {
+            /* space */
+            argc++;
+            /* skip the remaining spaces */
+            while (*s == ' ' || *s == '\t') s++;
+            if (*s == '\0') break;
+            bcount = 0;
+            continue;
+        }
+        else if (*s == '\\') bcount++;  /* '\', count them */
+        else if ((*s == '"') && ((bcount & 1) == 0))
+        {
+            if (in_quotes && s[1] == '"') s++;
+            else
+            {
+                /* unescaped '"' */
+                in_quotes = !in_quotes;
+                bcount = 0;
+            }
+        }
+        else bcount = 0; /* a regular character */
+        s++;
+    }
+    if (!(argv = RtlAllocateHeap( GetProcessHeap(), 0, argc * sizeof(*argv) + len )))
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, cmdline );
+        return NULL;
+    }
+
+    arg = d = s = (char *)(argv + argc);
+    memcpy( d, cmdline, len );
+    bcount = 0;
+    in_quotes = 0;
+    argc = reserved;
+    while (*s)
+    {
+        if ((*s == ' ' || *s == '\t') && !in_quotes)
+        {
+            /* Close the argument and copy it */
+            *d = 0;
+            argv[argc++] = arg;
+            /* skip the remaining spaces */
+            do
+            {
+                s++;
+            } while (*s == ' ' || *s == '\t');
+
+            /* Start with a new argument */
+            arg = d = s;
+            bcount = 0;
+        }
+        else if (*s == '\\')
+        {
+            *d++ = *s++;
+            bcount++;
+        }
+        else if (*s == '"')
+        {
+            if ((bcount & 1) == 0)
+            {
+                /* Preceded by an even number of '\', this is half that
+                 * number of '\', plus a '"' which we discard.
+                 */
+                d -= bcount/2;
+                s++;
+                if (in_quotes && *s == '"')
+                {
+                    *d++ = '"';
+                    s++;
+                }
+                else in_quotes = !in_quotes;
+            }
+            else
+            {
+                /* Preceded by an odd number of '\', this is half that
+                 * number of '\' followed by a '"'
+                 */
+                d = d - bcount / 2 - 1;
+                *d++ = '"';
+                s++;
+            }
+            bcount = 0;
+        }
+        else
+        {
+            /* a regular character */
+            *d++ = *s++;
+            bcount = 0;
+        }
+    }
+    if (*arg)
+    {
+        *d = '\0';
+        argv[argc++] = arg;
+    }
+    argv[argc] = NULL;
+
+    RtlFreeHeap( GetProcessHeap(), 0, cmdline );
+    return argv;
+}
+
+
+static inline const WCHAR *get_params_string( const RTL_USER_PROCESS_PARAMETERS *params,
+                                              const UNICODE_STRING *str )
+{
+    if (params->Flags & PROCESS_PARAMS_FLAG_NORMALIZED) return str->Buffer;
+    return (const WCHAR *)((const char *)params + (UINT_PTR)str->Buffer);
+}
+
+static inline DWORD append_string( void **ptr, const RTL_USER_PROCESS_PARAMETERS *params,
+                                   const UNICODE_STRING *str )
+{
+    const WCHAR *buffer = get_params_string( params, str );
+    memcpy( *ptr, buffer, str->Length );
+    *ptr = (WCHAR *)*ptr + str->Length / sizeof(WCHAR);
+    return str->Length;
+}
+
+/***********************************************************************
+ *           create_startup_info
+ */
+static startup_info_t *create_startup_info( const RTL_USER_PROCESS_PARAMETERS *params, DWORD *info_size )
+{
+    startup_info_t *info;
+    DWORD size;
+    void *ptr;
+
+    size = sizeof(*info);
+    size += params->CurrentDirectory.DosPath.Length;
+    size += params->DllPath.Length;
+    size += params->ImagePathName.Length;
+    size += params->CommandLine.Length;
+    size += params->WindowTitle.Length;
+    size += params->Desktop.Length;
+    size += params->ShellInfo.Length;
+    size += params->RuntimeInfo.Length;
+    size = (size + 1) & ~1;
+    *info_size = size;
+
+    if (!(info = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, size ))) return NULL;
+
+    info->debug_flags   = params->DebugFlags;
+    info->console_flags = params->ConsoleFlags;
+    info->console       = wine_server_obj_handle( params->ConsoleHandle );
+    info->hstdin        = wine_server_obj_handle( params->hStdInput );
+    info->hstdout       = wine_server_obj_handle( params->hStdOutput );
+    info->hstderr       = wine_server_obj_handle( params->hStdError );
+    info->x             = params->dwX;
+    info->y             = params->dwY;
+    info->xsize         = params->dwXSize;
+    info->ysize         = params->dwYSize;
+    info->xchars        = params->dwXCountChars;
+    info->ychars        = params->dwYCountChars;
+    info->attribute     = params->dwFillAttribute;
+    info->flags         = params->dwFlags;
+    info->show          = params->wShowWindow;
+
+    ptr = info + 1;
+    info->curdir_len = append_string( &ptr, params, &params->CurrentDirectory.DosPath );
+    info->dllpath_len = append_string( &ptr, params, &params->DllPath );
+    info->imagepath_len = append_string( &ptr, params, &params->ImagePathName );
+    info->cmdline_len = append_string( &ptr, params, &params->CommandLine );
+    info->title_len = append_string( &ptr, params, &params->WindowTitle );
+    info->desktop_len = append_string( &ptr, params, &params->Desktop );
+    info->shellinfo_len = append_string( &ptr, params, &params->ShellInfo );
+    info->runtime_len = append_string( &ptr, params, &params->RuntimeInfo );
+    return info;
+}
+
+
+#ifdef __APPLE__
+/***********************************************************************
+ *           terminate_main_thread
+ *
+ * On some versions of Mac OS X, the execve system call fails with
+ * ENOTSUP if the process has multiple threads.  Wine is always multi-
+ * threaded on Mac OS X because it specifically reserves the main thread
+ * for use by the system frameworks (see apple_main_thread() in
+ * libs/wine/loader.c).  So, when we need to exec without first forking,
+ * we need to terminate the main thread first.  We do this by installing
+ * a custom run loop source onto the main run loop and signaling it.
+ * The source's "perform" callback is pthread_exit and it will be
+ * executed on the main thread, terminating it.
+ *
+ * Returns TRUE if there's still hope the main thread has terminated or
+ * will soon.  Return FALSE if we've given up.
+ */
+static BOOL terminate_main_thread(void)
+{
+    static int delayms;
+
+    if (!delayms)
+    {
+        CFRunLoopSourceContext source_context = { 0 };
+        CFRunLoopSourceRef source;
+
+        source_context.perform = pthread_exit;
+        if (!(source = CFRunLoopSourceCreate( NULL, 0, &source_context )))
+            return FALSE;
+
+        CFRunLoopAddSource( CFRunLoopGetMain(), source, kCFRunLoopCommonModes );
+        CFRunLoopSourceSignal( source );
+        CFRunLoopWakeUp( CFRunLoopGetMain() );
+        CFRelease( source );
+
+        delayms = 20;
+    }
+
+    if (delayms > 1000)
+        return FALSE;
+
+    usleep(delayms * 1000);
+    delayms *= 2;
+
+    return TRUE;
+}
+#endif
+
+
+/***********************************************************************
+ *           set_stdio_fd
+ */
+static void set_stdio_fd( int stdin_fd, int stdout_fd )
+{
+    int fd = -1;
+
+    if (stdin_fd == -1 || stdout_fd == -1)
+    {
+        fd = open( "/dev/null", O_RDWR );
+        if (stdin_fd == -1) stdin_fd = fd;
+        if (stdout_fd == -1) stdout_fd = fd;
+    }
+
+    dup2( stdin_fd, 0 );
+    dup2( stdout_fd, 1 );
+    if (fd != -1) close( fd );
+}
+
+
+/***********************************************************************
+ *           spawn_loader
+ */
+static NTSTATUS spawn_loader( const RTL_USER_PROCESS_PARAMETERS *params, int socketfd,
+                              const char *unixdir, char *winedebug, const pe_image_info_t *pe_info )
+{
+    const int is_child_64bit = (pe_info->cpu == CPU_x86_64 || pe_info->cpu == CPU_ARM64);
+    pid_t pid;
+    int stdin_fd = -1, stdout_fd = -1;
+    char **argv;
+    NTSTATUS status = STATUS_SUCCESS;
+
+    argv = build_argv( &params->CommandLine, 2 );
+
+    wine_server_handle_to_fd( params->hStdInput, FILE_READ_DATA, &stdin_fd, NULL );
+    wine_server_handle_to_fd( params->hStdOutput, FILE_WRITE_DATA, &stdout_fd, NULL );
+
+    if (!(pid = fork()))  /* child */
+    {
+        if (!(pid = fork()))  /* grandchild */
+        {
+            if (params->ConsoleFlags ||
+                params->ConsoleHandle == (HANDLE)1 /* KERNEL32_CONSOLE_ALLOC */ ||
+                (params->hStdInput == INVALID_HANDLE_VALUE && params->hStdOutput == INVALID_HANDLE_VALUE))
+            {
+                setsid();
+                set_stdio_fd( -1, -1 );  /* close stdin and stdout */
+            }
+            else set_stdio_fd( stdin_fd, stdout_fd );
+
+            if (stdin_fd != -1) close( stdin_fd );
+            if (stdout_fd != -1) close( stdout_fd );
+
+            if (winedebug) putenv( winedebug );
+            if (unixdir) chdir( unixdir );
+
+            unix_funcs->exec_wineloader( argv, socketfd, is_child_64bit,
+                                         pe_info->base, pe_info->base + pe_info->map_size );
+            _exit(1);
+        }
+
+        _exit(pid == -1);
+    }
+
+    if (pid != -1)
+    {
+        /* reap child */
+        pid_t wret;
+        do {
+            wret = waitpid(pid, NULL, 0);
+        } while (wret < 0 && errno == EINTR);
+    }
+    else status = FILE_GetNtStatus();
+
+    if (stdin_fd != -1) close( stdin_fd );
+    if (stdout_fd != -1) close( stdout_fd );
+    RtlFreeHeap( GetProcessHeap(), 0, argv );
+    return status;
+}
+
+
+/***************************************************************************
+ *	is_builtin_path
+ */
+static BOOL is_builtin_path( UNICODE_STRING *path, BOOL *is_64bit )
+{
+    static const WCHAR systemW[] = {'\\','?','?','\\','c',':','\\','w','i','n','d','o','w','s','\\',
+                                    's','y','s','t','e','m','3','2','\\'};
+    static const WCHAR wow64W[] = {'\\','?','?','\\','c',':','\\','w','i','n','d','o','w','s','\\',
+                                   's','y','s','w','o','w','6','4'};
+
+    *is_64bit = is_win64;
+    if (path->Length > sizeof(systemW) && !wcsnicmp( path->Buffer, systemW, ARRAY_SIZE(systemW) ))
+    {
+        if (is_wow64 && !ntdll_get_thread_data()->wow64_redir) *is_64bit = TRUE;
+        return TRUE;
+    }
+    if ((is_win64 || is_wow64) && path->Length > sizeof(wow64W) &&
+        !wcsnicmp( path->Buffer, wow64W, ARRAY_SIZE(wow64W) ))
+    {
+        *is_64bit = FALSE;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+
+/***********************************************************************
+ *           get_so_file_info
+ */
+static BOOL get_so_file_info( HANDLE handle, pe_image_info_t *info )
+{
+    union
+    {
+        struct
+        {
+            unsigned char magic[4];
+            unsigned char class;
+            unsigned char data;
+            unsigned char version;
+            unsigned char ignored1[9];
+            unsigned short type;
+            unsigned short machine;
+            unsigned char ignored2[8];
+            unsigned int phoff;
+            unsigned char ignored3[12];
+            unsigned short phnum;
+        } elf;
+        struct
+        {
+            unsigned char magic[4];
+            unsigned char class;
+            unsigned char data;
+            unsigned char ignored1[10];
+            unsigned short type;
+            unsigned short machine;
+            unsigned char ignored2[12];
+            unsigned __int64 phoff;
+            unsigned char ignored3[16];
+            unsigned short phnum;
+        } elf64;
+        struct
+        {
+            unsigned int magic;
+            unsigned int cputype;
+            unsigned int cpusubtype;
+            unsigned int filetype;
+        } macho;
+        IMAGE_DOS_HEADER mz;
+    } header;
+
+    IO_STATUS_BLOCK io;
+    LARGE_INTEGER offset;
+
+    offset.QuadPart = 0;
+    if (NtReadFile( handle, 0, NULL, NULL, &io, &header, sizeof(header), &offset, 0 )) return FALSE;
+    if (io.Information != sizeof(header)) return FALSE;
+
+    if (!memcmp( header.elf.magic, "\177ELF", 4 ))
+    {
+        unsigned int type;
+        unsigned short phnum;
+
+        if (header.elf.version != 1 /* EV_CURRENT */) return FALSE;
+#ifdef WORDS_BIGENDIAN
+        if (header.elf.data != 2 /* ELFDATA2MSB */) return FALSE;
+#else
+        if (header.elf.data != 1 /* ELFDATA2LSB */) return FALSE;
+#endif
+        switch (header.elf.machine)
+        {
+        case 3:   info->cpu = CPU_x86; break;
+        case 20:  info->cpu = CPU_POWERPC; break;
+        case 40:  info->cpu = CPU_ARM; break;
+        case 62:  info->cpu = CPU_x86_64; break;
+        case 183: info->cpu = CPU_ARM64; break;
+        }
+        if (header.elf.type != 3 /* ET_DYN */) return FALSE;
+        if (header.elf.class == 2 /* ELFCLASS64 */)
+        {
+            offset.QuadPart = header.elf64.phoff;
+            phnum = header.elf64.phnum;
+        }
+        else
+        {
+            offset.QuadPart = header.elf.phoff;
+            phnum = header.elf.phnum;
+        }
+        while (phnum--)
+        {
+            if (NtReadFile( handle, 0, NULL, NULL, &io, &type, sizeof(type), &offset, 0 )) return FALSE;
+            if (io.Information < sizeof(type)) return FALSE;
+            if (type == 3 /* PT_INTERP */) return FALSE;
+            offset.QuadPart += (header.elf.class == 2) ? 56 : 32;
+        }
+        return TRUE;
+    }
+    else if (header.macho.magic == 0xfeedface || header.macho.magic == 0xfeedfacf)
+    {
+        switch (header.macho.cputype)
+        {
+        case 0x00000007: info->cpu = CPU_x86; break;
+        case 0x01000007: info->cpu = CPU_x86_64; break;
+        case 0x0000000c: info->cpu = CPU_ARM; break;
+        case 0x0100000c: info->cpu = CPU_ARM64; break;
+        case 0x00000012: info->cpu = CPU_POWERPC; break;
+        }
+        if (header.macho.filetype == 8) return TRUE;
+    }
+    return FALSE;
+}
+
+
+/***********************************************************************
+ *           get_pe_file_info
+ */
+static NTSTATUS get_pe_file_info( UNICODE_STRING *path, ULONG attributes,
+                                  HANDLE *handle, pe_image_info_t *info )
+{
+    NTSTATUS status;
+    HANDLE mapping;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK io;
+
+    memset( info, 0, sizeof(*info) );
+    InitializeObjectAttributes( &attr, path, attributes, 0, 0 );
+    if ((status = NtOpenFile( handle, GENERIC_READ, &attr, &io,
+                              FILE_SHARE_READ | FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT )))
+    {
+        BOOL is_64bit;
+
+        if (is_builtin_path( path, &is_64bit ))
+        {
+            TRACE( "assuming %u-bit builtin for %s\n", is_64bit ? 64 : 32, debugstr_us(path));
+            /* assume current arch */
+#if defined(__i386__) || defined(__x86_64__)
+            info->cpu = is_64bit ? CPU_x86_64 : CPU_x86;
+#elif defined(__powerpc__)
+            info->cpu = CPU_POWERPC;
+#elif defined(__arm__)
+            info->cpu = CPU_ARM;
+#elif defined(__aarch64__)
+            info->cpu = CPU_ARM64;
+#endif
+            *handle = 0;
+            return STATUS_SUCCESS;
+        }
+        return status;
+    }
+
+    if (!(status = NtCreateSection( &mapping, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY |
+                                    SECTION_MAP_READ | SECTION_MAP_EXECUTE,
+                                    NULL, NULL, PAGE_EXECUTE_READ, SEC_IMAGE, *handle )))
+    {
+        SERVER_START_REQ( get_mapping_info )
+        {
+            req->handle = wine_server_obj_handle( mapping );
+            req->access = SECTION_QUERY;
+            wine_server_set_reply( req, info, sizeof(*info) );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        NtClose( mapping );
+    }
+    else if (status == STATUS_INVALID_IMAGE_NOT_MZ)
+    {
+        if (get_so_file_info( *handle, info )) return STATUS_SUCCESS;
+    }
+    return status;
+}
+
+
+/***********************************************************************
+ *           get_env_size
+ */
+static ULONG get_env_size( const RTL_USER_PROCESS_PARAMETERS *params, char **winedebug )
+{
+    WCHAR *ptr = params->Environment;
+
+    while (*ptr)
+    {
+        static const WCHAR WINEDEBUG[] = {'W','I','N','E','D','E','B','U','G','=',0};
+        if (!*winedebug && !wcsncmp( ptr, WINEDEBUG, ARRAY_SIZE( WINEDEBUG ) - 1 ))
+        {
+            DWORD len = wcslen(ptr) * 3 + 1;
+            if ((*winedebug = RtlAllocateHeap( GetProcessHeap(), 0, len )))
+                ntdll_wcstoumbs( ptr, wcslen(ptr) + 1, *winedebug, len, FALSE );
+        }
+        ptr += wcslen(ptr) + 1;
+    }
+    ptr++;
+    return (ptr - params->Environment) * sizeof(WCHAR);
+}
+
+
+/***********************************************************************
+ *           get_unix_curdir
+ */
+static char *get_unix_curdir( const RTL_USER_PROCESS_PARAMETERS *params )
+{
+    UNICODE_STRING nt_name;
+    ANSI_STRING unix_name;
+    NTSTATUS status;
+
+    if (!RtlDosPathNameToNtPathName_U( params->CurrentDirectory.DosPath.Buffer, &nt_name, NULL, NULL ))
+        return NULL;
+    status = wine_nt_to_unix_file_name( &nt_name, &unix_name, FILE_OPEN_IF, FALSE );
+    RtlFreeUnicodeString( &nt_name );
+    if (status && status != STATUS_NO_SUCH_FILE) return NULL;
+    return unix_name.Buffer;
+}
+
+
+/***********************************************************************
+ *           fork_and_exec
+ *
+ * Fork and exec a new Unix binary, checking for errors.
+ */
+static NTSTATUS fork_and_exec( UNICODE_STRING *path, const RTL_USER_PROCESS_PARAMETERS *params )
+{
+    pid_t pid;
+    int fd[2], stdin_fd = -1, stdout_fd = -1;
+    char **argv, **envp;
+    char *unixdir;
+    ANSI_STRING unix_name;
+    NTSTATUS status;
+
+    status = wine_nt_to_unix_file_name( path, &unix_name, FILE_OPEN, FALSE );
+    if (status) return status;
+
+#ifdef HAVE_PIPE2
+    if (pipe2( fd, O_CLOEXEC ) == -1)
+#endif
+    {
+        if (pipe(fd) == -1)
+        {
+            RtlFreeAnsiString( &unix_name );
+            return STATUS_TOO_MANY_OPENED_FILES;
+        }
+        fcntl( fd[0], F_SETFD, FD_CLOEXEC );
+        fcntl( fd[1], F_SETFD, FD_CLOEXEC );
+    }
+
+    wine_server_handle_to_fd( params->hStdInput, FILE_READ_DATA, &stdin_fd, NULL );
+    wine_server_handle_to_fd( params->hStdOutput, FILE_WRITE_DATA, &stdout_fd, NULL );
+
+    argv = build_argv( &params->CommandLine, 0 );
+    envp = build_envp( params->Environment );
+    unixdir = get_unix_curdir( params );
+
+    if (!(pid = fork()))  /* child */
+    {
+        if (!(pid = fork()))  /* grandchild */
+        {
+            close( fd[0] );
+
+            if (params->ConsoleFlags ||
+                params->ConsoleHandle == (HANDLE)1 /* KERNEL32_CONSOLE_ALLOC */ ||
+                (params->hStdInput == INVALID_HANDLE_VALUE && params->hStdOutput == INVALID_HANDLE_VALUE))
+            {
+                setsid();
+                set_stdio_fd( -1, -1 );  /* close stdin and stdout */
+            }
+            else set_stdio_fd( stdin_fd, stdout_fd );
+
+            if (stdin_fd != -1) close( stdin_fd );
+            if (stdout_fd != -1) close( stdout_fd );
+
+            /* Reset signals that we previously set to SIG_IGN */
+            signal( SIGPIPE, SIG_DFL );
+
+            if (unixdir) chdir( unixdir );
+
+            if (argv && envp) execve( unix_name.Buffer, argv, envp );
+        }
+
+        if (pid <= 0)  /* grandchild if exec failed or child if fork failed */
+        {
+            status = FILE_GetNtStatus();
+            write( fd[1], &status, sizeof(status) );
+            _exit(1);
+        }
+
+        _exit(0); /* child if fork succeeded */
+    }
+    close( fd[1] );
+
+    if (pid != -1)
+    {
+        /* reap child */
+        pid_t wret;
+        do {
+            wret = waitpid(pid, NULL, 0);
+        } while (wret < 0 && errno == EINTR);
+        read( fd[0], &status, sizeof(status) );  /* if we read something, exec or second fork failed */
+    }
+    else status = FILE_GetNtStatus();
+
+    close( fd[0] );
+    if (stdin_fd != -1) close( stdin_fd );
+    if (stdout_fd != -1) close( stdout_fd );
+    RtlFreeHeap( GetProcessHeap(), 0, argv );
+    RtlFreeHeap( GetProcessHeap(), 0, envp );
+    RtlFreeHeap( GetProcessHeap(), 0, unixdir );
+    RtlFreeAnsiString( &unix_name );
+    return status;
+}
+
+
 /***********************************************************************
  *           restart_process
  */
@@ -82,9 +1503,11 @@ NTSTATUS restart_process( RTL_USER_PROCESS_PARAMETERS *params, NTSTATUS status )
     static const WCHAR comW[] = {'.','c','o','m',0};
     static const WCHAR pifW[] = {'.','p','i','f',0};
 
-    DWORD len;
+    int socketfd[2];
     WCHAR *p, *cmdline;
-    UNICODE_STRING pathW, cmdW;
+    UNICODE_STRING strW;
+    pe_image_info_t pe_info;
+    HANDLE handle;
 
     /* check for .com or .pif extension */
     if (status == STATUS_INVALID_IMAGE_NOT_MZ &&
@@ -98,24 +1521,75 @@ NTSTATUS restart_process( RTL_USER_PROCESS_PARAMETERS *params, NTSTATUS status )
     case STATUS_NO_MEMORY:
     case STATUS_INVALID_IMAGE_FORMAT:
     case STATUS_INVALID_IMAGE_NOT_MZ:
-        if (!RtlDosPathNameToNtPathName_U( params->ImagePathName.Buffer, &pathW, NULL, NULL ))
+        if (getenv( "WINEPRELOADRESERVE" ))
+            return status;
+        if ((status = RtlDosPathNameToNtPathName_U_WithStatus( params->ImagePathName.Buffer, &strW,
+                                                               NULL, NULL )))
+            return status;
+        if ((status = get_pe_file_info( &strW, OBJ_CASE_INSENSITIVE, &handle, &pe_info )))
             return status;
-        status = unix_funcs->exec_process( &pathW, &params->CommandLine, status );
+        strW = params->CommandLine;
         break;
     case STATUS_INVALID_IMAGE_WIN_16:
     case STATUS_INVALID_IMAGE_NE_FORMAT:
     case STATUS_INVALID_IMAGE_PROTECT:
-        len = (wcslen(system_dir) + wcslen(winevdm) + 16 + wcslen(params->ImagePathName.Buffer) +
-               wcslen(params->CommandLine.Buffer));
-        if (!(cmdline = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
-            return STATUS_NO_MEMORY;
-        swprintf( cmdline, len, argsW, (is_win64 || is_wow64) ? syswow64_dir : system_dir,
+        cmdline = RtlAllocateHeap( GetProcessHeap(), 0,
+                                   (wcslen(system_dir) + wcslen(winevdm) + 16 +
+                                    wcslen(params->ImagePathName.Buffer) +
+                                    wcslen(params->CommandLine.Buffer)) * sizeof(WCHAR));
+        if (!cmdline) return STATUS_NO_MEMORY;
+        NTDLL_swprintf( cmdline, argsW, (is_win64 || is_wow64) ? syswow64_dir : system_dir,
                   winevdm, params->ImagePathName.Buffer, params->CommandLine.Buffer );
-        RtlInitUnicodeString( &pathW, winevdm );
-        RtlInitUnicodeString( &cmdW, cmdline );
-        status = unix_funcs->exec_process( &pathW, &cmdW, status );
+        RtlInitUnicodeString( &strW, cmdline );
+        memset( &pe_info, 0, sizeof(pe_info) );
+        pe_info.cpu = CPU_x86;
         break;
+    default:
+        return status;
     }
+
+    /* exec the new process */
+
+    if (socketpair( PF_UNIX, SOCK_STREAM, 0, socketfd ) == -1) return STATUS_TOO_MANY_OPENED_FILES;
+#ifdef SO_PASSCRED
+    else
+    {
+        int enable = 1;
+        setsockopt( socketfd[0], SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
+    }
+#endif
+    wine_server_send_fd( socketfd[1] );
+    close( socketfd[1] );
+
+    SERVER_START_REQ( exec_process )
+    {
+        req->socket_fd = socketfd[1];
+        req->cpu       = pe_info.cpu;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (!status)
+    {
+        const int is_child_64bit = (pe_info.cpu == CPU_x86_64 || pe_info.cpu == CPU_ARM64);
+        char **argv = build_argv( &strW, 2 );
+        if (argv)
+        {
+            do
+            {
+                status = unix_funcs->exec_wineloader( argv, socketfd[0], is_child_64bit,
+                                                      pe_info.base, pe_info.base + pe_info.map_size );
+            }
+#ifdef __APPLE__
+            while (errno == ENOTSUP && terminate_main_thread());
+#else
+            while (0);
+#endif
+            RtlFreeHeap( GetProcessHeap(), 0, argv );
+        }
+        else status = STATUS_NO_MEMORY;
+    }
+    close( socketfd[0] );
     return status;
 }
 
@@ -130,55 +1604,162 @@ NTSTATUS WINAPI RtlCreateUserProcess( UNICODE_STRING *path, ULONG attributes,
                                       HANDLE parent, BOOLEAN inherit, HANDLE debug, HANDLE exception,
                                       RTL_USER_PROCESS_INFORMATION *info )
 {
-    OBJECT_ATTRIBUTES process_attr, thread_attr;
-    PS_CREATE_INFO create_info;
-    ULONG_PTR buffer[offsetof( PS_ATTRIBUTE_LIST, Attributes[5] ) / sizeof(ULONG_PTR)];
-    PS_ATTRIBUTE_LIST *attr = (PS_ATTRIBUTE_LIST *)buffer;
-    UINT pos = 0;
+    NTSTATUS status;
+    BOOL success = FALSE;
+    HANDLE file_handle, process_info = 0, process_handle = 0, thread_handle = 0;
+    ULONG process_id, thread_id;
+    struct object_attributes *objattr;
+    data_size_t attr_len;
+    char *unixdir = NULL, *winedebug = NULL;
+    startup_info_t *startup_info = NULL;
+    ULONG startup_info_size, env_size;
+    int socketfd[2] = { -1, -1 };
+    OBJECT_ATTRIBUTES attr;
+    pe_image_info_t pe_info;
 
     RtlNormalizeProcessParams( params );
 
-    attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_IMAGE_NAME;
-    attr->Attributes[pos].Size         = path->Length;
-    attr->Attributes[pos].ValuePtr     = path->Buffer;
-    attr->Attributes[pos].ReturnLength = NULL;
-    pos++;
-    attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_CLIENT_ID;
-    attr->Attributes[pos].Size         = sizeof(info->ClientId);
-    attr->Attributes[pos].ValuePtr     = &info->ClientId;
-    attr->Attributes[pos].ReturnLength = NULL;
-    pos++;
-    attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_IMAGE_INFO;
-    attr->Attributes[pos].Size         = sizeof(info->ImageInformation);
-    attr->Attributes[pos].ValuePtr     = &info->ImageInformation;
-    attr->Attributes[pos].ReturnLength = NULL;
-    pos++;
-    if (parent)
-    {
-        attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_PARENT_PROCESS;
-        attr->Attributes[pos].Size         = sizeof(parent);
-        attr->Attributes[pos].ValuePtr     = parent;
-        attr->Attributes[pos].ReturnLength = NULL;
-        pos++;
-    }
-    if (debug)
-    {
-        attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_DEBUG_PORT;
-        attr->Attributes[pos].Size         = sizeof(debug);
-        attr->Attributes[pos].ValuePtr     = debug;
-        attr->Attributes[pos].ReturnLength = NULL;
-        pos++;
-    }
-    attr->TotalLength = offsetof( PS_ATTRIBUTE_LIST, Attributes[pos] );
-
-    InitializeObjectAttributes( &process_attr, NULL, 0, NULL, process_descr );
-    InitializeObjectAttributes( &thread_attr, NULL, 0, NULL, thread_descr );
-
-    return NtCreateUserProcess( &info->Process, &info->Thread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS,
-                                &process_attr, &thread_attr,
-                                inherit ? PROCESS_CREATE_FLAGS_INHERIT_HANDLES : 0,
-                                THREAD_CREATE_FLAGS_CREATE_SUSPENDED, params,
-                                &create_info, attr );
+    TRACE( "%s image %s cmdline %s\n", debugstr_us( path ),
+           debugstr_us( &params->ImagePathName ), debugstr_us( &params->CommandLine ));
+
+    if ((status = get_pe_file_info( path, attributes, &file_handle, &pe_info )))
+    {
+        if (status == STATUS_INVALID_IMAGE_NOT_MZ && !fork_and_exec( path, params ))
+        {
+            memset( info, 0, sizeof(*info) );
+            return STATUS_SUCCESS;
+        }
+        goto done;
+    }
+    if (!(startup_info = create_startup_info( params, &startup_info_size ))) goto done;
+    env_size = get_env_size( params, &winedebug );
+    unixdir = get_unix_curdir( params );
+
+    InitializeObjectAttributes( &attr, NULL, 0, NULL, process_descr );
+    if ((status = alloc_object_attributes( &attr, &objattr, &attr_len ))) goto done;
+
+    /* create the socket for the new process */
+
+    if (socketpair( PF_UNIX, SOCK_STREAM, 0, socketfd ) == -1)
+    {
+        status = STATUS_TOO_MANY_OPENED_FILES;
+        RtlFreeHeap( GetProcessHeap(), 0, objattr );
+        goto done;
+    }
+#ifdef SO_PASSCRED
+    else
+    {
+        int enable = 1;
+        setsockopt( socketfd[0], SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
+    }
+#endif
+
+    wine_server_send_fd( socketfd[1] );
+    close( socketfd[1] );
+
+    /* create the process on the server side */
+
+    SERVER_START_REQ( new_process )
+    {
+        req->parent_process = wine_server_obj_handle(parent);
+        req->inherit_all    = inherit;
+        req->create_flags   = params->DebugFlags; /* hack: creation flags stored in DebugFlags for now */
+        req->socket_fd      = socketfd[1];
+        req->exe_file       = wine_server_obj_handle( file_handle );
+        req->access         = PROCESS_ALL_ACCESS;
+        req->cpu            = pe_info.cpu;
+        req->info_size      = startup_info_size;
+        wine_server_add_data( req, objattr, attr_len );
+        wine_server_add_data( req, startup_info, startup_info_size );
+        wine_server_add_data( req, params->Environment, env_size );
+        if (!(status = wine_server_call( req )))
+        {
+            process_id = reply->pid;
+            process_handle = wine_server_ptr_handle( reply->handle );
+        }
+        process_info = wine_server_ptr_handle( reply->info );
+    }
+    SERVER_END_REQ;
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+
+    if (status)
+    {
+        switch (status)
+        {
+        case STATUS_INVALID_IMAGE_WIN_64:
+            ERR( "64-bit application %s not supported in 32-bit prefix\n", debugstr_us(path) );
+            break;
+        case STATUS_INVALID_IMAGE_FORMAT:
+            ERR( "%s not supported on this installation (%s binary)\n",
+                 debugstr_us(path), cpu_names[pe_info.cpu] );
+            break;
+        }
+        goto done;
+    }
+
+    InitializeObjectAttributes( &attr, NULL, 0, NULL, thread_descr );
+    if ((status = alloc_object_attributes( &attr, &objattr, &attr_len ))) goto done;
+
+    SERVER_START_REQ( new_thread )
+    {
+        req->process    = wine_server_obj_handle( process_handle );
+        req->access     = THREAD_ALL_ACCESS;
+        req->suspend    = 1;
+        req->request_fd = -1;
+        wine_server_add_data( req, objattr, attr_len );
+        if (!(status = wine_server_call( req )))
+        {
+            thread_handle = wine_server_ptr_handle( reply->handle );
+            thread_id = reply->tid;
+        }
+    }
+    SERVER_END_REQ;
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    if (status) goto done;
+
+    /* create the child process */
+
+    if ((status = spawn_loader( params, socketfd[0], unixdir, winedebug, &pe_info ))) goto done;
+
+    close( socketfd[0] );
+    socketfd[0] = -1;
+
+    /* wait for the new process info to be ready */
+
+    NtWaitForSingleObject( process_info, FALSE, NULL );
+    SERVER_START_REQ( get_new_process_info )
+    {
+        req->info = wine_server_obj_handle( process_info );
+        wine_server_call( req );
+        success = reply->success;
+        status = reply->exit_code;
+    }
+    SERVER_END_REQ;
+
+    if (success)
+    {
+        TRACE( "%s pid %04x tid %04x handles %p/%p\n", debugstr_us( path ),
+               process_id, thread_id, process_handle, thread_handle );
+        info->Process = process_handle;
+        info->Thread = thread_handle;
+        info->ClientId.UniqueProcess = ULongToHandle( process_id );
+        info->ClientId.UniqueThread = ULongToHandle( thread_id );
+        virtual_fill_image_information( &pe_info, &info->ImageInformation );
+        process_handle = thread_handle = 0;
+        status = STATUS_SUCCESS;
+    }
+    else if (!status) status = STATUS_INTERNAL_ERROR;
+
+done:
+    if (file_handle) NtClose( file_handle );
+    if (process_info) NtClose( process_info );
+    if (process_handle) NtClose( process_handle );
+    if (thread_handle) NtClose( thread_handle );
+    if (socketfd[0] != -1) close( socketfd[0] );
+    RtlFreeHeap( GetProcessHeap(), 0, startup_info );
+    RtlFreeHeap( GetProcessHeap(), 0, winedebug );
+    RtlFreeHeap( GetProcessHeap(), 0, unixdir );
+    return status;
 }
 
 /***********************************************************************
@@ -207,5 +1788,16 @@ void WINAPI DbgUiRemoteBreakin( void *arg )
  */
 NTSTATUS WINAPI DbgUiIssueRemoteBreakin( HANDLE process )
 {
-    return unix_funcs->DbgUiIssueRemoteBreakin( process );
+    apc_call_t call;
+    apc_result_t result;
+    NTSTATUS status;
+
+    TRACE( "(%p)\n", process );
+
+    memset( &call, 0, sizeof(call) );
+
+    call.type = APC_BREAK_PROCESS;
+    status = server_queue_process_apc( process, &call, &result );
+    if (status) return status;
+    return result.break_process.status;
 }
diff --git a/dlls/ntdll/reg.c b/dlls/ntdll/reg.c
index 5a54d7fee2..46d4c7029a 100644
--- a/dlls/ntdll/reg.c
+++ b/dlls/ntdll/reg.c
@@ -26,17 +26,75 @@
   *	HKEY_CLASSES		\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <stdio.h>
 #include <string.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
+#include "wine/library.h"
 #include "ntdll_misc.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(reg);
 
+/* maximum length of a value name in bytes (without terminating null) */
+#define MAX_VALUE_LENGTH (16383 * sizeof(WCHAR))
+
+/******************************************************************************
+ * NtCreateKey [NTDLL.@]
+ * ZwCreateKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtCreateKey( PHANDLE retkey, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+                             ULONG TitleIndex, const UNICODE_STRING *class, ULONG options,
+                             PULONG dispos )
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if (!retkey || !attr) return STATUS_ACCESS_VIOLATION;
+    if (attr->Length > sizeof(OBJECT_ATTRIBUTES)) return STATUS_INVALID_PARAMETER;
+
+    TRACE( "(%p,%s,%s,%x,%x,%p)\n", attr->RootDirectory, debugstr_us(attr->ObjectName),
+           debugstr_us(class), options, access, retkey );
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ( create_key )
+    {
+        req->access     = access;
+        req->options    = options;
+        wine_server_add_data( req, objattr, len );
+        if (class) wine_server_add_data( req, class->Buffer, class->Length );
+        ret = wine_server_call( req );
+        *retkey = wine_server_ptr_handle( reply->hkey );
+        if (dispos && !ret) *dispos = reply->created ? REG_CREATED_NEW_KEY : REG_OPENED_EXISTING_KEY;
+    }
+    SERVER_END_REQ;
+
+    TRACE("<- %p\n", *retkey);
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+NTSTATUS WINAPI NtCreateKeyTransacted( PHANDLE retkey, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+                                       ULONG TitleIndex, const UNICODE_STRING *class, ULONG options,
+                                       HANDLE transacted, ULONG *dispos )
+{
+    FIXME( "(%p,%s,%s,%x,%x,%p,%p)\n", attr->RootDirectory, debugstr_us(attr->ObjectName),
+           debugstr_us(class), options, access, transacted, retkey );
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS WINAPI NtRenameKey( HANDLE handle, UNICODE_STRING *name )
+{
+    FIXME( "(%p %s)\n", handle, debugstr_us(name) );
+    return STATUS_NOT_IMPLEMENTED;
+}
 
 /******************************************************************************
  *  RtlpNtCreateKey [NTDLL.@]
@@ -59,6 +117,67 @@ NTSTATUS WINAPI RtlpNtCreateKey( PHANDLE retkey, ACCESS_MASK access, const OBJEC
     return NtCreateKey(retkey, access, attr, 0, NULL, 0, dispos);
 }
 
+static NTSTATUS open_key( PHANDLE retkey, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, ULONG options )
+{
+    NTSTATUS ret;
+
+    if (!retkey || !attr || !attr->ObjectName) return STATUS_ACCESS_VIOLATION;
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    TRACE( "(%p,%s,%x,%p)\n", attr->RootDirectory,
+           debugstr_us(attr->ObjectName), access, retkey );
+    if (options & ~REG_OPTION_OPEN_LINK)
+        FIXME("options %x not implemented\n", options);
+
+    SERVER_START_REQ( open_key )
+    {
+        req->parent     = wine_server_obj_handle( attr->RootDirectory );
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *retkey = wine_server_ptr_handle( reply->hkey );
+    }
+    SERVER_END_REQ;
+    TRACE("<- %p\n", *retkey);
+    return ret;
+}
+
+/******************************************************************************
+ * NtOpenKeyEx [NTDLL.@]
+ * ZwOpenKeyEx [NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenKeyEx( PHANDLE retkey, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, ULONG options )
+{
+    return open_key( retkey, access, attr, options );
+}
+
+/******************************************************************************
+ * NtOpenKey [NTDLL.@]
+ * ZwOpenKey [NTDLL.@]
+ *
+ *   OUT	HANDLE			retkey (returns 0 when failure)
+ *   IN		ACCESS_MASK		access
+ *   IN		POBJECT_ATTRIBUTES 	attr
+ */
+NTSTATUS WINAPI NtOpenKey( PHANDLE retkey, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    return open_key( retkey, access, attr, 0 );
+}
+
+NTSTATUS WINAPI NtOpenKeyTransactedEx( PHANDLE retkey, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+                                       ULONG options, HANDLE transaction )
+{
+    FIXME( "(%p %x %p %x %p)\n", retkey, access, attr, options, transaction );
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS WINAPI NtOpenKeyTransacted( PHANDLE retkey, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+                                     HANDLE transaction )
+{
+    return NtOpenKeyTransactedEx( retkey, access, attr, 0, transaction );
+}
+
 /******************************************************************************
  * RtlpNtOpenKey [NTDLL.@]
  *
@@ -71,6 +190,25 @@ NTSTATUS WINAPI RtlpNtOpenKey( PHANDLE retkey, ACCESS_MASK access, OBJECT_ATTRIB
     return NtOpenKey(retkey, access, attr);
 }
 
+/******************************************************************************
+ * NtDeleteKey [NTDLL.@]
+ * ZwDeleteKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtDeleteKey( HANDLE hkey )
+{
+    NTSTATUS ret;
+
+    TRACE( "(%p)\n", hkey );
+
+    SERVER_START_REQ( delete_key )
+    {
+        req->hkey = wine_server_obj_handle( hkey );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
 /******************************************************************************
  * RtlpNtMakeTemporaryKey [NTDLL.@]
  *
@@ -81,6 +219,163 @@ NTSTATUS WINAPI RtlpNtMakeTemporaryKey( HANDLE hkey )
     return NtDeleteKey(hkey);
 }
 
+/******************************************************************************
+ * NtDeleteValueKey [NTDLL.@]
+ * ZwDeleteValueKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtDeleteValueKey( HANDLE hkey, const UNICODE_STRING *name )
+{
+    NTSTATUS ret;
+
+    TRACE( "(%p,%s)\n", hkey, debugstr_us(name) );
+    if (name->Length > MAX_VALUE_LENGTH) return STATUS_OBJECT_NAME_NOT_FOUND;
+
+    SERVER_START_REQ( delete_key_value )
+    {
+        req->hkey = wine_server_obj_handle( hkey );
+        wine_server_add_data( req, name->Buffer, name->Length );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/******************************************************************************
+ *     enumerate_key
+ *
+ * Implementation of NtQueryKey and NtEnumerateKey
+ */
+static NTSTATUS enumerate_key( HANDLE handle, int index, KEY_INFORMATION_CLASS info_class,
+                               void *info, DWORD length, DWORD *result_len )
+
+{
+    NTSTATUS ret;
+    void *data_ptr;
+    size_t fixed_size;
+
+    switch(info_class)
+    {
+    case KeyBasicInformation:  data_ptr = ((KEY_BASIC_INFORMATION *)info)->Name; break;
+    case KeyFullInformation:   data_ptr = ((KEY_FULL_INFORMATION *)info)->Class; break;
+    case KeyNodeInformation:   data_ptr = ((KEY_NODE_INFORMATION *)info)->Name;  break;
+    case KeyNameInformation:   data_ptr = ((KEY_NAME_INFORMATION *)info)->Name;  break;
+    case KeyCachedInformation: data_ptr = ((KEY_CACHED_INFORMATION *)info)+1;    break;
+    default:
+        FIXME( "Information class %d not implemented\n", info_class );
+        return STATUS_INVALID_PARAMETER;
+    }
+    fixed_size = (char *)data_ptr - (char *)info;
+
+    SERVER_START_REQ( enum_key )
+    {
+        req->hkey       = wine_server_obj_handle( handle );
+        req->index      = index;
+        req->info_class = info_class;
+        if (length > fixed_size) wine_server_set_reply( req, data_ptr, length - fixed_size );
+        if (!(ret = wine_server_call( req )))
+        {
+            switch(info_class)
+            {
+            case KeyBasicInformation:
+                {
+                    KEY_BASIC_INFORMATION keyinfo;
+                    fixed_size = (char *)keyinfo.Name - (char *)&keyinfo;
+                    keyinfo.LastWriteTime.QuadPart = reply->modif;
+                    keyinfo.TitleIndex = 0;
+                    keyinfo.NameLength = reply->namelen;
+                    memcpy( info, &keyinfo, min( length, fixed_size ) );
+                }
+                break;
+            case KeyFullInformation:
+                {
+                    KEY_FULL_INFORMATION keyinfo;
+                    fixed_size = (char *)keyinfo.Class - (char *)&keyinfo;
+                    keyinfo.LastWriteTime.QuadPart = reply->modif;
+                    keyinfo.TitleIndex = 0;
+                    keyinfo.ClassLength = wine_server_reply_size(reply);
+                    keyinfo.ClassOffset = keyinfo.ClassLength ? fixed_size : -1;
+                    keyinfo.SubKeys = reply->subkeys;
+                    keyinfo.MaxNameLen = reply->max_subkey;
+                    keyinfo.MaxClassLen = reply->max_class;
+                    keyinfo.Values = reply->values;
+                    keyinfo.MaxValueNameLen = reply->max_value;
+                    keyinfo.MaxValueDataLen = reply->max_data;
+                    memcpy( info, &keyinfo, min( length, fixed_size ) );
+                }
+                break;
+            case KeyNodeInformation:
+                {
+                    KEY_NODE_INFORMATION keyinfo;
+                    fixed_size = (char *)keyinfo.Name - (char *)&keyinfo;
+                    keyinfo.LastWriteTime.QuadPart = reply->modif;
+                    keyinfo.TitleIndex = 0;
+                    if (reply->namelen < wine_server_reply_size(reply))
+                    {
+                        keyinfo.ClassLength = wine_server_reply_size(reply) - reply->namelen;
+                        keyinfo.ClassOffset = fixed_size + reply->namelen;
+                    }
+                    else
+                    {
+                        keyinfo.ClassLength = 0;
+                        keyinfo.ClassOffset = -1;
+                    }
+                    keyinfo.NameLength = reply->namelen;
+                    memcpy( info, &keyinfo, min( length, fixed_size ) );
+                }
+                break;
+            case KeyNameInformation:
+                {
+                    KEY_NAME_INFORMATION keyinfo;
+                    fixed_size = (char *)keyinfo.Name - (char *)&keyinfo;
+                    keyinfo.NameLength = reply->namelen;
+                    memcpy( info, &keyinfo, min( length, fixed_size ) );
+                }
+                break;
+            case KeyCachedInformation:
+                {
+                    KEY_CACHED_INFORMATION keyinfo;
+                    fixed_size = sizeof(keyinfo);
+                    keyinfo.LastWriteTime.QuadPart = reply->modif;
+                    keyinfo.TitleIndex = 0;
+                    keyinfo.SubKeys = reply->subkeys;
+                    keyinfo.MaxNameLen = reply->max_subkey;
+                    keyinfo.Values = reply->values;
+                    keyinfo.MaxValueNameLen = reply->max_value;
+                    keyinfo.MaxValueDataLen = reply->max_data;
+                    keyinfo.NameLength = reply->namelen;
+                    memcpy( info, &keyinfo, min( length, fixed_size ) );
+                }
+                break;
+            default:
+                break;
+            }
+            *result_len = fixed_size + reply->total;
+            if (length < *result_len) ret = STATUS_BUFFER_OVERFLOW;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+
+/******************************************************************************
+ * NtEnumerateKey [NTDLL.@]
+ * ZwEnumerateKey [NTDLL.@]
+ *
+ * NOTES
+ *  the name copied into the buffer is NOT 0-terminated
+ */
+NTSTATUS WINAPI NtEnumerateKey( HANDLE handle, ULONG index, KEY_INFORMATION_CLASS info_class,
+                                void *info, DWORD length, DWORD *result_len )
+{
+    /* -1 means query key, so avoid it here */
+    if (index == (ULONG)-1) return STATUS_NO_MORE_ENTRIES;
+    return enumerate_key( handle, index, info_class, info, length, result_len );
+}
+
+
 /******************************************************************************
  * RtlpNtEnumerateSubKey [NTDLL.@]
  *
@@ -127,6 +422,175 @@ NTSTATUS WINAPI RtlpNtEnumerateSubKey( HANDLE handle, UNICODE_STRING *out, ULONG
   return ret;
 }
 
+/******************************************************************************
+ * NtQueryKey [NTDLL.@]
+ * ZwQueryKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtQueryKey( HANDLE handle, KEY_INFORMATION_CLASS info_class,
+                            void *info, DWORD length, DWORD *result_len )
+{
+    return enumerate_key( handle, -1, info_class, info, length, result_len );
+}
+
+
+/* fill the key value info structure for a specific info class */
+static void copy_key_value_info( KEY_VALUE_INFORMATION_CLASS info_class, void *info,
+                                 DWORD length, int type, int name_len, int data_len )
+{
+    switch(info_class)
+    {
+    case KeyValueBasicInformation:
+        {
+            KEY_VALUE_BASIC_INFORMATION keyinfo;
+            keyinfo.TitleIndex = 0;
+            keyinfo.Type       = type;
+            keyinfo.NameLength = name_len;
+            length = min( length, (char *)keyinfo.Name - (char *)&keyinfo );
+            memcpy( info, &keyinfo, length );
+            break;
+        }
+    case KeyValueFullInformation:
+        {
+            KEY_VALUE_FULL_INFORMATION keyinfo;
+            keyinfo.TitleIndex = 0;
+            keyinfo.Type       = type;
+            keyinfo.DataOffset = (char *)keyinfo.Name - (char *)&keyinfo + name_len;
+            keyinfo.DataLength = data_len;
+            keyinfo.NameLength = name_len;
+            length = min( length, (char *)keyinfo.Name - (char *)&keyinfo );
+            memcpy( info, &keyinfo, length );
+            break;
+        }
+    case KeyValuePartialInformation:
+        {
+            KEY_VALUE_PARTIAL_INFORMATION keyinfo;
+            keyinfo.TitleIndex = 0;
+            keyinfo.Type       = type;
+            keyinfo.DataLength = data_len;
+            length = min( length, (char *)keyinfo.Data - (char *)&keyinfo );
+            memcpy( info, &keyinfo, length );
+            break;
+        }
+    default:
+        break;
+    }
+}
+
+
+/******************************************************************************
+ *  NtEnumerateValueKey	[NTDLL.@]
+ *  ZwEnumerateValueKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtEnumerateValueKey( HANDLE handle, ULONG index,
+                                     KEY_VALUE_INFORMATION_CLASS info_class,
+                                     void *info, DWORD length, DWORD *result_len )
+{
+    NTSTATUS ret;
+    void *ptr;
+    size_t fixed_size;
+
+    TRACE( "(%p,%u,%d,%p,%d)\n", handle, index, info_class, info, length );
+
+    /* compute the length we want to retrieve */
+    switch(info_class)
+    {
+    case KeyValueBasicInformation:   ptr = ((KEY_VALUE_BASIC_INFORMATION *)info)->Name; break;
+    case KeyValueFullInformation:    ptr = ((KEY_VALUE_FULL_INFORMATION *)info)->Name; break;
+    case KeyValuePartialInformation: ptr = ((KEY_VALUE_PARTIAL_INFORMATION *)info)->Data; break;
+    default:
+        FIXME( "Information class %d not implemented\n", info_class );
+        return STATUS_INVALID_PARAMETER;
+    }
+    fixed_size = (char *)ptr - (char *)info;
+
+    SERVER_START_REQ( enum_key_value )
+    {
+        req->hkey       = wine_server_obj_handle( handle );
+        req->index      = index;
+        req->info_class = info_class;
+        if (length > fixed_size) wine_server_set_reply( req, ptr, length - fixed_size );
+        if (!(ret = wine_server_call( req )))
+        {
+            copy_key_value_info( info_class, info, length, reply->type, reply->namelen,
+                                 wine_server_reply_size(reply) - reply->namelen );
+            *result_len = fixed_size + reply->total;
+            if (length < *result_len) ret = STATUS_BUFFER_OVERFLOW;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/******************************************************************************
+ * NtQueryValueKey [NTDLL.@]
+ * ZwQueryValueKey [NTDLL.@]
+ *
+ * NOTES
+ *  the name in the KeyValueInformation is never set
+ */
+NTSTATUS WINAPI DECLSPEC_HOTPATCH NtQueryValueKey( HANDLE handle, const UNICODE_STRING *name,
+                                 KEY_VALUE_INFORMATION_CLASS info_class,
+                                 void *info, DWORD length, DWORD *result_len )
+{
+    NTSTATUS ret;
+    UCHAR *data_ptr;
+    unsigned int fixed_size, min_size;
+
+    TRACE( "(%p,%s,%d,%p,%d)\n", handle, debugstr_us(name), info_class, info, length );
+
+    if (name->Length > MAX_VALUE_LENGTH) return STATUS_OBJECT_NAME_NOT_FOUND;
+
+    /* compute the length we want to retrieve */
+    switch(info_class)
+    {
+    case KeyValueBasicInformation:
+    {
+        KEY_VALUE_BASIC_INFORMATION *basic_info = info;
+        min_size = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name);
+        fixed_size = min_size + name->Length;
+        if (min_size < length)
+            memcpy(basic_info->Name, name->Buffer, min(length - min_size, name->Length));
+        data_ptr = NULL;
+        break;
+    }
+    case KeyValueFullInformation:
+    {
+        KEY_VALUE_FULL_INFORMATION *full_info = info;
+        min_size = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name);
+        fixed_size = min_size + name->Length;
+        if (min_size < length)
+            memcpy(full_info->Name, name->Buffer, min(length - min_size, name->Length));
+        data_ptr = (UCHAR *)full_info->Name + name->Length;
+        break;
+    }
+    case KeyValuePartialInformation:
+        min_size = fixed_size = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
+        data_ptr = ((KEY_VALUE_PARTIAL_INFORMATION *)info)->Data;
+        break;
+    default:
+        FIXME( "Information class %d not implemented\n", info_class );
+        return STATUS_INVALID_PARAMETER;
+    }
+
+    SERVER_START_REQ( get_key_value )
+    {
+        req->hkey = wine_server_obj_handle( handle );
+        wine_server_add_data( req, name->Buffer, name->Length );
+        if (length > fixed_size && data_ptr) wine_server_set_reply( req, data_ptr, length - fixed_size );
+        if (!(ret = wine_server_call( req )))
+        {
+            copy_key_value_info( info_class, info, length, reply->type,
+                                 name->Length, reply->total );
+            *result_len = fixed_size + (info_class == KeyValueBasicInformation ? 0 : reply->total);
+            if (length < min_size) ret = STATUS_BUFFER_TOO_SMALL;
+            else if (length < *result_len) ret = STATUS_BUFFER_OVERFLOW;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
 /******************************************************************************
  * RtlpNtQueryValueKey [NTDLL.@]
  *
@@ -163,6 +627,257 @@ NTSTATUS WINAPI RtlpNtQueryValueKey( HANDLE handle, ULONG *result_type, PBYTE de
     return ret;
 }
 
+/******************************************************************************
+ *  NtFlushKey	[NTDLL.@]
+ *  ZwFlushKey  [NTDLL.@]
+ */
+NTSTATUS WINAPI NtFlushKey(HANDLE key)
+{
+    NTSTATUS ret;
+
+    TRACE("key=%p\n", key);
+
+    SERVER_START_REQ( flush_key )
+    {
+	req->hkey = wine_server_obj_handle( key );
+	ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    
+    return ret;
+}
+
+/******************************************************************************
+ *  NtLoadKey	[NTDLL.@]
+ *  ZwLoadKey   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtLoadKey( const OBJECT_ATTRIBUTES *attr, OBJECT_ATTRIBUTES *file )
+{
+    NTSTATUS ret;
+    HANDLE hive;
+    IO_STATUS_BLOCK io;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    TRACE("(%p,%p)\n", attr, file);
+
+    ret = NtCreateFile(&hive, GENERIC_READ | SYNCHRONIZE, file, &io, NULL, FILE_ATTRIBUTE_NORMAL, 0,
+                       FILE_OPEN, 0, NULL, 0);
+    if (ret) return ret;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ( load_registry )
+    {
+        req->file = wine_server_obj_handle( hive );
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    NtClose(hive);
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+/******************************************************************************
+ *  NtLoadKey2  [NTDLL.@]
+ *  ZwLoadKey2  [NTDLL.@]
+ */
+NTSTATUS WINAPI NtLoadKey2(OBJECT_ATTRIBUTES *attr, OBJECT_ATTRIBUTES *file, ULONG flags)
+{
+    FIXME("(%p,%p,0x%08x) semi-stub: ignoring flags\n", attr, file, flags);
+    return NtLoadKey(attr, file);
+}
+
+/******************************************************************************
+ *  NtNotifyChangeMultipleKeys  [NTDLL.@]
+ *  ZwNotifyChangeMultipleKeys  [NTDLL.@]
+ */
+NTSTATUS WINAPI NtNotifyChangeMultipleKeys(
+        HANDLE KeyHandle,
+        ULONG Count,
+        OBJECT_ATTRIBUTES *SubordinateObjects,
+        HANDLE Event,
+        PIO_APC_ROUTINE ApcRoutine,
+        PVOID ApcContext,
+        PIO_STATUS_BLOCK IoStatusBlock,
+        ULONG CompletionFilter,
+        BOOLEAN WatchSubtree,
+        PVOID ChangeBuffer,
+        ULONG Length,
+        BOOLEAN Asynchronous)
+{
+    NTSTATUS ret;
+
+    TRACE("(%p,%u,%p,%p,%p,%p,%p,0x%08x, 0x%08x,%p,0x%08x,0x%08x)\n",
+        KeyHandle, Count, SubordinateObjects, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter,
+        Asynchronous, ChangeBuffer, Length, WatchSubtree);
+
+    if (Count || SubordinateObjects || ApcRoutine || ApcContext || ChangeBuffer || Length)
+        FIXME("Unimplemented optional parameter\n");
+
+    if (!Asynchronous)
+    {
+        OBJECT_ATTRIBUTES attr;
+        InitializeObjectAttributes( &attr, NULL, 0, NULL, NULL );
+        ret = NtCreateEvent( &Event, EVENT_ALL_ACCESS, &attr, SynchronizationEvent, FALSE );
+        if (ret != STATUS_SUCCESS)
+            return ret;
+    }
+
+    SERVER_START_REQ( set_registry_notification )
+    {
+        req->hkey    = wine_server_obj_handle( KeyHandle );
+        req->event   = wine_server_obj_handle( Event );
+        req->subtree = WatchSubtree;
+        req->filter  = CompletionFilter;
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+ 
+    if (!Asynchronous)
+    {
+        if (ret == STATUS_PENDING)
+            ret = NtWaitForSingleObject( Event, FALSE, NULL );
+        NtClose( Event );
+    }
+
+    return ret;
+}
+
+/******************************************************************************
+ *  NtNotifyChangeKey	[NTDLL.@]
+ *  ZwNotifyChangeKey   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtNotifyChangeKey(
+	IN HANDLE KeyHandle,
+	IN HANDLE Event,
+	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
+	IN PVOID ApcContext OPTIONAL,
+	OUT PIO_STATUS_BLOCK IoStatusBlock,
+	IN ULONG CompletionFilter,
+	IN BOOLEAN WatchSubtree,
+	OUT PVOID ChangeBuffer,
+	IN ULONG Length,
+	IN BOOLEAN Asynchronous)
+{
+    return NtNotifyChangeMultipleKeys(KeyHandle, 0, NULL, Event, ApcRoutine, ApcContext,
+                                      IoStatusBlock, CompletionFilter, WatchSubtree,
+                                      ChangeBuffer, Length, Asynchronous);
+}
+
+/******************************************************************************
+ * NtQueryMultipleValueKey [NTDLL]
+ * ZwQueryMultipleValueKey
+ */
+
+NTSTATUS WINAPI NtQueryMultipleValueKey(
+	HANDLE KeyHandle,
+	PKEY_MULTIPLE_VALUE_INFORMATION ListOfValuesToQuery,
+	ULONG NumberOfItems,
+	PVOID MultipleValueInformation,
+	ULONG Length,
+	PULONG  ReturnLength)
+{
+	FIXME("(%p,%p,0x%08x,%p,0x%08x,%p) stub!\n",
+	KeyHandle, ListOfValuesToQuery, NumberOfItems, MultipleValueInformation,
+	Length,ReturnLength);
+	return STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * NtReplaceKey [NTDLL.@]
+ * ZwReplaceKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtReplaceKey(
+	IN POBJECT_ATTRIBUTES ObjectAttributes,
+	IN HANDLE Key,
+	IN POBJECT_ATTRIBUTES ReplacedObjectAttributes)
+{
+    FIXME("(%s,%p,%s),stub!\n", debugstr_ObjectAttributes(ObjectAttributes), Key,
+          debugstr_ObjectAttributes(ReplacedObjectAttributes) );
+    return STATUS_SUCCESS;
+}
+/******************************************************************************
+ * NtRestoreKey [NTDLL.@]
+ * ZwRestoreKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtRestoreKey(
+	HANDLE KeyHandle,
+	HANDLE FileHandle,
+	ULONG RestoreFlags)
+{
+	FIXME("(%p,%p,0x%08x) stub\n",
+	KeyHandle, FileHandle, RestoreFlags);
+	return STATUS_SUCCESS;
+}
+/******************************************************************************
+ * NtSaveKey [NTDLL.@]
+ * ZwSaveKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtSaveKey(IN HANDLE KeyHandle, IN HANDLE FileHandle)
+{
+    NTSTATUS ret;
+
+    TRACE("(%p,%p)\n", KeyHandle, FileHandle);
+
+    SERVER_START_REQ( save_registry )
+    {
+        req->hkey = wine_server_obj_handle( KeyHandle );
+        req->file = wine_server_obj_handle( FileHandle );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+/******************************************************************************
+ * NtSetInformationKey [NTDLL.@]
+ * ZwSetInformationKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtSetInformationKey(
+	IN HANDLE KeyHandle,
+	IN const int KeyInformationClass,
+	IN PVOID KeyInformation,
+	IN ULONG KeyInformationLength)
+{
+	FIXME("(%p,0x%08x,%p,0x%08x) stub\n",
+	KeyHandle, KeyInformationClass, KeyInformation, KeyInformationLength);
+	return STATUS_SUCCESS;
+}
+
+
+/******************************************************************************
+ * NtSetValueKey [NTDLL.@]
+ * ZwSetValueKey [NTDLL.@]
+ *
+ * NOTES
+ *   win95 does not care about count for REG_SZ and finds out the len by itself (js)
+ *   NT does definitely care (aj)
+ */
+NTSTATUS WINAPI NtSetValueKey( HANDLE hkey, const UNICODE_STRING *name, ULONG TitleIndex,
+                               ULONG type, const void *data, ULONG count )
+{
+    NTSTATUS ret;
+
+    TRACE( "(%p,%s,%d,%p,%d)\n", hkey, debugstr_us(name), type, data, count );
+
+    if (name->Length > MAX_VALUE_LENGTH) return STATUS_INVALID_PARAMETER;
+
+    SERVER_START_REQ( set_key_value )
+    {
+        req->hkey    = wine_server_obj_handle( hkey );
+        req->type    = type;
+        req->namelen = name->Length;
+        wine_server_add_data( req, name->Buffer, name->Length );
+        wine_server_add_data( req, data, count );
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
 /******************************************************************************
  * RtlpNtSetValueKey [NTDLL.@]
  *
@@ -176,6 +891,26 @@ NTSTATUS WINAPI RtlpNtSetValueKey( HANDLE hkey, ULONG type, const void *data,
     return NtSetValueKey( hkey, &name, 0, type, data, count );
 }
 
+/******************************************************************************
+ * NtUnloadKey [NTDLL.@]
+ * ZwUnloadKey [NTDLL.@]
+ */
+NTSTATUS WINAPI NtUnloadKey(IN POBJECT_ATTRIBUTES attr)
+{
+    NTSTATUS ret;
+
+    TRACE("(%p)\n", attr);
+
+    SERVER_START_REQ( unload_registry )
+    {
+        req->hkey = wine_server_obj_handle( attr->RootDirectory );
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
 /******************************************************************************
  *  RtlFormatCurrentUserKeyPath		[NTDLL.@]
  *
@@ -796,3 +1531,67 @@ NTSTATUS WINAPI RtlWriteRegistryValue( ULONG RelativeTo, PCWSTR path, PCWSTR nam
 
     return status;
 }
+
+/*************************************************************************
+ * NtQueryLicenseValue   [NTDLL.@]
+ *
+ * NOTES
+ *  On Windows all license properties are stored in a single key, but
+ *  unless there is some app which explicitly depends on that, there is
+ *  no good reason to reproduce that.
+ */
+NTSTATUS WINAPI NtQueryLicenseValue( const UNICODE_STRING *name, ULONG *result_type,
+                                     PVOID data, ULONG length, ULONG *result_len )
+{
+    static const WCHAR LicenseInformationW[] = {'M','a','c','h','i','n','e','\\',
+                                                'S','o','f','t','w','a','r','e','\\',
+                                                'W','i','n','e','\\','L','i','c','e','n','s','e',
+                                                'I','n','f','o','r','m','a','t','i','o','n',0};
+    KEY_VALUE_PARTIAL_INFORMATION *info;
+    NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
+    DWORD info_length, count;
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING keyW;
+    HANDLE hkey;
+
+    if (!name || !name->Buffer || !name->Length || !result_len)
+        return STATUS_INVALID_PARAMETER;
+
+    info_length = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + length;
+    info = RtlAllocateHeap( GetProcessHeap(), 0, info_length );
+    if (!info) return STATUS_NO_MEMORY;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &keyW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString( &keyW, LicenseInformationW );
+
+    /* @@ Wine registry key: HKLM\Software\Wine\LicenseInformation */
+    if (!NtOpenKey( &hkey, KEY_READ, &attr ))
+    {
+        status = NtQueryValueKey( hkey, name, KeyValuePartialInformation,
+                                  info, info_length, &count );
+        if (!status || status == STATUS_BUFFER_OVERFLOW)
+        {
+            if (result_type)
+                *result_type = info->Type;
+
+            *result_len = info->DataLength;
+
+            if (status == STATUS_BUFFER_OVERFLOW)
+                status = STATUS_BUFFER_TOO_SMALL;
+            else
+                memcpy( data, info->Data, info->DataLength );
+        }
+        NtClose( hkey );
+    }
+
+    if (status == STATUS_OBJECT_NAME_NOT_FOUND)
+        FIXME( "License key %s not found\n", debugstr_w(name->Buffer) );
+
+    RtlFreeHeap( GetProcessHeap(), 0, info );
+    return status;
+}
diff --git a/dlls/ntdll/relay.c b/dlls/ntdll/relay.c
index e159631249..6d819aeef1 100644
--- a/dlls/ntdll/relay.c
+++ b/dlls/ntdll/relay.c
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <string.h>
 #include <stdarg.h>
diff --git a/dlls/ntdll/resource.c b/dlls/ntdll/resource.c
index 981c538a8e..2d8c2edea0 100644
--- a/dlls/ntdll/resource.c
+++ b/dlls/ntdll/resource.c
@@ -25,6 +25,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <stdlib.h>
 #include <sys/types.h>
diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index ca4fea8420..a974bfbf31 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -23,18 +23,27 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
+#include "config.h"
+#include "wine/port.h"
 
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
 #include "ntstatus.h"
 #define NONAMELESSUNION
 #define NONAMELESSSTRUCT
 #define WIN32_NO_STATUS
-#include "winsock2.h"
+#define USE_WS_PREFIX
 #include "windef.h"
 #include "winternl.h"
 #include "wine/debug.h"
 #include "wine/exception.h"
 #include "ntdll_misc.h"
+#include "inaddr.h"
 #include "in6addr.h"
 #include "ddk/ntddk.h"
 
@@ -306,7 +315,7 @@ NTSTATUS WINAPIV DbgPrint(LPCSTR fmt, ...)
   __ms_va_list args;
 
   __ms_va_start(args, fmt);
-  _vsnprintf(buf, sizeof(buf), fmt, args);
+  NTDLL__vsnprintf(buf, sizeof(buf), fmt, args);
   __ms_va_end(args);
 
   MESSAGE("DbgPrint says: %s",buf);
@@ -344,7 +353,7 @@ NTSTATUS WINAPI vDbgPrintExWithPrefix( LPCSTR prefix, ULONG id, ULONG level, LPC
 {
     char buf[1024];
 
-    _vsnprintf(buf, sizeof(buf), fmt, args);
+    NTDLL__vsnprintf(buf, sizeof(buf), fmt, args);
 
     switch (level & DPFLTR_MASK)
     {
@@ -1301,11 +1310,11 @@ NTSTATUS WINAPI RtlIpv4AddressToStringExW(const IN_ADDR *pin, USHORT port, LPWST
 
     TRACE("(%p:0x%x, %d, %p, %p:%d)\n", pin, pin->S_un.S_addr, port, buffer, psize, *psize);
 
-    needed = swprintf(tmp_ip, ARRAY_SIZE(tmp_ip), fmt_ip,
+    needed = NTDLL_swprintf(tmp_ip, fmt_ip,
                       pin->S_un.S_un_b.s_b1, pin->S_un.S_un_b.s_b2,
                       pin->S_un.S_un_b.s_b3, pin->S_un.S_un_b.s_b4);
 
-    if (port) needed += swprintf(tmp_ip + needed, ARRAY_SIZE(tmp_ip) - needed, fmt_port, ntohs(port));
+    if (port) needed += NTDLL_swprintf(tmp_ip + needed, fmt_port, ntohs(port));
 
     if (*psize > needed) {
         *psize = needed + 1;
diff --git a/dlls/ntdll/rtlbitmap.c b/dlls/ntdll/rtlbitmap.c
index 16761f3449..d0a4e5cf28 100644
--- a/dlls/ntdll/rtlbitmap.c
+++ b/dlls/ntdll/rtlbitmap.c
@@ -662,7 +662,7 @@ CCHAR WINAPI RtlFindLeastSignificantBit(ULONGLONG ulLong)
  *
  * Internal helper: qsort comparison function for RTL_BITMAP_RUN arrays
  */
-static int __cdecl NTDLL_RunSortFn(const void *lhs, const void *rhs)
+static int NTDLL_RunSortFn(const void *lhs, const void *rhs)
 {
   if (((const RTL_BITMAP_RUN*)lhs)->NumberOfBits > ((const RTL_BITMAP_RUN*)rhs)->NumberOfBits)
     return -1;
diff --git a/dlls/ntdll/rtlstr.c b/dlls/ntdll/rtlstr.c
index d8ff81b805..534e42e8e3 100644
--- a/dlls/ntdll/rtlstr.c
+++ b/dlls/ntdll/rtlstr.c
@@ -20,6 +20,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <assert.h>
 #include <stdarg.h>
 #include <stdlib.h>
@@ -1699,7 +1701,7 @@ NTSTATUS WINAPI RtlStringFromGUID(const GUID* guid, UNICODE_STRING *str)
     str->Length = str->MaximumLength = 0;
     return STATUS_NO_MEMORY;
   }
-  swprintf(str->Buffer, str->MaximumLength/sizeof(WCHAR), szFormat, guid->Data1, guid->Data2, guid->Data3,
+  NTDLL_swprintf(str->Buffer, szFormat, guid->Data1, guid->Data2, guid->Data3,
           guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
           guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7]);
 
diff --git a/dlls/ntdll/sec.c b/dlls/ntdll/sec.c
index 70828a76c6..4e12353584 100644
--- a/dlls/ntdll/sec.c
+++ b/dlls/ntdll/sec.c
@@ -19,18 +19,25 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <ctype.h>
 #include <math.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "ntdll_misc.h"
 #include "wine/exception.h"
+#include "wine/library.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
@@ -1603,6 +1610,202 @@ RtlImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     return Status;
 }
 
+/******************************************************************************
+ *  NtImpersonateAnonymousToken      [NTDLL.@]
+ */
+NTSTATUS WINAPI
+NtImpersonateAnonymousToken(HANDLE thread)
+{
+    FIXME("(%p): stub\n", thread);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *  NtAccessCheck		[NTDLL.@]
+ *  ZwAccessCheck		[NTDLL.@]
+ *
+ * Checks that a user represented by a token is allowed to access an object
+ * represented by a security descriptor.
+ *
+ * PARAMS
+ *  SecurityDescriptor [I] The security descriptor of the object to check.
+ *  ClientToken        [I] Token of the user accessing the object.
+ *  DesiredAccess      [I] The desired access to the object.
+ *  GenericMapping     [I] Mapping used to transform access rights in the SD to their specific forms.
+ *  PrivilegeSet       [I/O] Privileges used during the access check.
+ *  ReturnLength       [O] Number of bytes stored into PrivilegeSet.
+ *  GrantedAccess      [O] The actual access rights granted.
+ *  AccessStatus       [O] The status of the access check.
+ *
+ * RETURNS
+ *  NTSTATUS code.
+ *
+ * NOTES
+ *  DesiredAccess may be MAXIMUM_ALLOWED, in which case the function determines
+ *  the maximum access rights allowed by the SD and returns them in
+ *  GrantedAccess.
+ *  The SecurityDescriptor must have a valid owner and groups present,
+ *  otherwise the function will fail.
+ */
+NTSTATUS WINAPI
+NtAccessCheck(
+    PSECURITY_DESCRIPTOR SecurityDescriptor,
+    HANDLE ClientToken,
+    ACCESS_MASK DesiredAccess,
+    PGENERIC_MAPPING GenericMapping,
+    PPRIVILEGE_SET PrivilegeSet,
+    PULONG ReturnLength,
+    PULONG GrantedAccess,
+    NTSTATUS *AccessStatus)
+{
+    NTSTATUS status;
+
+    TRACE("(%p, %p, %08x, %p, %p, %p, %p, %p)\n",
+        SecurityDescriptor, ClientToken, DesiredAccess, GenericMapping,
+        PrivilegeSet, ReturnLength, GrantedAccess, AccessStatus);
+
+    if (!PrivilegeSet || !ReturnLength)
+        return STATUS_ACCESS_VIOLATION;
+
+    SERVER_START_REQ( access_check )
+    {
+        struct security_descriptor sd;
+        PSID owner;
+        PSID group;
+        PACL sacl;
+        PACL dacl;
+        BOOLEAN defaulted, present;
+        DWORD revision;
+        SECURITY_DESCRIPTOR_CONTROL control;
+
+        req->handle = wine_server_obj_handle( ClientToken );
+        req->desired_access = DesiredAccess;
+        req->mapping_read = GenericMapping->GenericRead;
+        req->mapping_write = GenericMapping->GenericWrite;
+        req->mapping_execute = GenericMapping->GenericExecute;
+        req->mapping_all = GenericMapping->GenericAll;
+
+        /* marshal security descriptor */
+        RtlGetControlSecurityDescriptor( SecurityDescriptor, &control, &revision );
+        sd.control = control & ~SE_SELF_RELATIVE;
+        RtlGetOwnerSecurityDescriptor( SecurityDescriptor, &owner, &defaulted );
+        sd.owner_len = RtlLengthSid( owner );
+        RtlGetGroupSecurityDescriptor( SecurityDescriptor, &group, &defaulted );
+        sd.group_len = RtlLengthSid( group );
+        RtlGetSaclSecurityDescriptor( SecurityDescriptor, &present, &sacl, &defaulted );
+        sd.sacl_len = ((present && sacl) ? acl_bytesInUse(sacl) : 0);
+        RtlGetDaclSecurityDescriptor( SecurityDescriptor, &present, &dacl, &defaulted );
+        sd.dacl_len = ((present && dacl) ? acl_bytesInUse(dacl) : 0);
+
+        wine_server_add_data( req, &sd, sizeof(sd) );
+        wine_server_add_data( req, owner, sd.owner_len );
+        wine_server_add_data( req, group, sd.group_len );
+        wine_server_add_data( req, sacl, sd.sacl_len );
+        wine_server_add_data( req, dacl, sd.dacl_len );
+
+        wine_server_set_reply( req, PrivilegeSet->Privilege, *ReturnLength - FIELD_OFFSET( PRIVILEGE_SET, Privilege ) );
+
+        status = wine_server_call( req );
+
+        *ReturnLength = FIELD_OFFSET( PRIVILEGE_SET, Privilege ) + reply->privileges_len;
+        PrivilegeSet->PrivilegeCount = reply->privileges_len / sizeof(LUID_AND_ATTRIBUTES);
+
+        if (status == STATUS_SUCCESS)
+        {
+            *AccessStatus = reply->access_status;
+            *GrantedAccess = reply->access_granted;
+        }
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
+
+/******************************************************************************
+ *  NtSetSecurityObject		[NTDLL.@]
+ *  ZwSetSecurityObject		[NTDLL.@]
+ *
+ * Sets specified parts of the object's security descriptor.
+ *
+ * PARAMS
+ *  Handle              [I] Handle to the object to change security descriptor of.
+ *  SecurityInformation [I] Specifies which parts of the security descriptor to set.
+ *  SecurityDescriptor  [I] New parts of a security descriptor for the object.
+ *
+ * RETURNS
+ *  NTSTATUS code.
+ *
+ */
+NTSTATUS WINAPI NtSetSecurityObject(HANDLE Handle,
+        SECURITY_INFORMATION SecurityInformation,
+        PSECURITY_DESCRIPTOR SecurityDescriptor)
+{
+    NTSTATUS status;
+    struct security_descriptor sd;
+    PACL dacl = NULL, sacl = NULL;
+    PSID owner = NULL, group = NULL;
+    BOOLEAN defaulted, present;
+    DWORD revision;
+    SECURITY_DESCRIPTOR_CONTROL control;
+
+    TRACE("%p 0x%08x %p\n", Handle, SecurityInformation, SecurityDescriptor);
+
+    if (!SecurityDescriptor) return STATUS_ACCESS_VIOLATION;
+
+    memset( &sd, 0, sizeof(sd) );
+    status = RtlGetControlSecurityDescriptor( SecurityDescriptor, &control, &revision );
+    if (status != STATUS_SUCCESS) return status;
+    sd.control = control & ~SE_SELF_RELATIVE;
+
+    if (SecurityInformation & OWNER_SECURITY_INFORMATION)
+    {
+        status = RtlGetOwnerSecurityDescriptor( SecurityDescriptor, &owner, &defaulted );
+        if (status != STATUS_SUCCESS) return status;
+        if (!(sd.owner_len = RtlLengthSid( owner )))
+            return STATUS_INVALID_SECURITY_DESCR;
+    }
+
+    if (SecurityInformation & GROUP_SECURITY_INFORMATION)
+    {
+        status = RtlGetGroupSecurityDescriptor( SecurityDescriptor, &group, &defaulted );
+        if (status != STATUS_SUCCESS) return status;
+        if (!(sd.group_len = RtlLengthSid( group )))
+            return STATUS_INVALID_SECURITY_DESCR;
+    }
+
+    if (SecurityInformation & SACL_SECURITY_INFORMATION ||
+        SecurityInformation & LABEL_SECURITY_INFORMATION)
+    {
+        status = RtlGetSaclSecurityDescriptor( SecurityDescriptor, &present, &sacl, &defaulted );
+        if (status != STATUS_SUCCESS) return status;
+        sd.sacl_len = (sacl && present) ? acl_bytesInUse(sacl) : 0;
+        sd.control |= SE_SACL_PRESENT;
+    }
+
+    if (SecurityInformation & DACL_SECURITY_INFORMATION)
+    {
+        status = RtlGetDaclSecurityDescriptor( SecurityDescriptor, &present, &dacl, &defaulted );
+        if (status != STATUS_SUCCESS) return status;
+        sd.dacl_len = (dacl && present) ? acl_bytesInUse(dacl) : 0;
+        sd.control |= SE_DACL_PRESENT;
+    }
+
+    SERVER_START_REQ( set_security_object )
+    {
+        req->handle = wine_server_obj_handle( Handle );
+        req->security_info = SecurityInformation;
+
+        wine_server_add_data( req, &sd, sizeof(sd) );
+        wine_server_add_data( req, owner, sd.owner_len );
+        wine_server_add_data( req, group, sd.group_len );
+        wine_server_add_data( req, sacl, sd.sacl_len );
+        wine_server_add_data( req, dacl, sd.dacl_len );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
 
 /******************************************************************************
  * RtlConvertSidToUnicodeString (NTDLL.@)
@@ -1624,14 +1827,13 @@ NTSTATUS WINAPI RtlConvertSidToUnicodeString(
     DWORD i, len;
 
     *p++ = 'S';
-    p += swprintf( p, ARRAY_SIZE(buffer) - (p - buffer), formatW, sid->Revision );
-    p += swprintf( p, ARRAY_SIZE(buffer) - (p - buffer), formatW,
-                   MAKELONG( MAKEWORD( sid->IdentifierAuthority.Value[5],
-                                       sid->IdentifierAuthority.Value[4] ),
-                             MAKEWORD( sid->IdentifierAuthority.Value[3],
-                                       sid->IdentifierAuthority.Value[2] )));
+    p += NTDLL_swprintf( p, formatW, sid->Revision );
+    p += NTDLL_swprintf( p, formatW, MAKELONG( MAKEWORD( sid->IdentifierAuthority.Value[5],
+                                                   sid->IdentifierAuthority.Value[4] ),
+                                         MAKEWORD( sid->IdentifierAuthority.Value[3],
+                                                   sid->IdentifierAuthority.Value[2] )));
     for (i = 0; i < sid->SubAuthorityCount; i++)
-        p += swprintf( p, ARRAY_SIZE(buffer) - (p - buffer), formatW, sid->SubAuthority[i] );
+        p += NTDLL_swprintf( p, formatW, sid->SubAuthority[i] );
 
     len = (p + 1 - buffer) * sizeof(WCHAR);
 
diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/serial.c
similarity index 86%
rename from dlls/ntdll/unix/serial.c
rename to dlls/ntdll/serial.c
index 9454185e17..66fb840167 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/serial.c
@@ -1,7 +1,6 @@
-/*
- * Serial device support
+/* Main file for COMM support
  *
- * Copyright 1993 Erik Bos
+ * DEC 93 Erik Bos <erik@xs4all.nl>
  * Copyright 1996 Marcus Meissner
  * Copyright 2005,2006 Eric Pouech
  *
@@ -20,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 #include "wine/port.h"
 
@@ -66,8 +61,9 @@
 #include "winternl.h"
 #include "winioctl.h"
 #include "ddk/ntddser.h"
+#include "ntdll_misc.h"
 #include "wine/server.h"
-#include "unix_private.h"
+#include "wine/library.h"
 #include "wine/debug.h"
 
 #ifdef HAVE_LINUX_SERIAL_H
@@ -134,11 +130,11 @@ static NTSTATUS get_baud_rate(int fd, SERIAL_BAUD_RATE* sbr)
 {
     struct termios port;
     int speed;
-
+    
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     speed = cfgetospeed(&port);
     switch (speed)
@@ -216,7 +212,7 @@ static NTSTATUS get_hand_flow(int fd, SERIAL_HANDFLOW* shf)
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     /* termios does not support DTR/DSR flow control */
     shf->ControlHandShake = 0;
@@ -264,13 +260,13 @@ static NTSTATUS get_hand_flow(int fd, SERIAL_HANDFLOW* shf)
 static NTSTATUS get_line_control(int fd, SERIAL_LINE_CONTROL* slc)
 {
     struct termios port;
-
+    
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
-
+    
 #ifdef CMSPAR
     switch (port.c_cflag & (PARENB | PARODD | CMSPAR))
 #else
@@ -337,7 +333,7 @@ static NTSTATUS get_modem_status(int fd, DWORD* lpModemStat)
         return STATUS_SUCCESS;
     }
     WARN("TIOCMGET err %s\n", strerror(errno));
-    status = errno_to_status( errno );
+    status = FILE_GetNtStatus();
 #endif
     return status;
 }
@@ -370,11 +366,11 @@ static NTSTATUS get_properties(int fd, SERIAL_COMMPROP *prop)
 static NTSTATUS get_special_chars(int fd, SERIAL_CHARS* sc)
 {
     struct termios port;
-
+    
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     sc->EofChar   = port.c_cc[VEOF];
     sc->ErrorChar = 0xFF;
@@ -398,7 +394,7 @@ static NTSTATUS get_status(int fd, SERIAL_STATUS* ss)
     if (ioctl(fd, TIOCOUTQ, &ss->AmountInOutQueue) == -1)
     {
         WARN("ioctl returned error\n");
-        status = errno_to_status( errno );
+        status = FILE_GetNtStatus();
     }
 #else
     ss->AmountInOutQueue = 0; /* FIXME: find a different way to find out */
@@ -408,7 +404,7 @@ static NTSTATUS get_status(int fd, SERIAL_STATUS* ss)
     if (ioctl(fd, TIOCINQ, &ss->AmountInInQueue))
     {
         WARN("ioctl returned error\n");
-        status = errno_to_status( errno );
+        status = FILE_GetNtStatus();
     }
 #else
     ss->AmountInInQueue = 0; /* FIXME: find a different way to find out */
@@ -471,7 +467,7 @@ static NTSTATUS set_baud_rate(int fd, const SERIAL_BAUD_RATE* sbr)
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
 
     switch (sbr->BaudRate)
@@ -548,7 +544,7 @@ static NTSTATUS set_baud_rate(int fd, const SERIAL_BAUD_RATE* sbr)
         {
             struct serial_struct nuts;
             int arby;
-
+	
             ioctl(fd, TIOCGSERIAL, &nuts);
             nuts.custom_divisor = nuts.baud_base / sbr->BaudRate;
             if (!(nuts.custom_divisor)) nuts.custom_divisor = 1;
@@ -575,7 +571,7 @@ static NTSTATUS set_baud_rate(int fd, const SERIAL_BAUD_RATE* sbr)
     if (tcsetattr(fd, TCSANOW, &port) == -1)
     {
         ERR("tcsetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 }
@@ -598,16 +594,16 @@ static NTSTATUS set_handflow(int fd, const SERIAL_HANDFLOW* shf)
 {
     struct termios port;
 
-    if ((shf->FlowReplace & (SERIAL_RTS_CONTROL | SERIAL_RTS_HANDSHAKE)) ==
+    if ((shf->FlowReplace & (SERIAL_RTS_CONTROL | SERIAL_RTS_HANDSHAKE)) == 
         (SERIAL_RTS_CONTROL | SERIAL_RTS_HANDSHAKE))
         return STATUS_NOT_SUPPORTED;
 
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
-
+    
 #ifdef CRTSCTS
     if ((shf->ControlHandShake & SERIAL_CTS_HANDSHAKE) ||
         (shf->FlowReplace & SERIAL_RTS_HANDSHAKE))
@@ -632,7 +628,7 @@ static NTSTATUS set_handflow(int fd, const SERIAL_HANDFLOW* shf)
     {
         if ((shf->FlowReplace & (SERIAL_RTS_CONTROL|SERIAL_RTS_HANDSHAKE)) == 0)
             whack_modem(fd, ~TIOCM_RTS, 0);
-        else
+        else    
             whack_modem(fd, 0, TIOCM_RTS);
     }
 #endif
@@ -648,7 +644,7 @@ static NTSTATUS set_handflow(int fd, const SERIAL_HANDFLOW* shf)
     if (tcsetattr(fd, TCSANOW, &port) == -1)
     {
         ERR("tcsetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
 
     return STATUS_SUCCESS;
@@ -662,7 +658,7 @@ static NTSTATUS set_line_control(int fd, const SERIAL_LINE_CONTROL* slc)
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
 
 #ifdef IMAXBEL
@@ -761,7 +757,7 @@ static NTSTATUS set_line_control(int fd, const SERIAL_LINE_CONTROL* slc)
     if (tcsetattr(fd, TCSANOW, &port) == -1)
     {
         ERR("tcsetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 }
@@ -775,24 +771,24 @@ static NTSTATUS set_queue_size(int fd, const SERIAL_QUEUE_SIZE* sqs)
 static NTSTATUS set_special_chars(int fd, const SERIAL_CHARS* sc)
 {
     struct termios port;
-
+    
     if (tcgetattr(fd, &port) == -1)
     {
         ERR("tcgetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
-
+    
     port.c_cc[VEOF  ] = sc->EofChar;
     /* FIXME: sc->ErrorChar is not supported */
     /* FIXME: sc->BreakChar is not supported */
     /* FIXME: sc->EventChar is not supported */
     port.c_cc[VSTART] = sc->XonChar;
     port.c_cc[VSTOP ] = sc->XoffChar;
-
+    
     if (tcsetattr(fd, TCSANOW, &port) == -1)
     {
         ERR("tcsetattr error '%s'\n", strerror(errno));
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 }
@@ -804,7 +800,7 @@ static NTSTATUS set_XOff(int fd)
 {
     if (tcflow(fd, TCOOFF))
     {
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 }
@@ -816,7 +812,7 @@ static NTSTATUS set_XOn(int fd)
 {
     if (tcflow(fd, TCOON))
     {
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 }
@@ -896,7 +892,7 @@ static NTSTATUS get_irq_info(int fd, serial_irq_info *irq_info)
         return STATUS_SUCCESS;
     }
     TRACE("TIOCOUTQ err %s\n", strerror(errno));
-    return errno_to_status( errno );
+    return FILE_GetNtStatus();
 #endif
     return STATUS_SUCCESS;
 }
@@ -950,7 +946,7 @@ static DWORD check_events(int fd, DWORD mask,
  *  TIOCMIWAIT only checks modem status line and may not be aborted by a changing mask
  *
  */
-static void CALLBACK wait_for_event(LPVOID arg)
+static DWORD CALLBACK wait_for_event(LPVOID arg)
 {
     async_commio *commio = arg;
     int fd, needs_close;
@@ -961,7 +957,7 @@ static void CALLBACK wait_for_event(LPVOID arg)
         DWORD new_mstat, dummy, cookie;
         LARGE_INTEGER time;
 
-        TRACE("device=%p fd=0x%08x mask=0x%08x buffer=%p event=%p irq_info=%p\n",
+        TRACE("device=%p fd=0x%08x mask=0x%08x buffer=%p event=%p irq_info=%p\n", 
               commio->hDevice, fd, commio->evtmask, commio->events, commio->hEvent, &commio->irq_info);
 
         time.QuadPart = (ULONGLONG)10000;
@@ -1007,20 +1003,19 @@ static void CALLBACK wait_for_event(LPVOID arg)
     }
     stop_waiting(commio->hDevice);
     if (commio->hEvent) NtSetEvent(commio->hEvent, NULL);
-    free( commio );
-    NtTerminateThread( GetCurrentThread(), 0 );
+    RtlFreeHeap(GetProcessHeap(), 0, commio);
+    return 0;
 }
 
 static NTSTATUS wait_on(HANDLE hDevice, int fd, HANDLE hEvent, PIO_STATUS_BLOCK piosb, DWORD* events)
 {
     async_commio*       commio;
     NTSTATUS            status;
-    HANDLE handle;
 
     if ((status = NtResetEvent(hEvent, NULL)))
         return status;
 
-    commio = malloc( sizeof(async_commio) );
+    commio = RtlAllocateHeap(GetProcessHeap(), 0, sizeof (async_commio));
     if (!commio) return STATUS_NO_MEMORY;
 
     commio->hDevice = hDevice;
@@ -1031,7 +1026,7 @@ static NTSTATUS wait_on(HANDLE hDevice, int fd, HANDLE hEvent, PIO_STATUS_BLOCK
     status = get_wait_mask(commio->hDevice, &commio->evtmask, &commio->cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL, TRUE);
     if (status)
     {
-        free( commio );
+        RtlFreeHeap(GetProcessHeap(), 0, commio);
         return status;
     }
 
@@ -1087,12 +1082,9 @@ static NTSTATUS wait_on(HANDLE hDevice, int fd, HANDLE hEvent, PIO_STATUS_BLOCK
         goto out_now;
     }
 
-    /* create the worker thread for the task */
-    /* FIXME: should use async I/O instead */
-    status = NtCreateThreadEx( &handle, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(),
-                               wait_for_event, commio, 0, 0, 0, 0, NULL );
+    /* create the worker for the task */
+    status = RtlQueueWorkItem(wait_for_event, commio, 0 /* FIXME */);
     if (status != STATUS_SUCCESS) goto out_now;
-    NtClose( handle );
     return STATUS_PENDING;
 
 #if !defined(TIOCINQ) || (!(defined(TIOCSERGETLSR) && defined(TIOCSER_TEMT)) || !defined(TIOCINQ)) || !defined(TIOCMGET) || !defined(TIOCM_CTS) ||!defined(TIOCM_DSR) || !defined(TIOCM_RNG) || !defined(TIOCM_CAR)
@@ -1102,7 +1094,7 @@ error_caps:
 #endif
 out_now:
     stop_waiting(commio->hDevice);
-    free( commio );
+    RtlFreeHeap(GetProcessHeap(), 0, commio);
     return status;
 }
 
@@ -1111,23 +1103,33 @@ static NTSTATUS xmit_immediate(HANDLE hDevice, int fd, const char* ptr)
     /* FIXME: not perfect as it should bypass the in-queue */
     WARN("(%p,'%c') not perfect!\n", hDevice, *ptr);
     if (write(fd, ptr, 1) != 1)
-        return errno_to_status( errno );
+        return FILE_GetNtStatus();
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                            IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
-                            ULONG in_size, void *out_buffer, ULONG out_size )
+/******************************************************************
+ *		COMM_DeviceIoControl
+ *
+ *
+ */
+static inline NTSTATUS io_control(HANDLE hDevice, 
+                                  HANDLE hEvent, PIO_APC_ROUTINE UserApcRoutine,
+                                  PVOID UserApcContext, 
+                                  PIO_STATUS_BLOCK piosb, 
+                                  ULONG dwIoControlCode,
+                                  LPVOID lpInBuffer, DWORD nInBufferSize,
+                                  LPVOID lpOutBuffer, DWORD nOutBufferSize)
 {
-    DWORD sz = 0, access = FILE_READ_DATA;
-    NTSTATUS status = STATUS_SUCCESS;
-    int fd = -1, needs_close = 0;
+    DWORD       sz = 0, access = FILE_READ_DATA;
+    NTSTATUS    status = STATUS_SUCCESS;
+    int         fd = -1, needs_close = 0;
     enum server_fd_type type;
 
     TRACE("%p %s %p %d %p %d %p\n",
-          device, iocode2str(code), in_buffer, in_size, out_buffer, out_size, io);
+          hDevice, iocode2str(dwIoControlCode), lpInBuffer, nInBufferSize,
+          lpOutBuffer, nOutBufferSize, piosb);
 
-    switch (code)
+    switch (dwIoControlCode)
     {
     case IOCTL_SERIAL_GET_TIMEOUTS:
     case IOCTL_SERIAL_SET_TIMEOUTS:
@@ -1137,9 +1139,10 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
         return STATUS_NOT_SUPPORTED;
     }
 
-    io->Information = 0;
+    piosb->Information = 0;
 
-    if ((status = server_get_unix_fd( device, access, &fd, &needs_close, &type, NULL ))) goto error;
+    if ((status = server_get_unix_fd( hDevice, access, &fd, &needs_close, &type, NULL )))
+        goto error;
     if (type != FD_TYPE_SERIAL)
     {
         if (needs_close) close( fd );
@@ -1147,91 +1150,91 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
         goto error;
     }
 
-    switch (code)
+    switch (dwIoControlCode)
     {
     case IOCTL_SERIAL_CLR_DTR:
 #ifdef TIOCM_DTR
-        if (whack_modem(fd, ~TIOCM_DTR, 0) == -1) status = errno_to_status( errno );
+        if (whack_modem(fd, ~TIOCM_DTR, 0) == -1) status = FILE_GetNtStatus();
 #else
         status = STATUS_NOT_SUPPORTED;
 #endif
         break;
     case IOCTL_SERIAL_CLR_RTS:
 #ifdef TIOCM_RTS
-        if (whack_modem(fd, ~TIOCM_RTS, 0) == -1) status = errno_to_status( errno );
+        if (whack_modem(fd, ~TIOCM_RTS, 0) == -1) status = FILE_GetNtStatus();
 #else
         status = STATUS_NOT_SUPPORTED;
 #endif
         break;
     case IOCTL_SERIAL_GET_BAUD_RATE:
-        if (out_buffer && out_size == sizeof(SERIAL_BAUD_RATE))
+        if (lpOutBuffer && nOutBufferSize == sizeof(SERIAL_BAUD_RATE))
         {
-            if (!(status = get_baud_rate(fd, out_buffer)))
+            if (!(status = get_baud_rate(fd, lpOutBuffer)))
                 sz = sizeof(SERIAL_BAUD_RATE);
         }
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_GET_CHARS:
-        if (out_buffer && out_size == sizeof(SERIAL_CHARS))
+        if (lpOutBuffer && nOutBufferSize == sizeof(SERIAL_CHARS))
         {
-            if (!(status = get_special_chars(fd, out_buffer)))
+            if (!(status = get_special_chars(fd, lpOutBuffer)))
                 sz = sizeof(SERIAL_CHARS);
         }
         else
             status = STATUS_INVALID_PARAMETER;
         break;
      case IOCTL_SERIAL_GET_COMMSTATUS:
-        if (out_buffer && out_size == sizeof(SERIAL_STATUS))
+        if (lpOutBuffer && nOutBufferSize == sizeof(SERIAL_STATUS))
         {
-            if (!(status = get_status(fd, out_buffer)))
+            if (!(status = get_status(fd, lpOutBuffer)))
                 sz = sizeof(SERIAL_STATUS);
         }
         else status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_GET_HANDFLOW:
-        if (out_buffer && out_size == sizeof(SERIAL_HANDFLOW))
+        if (lpOutBuffer && nOutBufferSize == sizeof(SERIAL_HANDFLOW))
         {
-            if (!(status = get_hand_flow(fd, out_buffer)))
+            if (!(status = get_hand_flow(fd, lpOutBuffer)))
                 sz = sizeof(SERIAL_HANDFLOW);
         }
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_GET_LINE_CONTROL:
-        if (out_buffer && out_size == sizeof(SERIAL_LINE_CONTROL))
+        if (lpOutBuffer && nOutBufferSize == sizeof(SERIAL_LINE_CONTROL))
         {
-            if (!(status = get_line_control(fd, out_buffer)))
+            if (!(status = get_line_control(fd, lpOutBuffer)))
                 sz = sizeof(SERIAL_LINE_CONTROL);
         }
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_GET_MODEMSTATUS:
-        if (out_buffer && out_size == sizeof(DWORD))
+        if (lpOutBuffer && nOutBufferSize == sizeof(DWORD))
         {
-            if (!(status = get_modem_status(fd, out_buffer)))
+            if (!(status = get_modem_status(fd, lpOutBuffer)))
                 sz = sizeof(DWORD);
         }
         else status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_GET_PROPERTIES:
-        if (out_buffer && out_size == sizeof(SERIAL_COMMPROP))
+        if (lpOutBuffer && nOutBufferSize == sizeof(SERIAL_COMMPROP))
         {
-            if (!(status = get_properties(fd, out_buffer)))
+            if (!(status = get_properties(fd, lpOutBuffer)))
                 sz = sizeof(SERIAL_COMMPROP);
         }
         else status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_IMMEDIATE_CHAR:
-        if (in_buffer && in_size == sizeof(CHAR))
-            status = xmit_immediate(device, fd, in_buffer);
+        if (lpInBuffer && nInBufferSize == sizeof(CHAR))
+            status = xmit_immediate(hDevice, fd, lpInBuffer);
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_PURGE:
-        if (in_buffer && in_size == sizeof(DWORD))
-            status = purge(fd, *(DWORD*)in_buffer);
+        if (lpInBuffer && nInBufferSize == sizeof(DWORD))
+            status = purge(fd, *(DWORD*)lpInBuffer);
         else
             status = STATUS_INVALID_PARAMETER;
         break;
@@ -1239,8 +1242,8 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
         FIXME("Unsupported\n");
         break;
     case IOCTL_SERIAL_SET_BAUD_RATE:
-        if (in_buffer && in_size == sizeof(SERIAL_BAUD_RATE))
-            status = set_baud_rate(fd, in_buffer);
+        if (lpInBuffer && nInBufferSize == sizeof(SERIAL_BAUD_RATE))
+            status = set_baud_rate(fd, lpInBuffer);
         else
             status = STATUS_INVALID_PARAMETER;
         break;
@@ -1249,7 +1252,7 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
 	if (ioctl(fd, TIOCCBRK, 0) == -1)
         {
             TRACE("ioctl failed\n");
-            status = errno_to_status( errno );
+            status = FILE_GetNtStatus();
         }
 #else
 	FIXME("ioctl not available\n");
@@ -1261,7 +1264,7 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
 	if (ioctl(fd, TIOCSBRK, 0) == -1)
         {
             TRACE("ioctl failed\n");
-            status = errno_to_status( errno );
+            status = FILE_GetNtStatus();
         }
 #else
 	FIXME("ioctl not available\n");
@@ -1269,39 +1272,39 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
 #endif
         break;
     case IOCTL_SERIAL_SET_CHARS:
-        if (in_buffer && in_size == sizeof(SERIAL_CHARS))
-            status = set_special_chars(fd, in_buffer);
+        if (lpInBuffer && nInBufferSize == sizeof(SERIAL_CHARS))
+            status = set_special_chars(fd, lpInBuffer);
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_SET_DTR:
 #ifdef TIOCM_DTR
-        if (whack_modem(fd, 0, TIOCM_DTR) == -1) status = errno_to_status( errno );
+        if (whack_modem(fd, 0, TIOCM_DTR) == -1) status = FILE_GetNtStatus();
 #else
         status = STATUS_NOT_SUPPORTED;
 #endif
         break;
     case IOCTL_SERIAL_SET_HANDFLOW:
-        if (in_buffer && in_size == sizeof(SERIAL_HANDFLOW))
-            status = set_handflow(fd, in_buffer);
+        if (lpInBuffer && nInBufferSize == sizeof(SERIAL_HANDFLOW))
+            status = set_handflow(fd, lpInBuffer);
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_SET_LINE_CONTROL:
-        if (in_buffer && in_size == sizeof(SERIAL_LINE_CONTROL))
-            status = set_line_control(fd, in_buffer);
+        if (lpInBuffer && nInBufferSize == sizeof(SERIAL_LINE_CONTROL))
+            status = set_line_control(fd, lpInBuffer);
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_SET_QUEUE_SIZE:
-        if (in_buffer && in_size == sizeof(SERIAL_QUEUE_SIZE))
-            status = set_queue_size(fd, in_buffer);
+        if (lpInBuffer && nInBufferSize == sizeof(SERIAL_QUEUE_SIZE))
+            status = set_queue_size(fd, lpInBuffer);
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     case IOCTL_SERIAL_SET_RTS:
 #ifdef TIOCM_RTS
-        if (whack_modem(fd, 0, TIOCM_RTS) == -1) status = errno_to_status( errno );
+        if (whack_modem(fd, 0, TIOCM_RTS) == -1) status = FILE_GetNtStatus();
 #else
         status = STATUS_NOT_SUPPORTED;
 #endif
@@ -1313,49 +1316,52 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
         status = set_XOn(fd);
         break;
     case IOCTL_SERIAL_WAIT_ON_MASK:
-        if (out_buffer && out_size == sizeof(DWORD))
+        if (lpOutBuffer && nOutBufferSize == sizeof(DWORD))
         {
-            if (!(status = wait_on(device, fd, event, io, out_buffer)))
+            if (!(status = wait_on(hDevice, fd, hEvent, piosb, lpOutBuffer)))
                 sz = sizeof(DWORD);
         }
         else
             status = STATUS_INVALID_PARAMETER;
         break;
     default:
-        FIXME("Unsupported IOCTL %x (type=%x access=%x func=%x meth=%x)\n",
-              code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xFFF, code & 3);
+        FIXME("Unsupported IOCTL %x (type=%x access=%x func=%x meth=%x)\n", 
+              dwIoControlCode, dwIoControlCode >> 16, (dwIoControlCode >> 14) & 3,
+              (dwIoControlCode >> 2) & 0xFFF, dwIoControlCode & 3);
         sz = 0;
         status = STATUS_INVALID_PARAMETER;
         break;
     }
     if (needs_close) close( fd );
  error:
-    io->u.Status = status;
-    io->Information = sz;
-    if (event && status != STATUS_PENDING) NtSetEvent(event, NULL);
+    piosb->u.Status = status;
+    piosb->Information = sz;
+    if (hEvent && status != STATUS_PENDING) NtSetEvent(hEvent, NULL);
     return status;
 }
 
-/******************************************************************
- *		serial_DeviceIoControl
- */
-NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                 IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
-                                 ULONG in_size, void *out_buffer, ULONG out_size )
+NTSTATUS COMM_DeviceIoControl(HANDLE hDevice, 
+                              HANDLE hEvent, PIO_APC_ROUTINE UserApcRoutine,
+                              PVOID UserApcContext, 
+                              PIO_STATUS_BLOCK piosb, 
+                              ULONG dwIoControlCode,
+                              LPVOID lpInBuffer, DWORD nInBufferSize,
+                              LPVOID lpOutBuffer, DWORD nOutBufferSize)
 {
     NTSTATUS    status;
 
-    if (code == IOCTL_SERIAL_WAIT_ON_MASK)
+    if (dwIoControlCode == IOCTL_SERIAL_WAIT_ON_MASK)
     {
-        HANDLE hev = event;
+        HANDLE          hev = hEvent;
 
-        /* this is an ioctl we implement in a non blocking way if event is not null
-         * so we have to explicitly wait if no event is provided
+        /* this is an ioctl we implement in a non blocking way if hEvent is not
+         * null
+         * so we have to explicitly wait if no hEvent is provided
          */
         if (!hev)
         {
             OBJECT_ATTRIBUTES   attr;
-
+            
             attr.Length                   = sizeof(attr);
             attr.RootDirectory            = 0;
             attr.ObjectName               = NULL;
@@ -1366,9 +1372,10 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
 
             if (status) return status;
         }
-        status = io_control( device, hev, apc, apc_user, io, code,
-                             in_buffer, in_size, out_buffer, out_size );
-        if (hev != event)
+        status = io_control(hDevice, hev, UserApcRoutine, UserApcContext,
+                            piosb, dwIoControlCode, lpInBuffer, nInBufferSize,
+                            lpOutBuffer, nOutBufferSize);
+        if (hev != hEvent)
         {
             if (status == STATUS_PENDING)
             {
@@ -1378,29 +1385,30 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
             NtClose(hev);
         }
     }
-    else status = io_control( device, event, apc, apc_user, io, code,
-                              in_buffer, in_size, out_buffer, out_size );
+    else status = io_control(hDevice, hEvent, UserApcRoutine, UserApcContext,
+                             piosb, dwIoControlCode, lpInBuffer, nInBufferSize,
+                             lpOutBuffer, nOutBufferSize);
     return status;
 }
 
-NTSTATUS serial_FlushBuffersFile( int fd )
+NTSTATUS COMM_FlushBuffersFile( int fd )
 {
 #ifdef HAVE_TCDRAIN
     while (tcdrain( fd ) == -1)
     {
-        if (errno != EINTR) return errno_to_status( errno );
+        if (errno != EINTR) return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 #elif defined(TIOCDRAIN)
     while (ioctl( fd, TIOCDRAIN ) == -1)
     {
-        if (errno != EINTR) return errno_to_status( errno );
+        if (errno != EINTR) return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 #elif defined(TCSBRK)
     while (ioctl( fd, TCSBRK, 1 ) == -1)
     {
-        if (errno != EINTR) return errno_to_status( errno );
+        if (errno != EINTR) return FILE_GetNtStatus();
     }
     return STATUS_SUCCESS;
 #else
diff --git a/dlls/ntdll/server.c b/dlls/ntdll/server.c
index a3ad3e6887..78cac72e44 100644
--- a/dlls/ntdll/server.c
+++ b/dlls/ntdll/server.c
@@ -18,23 +18,295 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <ctype.h>
+#ifdef HAVE_DIRENT_H
+# include <dirent.h>
+#endif
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_LWP_H
+#include <lwp.h>
+#endif
+#ifdef HAVE_PTHREAD_NP_H
+# include <pthread_np.h>
+#endif
+#ifdef HAVE_PWD_H
+# include <pwd.h>
+#endif
+#include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <string.h>
 #include <sys/types.h>
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_WAIT_H
+#include <sys/wait.h>
+#endif
+#ifdef HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#ifdef HAVE_SYS_PRCTL_H
+# include <sys/prctl.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+#ifdef HAVE_SYS_UIO_H
+#include <sys/uio.h>
+#endif
+#ifdef HAVE_SYS_UCONTEXT_H
+# include <sys/ucontext.h>
+#endif
+#ifdef HAVE_SYS_THR_H
+#include <sys/thr.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef __APPLE__
+#include <crt_externs.h>
+#include <spawn.h>
+#ifndef _POSIX_SPAWN_DISABLE_ASLR
+#define _POSIX_SPAWN_DISABLE_ASLR 0x0100
+#endif
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winnt.h"
+#include "wine/library.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
+#include "ddk/wdm.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(server);
+
+/* Some versions of glibc don't define this */
+#ifndef SCM_RIGHTS
+#define SCM_RIGHTS 1
+#endif
+
+#ifndef MSG_CMSG_CLOEXEC
+#define MSG_CMSG_CLOEXEC 0
+#endif
+
+#define SOCKETNAME "socket"        /* name of the socket file */
+#define LOCKNAME   "lock"          /* name of the lock file */
 
+#ifdef __i386__
+static const enum cpu_type client_cpu = CPU_x86;
+#elif defined(__x86_64__)
+static const enum cpu_type client_cpu = CPU_x86_64;
+#elif defined(__powerpc__)
+static const enum cpu_type client_cpu = CPU_POWERPC;
+#elif defined(__arm__)
+static const enum cpu_type client_cpu = CPU_ARM;
+#elif defined(__aarch64__)
+static const enum cpu_type client_cpu = CPU_ARM64;
+#else
+#error Unsupported CPU
+#endif
+
+static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
+
+const char *build_dir = NULL;
+const char *data_dir = NULL;
+const char *config_dir = NULL;
+static const char *server_dir;
+
+unsigned int server_cpus = 0;
 BOOL is_wow64 = FALSE;
 
+timeout_t server_start_time = 0;  /* time of server startup */
+
+sigset_t server_block_set;  /* signals to block during server calls */
+static int fd_socket = -1;  /* socket to exchange file descriptors with the server */
+static pid_t server_pid;
+
+static RTL_CRITICAL_SECTION fd_cache_section;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &fd_cache_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": fd_cache_section") }
+};
+static RTL_CRITICAL_SECTION fd_cache_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+/* atomically exchange a 64-bit value */
+static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
+{
+#ifdef _WIN64
+    return (LONG64)InterlockedExchangePointer( (void **)dest, (void *)val );
+#else
+    LONG64 tmp = *dest;
+    while (InterlockedCompareExchange64( dest, val, tmp ) != tmp) tmp = *dest;
+    return tmp;
+#endif
+}
+
+#ifdef __GNUC__
+static void fatal_error( const char *err, ... ) __attribute__((noreturn, format(printf,1,2)));
+static void fatal_perror( const char *err, ... ) __attribute__((noreturn, format(printf,1,2)));
+static void server_connect_error( const char *serverdir ) __attribute__((noreturn));
+#endif
+
+/* die on a fatal error; use only during initialization */
+static void fatal_error( const char *err, ... )
+{
+    va_list args;
+
+    va_start( args, err );
+    fprintf( stderr, "wine: " );
+    vfprintf( stderr, err, args );
+    va_end( args );
+    exit(1);
+}
+
+/* die on a fatal error; use only during initialization */
+static void fatal_perror( const char *err, ... )
+{
+    va_list args;
+
+    va_start( args, err );
+    fprintf( stderr, "wine: " );
+    vfprintf( stderr, err, args );
+    perror( " " );
+    va_end( args );
+    exit(1);
+}
+
+/***********************************************************************
+ *           server_protocol_error
+ */
+static DECLSPEC_NORETURN void server_protocol_error( const char *err, ... )
+{
+    va_list args;
+
+    va_start( args, err );
+    fprintf( stderr, "wine client error:%x: ", GetCurrentThreadId() );
+    vfprintf( stderr, err, args );
+    va_end( args );
+    abort_thread(1);
+}
+
+
+/***********************************************************************
+ *           server_protocol_perror
+ */
+static DECLSPEC_NORETURN void server_protocol_perror( const char *err )
+{
+    fprintf( stderr, "wine client error:%x: ", GetCurrentThreadId() );
+    perror( err );
+    abort_thread(1);
+}
+
+
+/***********************************************************************
+ *           send_request
+ *
+ * Send a request to the server.
+ */
+static unsigned int send_request( const struct __server_request_info *req )
+{
+    unsigned int i;
+    int ret;
+
+    if (!req->u.req.request_header.request_size)
+    {
+        if ((ret = write( ntdll_get_thread_data()->request_fd, &req->u.req,
+                          sizeof(req->u.req) )) == sizeof(req->u.req)) return STATUS_SUCCESS;
+
+    }
+    else
+    {
+        struct iovec vec[__SERVER_MAX_DATA+1];
+
+        vec[0].iov_base = (void *)&req->u.req;
+        vec[0].iov_len = sizeof(req->u.req);
+        for (i = 0; i < req->data_count; i++)
+        {
+            vec[i+1].iov_base = (void *)req->data[i].ptr;
+            vec[i+1].iov_len = req->data[i].size;
+        }
+        if ((ret = writev( ntdll_get_thread_data()->request_fd, vec, i+1 )) ==
+            req->u.req.request_header.request_size + sizeof(req->u.req)) return STATUS_SUCCESS;
+    }
+
+    if (ret >= 0) server_protocol_error( "partial write %d\n", ret );
+    if (errno == EPIPE) abort_thread(0);
+    if (errno == EFAULT) return STATUS_ACCESS_VIOLATION;
+    server_protocol_perror( "write" );
+}
+
+
+/***********************************************************************
+ *           read_reply_data
+ *
+ * Read data from the reply buffer; helper for wait_reply.
+ */
+static void read_reply_data( void *buffer, size_t size )
+{
+    int ret;
+
+    for (;;)
+    {
+        if ((ret = read( ntdll_get_thread_data()->reply_fd, buffer, size )) > 0)
+        {
+            if (!(size -= ret)) return;
+            buffer = (char *)buffer + ret;
+            continue;
+        }
+        if (!ret) break;
+        if (errno == EINTR) continue;
+        if (errno == EPIPE) break;
+        server_protocol_perror("read");
+    }
+    /* the server closed the connection; time to die... */
+    abort_thread(0);
+}
+
+
+/***********************************************************************
+ *           wait_reply
+ *
+ * Wait for a reply from the server.
+ */
+static inline unsigned int wait_reply( struct __server_request_info *req )
+{
+    read_reply_data( &req->u.reply, sizeof(req->u.reply) );
+    if (req->u.reply.reply_header.reply_size)
+        read_reply_data( req->reply_data, req->u.reply.reply_header.reply_size );
+    return req->u.reply.reply_header.error;
+}
+
+
+/***********************************************************************
+ *           server_call_unlocked
+ */
+unsigned int server_call_unlocked( void *req_ptr )
+{
+    struct __server_request_info * const req = req_ptr;
+    unsigned int ret;
+
+    if ((ret = send_request( req ))) return ret;
+    return wait_reply( req );
+}
+
+
 /***********************************************************************
  *           wine_server_call (NTDLL.@)
  *
@@ -59,7 +331,455 @@ BOOL is_wow64 = FALSE;
  */
 unsigned int CDECL wine_server_call( void *req_ptr )
 {
-    return unix_funcs->server_call( req_ptr );
+    sigset_t old_set;
+    unsigned int ret;
+
+    pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
+    ret = server_call_unlocked( req_ptr );
+    pthread_sigmask( SIG_SETMASK, &old_set, NULL );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           server_enter_uninterrupted_section
+ */
+void server_enter_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
+{
+    pthread_sigmask( SIG_BLOCK, &server_block_set, sigset );
+    RtlEnterCriticalSection( cs );
+}
+
+
+/***********************************************************************
+ *           server_leave_uninterrupted_section
+ */
+void server_leave_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
+{
+    RtlLeaveCriticalSection( cs );
+    pthread_sigmask( SIG_SETMASK, sigset, NULL );
+}
+
+
+/***********************************************************************
+ *              wait_select_reply
+ *
+ * Wait for a reply on the waiting pipe of the current thread.
+ */
+static int wait_select_reply( void *cookie )
+{
+    int signaled;
+    struct wake_up_reply reply;
+    for (;;)
+    {
+        int ret;
+        ret = read( ntdll_get_thread_data()->wait_fd[0], &reply, sizeof(reply) );
+        if (ret == sizeof(reply))
+        {
+            if (!reply.cookie) abort_thread( reply.signaled );  /* thread got killed */
+            if (wine_server_get_ptr(reply.cookie) == cookie) return reply.signaled;
+            /* we stole another reply, wait for the real one */
+            signaled = wait_select_reply( cookie );
+            /* and now put the wrong one back in the pipe */
+            for (;;)
+            {
+                ret = write( ntdll_get_thread_data()->wait_fd[1], &reply, sizeof(reply) );
+                if (ret == sizeof(reply)) break;
+                if (ret >= 0) server_protocol_error( "partial wakeup write %d\n", ret );
+                if (errno == EINTR) continue;
+                server_protocol_perror("wakeup write");
+            }
+            return signaled;
+        }
+        if (ret >= 0) server_protocol_error( "partial wakeup read %d\n", ret );
+        if (errno == EINTR) continue;
+        server_protocol_perror("wakeup read");
+    }
+}
+
+
+static void invoke_apc( const user_apc_t *apc )
+{
+    switch( apc->type )
+    {
+    case APC_USER:
+    {
+        void (WINAPI *func)(ULONG_PTR,ULONG_PTR,ULONG_PTR) = wine_server_get_ptr( apc->user.func );
+        func( apc->user.args[0], apc->user.args[1], apc->user.args[2] );
+        break;
+    }
+    case APC_TIMER:
+    {
+        void (WINAPI *func)(void*, unsigned int, unsigned int) = wine_server_get_ptr( apc->user.func );
+        func( wine_server_get_ptr( apc->user.args[1] ),
+              (DWORD)apc->timer.time, (DWORD)(apc->timer.time >> 32) );
+        break;
+    }
+    default:
+        server_protocol_error( "get_apc_request: bad type %d\n", apc->type );
+        break;
+    }
+}
+
+/***********************************************************************
+ *              invoke_apc
+ *
+ * Invoke a single APC.
+ *
+ */
+static void invoke_system_apc( const apc_call_t *call, apc_result_t *result )
+{
+    SIZE_T size;
+    void *addr;
+    pe_image_info_t image_info;
+
+    memset( result, 0, sizeof(*result) );
+
+    switch (call->type)
+    {
+    case APC_NONE:
+        break;
+    case APC_ASYNC_IO:
+    {
+        IO_STATUS_BLOCK *iosb = wine_server_get_ptr( call->async_io.sb );
+        NTSTATUS (**user)(void *, IO_STATUS_BLOCK *, NTSTATUS) = wine_server_get_ptr( call->async_io.user );
+        result->type = call->type;
+        result->async_io.status = (*user)( user, iosb, call->async_io.status );
+        if (result->async_io.status != STATUS_PENDING)
+            result->async_io.total = iosb->Information;
+        break;
+    }
+    case APC_VIRTUAL_ALLOC:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->virtual_alloc.addr );
+        size = call->virtual_alloc.size;
+        if ((ULONG_PTR)addr == call->virtual_alloc.addr && size == call->virtual_alloc.size)
+        {
+            result->virtual_alloc.status = virtual_alloc( &addr, call->virtual_alloc.zero_bits_64, &size,
+                                                          call->virtual_alloc.op_type,
+                                                          call->virtual_alloc.prot );
+            result->virtual_alloc.addr = wine_server_client_ptr( addr );
+            result->virtual_alloc.size = size;
+        }
+        else result->virtual_alloc.status = STATUS_WORKING_SET_LIMIT_RANGE;
+        break;
+    case APC_VIRTUAL_FREE:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->virtual_free.addr );
+        size = call->virtual_free.size;
+        if ((ULONG_PTR)addr == call->virtual_free.addr && size == call->virtual_free.size)
+        {
+            result->virtual_free.status = NtFreeVirtualMemory( NtCurrentProcess(), &addr, &size,
+                                                               call->virtual_free.op_type );
+            result->virtual_free.addr = wine_server_client_ptr( addr );
+            result->virtual_free.size = size;
+        }
+        else result->virtual_free.status = STATUS_INVALID_PARAMETER;
+        break;
+    case APC_VIRTUAL_QUERY:
+    {
+        MEMORY_BASIC_INFORMATION info;
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->virtual_query.addr );
+        if ((ULONG_PTR)addr == call->virtual_query.addr)
+            result->virtual_query.status = NtQueryVirtualMemory( NtCurrentProcess(),
+                                                                 addr, MemoryBasicInformation, &info,
+                                                                 sizeof(info), NULL );
+        else
+            result->virtual_query.status = STATUS_WORKING_SET_LIMIT_RANGE;
+
+        if (result->virtual_query.status == STATUS_SUCCESS)
+        {
+            result->virtual_query.base       = wine_server_client_ptr( info.BaseAddress );
+            result->virtual_query.alloc_base = wine_server_client_ptr( info.AllocationBase );
+            result->virtual_query.size       = info.RegionSize;
+            result->virtual_query.prot       = info.Protect;
+            result->virtual_query.alloc_prot = info.AllocationProtect;
+            result->virtual_query.state      = info.State >> 12;
+            result->virtual_query.alloc_type = info.Type >> 16;
+        }
+        break;
+    }
+    case APC_VIRTUAL_PROTECT:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->virtual_protect.addr );
+        size = call->virtual_protect.size;
+        if ((ULONG_PTR)addr == call->virtual_protect.addr && size == call->virtual_protect.size)
+        {
+            result->virtual_protect.status = NtProtectVirtualMemory( NtCurrentProcess(), &addr, &size,
+                                                                     call->virtual_protect.prot,
+                                                                     &result->virtual_protect.prot );
+            result->virtual_protect.addr = wine_server_client_ptr( addr );
+            result->virtual_protect.size = size;
+        }
+        else result->virtual_protect.status = STATUS_INVALID_PARAMETER;
+        break;
+    case APC_VIRTUAL_FLUSH:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->virtual_flush.addr );
+        size = call->virtual_flush.size;
+        if ((ULONG_PTR)addr == call->virtual_flush.addr && size == call->virtual_flush.size)
+        {
+            result->virtual_flush.status = NtFlushVirtualMemory( NtCurrentProcess(),
+                                                                 (const void **)&addr, &size, 0 );
+            result->virtual_flush.addr = wine_server_client_ptr( addr );
+            result->virtual_flush.size = size;
+        }
+        else result->virtual_flush.status = STATUS_INVALID_PARAMETER;
+        break;
+    case APC_VIRTUAL_LOCK:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->virtual_lock.addr );
+        size = call->virtual_lock.size;
+        if ((ULONG_PTR)addr == call->virtual_lock.addr && size == call->virtual_lock.size)
+        {
+            result->virtual_lock.status = NtLockVirtualMemory( NtCurrentProcess(), &addr, &size, 0 );
+            result->virtual_lock.addr = wine_server_client_ptr( addr );
+            result->virtual_lock.size = size;
+        }
+        else result->virtual_lock.status = STATUS_INVALID_PARAMETER;
+        break;
+    case APC_VIRTUAL_UNLOCK:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->virtual_unlock.addr );
+        size = call->virtual_unlock.size;
+        if ((ULONG_PTR)addr == call->virtual_unlock.addr && size == call->virtual_unlock.size)
+        {
+            result->virtual_unlock.status = NtUnlockVirtualMemory( NtCurrentProcess(), &addr, &size, 0 );
+            result->virtual_unlock.addr = wine_server_client_ptr( addr );
+            result->virtual_unlock.size = size;
+        }
+        else result->virtual_unlock.status = STATUS_INVALID_PARAMETER;
+        break;
+    case APC_MAP_VIEW:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->map_view.addr );
+        size = call->map_view.size;
+        if ((ULONG_PTR)addr == call->map_view.addr && size == call->map_view.size)
+        {
+            LARGE_INTEGER offset;
+            offset.QuadPart = call->map_view.offset;
+            result->map_view.status = virtual_map_section( wine_server_ptr_handle(call->map_view.handle),
+                                                           &addr,
+                                                           call->map_view.zero_bits_64, 0,
+                                                           &offset, &size,
+                                                           call->map_view.alloc_type, call->map_view.prot,
+                                                           &image_info );
+            result->map_view.addr = wine_server_client_ptr( addr );
+            result->map_view.size = size;
+        }
+        else result->map_view.status = STATUS_INVALID_PARAMETER;
+        NtClose( wine_server_ptr_handle(call->map_view.handle) );
+        break;
+    case APC_UNMAP_VIEW:
+        result->type = call->type;
+        addr = wine_server_get_ptr( call->unmap_view.addr );
+        if ((ULONG_PTR)addr == call->unmap_view.addr)
+            result->unmap_view.status = NtUnmapViewOfSection( NtCurrentProcess(), addr );
+        else
+            result->unmap_view.status = STATUS_INVALID_PARAMETER;
+        break;
+    case APC_CREATE_THREAD:
+    {
+        CLIENT_ID id;
+        HANDLE handle;
+        SIZE_T reserve = call->create_thread.reserve;
+        SIZE_T commit = call->create_thread.commit;
+        void *func = wine_server_get_ptr( call->create_thread.func );
+        void *arg  = wine_server_get_ptr( call->create_thread.arg );
+
+        result->type = call->type;
+        if (reserve == call->create_thread.reserve && commit == call->create_thread.commit &&
+            (ULONG_PTR)func == call->create_thread.func && (ULONG_PTR)arg == call->create_thread.arg)
+        {
+            result->create_thread.status = RtlCreateUserThread( NtCurrentProcess(), NULL,
+                                                                call->create_thread.suspend, NULL,
+                                                                reserve, commit, func, arg, &handle, &id );
+            result->create_thread.handle = wine_server_obj_handle( handle );
+            result->create_thread.tid = HandleToULong(id.UniqueThread);
+        }
+        else result->create_thread.status = STATUS_INVALID_PARAMETER;
+        break;
+    }
+    case APC_BREAK_PROCESS:
+        result->type = APC_BREAK_PROCESS;
+        result->break_process.status = RtlCreateUserThread( NtCurrentProcess(), NULL, FALSE, NULL, 0, 0,
+                                                            DbgUiRemoteBreakin, NULL, NULL, NULL );
+        break;
+    default:
+        server_protocol_error( "get_apc_request: bad type %d\n", call->type );
+        break;
+    }
+}
+
+
+/***********************************************************************
+ *              server_select
+ */
+unsigned int server_select( const select_op_t *select_op, data_size_t size, UINT flags,
+                            timeout_t abs_timeout, CONTEXT *context, RTL_CRITICAL_SECTION *cs, user_apc_t *user_apc )
+{
+    unsigned int ret;
+    int cookie;
+    obj_handle_t apc_handle = 0;
+    context_t server_context;
+    BOOL suspend_context = FALSE;
+    apc_call_t call;
+    apc_result_t result;
+    sigset_t old_set;
+
+    memset( &result, 0, sizeof(result) );
+    if (context)
+    {
+        suspend_context = TRUE;
+        context_to_server( &server_context, context );
+    }
+
+    do
+    {
+        pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
+        for (;;)
+        {
+            SERVER_START_REQ( select )
+            {
+                req->flags    = flags;
+                req->cookie   = wine_server_client_ptr( &cookie );
+                req->prev_apc = apc_handle;
+                req->timeout  = abs_timeout;
+                req->size     = size;
+                wine_server_add_data( req, &result, sizeof(result) );
+                wine_server_add_data( req, select_op, size );
+                if (suspend_context)
+                {
+                    wine_server_add_data( req, &server_context, sizeof(server_context) );
+                    suspend_context = FALSE; /* server owns the context now */
+                }
+                if (context) wine_server_set_reply( req, &server_context, sizeof(server_context) );
+                ret = server_call_unlocked( req );
+                apc_handle  = reply->apc_handle;
+                call        = reply->call;
+                if (wine_server_reply_size( reply ))
+                {
+                    DWORD context_flags = context->ContextFlags; /* unchanged registers are still available */
+                    context_from_server( context, &server_context );
+                    context->ContextFlags |= context_flags;
+                }
+            }
+            SERVER_END_REQ;
+
+            if (ret != STATUS_KERNEL_APC) break;
+            invoke_system_apc( &call, &result );
+
+            /* don't signal multiple times */
+            if (size >= sizeof(select_op->signal_and_wait) && select_op->op == SELECT_SIGNAL_AND_WAIT)
+                size = offsetof( select_op_t, signal_and_wait.signal );
+        }
+        pthread_sigmask( SIG_SETMASK, &old_set, NULL );
+        if (cs)
+        {
+            RtlLeaveCriticalSection( cs );
+            cs = NULL;
+        }
+        if (ret != STATUS_PENDING) break;
+
+        ret = wait_select_reply( &cookie );
+    }
+    while (ret == STATUS_USER_APC || ret == STATUS_KERNEL_APC);
+
+    if (ret == STATUS_USER_APC) *user_apc = call.user;
+    return ret;
+}
+
+
+/***********************************************************************
+ *              server_wait
+ */
+unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT flags,
+                          const LARGE_INTEGER *timeout )
+{
+    timeout_t abs_timeout = timeout ? timeout->QuadPart : TIMEOUT_INFINITE;
+    BOOL user_apc = FALSE;
+    unsigned int ret;
+    user_apc_t apc;
+
+    if (abs_timeout < 0)
+    {
+        LARGE_INTEGER now;
+
+        RtlQueryPerformanceCounter(&now);
+        abs_timeout -= now.QuadPart;
+    }
+
+    for (;;)
+    {
+        ret = server_select( select_op, size, flags, abs_timeout, NULL, NULL, &apc );
+        if (ret != STATUS_USER_APC) break;
+        invoke_apc( &apc );
+
+        /* if we ran a user apc we have to check once more if additional apcs are queued,
+         * but we don't want to wait */
+        abs_timeout = 0;
+        user_apc = TRUE;
+        size = 0;
+        /* don't signal multiple times */
+        if (size >= sizeof(select_op->signal_and_wait) && select_op->op == SELECT_SIGNAL_AND_WAIT)
+            size = offsetof( select_op_t, signal_and_wait.signal );
+    }
+
+    if (ret == STATUS_TIMEOUT && user_apc) ret = STATUS_USER_APC;
+
+    /* A test on Windows 2000 shows that Windows always yields during
+       a wait, but a wait that is hit by an event gets a priority
+       boost as well.  This seems to model that behavior the closest.  */
+    if (ret == STATUS_TIMEOUT) NtYieldExecution();
+
+    return ret;
+}
+
+
+/***********************************************************************
+ *           server_queue_process_apc
+ */
+unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call, apc_result_t *result )
+{
+    for (;;)
+    {
+        unsigned int ret;
+        HANDLE handle = 0;
+        BOOL self = FALSE;
+
+        SERVER_START_REQ( queue_apc )
+        {
+            req->handle = wine_server_obj_handle( process );
+            req->call = *call;
+            if (!(ret = wine_server_call( req )))
+            {
+                handle = wine_server_ptr_handle( reply->handle );
+                self = reply->self;
+            }
+        }
+        SERVER_END_REQ;
+        if (ret != STATUS_SUCCESS) return ret;
+
+        if (self)
+        {
+            invoke_system_apc( call, result );
+        }
+        else
+        {
+            NtWaitForSingleObject( handle, FALSE, NULL );
+
+            SERVER_START_REQ( get_apc_result )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                if (!(ret = wine_server_call( req ))) *result = reply->result;
+            }
+            SERVER_END_REQ;
+
+            if (!ret && result->type == APC_NONE) continue;  /* APC didn't run, try again */
+        }
+        return ret;
+    }
 }
 
 
@@ -76,7 +796,283 @@ unsigned int CDECL wine_server_call( void *req_ptr )
  */
 void CDECL wine_server_send_fd( int fd )
 {
-    unix_funcs->server_send_fd( fd );
+    struct send_fd data;
+    struct msghdr msghdr;
+    struct iovec vec;
+    int ret;
+
+#ifdef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS
+    msghdr.msg_accrights    = (void *)&fd;
+    msghdr.msg_accrightslen = sizeof(fd);
+#else  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
+    char cmsg_buffer[256];
+    struct cmsghdr *cmsg;
+    msghdr.msg_control    = cmsg_buffer;
+    msghdr.msg_controllen = sizeof(cmsg_buffer);
+    msghdr.msg_flags      = 0;
+    cmsg = CMSG_FIRSTHDR( &msghdr );
+    cmsg->cmsg_len   = CMSG_LEN( sizeof(fd) );
+    cmsg->cmsg_level = SOL_SOCKET;
+    cmsg->cmsg_type  = SCM_RIGHTS;
+    *(int *)CMSG_DATA(cmsg) = fd;
+    msghdr.msg_controllen = cmsg->cmsg_len;
+#endif  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
+
+    msghdr.msg_name    = NULL;
+    msghdr.msg_namelen = 0;
+    msghdr.msg_iov     = &vec;
+    msghdr.msg_iovlen  = 1;
+
+    vec.iov_base = (void *)&data;
+    vec.iov_len  = sizeof(data);
+
+    data.tid = GetCurrentThreadId();
+    data.fd  = fd;
+
+    for (;;)
+    {
+        if ((ret = sendmsg( fd_socket, &msghdr, 0 )) == sizeof(data)) return;
+        if (ret >= 0) server_protocol_error( "partial write %d\n", ret );
+        if (errno == EINTR) continue;
+        if (errno == EPIPE) abort_thread(0);
+        server_protocol_perror( "sendmsg" );
+    }
+}
+
+
+/***********************************************************************
+ *           receive_fd
+ *
+ * Receive a file descriptor passed from the server.
+ */
+static int receive_fd( obj_handle_t *handle )
+{
+    struct iovec vec;
+    struct msghdr msghdr;
+    int ret, fd = -1;
+
+#ifdef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS
+    msghdr.msg_accrights    = (void *)&fd;
+    msghdr.msg_accrightslen = sizeof(fd);
+#else  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
+    char cmsg_buffer[256];
+    msghdr.msg_control    = cmsg_buffer;
+    msghdr.msg_controllen = sizeof(cmsg_buffer);
+    msghdr.msg_flags      = 0;
+#endif  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
+
+    msghdr.msg_name    = NULL;
+    msghdr.msg_namelen = 0;
+    msghdr.msg_iov     = &vec;
+    msghdr.msg_iovlen  = 1;
+    vec.iov_base = (void *)handle;
+    vec.iov_len  = sizeof(*handle);
+
+    for (;;)
+    {
+        if ((ret = recvmsg( fd_socket, &msghdr, MSG_CMSG_CLOEXEC )) > 0)
+        {
+#ifndef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS
+            struct cmsghdr *cmsg;
+            for (cmsg = CMSG_FIRSTHDR( &msghdr ); cmsg; cmsg = CMSG_NXTHDR( &msghdr, cmsg ))
+            {
+                if (cmsg->cmsg_level != SOL_SOCKET) continue;
+                if (cmsg->cmsg_type == SCM_RIGHTS) fd = *(int *)CMSG_DATA(cmsg);
+#ifdef SCM_CREDENTIALS
+                else if (cmsg->cmsg_type == SCM_CREDENTIALS)
+                {
+                    struct ucred *ucred = (struct ucred *)CMSG_DATA(cmsg);
+                    server_pid = ucred->pid;
+                }
+#endif
+            }
+#endif  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
+            if (fd != -1) fcntl( fd, F_SETFD, FD_CLOEXEC ); /* in case MSG_CMSG_CLOEXEC is not supported */
+            return fd;
+        }
+        if (!ret) break;
+        if (errno == EINTR) continue;
+        if (errno == EPIPE) break;
+        server_protocol_perror("recvmsg");
+    }
+    /* the server closed the connection; time to die... */
+    abort_thread(0);
+}
+
+
+/***********************************************************************/
+/* fd cache support */
+
+union fd_cache_entry
+{
+    LONG64 data;
+    struct
+    {
+        int fd;
+        enum server_fd_type type : 5;
+        unsigned int        access : 3;
+        unsigned int        options : 24;
+    } s;
+};
+
+C_ASSERT( sizeof(union fd_cache_entry) == sizeof(LONG64) );
+
+#define FD_CACHE_BLOCK_SIZE  (65536 / sizeof(union fd_cache_entry))
+#define FD_CACHE_ENTRIES     128
+
+static union fd_cache_entry *fd_cache[FD_CACHE_ENTRIES];
+static union fd_cache_entry fd_cache_initial_block[FD_CACHE_BLOCK_SIZE];
+
+static inline unsigned int handle_to_index( HANDLE handle, unsigned int *entry )
+{
+    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
+    *entry = idx / FD_CACHE_BLOCK_SIZE;
+    return idx % FD_CACHE_BLOCK_SIZE;
+}
+
+
+/***********************************************************************
+ *           add_fd_to_cache
+ *
+ * Caller must hold fd_cache_section.
+ */
+static BOOL add_fd_to_cache( HANDLE handle, int fd, enum server_fd_type type,
+                            unsigned int access, unsigned int options )
+{
+    unsigned int entry, idx = handle_to_index( handle, &entry );
+    union fd_cache_entry cache;
+
+    if (entry >= FD_CACHE_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return FALSE;
+    }
+
+    if (!fd_cache[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) fd_cache[0] = fd_cache_initial_block;
+        else
+        {
+            void *ptr = wine_anon_mmap( NULL, FD_CACHE_BLOCK_SIZE * sizeof(union fd_cache_entry),
+                                        PROT_READ | PROT_WRITE, 0 );
+            if (ptr == MAP_FAILED) return FALSE;
+            fd_cache[entry] = ptr;
+        }
+    }
+
+    /* store fd+1 so that 0 can be used as the unset value */
+    cache.s.fd = fd + 1;
+    cache.s.type = type;
+    cache.s.access = access;
+    cache.s.options = options;
+    cache.data = interlocked_xchg64( &fd_cache[entry][idx].data, cache.data );
+    assert( !cache.s.fd );
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           get_cached_fd
+ */
+static inline NTSTATUS get_cached_fd( HANDLE handle, int *fd, enum server_fd_type *type,
+                                      unsigned int *access, unsigned int *options )
+{
+    unsigned int entry, idx = handle_to_index( handle, &entry );
+    union fd_cache_entry cache;
+
+    if (entry >= FD_CACHE_ENTRIES || !fd_cache[entry]) return STATUS_INVALID_HANDLE;
+
+    cache.data = InterlockedCompareExchange64( &fd_cache[entry][idx].data, 0, 0 );
+    if (!cache.data) return STATUS_INVALID_HANDLE;
+
+    /* if fd type is invalid, fd stores an error value */
+    if (cache.s.type == FD_TYPE_INVALID) return cache.s.fd - 1;
+
+    *fd = cache.s.fd - 1;
+    if (type) *type = cache.s.type;
+    if (access) *access = cache.s.access;
+    if (options) *options = cache.s.options;
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           server_remove_fd_from_cache
+ */
+int server_remove_fd_from_cache( HANDLE handle )
+{
+    unsigned int entry, idx = handle_to_index( handle, &entry );
+    int fd = -1;
+
+    if (entry < FD_CACHE_ENTRIES && fd_cache[entry])
+    {
+        union fd_cache_entry cache;
+        cache.data = interlocked_xchg64( &fd_cache[entry][idx].data, 0 );
+        if (cache.s.type != FD_TYPE_INVALID) fd = cache.s.fd - 1;
+    }
+
+    return fd;
+}
+
+
+/***********************************************************************
+ *           server_get_unix_fd
+ *
+ * The returned unix_fd should be closed iff needs_close is non-zero.
+ */
+int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
+                        int *needs_close, enum server_fd_type *type, unsigned int *options )
+{
+    sigset_t sigset;
+    obj_handle_t fd_handle;
+    int ret, fd = -1;
+    unsigned int access = 0;
+
+    *unix_fd = -1;
+    *needs_close = 0;
+    wanted_access &= FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA;
+
+    ret = get_cached_fd( handle, &fd, type, &access, options );
+    if (ret != STATUS_INVALID_HANDLE) goto done;
+
+    server_enter_uninterrupted_section( &fd_cache_section, &sigset );
+    ret = get_cached_fd( handle, &fd, type, &access, options );
+    if (ret == STATUS_INVALID_HANDLE)
+    {
+        SERVER_START_REQ( get_handle_fd )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            if (!(ret = wine_server_call( req )))
+            {
+                if (type) *type = reply->type;
+                if (options) *options = reply->options;
+                access = reply->access;
+                if ((fd = receive_fd( &fd_handle )) != -1)
+                {
+                    assert( wine_server_ptr_handle(fd_handle) == handle );
+                    *needs_close = (!reply->cacheable ||
+                                    !add_fd_to_cache( handle, fd, reply->type,
+                                                      reply->access, reply->options ));
+                }
+                else ret = STATUS_TOO_MANY_OPENED_FILES;
+            }
+            else if (reply->cacheable)
+            {
+                add_fd_to_cache( handle, ret, FD_TYPE_INVALID, 0, 0 );
+            }
+        }
+        SERVER_END_REQ;
+    }
+    server_leave_uninterrupted_section( &fd_cache_section, &sigset );
+
+done:
+    if (!ret && ((access & wanted_access) != wanted_access))
+    {
+        ret = STATUS_ACCESS_DENIED;
+        if (*needs_close) close( fd );
+    }
+    if (!ret) *unix_fd = fd;
+    return ret;
 }
 
 
@@ -96,7 +1092,20 @@ void CDECL wine_server_send_fd( int fd )
  */
 int CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned int attributes, HANDLE *handle )
 {
-    return unix_funcs->server_fd_to_handle( fd, access, attributes, handle );
+    int ret;
+
+    *handle = 0;
+    wine_server_send_fd( fd );
+
+    SERVER_START_REQ( alloc_file_handle )
+    {
+        req->access     = access;
+        req->attributes = attributes;
+        req->fd         = fd;
+        if (!(ret = wine_server_call( req ))) *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -115,9 +1124,15 @@ int CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned int at
  *     NTSTATUS code
  */
 int CDECL wine_server_handle_to_fd( HANDLE handle, unsigned int access, int *unix_fd,
-                                    unsigned int *options )
+                              unsigned int *options )
 {
-    return unix_funcs->server_handle_to_fd( handle, access, unix_fd, options );
+    int needs_close, ret = server_get_unix_fd( handle, access, unix_fd, &needs_close, NULL, options );
+
+    if (!ret && !needs_close)
+    {
+        if ((*unix_fd = dup(*unix_fd)) == -1) ret = FILE_GetNtStatus();
+    }
+    return ret;
 }
 
 
@@ -135,5 +1150,491 @@ int CDECL wine_server_handle_to_fd( HANDLE handle, unsigned int access, int *uni
  */
 void CDECL wine_server_release_fd( HANDLE handle, int unix_fd )
 {
-    unix_funcs->server_release_fd( handle, unix_fd );
+    close( unix_fd );
+}
+
+
+/***********************************************************************
+ *           server_pipe
+ *
+ * Create a pipe for communicating with the server.
+ */
+int server_pipe( int fd[2] )
+{
+    int ret;
+#ifdef HAVE_PIPE2
+    static BOOL have_pipe2 = TRUE;
+
+    if (have_pipe2)
+    {
+        if (!(ret = pipe2( fd, O_CLOEXEC ))) return ret;
+        if (errno == ENOSYS || errno == EINVAL) have_pipe2 = FALSE;  /* don't try again */
+    }
+#endif
+    if (!(ret = pipe( fd )))
+    {
+        fcntl( fd[0], F_SETFD, FD_CLOEXEC );
+        fcntl( fd[1], F_SETFD, FD_CLOEXEC );
+    }
+    return ret;
+}
+
+
+/***********************************************************************
+ *           init_server_dir
+ */
+static const char *init_server_dir( dev_t dev, ino_t ino )
+{
+    char *p, *dir;
+    size_t len = sizeof("/server-") + 2 * sizeof(dev) + 2 * sizeof(ino) + 2;
+
+#ifdef __ANDROID__  /* there's no /tmp dir on Android */
+    len += strlen( config_dir ) + sizeof("/.wineserver");
+    dir = malloc( len );
+    strcpy( dir, config_dir );
+    strcat( dir, "/.wineserver/server-" );
+#else
+    len += sizeof("/tmp/.wine-") + 12;
+    dir = malloc( len );
+    sprintf( dir, "/tmp/.wine-%u/server-", getuid() );
+#endif
+    p = dir + strlen( dir );
+    if (dev != (unsigned long)dev)
+        p += sprintf( p, "%lx%08lx-", (unsigned long)((unsigned long long)dev >> 32), (unsigned long)dev );
+    else
+        p += sprintf( p, "%lx-", (unsigned long)dev );
+
+    if (ino != (unsigned long)ino)
+        sprintf( p, "%lx%08lx", (unsigned long)((unsigned long long)ino >> 32), (unsigned long)ino );
+    else
+        sprintf( p, "%lx", (unsigned long)ino );
+    return dir;
+}
+
+
+/***********************************************************************
+ *           setup_config_dir
+ *
+ * Setup the wine configuration dir.
+ */
+static int setup_config_dir(void)
+{
+    char *p;
+    struct stat st;
+    int fd_cwd = open( ".", O_RDONLY );
+
+    if (chdir( config_dir ) == -1)
+    {
+        if (errno != ENOENT) fatal_perror( "cannot use directory %s", config_dir );
+        if ((p = strrchr( config_dir, '/' )) && p != config_dir)
+        {
+            while (p > config_dir + 1 && p[-1] == '/') p--;
+            *p = 0;
+            if (!stat( config_dir, &st ) && st.st_uid != getuid())
+                fatal_error( "'%s' is not owned by you, refusing to create a configuration directory there\n",
+                             config_dir );
+            *p = '/';
+        }
+        mkdir( config_dir, 0777 );
+        if (chdir( config_dir ) == -1) fatal_perror( "chdir to %s", config_dir );
+        MESSAGE( "wine: created the configuration directory '%s'\n", config_dir );
+    }
+
+    if (stat( ".", &st ) == -1) fatal_perror( "stat %s", config_dir );
+    if (st.st_uid != getuid()) fatal_error( "'%s' is not owned by you\n", config_dir );
+
+    server_dir = init_server_dir( st.st_dev, st.st_ino );
+
+    if (!mkdir( "dosdevices", 0777 ))
+    {
+        mkdir( "drive_c", 0777 );
+        symlink( "../drive_c", "dosdevices/c:" );
+        symlink( "/", "dosdevices/z:" );
+    }
+    else if (errno != EEXIST) fatal_perror( "cannot create %s/dosdevices", config_dir );
+
+    if (fd_cwd == -1) fd_cwd = open( "dosdevices/c:", O_RDONLY );
+    fcntl( fd_cwd, F_SETFD, FD_CLOEXEC );
+    return fd_cwd;
+}
+
+
+/***********************************************************************
+ *           server_connect_error
+ *
+ * Try to display a meaningful explanation of why we couldn't connect
+ * to the server.
+ */
+static void server_connect_error( const char *serverdir )
+{
+    int fd;
+    struct flock fl;
+
+    if ((fd = open( LOCKNAME, O_WRONLY )) == -1)
+        fatal_error( "for some mysterious reason, the wine server never started.\n" );
+
+    fl.l_type   = F_WRLCK;
+    fl.l_whence = SEEK_SET;
+    fl.l_start  = 0;
+    fl.l_len    = 1;
+    if (fcntl( fd, F_GETLK, &fl ) != -1)
+    {
+        if (fl.l_type == F_WRLCK)  /* the file is locked */
+            fatal_error( "a wine server seems to be running, but I cannot connect to it.\n"
+                         "   You probably need to kill that process (it might be pid %d).\n",
+                         (int)fl.l_pid );
+        fatal_error( "for some mysterious reason, the wine server failed to run.\n" );
+    }
+    fatal_error( "the file system of '%s' doesn't support locks,\n"
+          "   and there is a 'socket' file in that directory that prevents wine from starting.\n"
+          "   You should make sure no wine server is running, remove that file and try again.\n",
+                 serverdir );
+}
+
+
+/***********************************************************************
+ *           server_connect
+ *
+ * Attempt to connect to an existing server socket.
+ * We need to be in the server directory already.
+ */
+static int server_connect(void)
+{
+    struct sockaddr_un addr;
+    struct stat st;
+    int s, slen, retry, fd_cwd;
+
+    fd_cwd = setup_config_dir();
+
+    /* chdir to the server directory */
+    if (chdir( server_dir ) == -1)
+    {
+        if (errno != ENOENT) fatal_perror( "chdir to %s", server_dir );
+        unix_funcs->start_server( TRACE_ON(server) );
+        if (chdir( server_dir ) == -1) fatal_perror( "chdir to %s", server_dir );
+    }
+
+    /* make sure we are at the right place */
+    if (stat( ".", &st ) == -1) fatal_perror( "stat %s", server_dir );
+    if (st.st_uid != getuid()) fatal_error( "'%s' is not owned by you\n", server_dir );
+    if (st.st_mode & 077) fatal_error( "'%s' must not be accessible by other users\n", server_dir );
+
+    for (retry = 0; retry < 6; retry++)
+    {
+        /* if not the first try, wait a bit to leave the previous server time to exit */
+        if (retry)
+        {
+            usleep( 100000 * retry * retry );
+            unix_funcs->start_server( TRACE_ON(server) );
+            if (lstat( SOCKETNAME, &st ) == -1) continue;  /* still no socket, wait a bit more */
+        }
+        else if (lstat( SOCKETNAME, &st ) == -1) /* check for an already existing socket */
+        {
+            if (errno != ENOENT) fatal_perror( "lstat %s/%s", server_dir, SOCKETNAME );
+            unix_funcs->start_server( TRACE_ON(server) );
+            if (lstat( SOCKETNAME, &st ) == -1) continue;  /* still no socket, wait a bit more */
+        }
+
+        /* make sure the socket is sane (ISFIFO needed for Solaris) */
+        if (!S_ISSOCK(st.st_mode) && !S_ISFIFO(st.st_mode))
+            fatal_error( "'%s/%s' is not a socket\n", server_dir, SOCKETNAME );
+        if (st.st_uid != getuid())
+            fatal_error( "'%s/%s' is not owned by you\n", server_dir, SOCKETNAME );
+
+        /* try to connect to it */
+        addr.sun_family = AF_UNIX;
+        strcpy( addr.sun_path, SOCKETNAME );
+        slen = sizeof(addr) - sizeof(addr.sun_path) + strlen(addr.sun_path) + 1;
+#ifdef HAVE_STRUCT_SOCKADDR_UN_SUN_LEN
+        addr.sun_len = slen;
+#endif
+        if ((s = socket( AF_UNIX, SOCK_STREAM, 0 )) == -1) fatal_perror( "socket" );
+#ifdef SO_PASSCRED
+        else
+        {
+            int enable = 1;
+            setsockopt( s, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
+        }
+#endif
+        if (connect( s, (struct sockaddr *)&addr, slen ) != -1)
+        {
+            /* switch back to the starting directory */
+            if (fd_cwd != -1)
+            {
+                fchdir( fd_cwd );
+                close( fd_cwd );
+            }
+            fcntl( s, F_SETFD, FD_CLOEXEC );
+            return s;
+        }
+        close( s );
+    }
+    server_connect_error( server_dir );
+}
+
+
+#ifdef __APPLE__
+#include <mach/mach.h>
+#include <mach/mach_error.h>
+#include <servers/bootstrap.h>
+
+/* send our task port to the server */
+static void send_server_task_port(void)
+{
+    mach_port_t bootstrap_port, wineserver_port;
+    kern_return_t kret;
+
+    struct {
+        mach_msg_header_t           header;
+        mach_msg_body_t             body;
+        mach_msg_port_descriptor_t  task_port;
+    } msg;
+
+    if (task_get_bootstrap_port(mach_task_self(), &bootstrap_port) != KERN_SUCCESS) return;
+
+    if (!server_dir)
+    {
+        struct stat st;
+        stat( config_dir, &st );
+        server_dir = init_server_dir( st.st_dev, st.st_ino );
+    }
+    kret = bootstrap_look_up(bootstrap_port, server_dir, &wineserver_port);
+    if (kret != KERN_SUCCESS)
+        fatal_error( "cannot find the server port: 0x%08x\n", kret );
+
+    mach_port_deallocate(mach_task_self(), bootstrap_port);
+
+    msg.header.msgh_bits        = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
+    msg.header.msgh_size        = sizeof(msg);
+    msg.header.msgh_remote_port = wineserver_port;
+    msg.header.msgh_local_port  = MACH_PORT_NULL;
+
+    msg.body.msgh_descriptor_count  = 1;
+    msg.task_port.name              = mach_task_self();
+    msg.task_port.disposition       = MACH_MSG_TYPE_COPY_SEND;
+    msg.task_port.type              = MACH_MSG_PORT_DESCRIPTOR;
+
+    kret = mach_msg_send(&msg.header);
+    if (kret != KERN_SUCCESS)
+        server_protocol_error( "mach_msg_send failed: 0x%08x\n", kret );
+
+    mach_port_deallocate(mach_task_self(), wineserver_port);
+}
+#endif  /* __APPLE__ */
+
+
+/***********************************************************************
+ *           get_unix_tid
+ *
+ * Retrieve the Unix tid to use on the server side for the current thread.
+ */
+static int get_unix_tid(void)
+{
+    int ret = -1;
+#ifdef HAVE_PTHREAD_GETTHREADID_NP
+    ret = pthread_getthreadid_np();
+#elif defined(linux)
+    ret = syscall( __NR_gettid );
+#elif defined(__sun)
+    ret = pthread_self();
+#elif defined(__APPLE__)
+    ret = mach_thread_self();
+    mach_port_deallocate(mach_task_self(), ret);
+#elif defined(__NetBSD__)
+    ret = _lwp_self();
+#elif defined(__FreeBSD__)
+    long lwpid;
+    thr_self( &lwpid );
+    ret = lwpid;
+#elif defined(__DragonFly__)
+    ret = lwp_gettid();
+#endif
+    return ret;
+}
+
+
+/***********************************************************************
+ *           server_init_process
+ *
+ * Start the server and create the initial socket pair.
+ */
+void server_init_process(void)
+{
+    obj_handle_t version;
+    const char *env_socket = getenv( "WINESERVERSOCKET" );
+
+    server_pid = -1;
+    if (env_socket)
+    {
+        fd_socket = atoi( env_socket );
+        if (fcntl( fd_socket, F_SETFD, FD_CLOEXEC ) == -1)
+            fatal_perror( "Bad server socket %d", fd_socket );
+        unsetenv( "WINESERVERSOCKET" );
+    }
+    else
+    {
+        const char *arch = getenv( "WINEARCH" );
+
+        if (arch && strcmp( arch, "win32" ) && strcmp( arch, "win64" ))
+            fatal_error( "WINEARCH set to invalid value '%s', it must be either win32 or win64.\n", arch );
+
+        fd_socket = server_connect();
+    }
+
+    /* setup the signal mask */
+    sigemptyset( &server_block_set );
+    sigaddset( &server_block_set, SIGALRM );
+    sigaddset( &server_block_set, SIGIO );
+    sigaddset( &server_block_set, SIGINT );
+    sigaddset( &server_block_set, SIGHUP );
+    sigaddset( &server_block_set, SIGUSR1 );
+    sigaddset( &server_block_set, SIGUSR2 );
+    sigaddset( &server_block_set, SIGCHLD );
+    pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
+
+    /* receive the first thread request fd on the main socket */
+    ntdll_get_thread_data()->request_fd = receive_fd( &version );
+
+#ifdef SO_PASSCRED
+    /* now that we hopefully received the server_pid, disable SO_PASSCRED */
+    {
+        int enable = 0;
+        setsockopt( fd_socket, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
+    }
+#endif
+
+    if (version != SERVER_PROTOCOL_VERSION)
+        server_protocol_error( "version mismatch %d/%d.\n"
+                               "Your %s binary was not upgraded correctly,\n"
+                               "or you have an older one somewhere in your PATH.\n"
+                               "Or maybe the wrong wineserver is still running?\n",
+                               version, SERVER_PROTOCOL_VERSION,
+                               (version > SERVER_PROTOCOL_VERSION) ? "wine" : "wineserver" );
+#if defined(__linux__) && defined(HAVE_PRCTL)
+    /* work around Ubuntu's ptrace breakage */
+    if (server_pid != -1) prctl( 0x59616d61 /* PR_SET_PTRACER */, server_pid );
+#endif
+}
+
+
+/***********************************************************************
+ *           server_init_process_done
+ */
+void server_init_process_done(void)
+{
+#ifdef __i386__
+    extern struct ldt_copy __wine_ldt_copy;
+#endif
+    PEB *peb = NtCurrentTeb()->Peb;
+    IMAGE_NT_HEADERS *nt = RtlImageNtHeader( peb->ImageBaseAddress );
+    void *entry = (char *)peb->ImageBaseAddress + nt->OptionalHeader.AddressOfEntryPoint;
+    NTSTATUS status;
+    HANDLE usd_handle = user_shared_data_init_done();
+    int suspend;
+
+#ifdef __APPLE__
+    send_server_task_port();
+#endif
+
+    /* Install signal handlers; this cannot be done earlier, since we cannot
+     * send exceptions to the debugger before the create process event that
+     * is sent by REQ_INIT_PROCESS_DONE.
+     * We do need the handlers in place by the time the request is over, so
+     * we set them up here. If we segfault between here and the server call
+     * something is very wrong... */
+    signal_init_process();
+
+    /* Signal the parent process to continue */
+    SERVER_START_REQ( init_process_done )
+    {
+        req->module   = wine_server_client_ptr( peb->ImageBaseAddress );
+#ifdef __i386__
+        req->ldt_copy = wine_server_client_ptr( &__wine_ldt_copy );
+#endif
+        req->entry    = wine_server_client_ptr( entry );
+        req->gui      = (nt->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_WINDOWS_CUI);
+        req->usd_handle = wine_server_obj_handle( usd_handle );
+        status = wine_server_call( req );
+        suspend = reply->suspend;
+    }
+    SERVER_END_REQ;
+    NtClose( usd_handle );
+
+    assert( !status );
+    signal_start_process( entry, suspend );
+}
+
+
+/***********************************************************************
+ *           server_init_thread
+ *
+ * Send an init thread request. Return 0 if OK.
+ */
+size_t server_init_thread( void *entry_point, BOOL *suspend )
+{
+    static const char *cpu_names[] = { "x86", "x86_64", "PowerPC", "ARM", "ARM64" };
+    const char *arch = getenv( "WINEARCH" );
+    int ret;
+    int reply_pipe[2];
+    struct sigaction sig_act;
+    size_t info_size;
+
+    sig_act.sa_handler = SIG_IGN;
+    sig_act.sa_flags   = 0;
+    sigemptyset( &sig_act.sa_mask );
+
+    /* ignore SIGPIPE so that we get an EPIPE error instead  */
+    sigaction( SIGPIPE, &sig_act, NULL );
+
+    /* create the server->client communication pipes */
+    if (server_pipe( reply_pipe ) == -1) server_protocol_perror( "pipe" );
+    if (server_pipe( ntdll_get_thread_data()->wait_fd ) == -1) server_protocol_perror( "pipe" );
+    wine_server_send_fd( reply_pipe[1] );
+    wine_server_send_fd( ntdll_get_thread_data()->wait_fd[1] );
+    ntdll_get_thread_data()->reply_fd = reply_pipe[0];
+    close( reply_pipe[1] );
+
+    SERVER_START_REQ( init_thread )
+    {
+        req->unix_pid    = getpid();
+        req->unix_tid    = get_unix_tid();
+        req->teb         = wine_server_client_ptr( NtCurrentTeb() );
+        req->entry       = wine_server_client_ptr( entry_point );
+        req->reply_fd    = reply_pipe[1];
+        req->wait_fd     = ntdll_get_thread_data()->wait_fd[1];
+        req->debug_level = (TRACE_ON(server) != 0);
+        req->cpu         = client_cpu;
+        ret = wine_server_call( req );
+        NtCurrentTeb()->ClientId.UniqueProcess = ULongToHandle(reply->pid);
+        NtCurrentTeb()->ClientId.UniqueThread  = ULongToHandle(reply->tid);
+        info_size         = reply->info_size;
+        server_start_time = reply->server_start;
+        server_cpus       = reply->all_cpus;
+        *suspend          = reply->suspend;
+    }
+    SERVER_END_REQ;
+
+    is_wow64 = !is_win64 && (server_cpus & ((1 << CPU_x86_64) | (1 << CPU_ARM64))) != 0;
+    ntdll_get_thread_data()->wow64_redir = is_wow64;
+
+    switch (ret)
+    {
+    case STATUS_SUCCESS:
+        if (arch)
+        {
+            if (!strcmp( arch, "win32" ) && (is_win64 || is_wow64))
+                fatal_error( "WINEARCH set to win32 but '%s' is a 64-bit installation.\n", config_dir );
+            if (!strcmp( arch, "win64" ) && !is_win64 && !is_wow64)
+                fatal_error( "WINEARCH set to win64 but '%s' is a 32-bit installation.\n", config_dir );
+        }
+        return info_size;
+    case STATUS_INVALID_IMAGE_WIN_64:
+        fatal_error( "'%s' is a 32-bit installation, it cannot support 64-bit applications.\n", config_dir );
+    case STATUS_NOT_SUPPORTED:
+        fatal_error( "'%s' is a 64-bit installation, it cannot be used with a 32-bit wineserver.\n", config_dir );
+    case STATUS_INVALID_IMAGE_FORMAT:
+        fatal_error( "wineserver doesn't support the %s architecture\n", cpu_names[client_cpu] );
+    default:
+        server_protocol_error( "init_thread failed with status %x\n", ret );
+    }
 }
diff --git a/dlls/ntdll/signal_arm.c b/dlls/ntdll/signal_arm.c
index ba455ea71e..31280edce4 100644
--- a/dlls/ntdll/signal_arm.c
+++ b/dlls/ntdll/signal_arm.c
@@ -21,8 +21,33 @@
 
 #ifdef __arm__
 
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
+#include <stdio.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYSCALL_H
+# include <syscall.h>
+#else
+# ifdef HAVE_SYS_SYSCALL_H
+#  include <sys/syscall.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SIGNAL_H
+# include <sys/signal.h>
+#endif
+#ifdef HAVE_SYS_UCONTEXT_H
+# include <sys/ucontext.h>
+#endif
 
 #define NONAMELESSUNION
 #define NONAMELESSSTRUCT
@@ -30,13 +55,127 @@
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winternl.h"
+#include "wine/library.h"
 #include "wine/exception.h"
 #include "ntdll_misc.h"
 #include "wine/debug.h"
 #include "winnt.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(seh);
+WINE_DECLARE_DEBUG_CHANNEL(relay);
+
+static pthread_key_t teb_key;
+
+/***********************************************************************
+ * signal context platform-specific definitions
+ */
+#ifdef linux
+
+#if defined(__ANDROID__) && !defined(HAVE_SYS_UCONTEXT_H)
+typedef struct ucontext
+{
+    unsigned long uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    struct sigcontext uc_mcontext;
+    sigset_t uc_sigmask;
+    unsigned long uc_regspace[128] __attribute__((__aligned__(8)));
+} ucontext_t;
+#endif
+
+/* All Registers access - only for local access */
+# define REG_sig(reg_name, context) ((context)->uc_mcontext.reg_name)
+# define REGn_sig(reg_num, context) ((context)->uc_mcontext.arm_r##reg_num)
+
+/* Special Registers access  */
+# define SP_sig(context)            REG_sig(arm_sp, context)    /* Stack pointer */
+# define LR_sig(context)            REG_sig(arm_lr, context)    /* Link register */
+# define PC_sig(context)            REG_sig(arm_pc, context)    /* Program counter */
+# define CPSR_sig(context)          REG_sig(arm_cpsr, context)  /* Current State Register */
+# define IP_sig(context)            REG_sig(arm_ip, context)    /* Intra-Procedure-call scratch register */
+# define FP_sig(context)            REG_sig(arm_fp, context)    /* Frame pointer */
+
+/* Exceptions */
+# define ERROR_sig(context)         REG_sig(error_code, context)
+# define TRAP_sig(context)          REG_sig(trap_no, context)
+
+#elif defined(__FreeBSD__)
+
+/* All Registers access - only for local access */
+# define REGn_sig(reg_num, context) ((context)->uc_mcontext.__gregs[reg_num])
 
+/* Special Registers access  */
+# define SP_sig(context)            REGn_sig(_REG_SP, context)    /* Stack pointer */
+# define LR_sig(context)            REGn_sig(_REG_LR, context)    /* Link register */
+# define PC_sig(context)            REGn_sig(_REG_PC, context)    /* Program counter */
+# define CPSR_sig(context)          REGn_sig(_REG_CPSR, context)  /* Current State Register */
+# define IP_sig(context)            REGn_sig(_REG_R12, context)   /* Intra-Procedure-call scratch register */
+# define FP_sig(context)            REGn_sig(_REG_FP, context)    /* Frame pointer */
+
+#endif /* linux */
+
+enum arm_trap_code
+{
+    TRAP_ARM_UNKNOWN    = -1,  /* Unknown fault (TRAP_sig not defined) */
+    TRAP_ARM_PRIVINFLT  =  6,  /* Invalid opcode exception */
+    TRAP_ARM_PAGEFLT    = 14,  /* Page fault */
+    TRAP_ARM_ALIGNFLT   = 17,  /* Alignment check exception */
+};
+
+typedef void (WINAPI *raise_func)( EXCEPTION_RECORD *rec, CONTEXT *context );
+typedef int (*wine_signal_handler)(unsigned int sig);
+
+static wine_signal_handler handlers[256];
+
+
+/***********************************************************************
+ *           get_trap_code
+ *
+ * Get the trap code for a signal.
+ */
+static inline enum arm_trap_code get_trap_code( int signal, const ucontext_t *sigcontext )
+{
+#ifdef TRAP_sig
+    enum arm_trap_code trap = TRAP_sig(sigcontext);
+    if (trap)
+        return trap;
+#endif
+
+    switch (signal)
+    {
+    case SIGILL:
+        return TRAP_ARM_PRIVINFLT;
+    case SIGSEGV:
+        return TRAP_ARM_PAGEFLT;
+    case SIGBUS:
+        return TRAP_ARM_ALIGNFLT;
+    default:
+        return TRAP_ARM_UNKNOWN;
+    }
+}
+
+/***********************************************************************
+ *           get_error_code
+ *
+ * Get the error code for a signal.
+ */
+static inline WORD get_error_code( const ucontext_t *sigcontext )
+{
+#ifdef ERROR_sig
+    return ERROR_sig(sigcontext);
+#else
+    return 0;
+#endif
+}
+
+/***********************************************************************
+ *           dispatch_signal
+ */
+static inline int dispatch_signal(unsigned int sig)
+{
+    if (handlers[sig] == NULL) return 0;
+    return handlers[sig](sig);
+}
 
 /*******************************************************************
  *         is_valid_frame
@@ -48,6 +187,69 @@ static inline BOOL is_valid_frame( void *frame )
             (void **)frame < (void **)NtCurrentTeb()->Tib.StackBase - 1);
 }
 
+/***********************************************************************
+ *           save_context
+ *
+ * Set the register values from a sigcontext.
+ */
+static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
+{
+#define C(x) context->R##x = REGn_sig(x,sigcontext)
+    /* Save normal registers */
+    C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
+#undef C
+
+    context->ContextFlags = CONTEXT_FULL;
+    context->Sp   = SP_sig(sigcontext);   /* Stack pointer */
+    context->Lr   = LR_sig(sigcontext);   /* Link register */
+    context->Pc   = PC_sig(sigcontext);   /* Program Counter */
+    context->Cpsr = CPSR_sig(sigcontext); /* Current State Register */
+    context->R11  = FP_sig(sigcontext);   /* Frame pointer */
+    context->R12  = IP_sig(sigcontext);   /* Intra-Procedure-call scratch register */
+}
+
+
+/***********************************************************************
+ *           restore_context
+ *
+ * Build a sigcontext from the register values.
+ */
+static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
+{
+#define C(x)  REGn_sig(x,sigcontext) = context->R##x
+    /* Restore normal registers */
+    C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
+#undef C
+
+    SP_sig(sigcontext)   = context->Sp;   /* Stack pointer */
+    LR_sig(sigcontext)   = context->Lr ;  /* Link register */
+    PC_sig(sigcontext)   = context->Pc;   /* Program Counter */
+    CPSR_sig(sigcontext) = context->Cpsr; /* Current State Register */
+    FP_sig(sigcontext)   = context->R11;  /* Frame pointer */
+    IP_sig(sigcontext)   = context->R12;  /* Intra-Procedure-call scratch register */
+}
+
+
+/***********************************************************************
+ *           save_fpu
+ *
+ * Set the FPU context from a sigcontext.
+ */
+static inline void save_fpu( CONTEXT *context, const ucontext_t *sigcontext )
+{
+    FIXME("not implemented\n");
+}
+
+
+/***********************************************************************
+ *           restore_fpu
+ *
+ * Restore the FPU context to a sigcontext.
+ */
+static inline void restore_fpu( CONTEXT *context, const ucontext_t *sigcontext )
+{
+    FIXME("not implemented\n");
+}
 
 /**************************************************************************
  *		__chkstk (NTDLL.@)
@@ -60,6 +262,7 @@ __ASM_GLOBAL_FUNC( __chkstk, "lsl r4, r4, #2\n\t"
 /***********************************************************************
  *		RtlCaptureContext (NTDLL.@)
  */
+/* FIXME: Use the Stack instead of the actual register values */
 __ASM_STDCALL_FUNC( RtlCaptureContext, 4,
                     ".arm\n\t"
                     "stmib r0, {r0-r12}\n\t"   /* context->R0..R12 */
@@ -68,13 +271,323 @@ __ASM_STDCALL_FUNC( RtlCaptureContext, 4,
                     "str r1, [r0]\n\t"         /* context->ContextFlags */
                     "str SP, [r0, #0x38]\n\t"  /* context->Sp */
                     "str LR, [r0, #0x3c]\n\t"  /* context->Lr */
-                    "str LR, [r0, #0x40]\n\t"  /* context->Pc */
+                    "str PC, [r0, #0x40]\n\t"  /* context->Pc */
                     "mrs r1, CPSR\n\t"
                     "str r1, [r0, #0x44]\n\t"  /* context->Cpsr */
                     "bx lr"
                     )
 
 
+/***********************************************************************
+ *           set_cpu_context
+ *
+ * Set the new CPU context.
+ */
+void DECLSPEC_HIDDEN set_cpu_context( const CONTEXT *context );
+__ASM_GLOBAL_FUNC( set_cpu_context,
+                   ".arm\n\t"
+                   "ldr r2, [r0, #0x44]\n\t"  /* context->Cpsr */
+                   "tst r2, #0x20\n\t"        /* thumb? */
+                   "ldr r1, [r0, #0x40]\n\t"  /* context->Pc */
+                   "orrne r1, r1, #1\n\t"     /* Adjust PC according to thumb */
+                   "biceq r1, r1, #1\n\t"     /* Adjust PC according to arm */
+                   "msr CPSR_f, r2\n\t"
+                   "ldr lr, [r0, #0x3c]\n\t"  /* context->Lr */
+                   "ldr sp, [r0, #0x38]\n\t"  /* context->Sp */
+                   "push {r1}\n\t"
+                   "ldmib r0, {r0-r12}\n\t"   /* context->R0..R12 */
+                   "pop {pc}" )
+
+
+/***********************************************************************
+ *           get_server_context_flags
+ *
+ * Convert CPU-specific flags to generic server flags
+ */
+static unsigned int get_server_context_flags( DWORD flags )
+{
+    unsigned int ret = 0;
+
+    flags &= ~CONTEXT_ARM;  /* get rid of CPU id */
+    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
+    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
+    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
+    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           copy_context
+ *
+ * Copy a register context according to the flags.
+ */
+static void copy_context( CONTEXT *to, const CONTEXT *from, DWORD flags )
+{
+    flags &= ~CONTEXT_ARM;  /* get rid of CPU id */
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->Sp      = from->Sp;
+        to->Lr      = from->Lr;
+        to->Pc      = from->Pc;
+        to->Cpsr    = from->Cpsr;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->R0  = from->R0;
+        to->R1  = from->R1;
+        to->R2  = from->R2;
+        to->R3  = from->R3;
+        to->R4  = from->R4;
+        to->R5  = from->R5;
+        to->R6  = from->R6;
+        to->R7  = from->R7;
+        to->R8  = from->R8;
+        to->R9  = from->R9;
+        to->R10 = from->R10;
+        to->R11 = from->R11;
+        to->R12 = from->R12;
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->Fpscr = from->Fpscr;
+        memcpy( to->u.D, from->u.D, sizeof(to->u.D) );
+    }
+}
+
+
+/***********************************************************************
+ *           context_to_server
+ *
+ * Convert a register context to the server format.
+ */
+NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
+{
+    DWORD i, flags = from->ContextFlags & ~CONTEXT_ARM;  /* get rid of CPU id */
+
+    memset( to, 0, sizeof(*to) );
+    to->cpu = CPU_ARM;
+
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->flags |= SERVER_CTX_CONTROL;
+        to->ctl.arm_regs.sp   = from->Sp;
+        to->ctl.arm_regs.lr   = from->Lr;
+        to->ctl.arm_regs.pc   = from->Pc;
+        to->ctl.arm_regs.cpsr = from->Cpsr;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->flags |= SERVER_CTX_INTEGER;
+        to->integer.arm_regs.r[0]  = from->R0;
+        to->integer.arm_regs.r[1]  = from->R1;
+        to->integer.arm_regs.r[2]  = from->R2;
+        to->integer.arm_regs.r[3]  = from->R3;
+        to->integer.arm_regs.r[4]  = from->R4;
+        to->integer.arm_regs.r[5]  = from->R5;
+        to->integer.arm_regs.r[6]  = from->R6;
+        to->integer.arm_regs.r[7]  = from->R7;
+        to->integer.arm_regs.r[8]  = from->R8;
+        to->integer.arm_regs.r[9]  = from->R9;
+        to->integer.arm_regs.r[10] = from->R10;
+        to->integer.arm_regs.r[11] = from->R11;
+        to->integer.arm_regs.r[12] = from->R12;
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->flags |= SERVER_CTX_FLOATING_POINT;
+        for (i = 0; i < 32; i++) to->fp.arm_regs.d[i] = from->u.D[i];
+        to->fp.arm_regs.fpscr = from->Fpscr;
+    }
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
+        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->debug.arm_regs.bvr[i] = from->Bvr[i];
+        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->debug.arm_regs.bcr[i] = from->Bcr[i];
+        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->debug.arm_regs.wvr[i] = from->Wvr[i];
+        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->debug.arm_regs.wcr[i] = from->Wcr[i];
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           context_from_server
+ *
+ * Convert a register context from the server format.
+ */
+NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
+{
+    DWORD i;
+
+    if (from->cpu != CPU_ARM) return STATUS_INVALID_PARAMETER;
+
+    to->ContextFlags = CONTEXT_ARM;
+    if (from->flags & SERVER_CTX_CONTROL)
+    {
+        to->ContextFlags |= CONTEXT_CONTROL;
+        to->Sp   = from->ctl.arm_regs.sp;
+        to->Lr   = from->ctl.arm_regs.lr;
+        to->Pc   = from->ctl.arm_regs.pc;
+        to->Cpsr = from->ctl.arm_regs.cpsr;
+    }
+    if (from->flags & SERVER_CTX_INTEGER)
+    {
+        to->ContextFlags |= CONTEXT_INTEGER;
+        to->R0  = from->integer.arm_regs.r[0];
+        to->R1  = from->integer.arm_regs.r[1];
+        to->R2  = from->integer.arm_regs.r[2];
+        to->R3  = from->integer.arm_regs.r[3];
+        to->R4  = from->integer.arm_regs.r[4];
+        to->R5  = from->integer.arm_regs.r[5];
+        to->R6  = from->integer.arm_regs.r[6];
+        to->R7  = from->integer.arm_regs.r[7];
+        to->R8  = from->integer.arm_regs.r[8];
+        to->R9  = from->integer.arm_regs.r[9];
+        to->R10 = from->integer.arm_regs.r[10];
+        to->R11 = from->integer.arm_regs.r[11];
+        to->R12 = from->integer.arm_regs.r[12];
+    }
+    if (from->flags & SERVER_CTX_FLOATING_POINT)
+    {
+        to->ContextFlags |= CONTEXT_FLOATING_POINT;
+        for (i = 0; i < 32; i++) to->u.D[i] = from->fp.arm_regs.d[i];
+        to->Fpscr = from->fp.arm_regs.fpscr;
+    }
+    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
+    {
+        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
+        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->Bvr[i] = from->debug.arm_regs.bvr[i];
+        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->Bcr[i] = from->debug.arm_regs.bcr[i];
+        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->Wvr[i] = from->debug.arm_regs.wvr[i];
+        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->Wcr[i] = from->debug.arm_regs.wcr[i];
+    }
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *              NtSetContextThread  (NTDLL.@)
+ *              ZwSetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
+{
+    NTSTATUS ret;
+    BOOL self;
+    context_t server_context;
+
+    context_to_server( &server_context, context );
+    ret = set_thread_context( handle, &server_context, &self );
+    if (self && ret == STATUS_SUCCESS) set_cpu_context( context );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              NtGetContextThread  (NTDLL.@)
+ *              ZwGetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
+{
+    NTSTATUS ret;
+    DWORD needed_flags = context->ContextFlags;
+    BOOL self = (handle == GetCurrentThread());
+
+    if (!self)
+    {
+        context_t server_context;
+        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
+
+        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
+        if ((ret = context_from_server( context, &server_context ))) return ret;
+        needed_flags &= ~context->ContextFlags;
+    }
+
+    if (self && needed_flags)
+    {
+        CONTEXT ctx;
+        RtlCaptureContext( &ctx );
+        copy_context( context, &ctx, ctx.ContextFlags & needed_flags );
+        context->ContextFlags |= ctx.ContextFlags & needed_flags;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+extern void raise_func_trampoline_thumb( EXCEPTION_RECORD *rec, CONTEXT *context, raise_func func );
+__ASM_GLOBAL_FUNC( raise_func_trampoline_thumb,
+                   ".thumb\n\t"
+                   "blx r2\n\t"
+                   "bkpt")
+
+extern void raise_func_trampoline_arm( EXCEPTION_RECORD *rec, CONTEXT *context, raise_func func );
+__ASM_GLOBAL_FUNC( raise_func_trampoline_arm,
+                   ".arm\n\t"
+                   "blx r2\n\t"
+                   "bkpt")
+
+/***********************************************************************
+ *           setup_exception_record
+ *
+ * Setup the exception record and context on the thread stack.
+ */
+static EXCEPTION_RECORD *setup_exception( ucontext_t *sigcontext, raise_func func )
+{
+    struct stack_layout
+    {
+        CONTEXT           context;
+        EXCEPTION_RECORD  rec;
+    } *stack;
+    DWORD exception_code = 0;
+
+    stack = (struct stack_layout *)(SP_sig(sigcontext) & ~3);
+    stack--;  /* push the stack_layout structure */
+
+    stack->rec.ExceptionRecord  = NULL;
+    stack->rec.ExceptionCode    = exception_code;
+    stack->rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    stack->rec.ExceptionAddress = (LPVOID)PC_sig(sigcontext);
+    stack->rec.NumberParameters = 0;
+
+    save_context( &stack->context, sigcontext );
+
+    /* now modify the sigcontext to return to the raise function */
+    SP_sig(sigcontext) = (DWORD)stack;
+    if (CPSR_sig(sigcontext) & 0x20)
+        PC_sig(sigcontext) = (DWORD)raise_func_trampoline_thumb;
+    else
+        PC_sig(sigcontext) = (DWORD)raise_func_trampoline_arm;
+    REGn_sig(0, sigcontext) = (DWORD)&stack->rec;  /* first arg for raise_func */
+    REGn_sig(1, sigcontext) = (DWORD)&stack->context; /* second arg for raise_func */
+    REGn_sig(2, sigcontext) = (DWORD)func; /* the raise_func as third arg for the trampoline */
+
+
+    return &stack->rec;
+}
+
+/**********************************************************************
+ *		raise_segv_exception
+ */
+static void WINAPI raise_segv_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
+{
+    NTSTATUS status;
+
+    switch(rec->ExceptionCode)
+    {
+    case EXCEPTION_ACCESS_VIOLATION:
+        if (rec->NumberParameters == 2)
+        {
+            if (!(rec->ExceptionCode = virtual_handle_fault( (void *)rec->ExceptionInformation[1],
+                                                             rec->ExceptionInformation[0], FALSE )))
+                goto done;
+        }
+        break;
+    }
+    status = NtRaiseException( rec, context, TRUE );
+    if (status) raise_status( status, rec );
+done:
+    set_cpu_context( context );
+}
+
 /**********************************************************************
  *           call_stack_handlers
  *
@@ -130,48 +643,392 @@ static NTSTATUS call_stack_handlers( EXCEPTION_RECORD *rec, CONTEXT *context )
 
 
 /*******************************************************************
- *		KiUserExceptionDispatcher (NTDLL.@)
+ *		raise_exception
+ *
+ * Implementation of NtRaiseException.
  */
-NTSTATUS WINAPI KiUserExceptionDispatcher( EXCEPTION_RECORD *rec, CONTEXT *context )
+static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
 {
     NTSTATUS status;
-    DWORD c;
 
-    TRACE( "code=%x flags=%x addr=%p pc=%08x tid=%04x\n",
-           rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
-           context->Pc, GetCurrentThreadId() );
-    for (c = 0; c < rec->NumberParameters; c++)
-        TRACE( " info[%d]=%08lx\n", c, rec->ExceptionInformation[c] );
+    if (first_chance)
+    {
+        DWORD c;
 
-    if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+        TRACE( "code=%x flags=%x addr=%p pc=%08x tid=%04x\n",
+               rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
+               context->Pc, GetCurrentThreadId() );
+        for (c = 0; c < rec->NumberParameters; c++)
+            TRACE( " info[%d]=%08lx\n", c, rec->ExceptionInformation[c] );
+        if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+        {
+            if (rec->ExceptionInformation[1] >> 16)
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+            else
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+        }
+        else
+        {
+            TRACE( " r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x\n",
+                   context->R0, context->R1, context->R2, context->R3, context->R4, context->R5 );
+            TRACE( " r6=%08x r7=%08x r8=%08x r9=%08x r10=%08x r11=%08x\n",
+                   context->R6, context->R7, context->R8, context->R9, context->R10, context->R11 );
+            TRACE( " r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
+                   context->R12, context->Sp, context->Lr, context->Pc, context->Cpsr );
+        }
+
+        status = send_debug_event( rec, TRUE, context );
+        if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
+            return STATUS_SUCCESS;
+
+        if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION)
+            return STATUS_SUCCESS;
+
+        if ((status = call_stack_handlers( rec, context )) != STATUS_UNHANDLED_EXCEPTION)
+            return status;
+    }
+
+    /* last chance exception */
+
+    status = send_debug_event( rec, FALSE, context );
+    if (status != DBG_CONTINUE)
     {
-        if (rec->ExceptionInformation[1] >> 16)
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+        if (rec->ExceptionFlags & EH_STACK_INVALID)
+            ERR("Exception frame is not in stack limits => unable to dispatch exception.\n");
+        else if (rec->ExceptionCode == STATUS_NONCONTINUABLE_EXCEPTION)
+            ERR("Process attempted to continue execution after noncontinuable exception.\n");
         else
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+            ERR("Unhandled exception code %x flags %x addr %p\n",
+                rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress );
+        NtTerminateProcess( NtCurrentProcess(), rec->ExceptionCode );
     }
-    else
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *		segv_handler
+ *
+ * Handler for SIGSEGV and related errors.
+ */
+static void segv_handler( int signal, siginfo_t *info, void *ucontext )
+{
+    EXCEPTION_RECORD *rec;
+    ucontext_t *context = ucontext;
+
+    /* check for page fault inside the thread stack */
+    if (get_trap_code(signal, context) == TRAP_ARM_PAGEFLT)
+    {
+        switch (virtual_handle_stack_fault( info->si_addr ))
+        {
+        case 1:  /* handled */
+            return;
+        case -1:  /* overflow */
+            rec = setup_exception( context, raise_segv_exception );
+            rec->ExceptionCode = EXCEPTION_STACK_OVERFLOW;
+            return;
+        }
+    }
+
+    rec = setup_exception( context, raise_segv_exception );
+    if (rec->ExceptionCode == EXCEPTION_STACK_OVERFLOW) return;
+
+    switch(get_trap_code(signal, context))
+    {
+    case TRAP_ARM_PRIVINFLT:   /* Invalid opcode exception */
+        rec->ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    case TRAP_ARM_PAGEFLT:  /* Page fault */
+        rec->ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
+        rec->NumberParameters = 2;
+        rec->ExceptionInformation[0] = (get_error_code(context) & 0x800) != 0;
+        rec->ExceptionInformation[1] = (ULONG_PTR)info->si_addr;
+        break;
+    case TRAP_ARM_ALIGNFLT:  /* Alignment check exception */
+        rec->ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
+        break;
+    case TRAP_ARM_UNKNOWN:   /* Unknown fault code */
+        rec->ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
+        rec->NumberParameters = 2;
+        rec->ExceptionInformation[0] = 0;
+        rec->ExceptionInformation[1] = 0xffffffff;
+        break;
+    default:
+        ERR("Got unexpected trap %d\n", get_trap_code(signal, context));
+        rec->ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    }
+}
+
+/**********************************************************************
+ *		trap_handler
+ *
+ * Handler for SIGTRAP.
+ */
+static void trap_handler( int signal, siginfo_t *info, void *ucontext )
+{
+    EXCEPTION_RECORD rec;
+    CONTEXT context;
+    NTSTATUS status;
+
+    switch ( info->si_code )
     {
-        TRACE( " r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x\n",
-               context->R0, context->R1, context->R2, context->R3, context->R4, context->R5 );
-        TRACE( " r6=%08x r7=%08x r8=%08x r9=%08x r10=%08x r11=%08x\n",
-               context->R6, context->R7, context->R8, context->R9, context->R10, context->R11 );
-        TRACE( " r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
-               context->R12, context->Sp, context->Lr, context->Pc, context->Cpsr );
+    case TRAP_TRACE:
+        rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
+        break;
+    case TRAP_BRKPT:
+    default:
+        rec.ExceptionCode = EXCEPTION_BREAKPOINT;
+        break;
+    }
+
+    save_context( &context, ucontext );
+    rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    rec.ExceptionRecord  = NULL;
+    rec.ExceptionAddress = (LPVOID)context.Pc;
+    rec.NumberParameters = 0;
+    status = raise_exception( &rec, &context, TRUE );
+    if (status) raise_status( status, &rec );
+    restore_context( &context, ucontext );
+}
+
+/**********************************************************************
+ *		fpe_handler
+ *
+ * Handler for SIGFPE.
+ */
+static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    EXCEPTION_RECORD rec;
+    CONTEXT context;
+    NTSTATUS status;
+
+    save_fpu( &context, sigcontext );
+    save_context( &context, sigcontext );
+
+    switch (siginfo->si_code & 0xffff )
+    {
+#ifdef FPE_FLTSUB
+    case FPE_FLTSUB:
+        rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
+        break;
+#endif
+#ifdef FPE_INTDIV
+    case FPE_INTDIV:
+        rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
+        break;
+#endif
+#ifdef FPE_INTOVF
+    case FPE_INTOVF:
+        rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTDIV
+    case FPE_FLTDIV:
+        rec.ExceptionCode = EXCEPTION_FLT_DIVIDE_BY_ZERO;
+        break;
+#endif
+#ifdef FPE_FLTOVF
+    case FPE_FLTOVF:
+        rec.ExceptionCode = EXCEPTION_FLT_OVERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTUND
+    case FPE_FLTUND:
+        rec.ExceptionCode = EXCEPTION_FLT_UNDERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTRES
+    case FPE_FLTRES:
+        rec.ExceptionCode = EXCEPTION_FLT_INEXACT_RESULT;
+        break;
+#endif
+#ifdef FPE_FLTINV
+    case FPE_FLTINV:
+#endif
+    default:
+        rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
+        break;
+    }
+    rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    rec.ExceptionRecord  = NULL;
+    rec.ExceptionAddress = (LPVOID)context.Pc;
+    rec.NumberParameters = 0;
+    status = raise_exception( &rec, &context, TRUE );
+    if (status) raise_status( status, &rec );
+
+    restore_context( &context, sigcontext );
+    restore_fpu( &context, sigcontext );
+}
+
+/**********************************************************************
+ *		int_handler
+ *
+ * Handler for SIGINT.
+ */
+static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    if (!dispatch_signal(SIGINT))
+    {
+        EXCEPTION_RECORD rec;
+        CONTEXT context;
+        NTSTATUS status;
+
+        save_context( &context, sigcontext );
+        rec.ExceptionCode    = CONTROL_C_EXIT;
+        rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+        rec.ExceptionRecord  = NULL;
+        rec.ExceptionAddress = (LPVOID)context.Pc;
+        rec.NumberParameters = 0;
+        status = raise_exception( &rec, &context, TRUE );
+        if (status) raise_status( status, &rec );
+        restore_context( &context, sigcontext );
     }
+}
+
+
+/**********************************************************************
+ *		abrt_handler
+ *
+ * Handler for SIGABRT.
+ */
+static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    EXCEPTION_RECORD rec;
+    CONTEXT context;
+    NTSTATUS status;
+
+    save_context( &context, sigcontext );
+    rec.ExceptionCode    = EXCEPTION_WINE_ASSERTION;
+    rec.ExceptionFlags   = EH_NONCONTINUABLE;
+    rec.ExceptionRecord  = NULL;
+    rec.ExceptionAddress = (LPVOID)context.Pc;
+    rec.NumberParameters = 0;
+    status = raise_exception( &rec, &context, TRUE );
+    if (status) raise_status( status, &rec );
+    restore_context( &context, sigcontext );
+}
+
+
+/**********************************************************************
+ *		quit_handler
+ *
+ * Handler for SIGQUIT.
+ */
+static void quit_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    abort_thread(0);
+}
+
+
+/**********************************************************************
+ *		usr1_handler
+ *
+ * Handler for SIGUSR1, used to signal a thread that it got suspended.
+ */
+static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    CONTEXT context;
+
+    save_context( &context, sigcontext );
+    wait_suspend( &context );
+    restore_context( &context, sigcontext );
+}
+
+
+/***********************************************************************
+ *           __wine_set_signal_handler   (NTDLL.@)
+ */
+int CDECL __wine_set_signal_handler(unsigned int sig, wine_signal_handler wsh)
+{
+    if (sig >= ARRAY_SIZE(handlers)) return -1;
+    if (handlers[sig] != NULL) return -2;
+    handlers[sig] = wsh;
+    return 0;
+}
+
+
+/**********************************************************************
+ *             signal_init_threading
+ */
+void signal_init_threading(void)
+{
+    pthread_key_create( &teb_key, NULL );
+}
+
+
+/**********************************************************************
+ *             signal_alloc_thread
+ */
+NTSTATUS signal_alloc_thread( TEB *teb )
+{
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *             signal_free_thread
+ */
+void signal_free_thread( TEB *teb )
+{
+}
+
+
+/**********************************************************************
+ *		signal_init_thread
+ */
+void signal_init_thread( TEB *teb )
+{
+#if defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_8A__)
+    /* Win32/ARM applications expect the TEB pointer to be in the TPIDRURW register. */
+    __asm__ __volatile__( "mcr p15, 0, %0, c13, c0, 2" : : "r" (teb) );
+#endif
+
+    pthread_setspecific( teb_key, teb );
+}
 
-    if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION)
-        NtContinue( context, FALSE );
 
-    if ((status = call_stack_handlers( rec, context )) == STATUS_SUCCESS)
-        NtContinue( context, FALSE );
+/**********************************************************************
+ *		signal_init_process
+ */
+void signal_init_process(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_RESTART | SA_SIGINFO;
+
+    sig_act.sa_sigaction = int_handler;
+    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = fpe_handler;
+    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = abrt_handler;
+    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = quit_handler;
+    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
+
+    sig_act.sa_sigaction = segv_handler;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
+    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
+#ifdef SIGBUS
+    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+#endif
 
-    if (status != STATUS_UNHANDLED_EXCEPTION) RtlRaiseStatus( status );
-    return NtRaiseException( rec, context, FALSE );
+#ifdef SIGTRAP
+    sig_act.sa_sigaction = trap_handler;
+    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
+#endif
+    return;
+
+ error:
+    perror("sigaction");
+    exit(1);
 }
 
 
@@ -234,25 +1091,29 @@ void WINAPI RtlUnwind( void *endframe, void *target_ip, EXCEPTION_RECORD *rec, v
     }
 }
 
+/*******************************************************************
+ *		NtRaiseException (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRaiseException( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+{
+    NTSTATUS status = raise_exception( rec, context, first_chance );
+    if (status == STATUS_SUCCESS) NtSetContextThread( GetCurrentThread(), context );
+    return status;
+}
 
 /***********************************************************************
  *		RtlRaiseException (NTDLL.@)
  */
-__ASM_STDCALL_FUNC( RtlRaiseException, 4,
-                    "push {r0, lr}\n\t"
-                    "sub sp, sp, #0x1a0\n\t"  /* sizeof(CONTEXT) */
-                    "mov r0, sp\n\t"  /* context */
-                    "bl " __ASM_NAME("RtlCaptureContext") "\n\t"
-                    "ldr r0, [sp, #0x1a0]\n\t" /* rec */
-                    "ldr r1, [sp, #0x1a4]\n\t"
-                    "str r1, [sp, #0x40]\n\t"  /* context->Pc */
-                    "str r1, [r0, #12]\n\t"    /* rec->ExceptionAddress */
-                    "add r1, sp, #0x1a8\n\t"
-                    "str r1, [sp, #0x38]\n\t"  /* context->Sp */
-                    "mov r1, sp\n\t"
-                    "mov r2, #1\n\t"
-                    "bl " __ASM_NAME("NtRaiseException") "\n\t"
-                    "bl " __ASM_NAME("RtlRaiseStatus") )
+void WINAPI RtlRaiseException( EXCEPTION_RECORD *rec )
+{
+    CONTEXT context;
+    NTSTATUS status;
+
+    RtlCaptureContext( &context );
+    rec->ExceptionAddress = (LPVOID)context.Pc;
+    status = raise_exception( rec, &context, TRUE );
+    if (status) raise_status( status, rec );
+}
 
 /*************************************************************************
  *             RtlCaptureStackBackTrace (NTDLL.@)
@@ -263,22 +1124,176 @@ USHORT WINAPI RtlCaptureStackBackTrace( ULONG skip, ULONG count, PVOID *buffer,
     return 0;
 }
 
+/***********************************************************************
+ *           call_thread_entry_point
+ */
+static void call_thread_entry_point( LPTHREAD_START_ROUTINE entry, void *arg )
+{
+    __TRY
+    {
+        TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", entry, arg );
+        RtlExitUserThread( entry( arg ));
+    }
+    __EXCEPT(call_unhandled_exception_filter)
+    {
+        NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+    }
+    __ENDTRY
+    abort();  /* should not be reached */
+}
+
+extern void DECLSPEC_NORETURN start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend,
+                                            void *relay, TEB *teb );
+__ASM_GLOBAL_FUNC( start_thread,
+                   ".arm\n\t"
+                   "push {r4-r12,lr}\n\t"
+                   /* store exit frame */
+                   "ldr r4, [sp, #40]\n\t"    /* teb */
+                   "str sp, [r4, #0x1d4]\n\t" /* teb->SystemReserved2 */
+                   /* switch to thread stack */
+                   "ldr r4, [r4, #4]\n\t"     /* teb->Tib.StackBase */
+                   "sub sp, r4, #0x1000\n\t"
+                   /* attach dlls */
+                   "bl " __ASM_NAME("attach_thread") "\n\t"
+                   "mov sp, r0\n\t"
+                   /* clear the stack */
+                   "and r0, #~0xff0\n\t"  /* round down to page size */
+                   "bl " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
+                   /* switch to the initial context */
+                   "mov r0, sp\n\t"
+                   "b " __ASM_NAME("set_cpu_context") )
+
+extern void DECLSPEC_NORETURN call_thread_exit_func( int status, void (*func)(int), TEB *teb );
+__ASM_GLOBAL_FUNC( call_thread_exit_func,
+                   ".arm\n\t"
+                   "ldr r3, [r2, #0x1d4]\n\t"  /* teb->SystemReserved2 */
+                   "mov ip, #0\n\t"
+                   "str ip, [r2, #0x1d4]\n\t"
+                   "cmp r3, ip\n\t"
+                   "movne sp, r3\n\t"
+                   "blx r1" )
+
+/***********************************************************************
+ *           init_thread_context
+ */
+static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
+{
+    context->R0 = (DWORD)entry;
+    context->R1 = (DWORD)arg;
+    context->Sp = (DWORD)NtCurrentTeb()->Tib.StackBase;
+    context->Pc = (DWORD)relay;
+}
+
+
+/***********************************************************************
+ *           attach_thread
+ */
+PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
+                                        BOOL suspend, void *relay )
+{
+    CONTEXT *ctx;
+
+    if (suspend)
+    {
+        CONTEXT context = { CONTEXT_ALL };
+
+        init_thread_context( &context, entry, arg, relay );
+        wait_suspend( &context );
+        ctx = (CONTEXT *)((ULONG_PTR)context.Sp & ~15) - 1;
+        *ctx = context;
+    }
+    else
+    {
+        ctx = (CONTEXT *)NtCurrentTeb()->Tib.StackBase - 1;
+        init_thread_context( ctx, entry, arg, relay );
+    }
+    ctx->ContextFlags = CONTEXT_FULL;
+    LdrInitializeThunk( ctx, (void **)&ctx->R0, 0, 0 );
+    return ctx;
+}
+
+
+/***********************************************************************
+ *           signal_start_thread
+ *
+ * Thread startup sequence:
+ * signal_start_thread()
+ *   -> thread_startup()
+ *     -> call_thread_entry_point()
+ */
+void signal_start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend )
+{
+    start_thread( entry, arg, suspend, call_thread_entry_point, NtCurrentTeb() );
+}
+
+/**********************************************************************
+ *		signal_start_process
+ *
+ * Process startup sequence:
+ * signal_start_process()
+ *   -> thread_startup()
+ *     -> kernel32_start_process()
+ */
+void signal_start_process( LPTHREAD_START_ROUTINE entry, BOOL suspend )
+{
+    start_thread( entry, NtCurrentTeb()->Peb, suspend, kernel32_start_process, NtCurrentTeb() );
+}
+
+/***********************************************************************
+ *           signal_exit_thread
+ */
+void signal_exit_thread( int status )
+{
+    call_thread_exit_func( status, exit_thread, NtCurrentTeb() );
+}
+
+/***********************************************************************
+ *           signal_exit_process
+ */
+void signal_exit_process( int status )
+{
+    call_thread_exit_func( status, exit, NtCurrentTeb() );
+}
+
+/**********************************************************************
+ *           get_thread_ldt_entry
+ */
+NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *           NtSetLdtEntries   (NTDLL.@)
+ *           ZwSetLdtEntries   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
 /**********************************************************************
  *              DbgBreakPoint   (NTDLL.@)
  */
-__ASM_STDCALL_FUNC( DbgBreakPoint, 0, "bkpt #0; bx lr; nop; nop; nop; nop" );
+void WINAPI DbgBreakPoint(void)
+{
+     kill(getpid(), SIGTRAP);
+}
 
 /**********************************************************************
  *              DbgUserBreakPoint   (NTDLL.@)
  */
-__ASM_STDCALL_FUNC( DbgUserBreakPoint, 0, "bkpt #0; bx lr; nop; nop; nop; nop" );
+void WINAPI DbgUserBreakPoint(void)
+{
+     kill(getpid(), SIGTRAP);
+}
 
 /**********************************************************************
  *           NtCurrentTeb   (NTDLL.@)
  */
 TEB * WINAPI NtCurrentTeb(void)
 {
-    return unix_funcs->NtCurrentTeb();
+    return pthread_getspecific( teb_key );
 }
 
 #endif  /* __arm__ */
diff --git a/dlls/ntdll/signal_arm64.c b/dlls/ntdll/signal_arm64.c
index a35e48c1d6..01b7e9bbf1 100644
--- a/dlls/ntdll/signal_arm64.c
+++ b/dlls/ntdll/signal_arm64.c
@@ -20,11 +20,37 @@
 
 #ifdef __aarch64__
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdio.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYSCALL_H
+# include <syscall.h>
+#else
+# ifdef HAVE_SYS_SYSCALL_H
+#  include <sys/syscall.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SIGNAL_H
+# include <sys/signal.h>
+#endif
+#ifdef HAVE_SYS_UCONTEXT_H
+# include <sys/ucontext.h>
+#endif
+#ifdef HAVE_LIBUNWIND
+# define UNW_LOCAL_ONLY
+# include <libunwind.h>
+#endif
 
 #define NONAMELESSUNION
 #define NONAMELESSSTRUCT
@@ -32,12 +58,16 @@
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winternl.h"
+#include "wine/library.h"
 #include "wine/exception.h"
 #include "ntdll_misc.h"
 #include "wine/debug.h"
 #include "winnt.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(seh);
+WINE_DECLARE_DEBUG_CHANNEL(relay);
+
+static pthread_key_t teb_key;
 
 /* layering violation: the setjmp buffer is defined in msvcrt, but used by RtlUnwindEx */
 struct MSVCRT_JUMP_BUFFER
@@ -62,6 +92,95 @@ struct MSVCRT_JUMP_BUFFER
     double D[8];
 };
 
+/***********************************************************************
+ * signal context platform-specific definitions
+ */
+#ifdef linux
+
+/* All Registers access - only for local access */
+# define REG_sig(reg_name, context) ((context)->uc_mcontext.reg_name)
+# define REGn_sig(reg_num, context) ((context)->uc_mcontext.regs[reg_num])
+
+/* Special Registers access  */
+# define SP_sig(context)            REG_sig(sp, context)    /* Stack pointer */
+# define PC_sig(context)            REG_sig(pc, context)    /* Program counter */
+# define PSTATE_sig(context)        REG_sig(pstate, context) /* Current State Register */
+# define FP_sig(context)            REGn_sig(29, context)    /* Frame pointer */
+# define LR_sig(context)            REGn_sig(30, context)    /* Link Register */
+
+static struct _aarch64_ctx *get_extended_sigcontext( ucontext_t *sigcontext, unsigned int magic )
+{
+    struct _aarch64_ctx *ctx = (struct _aarch64_ctx *)sigcontext->uc_mcontext.__reserved;
+    while ((char *)ctx < (char *)(&sigcontext->uc_mcontext + 1) && ctx->magic && ctx->size)
+    {
+        if (ctx->magic == magic) return ctx;
+        ctx = (struct _aarch64_ctx *)((char *)ctx + ctx->size);
+    }
+    return NULL;
+}
+
+static struct fpsimd_context *get_fpsimd_context( ucontext_t *sigcontext )
+{
+    return (struct fpsimd_context *)get_extended_sigcontext( sigcontext, FPSIMD_MAGIC );
+}
+
+static DWORD64 get_fault_esr( ucontext_t *sigcontext )
+{
+    struct esr_context *esr = (struct esr_context *)get_extended_sigcontext( sigcontext, ESR_MAGIC );
+    if (esr) return esr->esr;
+    return 0;
+}
+
+#endif /* linux */
+
+static const size_t teb_size = 0x2000;  /* we reserve two pages for the TEB */
+
+typedef void (*raise_func)( EXCEPTION_RECORD *rec, CONTEXT *context );
+
+/* stack layout when calling an exception raise function */
+struct stack_layout
+{
+    CONTEXT           context;
+    EXCEPTION_RECORD  rec;
+    void             *redzone[2];
+};
+
+typedef int (*wine_signal_handler)(unsigned int sig);
+
+static wine_signal_handler handlers[256];
+
+struct arm64_thread_data
+{
+    void     *exit_frame;    /* exit frame pointer */
+    CONTEXT  *context;       /* context to set with SIGUSR2 */
+};
+
+C_ASSERT( sizeof(struct arm64_thread_data) <= sizeof(((TEB *)0)->SystemReserved2) );
+C_ASSERT( offsetof( TEB, SystemReserved2 ) + offsetof( struct arm64_thread_data, exit_frame ) == 0x300 );
+
+static inline struct arm64_thread_data *arm64_thread_data(void)
+{
+    return (struct arm64_thread_data *)NtCurrentTeb()->SystemReserved2;
+}
+
+/***********************************************************************
+ *           dispatch_signal
+ */
+static inline int dispatch_signal(unsigned int sig)
+{
+    if (handlers[sig] == NULL) return 0;
+    return handlers[sig](sig);
+}
+
+/***********************************************************************
+ *           get_signal_stack
+ *
+ * Get the base of the signal stack for the current thread.
+ */
+static inline void *get_signal_stack(void)
+{
+    return (char *)NtCurrentTeb() + teb_size;
+}
 
 /*******************************************************************
  *         is_valid_frame
@@ -73,12 +192,90 @@ static inline BOOL is_valid_frame( ULONG_PTR frame )
             (void **)frame < (void **)NtCurrentTeb()->Tib.StackBase - 1);
 }
 
+/***********************************************************************
+ *           is_inside_signal_stack
+ *
+ * Check if pointer is inside the signal stack.
+ */
+static inline BOOL is_inside_signal_stack( void *ptr )
+{
+    return ((char *)ptr >= (char *)get_signal_stack() &&
+            (char *)ptr < (char *)get_signal_stack() + signal_stack_size);
+}
+
+/***********************************************************************
+ *           save_context
+ *
+ * Set the register values from a sigcontext.
+ */
+static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
+{
+    DWORD i;
+
+    context->ContextFlags = CONTEXT_FULL;
+    context->u.s.Fp = FP_sig(sigcontext);     /* Frame pointer */
+    context->u.s.Lr = LR_sig(sigcontext);     /* Link register */
+    context->Sp     = SP_sig(sigcontext);     /* Stack pointer */
+    context->Pc     = PC_sig(sigcontext);     /* Program Counter */
+    context->Cpsr   = PSTATE_sig(sigcontext); /* Current State Register */
+    for (i = 0; i <= 28; i++) context->u.X[i] = REGn_sig( i, sigcontext );
+}
+
+
+/***********************************************************************
+ *           restore_context
+ *
+ * Build a sigcontext from the register values.
+ */
+static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
+{
+    DWORD i;
+
+    FP_sig(sigcontext)     = context->u.s.Fp; /* Frame pointer */
+    LR_sig(sigcontext)     = context->u.s.Lr; /* Link register */
+    SP_sig(sigcontext)     = context->Sp;     /* Stack pointer */
+    PC_sig(sigcontext)     = context->Pc;     /* Program Counter */
+    PSTATE_sig(sigcontext) = context->Cpsr;   /* Current State Register */
+    for (i = 0; i <= 28; i++) REGn_sig( i, sigcontext ) = context->u.X[i];
+}
+
+
+/***********************************************************************
+ *           save_fpu
+ *
+ * Set the FPU context from a sigcontext.
+ */
+static void save_fpu( CONTEXT *context, ucontext_t *sigcontext )
+{
+    struct fpsimd_context *fp = get_fpsimd_context( sigcontext );
+
+    if (!fp) return;
+    context->ContextFlags |= CONTEXT_FLOATING_POINT;
+    context->Fpcr = fp->fpcr;
+    context->Fpsr = fp->fpsr;
+    memcpy( context->V, fp->vregs, sizeof(context->V) );
+}
+
+
+/***********************************************************************
+ *           restore_fpu
+ *
+ * Restore the FPU context to a sigcontext.
+ */
+static void restore_fpu( CONTEXT *context, ucontext_t *sigcontext )
+{
+    struct fpsimd_context *fp = get_fpsimd_context( sigcontext );
+
+    if (!fp) return;
+    fp->fpcr = context->Fpcr;
+    fp->fpsr = context->Fpsr;
+    memcpy( fp->vregs, context->V, sizeof(fp->vregs) );
+}
 
 /***********************************************************************
  *		RtlCaptureContext (NTDLL.@)
  */
 __ASM_STDCALL_FUNC( RtlCaptureContext, 8,
-                    "str x0, [x0, #0x8]\n\t"         /* context->X0 */
                     "stp x1, x2, [x0, #0x10]\n\t"    /* context->X1,X2 */
                     "stp x3, x4, [x0, #0x20]\n\t"    /* context->X3,X4 */
                     "stp x5, x6, [x0, #0x30]\n\t"    /* context->X5,X6 */
@@ -103,6 +300,334 @@ __ASM_STDCALL_FUNC( RtlCaptureContext, 8,
                     "str w1, [x0, #0x4]\n\t"         /* context->Cpsr */
                     "ret" )
 
+/***********************************************************************
+ *           set_cpu_context
+ *
+ * Set the new CPU context.
+ */
+static void set_cpu_context( const CONTEXT *context )
+{
+    InterlockedExchangePointer( (void **)&arm64_thread_data()->context, (void *)context );
+    raise( SIGUSR2 );
+}
+
+/***********************************************************************
+ *           get_server_context_flags
+ *
+ * Convert CPU-specific flags to generic server flags
+ */
+static unsigned int get_server_context_flags( DWORD flags )
+{
+    unsigned int ret = 0;
+
+    flags &= ~CONTEXT_ARM64;  /* get rid of CPU id */
+    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
+    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
+    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
+    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
+    return ret;
+}
+
+/***********************************************************************
+ *           copy_context
+ *
+ * Copy a register context according to the flags.
+ */
+static void copy_context( CONTEXT *to, const CONTEXT *from, DWORD flags )
+{
+    flags &= ~CONTEXT_ARM64;  /* get rid of CPU id */
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->u.s.Fp  = from->u.s.Fp;
+        to->u.s.Lr  = from->u.s.Lr;
+        to->Sp      = from->Sp;
+        to->Pc      = from->Pc;
+        to->Cpsr    = from->Cpsr;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        memcpy( to->u.X, from->u.X, sizeof(to->u.X) );
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        memcpy( to->V, from->V, sizeof(to->V) );
+        to->Fpcr = from->Fpcr;
+        to->Fpsr = from->Fpsr;
+    }
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        memcpy( to->Bcr, from->Bcr, sizeof(to->Bcr) );
+        memcpy( to->Bvr, from->Bvr, sizeof(to->Bvr) );
+        memcpy( to->Wcr, from->Wcr, sizeof(to->Wcr) );
+        memcpy( to->Wvr, from->Wvr, sizeof(to->Wvr) );
+    }
+}
+
+/***********************************************************************
+ *           context_to_server
+ *
+ * Convert a register context to the server format.
+ */
+NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
+{
+    DWORD i, flags = from->ContextFlags & ~CONTEXT_ARM64;  /* get rid of CPU id */
+
+    memset( to, 0, sizeof(*to) );
+    to->cpu = CPU_ARM64;
+
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->flags |= SERVER_CTX_CONTROL;
+        to->integer.arm64_regs.x[29] = from->u.s.Fp;
+        to->integer.arm64_regs.x[30] = from->u.s.Lr;
+        to->ctl.arm64_regs.sp     = from->Sp;
+        to->ctl.arm64_regs.pc     = from->Pc;
+        to->ctl.arm64_regs.pstate = from->Cpsr;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->flags |= SERVER_CTX_INTEGER;
+        for (i = 0; i <= 28; i++) to->integer.arm64_regs.x[i] = from->u.X[i];
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->flags |= SERVER_CTX_FLOATING_POINT;
+        for (i = 0; i < 32; i++)
+        {
+            to->fp.arm64_regs.q[i].low = from->V[i].s.Low;
+            to->fp.arm64_regs.q[i].high = from->V[i].s.High;
+        }
+        to->fp.arm64_regs.fpcr = from->Fpcr;
+        to->fp.arm64_regs.fpsr = from->Fpsr;
+    }
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
+        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->debug.arm64_regs.bcr[i] = from->Bcr[i];
+        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->debug.arm64_regs.bvr[i] = from->Bvr[i];
+        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->debug.arm64_regs.wcr[i] = from->Wcr[i];
+        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->debug.arm64_regs.wvr[i] = from->Wvr[i];
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           context_from_server
+ *
+ * Convert a register context from the server format.
+ */
+NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
+{
+    DWORD i;
+
+    if (from->cpu != CPU_ARM64) return STATUS_INVALID_PARAMETER;
+
+    to->ContextFlags = CONTEXT_ARM64;
+    if (from->flags & SERVER_CTX_CONTROL)
+    {
+        to->ContextFlags |= CONTEXT_CONTROL;
+        to->u.s.Fp = from->integer.arm64_regs.x[29];
+        to->u.s.Lr = from->integer.arm64_regs.x[30];
+        to->Sp     = from->ctl.arm64_regs.sp;
+        to->Pc     = from->ctl.arm64_regs.pc;
+        to->Cpsr   = from->ctl.arm64_regs.pstate;
+    }
+    if (from->flags & SERVER_CTX_INTEGER)
+    {
+        to->ContextFlags |= CONTEXT_INTEGER;
+        for (i = 0; i <= 28; i++) to->u.X[i] = from->integer.arm64_regs.x[i];
+    }
+    if (from->flags & SERVER_CTX_FLOATING_POINT)
+    {
+        to->ContextFlags |= CONTEXT_FLOATING_POINT;
+        for (i = 0; i < 32; i++)
+        {
+            to->V[i].s.Low = from->fp.arm64_regs.q[i].low;
+            to->V[i].s.High = from->fp.arm64_regs.q[i].high;
+        }
+        to->Fpcr = from->fp.arm64_regs.fpcr;
+        to->Fpsr = from->fp.arm64_regs.fpsr;
+    }
+    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
+    {
+        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
+        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->Bcr[i] = from->debug.arm64_regs.bcr[i];
+        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->Bvr[i] = from->debug.arm64_regs.bvr[i];
+        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->Wcr[i] = from->debug.arm64_regs.wcr[i];
+        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->Wvr[i] = from->debug.arm64_regs.wvr[i];
+    }
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *              NtSetContextThread  (NTDLL.@)
+ *              ZwSetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
+{
+    NTSTATUS ret = STATUS_SUCCESS;
+    BOOL self = (handle == GetCurrentThread());
+
+    if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_ARM64)))
+        self = FALSE;
+
+    if (!self)
+    {
+        context_t server_context;
+        context_to_server( &server_context, context );
+        ret = set_thread_context( handle, &server_context, &self );
+    }
+    if (self && ret == STATUS_SUCCESS) set_cpu_context( context );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              NtGetContextThread  (NTDLL.@)
+ *              ZwGetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
+{
+    NTSTATUS ret;
+    DWORD needed_flags = context->ContextFlags;
+    BOOL self = (handle == GetCurrentThread());
+
+    if (!self)
+    {
+        context_t server_context;
+        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
+
+        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
+        if ((ret = context_from_server( context, &server_context ))) return ret;
+        needed_flags &= ~context->ContextFlags;
+    }
+
+    if (self && needed_flags)
+    {
+        CONTEXT ctx;
+        RtlCaptureContext( &ctx );
+        copy_context( context, &ctx, ctx.ContextFlags & needed_flags );
+        context->ContextFlags |= ctx.ContextFlags & needed_flags;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           libunwind_virtual_unwind
+ *
+ * Equivalent of RtlVirtualUnwind for builtin modules.
+ */
+static NTSTATUS libunwind_virtual_unwind( ULONG_PTR ip, ULONG_PTR *frame, CONTEXT *context,
+                                          PEXCEPTION_ROUTINE *handler, void **handler_data )
+{
+#ifdef HAVE_LIBUNWIND
+    unw_context_t unw_context;
+    unw_cursor_t cursor;
+    unw_proc_info_t info;
+    int rc;
+
+    memcpy( unw_context.uc_mcontext.regs, context->u.X, sizeof(context->u.X) );
+    unw_context.uc_mcontext.sp = context->Sp;
+    unw_context.uc_mcontext.pc = context->Pc;
+
+    rc = unw_init_local( &cursor, &unw_context );
+    if (rc != UNW_ESUCCESS)
+    {
+        WARN( "setup failed: %d\n", rc );
+        return STATUS_INVALID_DISPOSITION;
+    }
+    rc = unw_get_proc_info( &cursor, &info );
+    if (rc != UNW_ESUCCESS && rc != -UNW_ENOINFO)
+    {
+        WARN( "failed to get info: %d\n", rc );
+        return STATUS_INVALID_DISPOSITION;
+    }
+    if (rc == -UNW_ENOINFO || ip < info.start_ip || ip > info.end_ip)
+    {
+        TRACE( "no info found for %lx ip %lx-%lx, assuming leaf function\n",
+               ip, info.start_ip, info.end_ip );
+        *handler = NULL;
+        *frame = context->Sp;
+        context->Pc = context->u.s.Lr;
+        context->Sp = context->Sp + sizeof(ULONG64);
+        context->ContextFlags |= CONTEXT_UNWOUND_TO_CALL;
+        return STATUS_SUCCESS;
+    }
+
+    TRACE( "ip %#lx function %#lx-%#lx personality %#lx lsda %#lx fde %#lx\n",
+           ip, (unsigned long)info.start_ip, (unsigned long)info.end_ip, (unsigned long)info.handler,
+           (unsigned long)info.lsda, (unsigned long)info.unwind_info );
+
+    rc = unw_step( &cursor );
+    if (rc < 0)
+    {
+        WARN( "failed to unwind: %d %d\n", rc, UNW_ENOINFO );
+        return STATUS_INVALID_DISPOSITION;
+    }
+
+    *handler = (void *)info.handler;
+    *handler_data = (void *)info.lsda;
+    *frame = context->Sp;
+    unw_get_reg( &cursor, UNW_AARCH64_X0,  (unw_word_t *)&context->u.s.X0 );
+    unw_get_reg( &cursor, UNW_AARCH64_X1,  (unw_word_t *)&context->u.s.X1 );
+    unw_get_reg( &cursor, UNW_AARCH64_X2,  (unw_word_t *)&context->u.s.X2 );
+    unw_get_reg( &cursor, UNW_AARCH64_X3,  (unw_word_t *)&context->u.s.X3 );
+    unw_get_reg( &cursor, UNW_AARCH64_X4,  (unw_word_t *)&context->u.s.X4 );
+    unw_get_reg( &cursor, UNW_AARCH64_X5,  (unw_word_t *)&context->u.s.X5 );
+    unw_get_reg( &cursor, UNW_AARCH64_X6,  (unw_word_t *)&context->u.s.X6 );
+    unw_get_reg( &cursor, UNW_AARCH64_X7,  (unw_word_t *)&context->u.s.X7 );
+    unw_get_reg( &cursor, UNW_AARCH64_X8,  (unw_word_t *)&context->u.s.X8 );
+    unw_get_reg( &cursor, UNW_AARCH64_X9,  (unw_word_t *)&context->u.s.X9 );
+    unw_get_reg( &cursor, UNW_AARCH64_X10, (unw_word_t *)&context->u.s.X10 );
+    unw_get_reg( &cursor, UNW_AARCH64_X11, (unw_word_t *)&context->u.s.X11 );
+    unw_get_reg( &cursor, UNW_AARCH64_X12, (unw_word_t *)&context->u.s.X12 );
+    unw_get_reg( &cursor, UNW_AARCH64_X13, (unw_word_t *)&context->u.s.X13 );
+    unw_get_reg( &cursor, UNW_AARCH64_X14, (unw_word_t *)&context->u.s.X14 );
+    unw_get_reg( &cursor, UNW_AARCH64_X15, (unw_word_t *)&context->u.s.X15 );
+    unw_get_reg( &cursor, UNW_AARCH64_X16, (unw_word_t *)&context->u.s.X16 );
+    unw_get_reg( &cursor, UNW_AARCH64_X17, (unw_word_t *)&context->u.s.X17 );
+    unw_get_reg( &cursor, UNW_AARCH64_X18, (unw_word_t *)&context->u.s.X18 );
+    unw_get_reg( &cursor, UNW_AARCH64_X19, (unw_word_t *)&context->u.s.X19 );
+    unw_get_reg( &cursor, UNW_AARCH64_X20, (unw_word_t *)&context->u.s.X20 );
+    unw_get_reg( &cursor, UNW_AARCH64_X21, (unw_word_t *)&context->u.s.X21 );
+    unw_get_reg( &cursor, UNW_AARCH64_X22, (unw_word_t *)&context->u.s.X22 );
+    unw_get_reg( &cursor, UNW_AARCH64_X23, (unw_word_t *)&context->u.s.X23 );
+    unw_get_reg( &cursor, UNW_AARCH64_X24, (unw_word_t *)&context->u.s.X24 );
+    unw_get_reg( &cursor, UNW_AARCH64_X25, (unw_word_t *)&context->u.s.X25 );
+    unw_get_reg( &cursor, UNW_AARCH64_X26, (unw_word_t *)&context->u.s.X26 );
+    unw_get_reg( &cursor, UNW_AARCH64_X27, (unw_word_t *)&context->u.s.X27 );
+    unw_get_reg( &cursor, UNW_AARCH64_X28, (unw_word_t *)&context->u.s.X28 );
+    unw_get_reg( &cursor, UNW_AARCH64_X29, (unw_word_t *)&context->u.s.Fp );
+    unw_get_reg( &cursor, UNW_AARCH64_X30, (unw_word_t *)&context->u.s.Lr );
+    unw_get_reg( &cursor, UNW_AARCH64_SP,  (unw_word_t *)&context->Sp );
+    context->Pc = context->u.s.Lr;
+    context->ContextFlags |= CONTEXT_UNWOUND_TO_CALL;
+
+    TRACE( "next function pc=%016lx%s\n", context->Pc, rc ? "" : " (last frame)" );
+    TRACE("  x0=%016lx  x1=%016lx  x2=%016lx  x3=%016lx\n",
+          context->u.s.X0, context->u.s.X1, context->u.s.X2, context->u.s.X3 );
+    TRACE("  x4=%016lx  x5=%016lx  x6=%016lx  x7=%016lx\n",
+          context->u.s.X4, context->u.s.X5, context->u.s.X6, context->u.s.X7 );
+    TRACE("  x8=%016lx  x9=%016lx x10=%016lx x11=%016lx\n",
+          context->u.s.X8, context->u.s.X9, context->u.s.X10, context->u.s.X11 );
+    TRACE(" x12=%016lx x13=%016lx x14=%016lx x15=%016lx\n",
+          context->u.s.X12, context->u.s.X13, context->u.s.X14, context->u.s.X15 );
+    TRACE(" x16=%016lx x17=%016lx x18=%016lx x19=%016lx\n",
+          context->u.s.X16, context->u.s.X17, context->u.s.X18, context->u.s.X19 );
+    TRACE(" x20=%016lx x21=%016lx x22=%016lx x23=%016lx\n",
+          context->u.s.X20, context->u.s.X21, context->u.s.X22, context->u.s.X23 );
+    TRACE(" x24=%016lx x25=%016lx x26=%016lx x27=%016lx\n",
+          context->u.s.X24, context->u.s.X25, context->u.s.X26, context->u.s.X27 );
+    TRACE(" x28=%016lx  fp=%016lx  lr=%016lx  sp=%016lx\n",
+          context->u.s.X28, context->u.s.Fp, context->u.s.Lr, context->Sp );
+    return STATUS_SUCCESS;
+#else
+    return STATUS_INVALID_DISPOSITION;
+#endif
+}
+
 
 /**********************************************************************
  *           virtual_unwind
@@ -139,7 +664,8 @@ static NTSTATUS virtual_unwind( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEX
 
     if (!module || (module->Flags & LDR_WINE_INTERNAL))
     {
-        status = unix_funcs->unwind_builtin_dll( type, dispatch, context );
+        status = libunwind_virtual_unwind( context->Pc, &dispatch->EstablisherFrame, context,
+                                           &dispatch->LanguageHandler, &dispatch->HandlerData );
         if (status != STATUS_SUCCESS) return status;
 
         if (dispatch->EstablisherFrame)
@@ -416,60 +942,455 @@ static NTSTATUS call_function_handlers( EXCEPTION_RECORD *rec, CONTEXT *orig_con
     return STATUS_UNHANDLED_EXCEPTION;
 }
 
-
 /*******************************************************************
- *		KiUserExceptionDispatcher (NTDLL.@)
+ *		raise_exception
+ *
+ * Implementation of NtRaiseException.
  */
-NTSTATUS WINAPI KiUserExceptionDispatcher( EXCEPTION_RECORD *rec, CONTEXT *context )
+static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
 {
     NTSTATUS status;
-    DWORD c;
 
-    TRACE( "code=%x flags=%x addr=%p pc=%lx tid=%04x\n",
-           rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
-           context->Pc, GetCurrentThreadId() );
-    for (c = 0; c < rec->NumberParameters; c++)
-        TRACE( " info[%d]=%016lx\n", c, rec->ExceptionInformation[c] );
+    if (first_chance)
+    {
+        DWORD c;
+
+        TRACE( "code=%x flags=%x addr=%p pc=%lx tid=%04x\n",
+               rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
+               context->Pc, GetCurrentThreadId() );
+        for (c = 0; c < rec->NumberParameters; c++)
+            TRACE( " info[%d]=%016lx\n", c, rec->ExceptionInformation[c] );
+        if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+        {
+            if (rec->ExceptionInformation[1] >> 16)
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+            else
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+        }
+        else
+        {
+            TRACE("  x0=%016lx  x1=%016lx  x2=%016lx  x3=%016lx\n",
+                  context->u.s.X0, context->u.s.X1, context->u.s.X2, context->u.s.X3 );
+            TRACE("  x4=%016lx  x5=%016lx  x6=%016lx  x7=%016lx\n",
+                  context->u.s.X4, context->u.s.X5, context->u.s.X6, context->u.s.X7 );
+            TRACE("  x8=%016lx  x9=%016lx x10=%016lx x11=%016lx\n",
+                  context->u.s.X8, context->u.s.X9, context->u.s.X10, context->u.s.X11 );
+            TRACE(" x12=%016lx x13=%016lx x14=%016lx x15=%016lx\n",
+                  context->u.s.X12, context->u.s.X13, context->u.s.X14, context->u.s.X15 );
+            TRACE(" x16=%016lx x17=%016lx x18=%016lx x19=%016lx\n",
+                  context->u.s.X16, context->u.s.X17, context->u.s.X18, context->u.s.X19 );
+            TRACE(" x20=%016lx x21=%016lx x22=%016lx x23=%016lx\n",
+                  context->u.s.X20, context->u.s.X21, context->u.s.X22, context->u.s.X23 );
+            TRACE(" x24=%016lx x25=%016lx x26=%016lx x27=%016lx\n",
+                  context->u.s.X24, context->u.s.X25, context->u.s.X26, context->u.s.X27 );
+            TRACE(" x28=%016lx  fp=%016lx  lr=%016lx  sp=%016lx\n",
+                  context->u.s.X28, context->u.s.Fp, context->u.s.Lr, context->Sp );
+        }
+
+        if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION) goto done;
+
+        if ((status = call_function_handlers( rec, context )) == STATUS_SUCCESS) goto done;
+        if (status != STATUS_UNHANDLED_EXCEPTION) return status;
+    }
+
+    /* last chance exception */
 
-    if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+    status = send_debug_event( rec, FALSE, context );
+    if (status != DBG_CONTINUE)
     {
-        if (rec->ExceptionInformation[1] >> 16)
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+        if (rec->ExceptionFlags & EH_STACK_INVALID)
+            ERR("Exception frame is not in stack limits => unable to dispatch exception.\n");
+        else if (rec->ExceptionCode == STATUS_NONCONTINUABLE_EXCEPTION)
+            ERR("Process attempted to continue execution after noncontinuable exception.\n");
         else
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+            ERR("Unhandled exception code %x flags %x addr %p\n",
+                rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress );
+        NtTerminateProcess( NtCurrentProcess(), rec->ExceptionCode );
     }
-    else
+done:
+    return NtSetContextThread( GetCurrentThread(), context );
+}
+
+/***********************************************************************
+ *           setup_exception
+ *
+ * Setup the exception record and context on the thread stack.
+ */
+static struct stack_layout *setup_exception( ucontext_t *sigcontext )
+{
+    struct stack_layout *stack;
+    DWORD exception_code = 0;
+
+    /* push the stack_layout structure */
+    stack = (struct stack_layout *)((SP_sig(sigcontext) - sizeof(*stack)) & ~15);
+
+    stack->rec.ExceptionRecord  = NULL;
+    stack->rec.ExceptionCode    = exception_code;
+    stack->rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    stack->rec.ExceptionAddress = (LPVOID)PC_sig(sigcontext);
+    stack->rec.NumberParameters = 0;
+
+    save_context( &stack->context, sigcontext );
+    save_fpu( &stack->context, sigcontext );
+    return stack;
+}
+
+/**********************************************************************
+ *		raise_generic_exception
+ */
+static void WINAPI raise_generic_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
+{
+    NTSTATUS status = raise_exception( rec, context, TRUE );
+    raise_status( status, rec );
+}
+
+extern void raise_func_trampoline( EXCEPTION_RECORD *rec, CONTEXT *context, raise_func func, void *sp );
+__ASM_GLOBAL_FUNC( raise_func_trampoline,
+                   __ASM_CFI(".cfi_signal_frame\n\t")
+                   "stp x29, x30, [sp, #-0x20]!\n\t"
+                   __ASM_CFI(".cfi_def_cfa_offset 32\n\t")
+                   __ASM_CFI(".cfi_offset 29, -32\n\t")
+                   __ASM_CFI(".cfi_offset 30, -24\n\t")
+                   "mov x29, sp\n\t"
+                   __ASM_CFI(".cfi_def_cfa_register 29\n\t")
+                   "str x3, [sp, 0x10]\n\t"
+                   __ASM_CFI(".cfi_remember_state\n\t")
+                   __ASM_CFI(".cfi_escape 0x0f,0x03,0x8d,0x10,0x06\n\t") /* CFA */
+                   __ASM_CFI(".cfi_escape 0x10,0x1d,0x02,0x8d,0x00\n\t") /* x29 */
+                   __ASM_CFI(".cfi_escape 0x10,0x1e,0x02,0x8d,0x08\n\t") /* x30 */
+                   "blr x2\n\t"
+                   __ASM_CFI(".cfi_restore_state\n\t")
+                   "brk #1")
+
+/***********************************************************************
+ *           setup_raise_exception
+ *
+ * Modify the signal context to call the exception raise function.
+ */
+static void setup_raise_exception( ucontext_t *sigcontext, struct stack_layout *stack )
+{
+    NTSTATUS status = send_debug_event( &stack->rec, TRUE, &stack->context );
+
+    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
     {
-        TRACE("  x0=%016lx  x1=%016lx  x2=%016lx  x3=%016lx\n",
-              context->u.s.X0, context->u.s.X1, context->u.s.X2, context->u.s.X3 );
-        TRACE("  x4=%016lx  x5=%016lx  x6=%016lx  x7=%016lx\n",
-              context->u.s.X4, context->u.s.X5, context->u.s.X6, context->u.s.X7 );
-        TRACE("  x8=%016lx  x9=%016lx x10=%016lx x11=%016lx\n",
-              context->u.s.X8, context->u.s.X9, context->u.s.X10, context->u.s.X11 );
-        TRACE(" x12=%016lx x13=%016lx x14=%016lx x15=%016lx\n",
-              context->u.s.X12, context->u.s.X13, context->u.s.X14, context->u.s.X15 );
-        TRACE(" x16=%016lx x17=%016lx x18=%016lx x19=%016lx\n",
-              context->u.s.X16, context->u.s.X17, context->u.s.X18, context->u.s.X19 );
-        TRACE(" x20=%016lx x21=%016lx x22=%016lx x23=%016lx\n",
-              context->u.s.X20, context->u.s.X21, context->u.s.X22, context->u.s.X23 );
-        TRACE(" x24=%016lx x25=%016lx x26=%016lx x27=%016lx\n",
-              context->u.s.X24, context->u.s.X25, context->u.s.X26, context->u.s.X27 );
-        TRACE(" x28=%016lx  fp=%016lx  lr=%016lx  sp=%016lx\n",
-              context->u.s.X28, context->u.s.Fp, context->u.s.Lr, context->Sp );
+        restore_context( &stack->context, sigcontext );
+        return;
     }
+    REGn_sig(3, sigcontext) = SP_sig(sigcontext); /* original stack pointer, fourth arg for raise_func_trampoline */
+    SP_sig(sigcontext) = (ULONG_PTR)stack;
+    LR_sig(sigcontext) = PC_sig(sigcontext);
+    PC_sig(sigcontext) = (ULONG_PTR)raise_func_trampoline; /* raise_generic_exception; */
+    REGn_sig(0, sigcontext) = (ULONG_PTR)&stack->rec;  /* first arg for raise_generic_exception */
+    REGn_sig(1, sigcontext) = (ULONG_PTR)&stack->context; /* second arg for raise_generic_exception */
+    REGn_sig(2, sigcontext) = (ULONG_PTR)raise_generic_exception; /* third arg for raise_func_trampoline */
+    REGn_sig(18, sigcontext) = (ULONG_PTR)NtCurrentTeb();
+}
+
+/**********************************************************************
+ *		segv_handler
+ *
+ * Handler for SIGSEGV and related errors.
+ */
+static void segv_handler( int signal, siginfo_t *info, void *ucontext )
+{
+    struct stack_layout *stack;
+    ucontext_t *context = ucontext;
+
+    /* check for page fault inside the thread stack */
+    if (signal == SIGSEGV)
+    {
+        switch (virtual_handle_stack_fault( info->si_addr ))
+        {
+        case 1:  /* handled */
+            return;
+        case -1:  /* overflow */
+            stack = setup_exception( context );
+            stack->rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
+            goto done;
+        }
+    }
+
+    stack = setup_exception( context );
+    if (stack->rec.ExceptionCode == EXCEPTION_STACK_OVERFLOW) goto done;
+
+    switch(signal)
+    {
+    case SIGILL:   /* Invalid opcode exception */
+        stack->rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    case SIGSEGV:  /* Segmentation fault */
+        stack->rec.NumberParameters = 2;
+        stack->rec.ExceptionInformation[0] = (get_fault_esr( context ) & 0x40) != 0;
+        stack->rec.ExceptionInformation[1] = (ULONG_PTR)info->si_addr;
+        if (!(stack->rec.ExceptionCode = virtual_handle_fault( (void *)stack->rec.ExceptionInformation[1],
+                                                         stack->rec.ExceptionInformation[0], FALSE )))
+            return;
+        break;
+    case SIGBUS:  /* Alignment check exception */
+        stack->rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
+        break;
+    default:
+        ERR("Got unexpected signal %i\n", signal);
+        stack->rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    }
+done:
+    setup_raise_exception( context, stack );
+}
+
+/**********************************************************************
+ *		trap_handler
+ *
+ * Handler for SIGTRAP.
+ */
+static void trap_handler( int signal, siginfo_t *info, void *ucontext )
+{
+    ucontext_t *context = ucontext;
+    struct stack_layout *stack = setup_exception( context );
+
+    switch (info->si_code)
+    {
+    case TRAP_TRACE:
+        stack->rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
+        break;
+    case TRAP_BRKPT:
+    default:
+        stack->rec.ExceptionCode = EXCEPTION_BREAKPOINT;
+        stack->context.Pc += 4;
+        break;
+    }
+    setup_raise_exception( context, stack );
+}
+
+/**********************************************************************
+ *		fpe_handler
+ *
+ * Handler for SIGFPE.
+ */
+static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    struct stack_layout *stack = setup_exception( sigcontext );
+
+    switch (siginfo->si_code & 0xffff )
+    {
+#ifdef FPE_FLTSUB
+    case FPE_FLTSUB:
+        stack->rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
+        break;
+#endif
+#ifdef FPE_INTDIV
+    case FPE_INTDIV:
+        stack->rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
+        break;
+#endif
+#ifdef FPE_INTOVF
+    case FPE_INTOVF:
+        stack->rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTDIV
+    case FPE_FLTDIV:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_DIVIDE_BY_ZERO;
+        break;
+#endif
+#ifdef FPE_FLTOVF
+    case FPE_FLTOVF:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_OVERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTUND
+    case FPE_FLTUND:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_UNDERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTRES
+    case FPE_FLTRES:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_INEXACT_RESULT;
+        break;
+#endif
+#ifdef FPE_FLTINV
+    case FPE_FLTINV:
+#endif
+    default:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
+        break;
+    }
+    setup_raise_exception( sigcontext, stack );
+}
+
+/**********************************************************************
+ *		int_handler
+ *
+ * Handler for SIGINT.
+ */
+static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    if (!dispatch_signal(SIGINT))
+    {
+        struct stack_layout *stack = setup_exception( sigcontext );
+
+        stack->rec.ExceptionCode = CONTROL_C_EXIT;
+        setup_raise_exception( sigcontext, stack );
+    }
+}
+
+
+/**********************************************************************
+ *		abrt_handler
+ *
+ * Handler for SIGABRT.
+ */
+static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    struct stack_layout *stack = setup_exception( sigcontext );
+
+    stack->rec.ExceptionCode  = EXCEPTION_WINE_ASSERTION;
+    stack->rec.ExceptionFlags = EH_NONCONTINUABLE;
+    setup_raise_exception( sigcontext, stack );
+}
+
+
+/**********************************************************************
+ *		quit_handler
+ *
+ * Handler for SIGQUIT.
+ */
+static void quit_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    abort_thread(0);
+}
+
+
+/**********************************************************************
+ *		usr1_handler
+ *
+ * Handler for SIGUSR1, used to signal a thread that it got suspended.
+ */
+static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    CONTEXT context;
+
+    save_context( &context, sigcontext );
+    wait_suspend( &context );
+    restore_context( &context, sigcontext );
+}
+
+
+/**********************************************************************
+ *		usr2_handler
+ *
+ * Handler for SIGUSR2, used to set a thread context.
+ */
+static void usr2_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    CONTEXT *context = InterlockedExchangePointer( (void **)&arm64_thread_data()->context, NULL );
+    if (!context) return;
+    if ((context->ContextFlags & ~CONTEXT_ARM64) & CONTEXT_FLOATING_POINT)
+        restore_fpu( context, sigcontext );
+    restore_context( context, sigcontext );
+}
+
+
+/***********************************************************************
+ *           __wine_set_signal_handler   (NTDLL.@)
+ */
+int CDECL __wine_set_signal_handler(unsigned int sig, wine_signal_handler wsh)
+{
+    if (sig >= ARRAY_SIZE(handlers)) return -1;
+    if (handlers[sig] != NULL) return -2;
+    handlers[sig] = wsh;
+    return 0;
+}
+
+
+/**********************************************************************
+ *             signal_init_threading
+ */
+void signal_init_threading(void)
+{
+    pthread_key_create( &teb_key, NULL );
+}
+
+
+/**********************************************************************
+ *             signal_alloc_thread
+ */
+NTSTATUS signal_alloc_thread( TEB *teb )
+{
+    return STATUS_SUCCESS;
+}
 
-    if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION)
-        NtContinue( context, FALSE );
 
-    if ((status = call_function_handlers( rec, context )) == STATUS_SUCCESS)
-        NtContinue( context, FALSE );
+/**********************************************************************
+ *             signal_free_thread
+ */
+void signal_free_thread( TEB *teb )
+{
+}
 
-    if (status != STATUS_UNHANDLED_EXCEPTION) RtlRaiseStatus( status );
-    return NtRaiseException( rec, context, FALSE );
+
+/**********************************************************************
+ *		signal_init_thread
+ */
+void signal_init_thread( TEB *teb )
+{
+    stack_t ss;
+
+    ss.ss_sp    = (char *)teb + teb_size;
+    ss.ss_size  = signal_stack_size;
+    ss.ss_flags = 0;
+    if (sigaltstack( &ss, NULL ) == -1) perror( "sigaltstack" );
+
+    /* Win64/ARM applications expect the TEB pointer to be in the x18 platform register. */
+    __asm__ __volatile__( "mov x18, %0" : : "r" (teb) );
+
+    pthread_setspecific( teb_key, teb );
+}
+
+
+/**********************************************************************
+ *		signal_init_process
+ */
+void signal_init_process(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
+
+    sig_act.sa_sigaction = int_handler;
+    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = fpe_handler;
+    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = abrt_handler;
+    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = quit_handler;
+    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr2_handler;
+    if (sigaction( SIGUSR2, &sig_act, NULL ) == -1) goto error;
+
+    sig_act.sa_sigaction = segv_handler;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
+    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
+#ifdef SIGBUS
+    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+#endif
+
+#ifdef SIGTRAP
+    sig_act.sa_sigaction = trap_handler;
+    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
+#endif
+    return;
+
+ error:
+    perror("sigaction");
+    exit(1);
 }
 
 /***********************************************************************
@@ -1008,7 +1929,7 @@ void CDECL RtlRestoreContext( CONTEXT *context, EXCEPTION_RECORD *rec )
     }
 
     TRACE( "returning to %lx stack %lx\n", context->Pc, context->Sp );
-    NtSetContextThread( GetCurrentThread(), context );
+    set_cpu_context( context );
 }
 
 /*******************************************************************
@@ -1074,6 +1995,13 @@ void WINAPI RtlUnwindEx( PVOID end_frame, PVOID target_ip, EXCEPTION_RECORD *rec
     unwind_done:
         if (!dispatch.EstablisherFrame) break;
 
+        if (is_inside_signal_stack( (void *)dispatch.EstablisherFrame ))
+        {
+            TRACE( "frame %lx is inside signal stack (%p-%p)\n", dispatch.EstablisherFrame,
+                   get_signal_stack(), (char *)get_signal_stack() + signal_stack_size );
+            *context = new_context;
+            continue;
+        }
         if (!is_valid_frame( dispatch.EstablisherFrame ))
         {
             ERR( "invalid frame %lx (%p-%p)\n", dispatch.EstablisherFrame,
@@ -1152,6 +2080,19 @@ void WINAPI RtlUnwind( void *frame, void *target_ip, EXCEPTION_RECORD *rec, void
     RtlUnwindEx( frame, target_ip, rec, retval, &context, NULL );
 }
 
+/*******************************************************************
+ *		NtRaiseException (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRaiseException( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+{
+    if (first_chance)
+    {
+        NTSTATUS status = send_debug_event( rec, TRUE, context );
+        if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
+            NtSetContextThread( GetCurrentThread(), context );
+    }
+    return raise_exception( rec, context, first_chance );
+}
 
 /***********************************************************************
  *		RtlRaiseException (NTDLL.@)
@@ -1174,6 +2115,7 @@ __ASM_STDCALL_FUNC( RtlRaiseException, 4,
                    "ldp x4, x5, [sp]\n\t"        /* frame pointer, return address */
                    "stp x4, x5, [x1, #0xf0]\n\t" /* context->Fp, Lr */
                    "str  x5, [x1, #0x108]\n\t"   /* context->Pc */
+                   "str  x5, [x1, #0x108]\n\t"   /* context->Pc */
                    "str  x5, [x0, #0x10]\n\t"    /* rec->ExceptionAddress */
                    "mov  x2, #1\n\t"
                    "bl " __ASM_NAME("NtRaiseException") "\n\t"
@@ -1188,6 +2130,190 @@ USHORT WINAPI RtlCaptureStackBackTrace( ULONG skip, ULONG count, PVOID *buffer,
     return 0;
 }
 
+/***********************************************************************
+ *           call_thread_entry_point
+ */
+static void WINAPI call_thread_entry_point( LPTHREAD_START_ROUTINE entry, void *arg )
+{
+    __TRY
+    {
+        TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", entry, arg );
+        RtlExitUserThread( entry( arg ));
+    }
+    __EXCEPT(call_unhandled_exception_filter)
+    {
+        NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+    }
+    __ENDTRY
+    abort();  /* should not be reached */
+}
+
+extern void DECLSPEC_NORETURN start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend,
+                                            void *relay, TEB *teb );
+__ASM_GLOBAL_FUNC( start_thread,
+                   "stp x29, x30, [sp,#-16]!\n\t"
+                   "mov x18, x4\n\t"             /* teb */
+                   /* store exit frame */
+                   "mov x29, sp\n\t"
+                   "str x29, [x4, #0x300]\n\t"  /* arm64_thread_data()->exit_frame */
+                   /* switch to thread stack */
+                   "ldr x5, [x4, #8]\n\t"       /* teb->Tib.StackBase */
+                   "sub sp, x5, #0x1000\n\t"
+                   /* attach dlls */
+                   "bl " __ASM_NAME("attach_thread") "\n\t"
+                   "mov sp, x0\n\t"
+                   /* clear the stack */
+                   "and x0, x0, #~0xfff\n\t"  /* round down to page size */
+                   "bl " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
+                   /* switch to the initial context */
+                   "mov x0, sp\n\t"
+                   "ldp q0, q1, [x0, #0x110]\n\t"      /* context->V[0,1] */
+                   "ldp q2, q3, [x0, #0x130]\n\t"      /* context->V[2,3] */
+                   "ldp q4, q5, [x0, #0x150]\n\t"      /* context->V[4,5] */
+                   "ldp q6, q7, [x0, #0x170]\n\t"      /* context->V[6,7] */
+                   "ldp q8, q9, [x0, #0x190]\n\t"      /* context->V[8,9] */
+                   "ldp q10, q11, [x0, #0x1b0]\n\t"    /* context->V[10,11] */
+                   "ldp q12, q13, [x0, #0x1d0]\n\t"    /* context->V[12,13] */
+                   "ldp q14, q15, [x0, #0x1f0]\n\t"    /* context->V[14,15] */
+                   "ldp q16, q17, [x0, #0x210]\n\t"    /* context->V[16,17] */
+                   "ldp q18, q19, [x0, #0x230]\n\t"    /* context->V[18,19] */
+                   "ldp q20, q21, [x0, #0x250]\n\t"    /* context->V[20,21] */
+                   "ldp q22, q23, [x0, #0x270]\n\t"    /* context->V[22,23] */
+                   "ldp q24, q25, [x0, #0x290]\n\t"    /* context->V[24,25] */
+                   "ldp q26, q27, [x0, #0x2b0]\n\t"    /* context->V[26,27] */
+                   "ldp q28, q29, [x0, #0x2d0]\n\t"    /* context->V[28,29] */
+                   "ldp q30, q31, [x0, #0x2f0]\n\t"    /* context->V[30,31] */
+                   "ldr w1, [x0, #0x310]\n\t"          /* context->Fpcr */
+                   "msr fpcr, x1\n\t"
+                   "ldr w1, [x0, #0x314]\n\t"          /* context->Fpsr */
+                   "msr fpsr, x1\n\t"
+                   "ldp x1, x2, [x0, #0x10]\n\t"       /* context->X1,2 */
+                   "ldp x3, x4, [x0, #0x20]\n\t"       /* context->X3,4 */
+                   "ldp x5, x6, [x0, #0x30]\n\t"       /* context->X5,6 */
+                   "ldp x7, x8, [x0, #0x40]\n\t"       /* context->X7,8 */
+                   "ldp x9, x10, [x0, #0x50]\n\t"      /* context->X9,10 */
+                   "ldp x11, x12, [x0, #0x60]\n\t"     /* context->X11,12 */
+                   "ldp x13, x14, [x0, #0x70]\n\t"     /* context->X13,14 */
+                   "ldp x15, x16, [x0, #0x80]\n\t"     /* context->X15,16 */
+                   "ldp x17, x18, [x0, #0x90]\n\t"     /* context->X17,18 */
+                   "ldp x19, x20, [x0, #0xa0]\n\t"     /* context->X19,20 */
+                   "ldp x21, x22, [x0, #0xb0]\n\t"     /* context->X21,22 */
+                   "ldp x23, x24, [x0, #0xc0]\n\t"     /* context->X23,24 */
+                   "ldp x25, x26, [x0, #0xd0]\n\t"     /* context->X25,26 */
+                   "ldp x27, x28, [x0, #0xe0]\n\t"     /* context->X27,28 */
+                   "ldp x29, x30, [x0, #0xf0]\n\t"     /* context->Fp,Lr */
+                   "ldr x17, [x0, #0x100]\n\t"         /* context->Sp */
+                   "mov sp, x17\n\t"
+                   "ldr x17, [x0, #0x108]\n\t"         /* context->Pc */
+                   "ldr x0, [x0, #0x8]\n\t"            /* context->X0 */
+                   "br x17" )
+
+extern void DECLSPEC_NORETURN call_thread_exit_func( int status, void (*func)(int), TEB *teb );
+__ASM_GLOBAL_FUNC( call_thread_exit_func,
+                   "ldr x3, [x2, #0x300]\n\t"  /* arm64_thread_data()->exit_frame */
+                   "str xzr, [x2, #0x300]\n\t"
+                   "cbz x3, 1f\n\t"
+                   "mov sp, x3\n"
+                   "1:\tblr x1" )
+
+/***********************************************************************
+ *           init_thread_context
+ */
+static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
+{
+    context->u.s.X0  = (DWORD64)entry;
+    context->u.s.X1  = (DWORD64)arg;
+    context->u.s.X18 = (DWORD64)NtCurrentTeb();
+    context->Sp      = (DWORD64)NtCurrentTeb()->Tib.StackBase;
+    context->Pc      = (DWORD64)relay;
+}
+
+/***********************************************************************
+ *           attach_thread
+ */
+PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
+                                        BOOL suspend, void *relay )
+{
+    CONTEXT *ctx;
+
+    if (suspend)
+    {
+        CONTEXT context = { CONTEXT_ALL };
+
+        init_thread_context( &context, entry, arg, relay );
+        wait_suspend( &context );
+        ctx = (CONTEXT *)((ULONG_PTR)context.Sp & ~15) - 1;
+        *ctx = context;
+    }
+    else
+    {
+        ctx = (CONTEXT *)NtCurrentTeb()->Tib.StackBase - 1;
+        init_thread_context( ctx, entry, arg, relay );
+    }
+    ctx->ContextFlags = CONTEXT_FULL;
+    LdrInitializeThunk( ctx, (void **)&ctx->u.s.X0, 0, 0 );
+    return ctx;
+}
+
+/***********************************************************************
+ *           signal_start_thread
+ *
+ * Thread startup sequence:
+ * signal_start_thread()
+ *   -> start_thread()
+ *     -> call_thread_func()
+ */
+void signal_start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend )
+{
+    start_thread( entry, arg, suspend, call_thread_entry_point, NtCurrentTeb() );
+}
+
+/**********************************************************************
+ *		signal_start_process
+ *
+ * Process startup sequence:
+ * signal_start_process()
+ *   -> start_thread()
+ *     -> kernel32_start_process()
+ */
+void signal_start_process( LPTHREAD_START_ROUTINE entry, BOOL suspend )
+{
+    start_thread( entry, NtCurrentTeb()->Peb, suspend, kernel32_start_process, NtCurrentTeb() );
+}
+
+/***********************************************************************
+ *           signal_exit_thread
+ */
+void signal_exit_thread( int status )
+{
+    call_thread_exit_func( status, exit_thread, NtCurrentTeb() );
+}
+
+/***********************************************************************
+ *           signal_exit_process
+ */
+void signal_exit_process( int status )
+{
+    call_thread_exit_func( status, exit, NtCurrentTeb() );
+}
+
+/**********************************************************************
+ *           get_thread_ldt_entry
+ */
+NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *           NtSetLdtEntries   (NTDLL.@)
+ *           ZwSetLdtEntries   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
 /**********************************************************************
  *              DbgBreakPoint   (NTDLL.@)
  */
@@ -1207,7 +2333,7 @@ __ASM_STDCALL_FUNC( DbgUserBreakPoint, 0, "brk #0; ret"
  */
 TEB * WINAPI NtCurrentTeb(void)
 {
-    return unix_funcs->NtCurrentTeb();
+    return pthread_getspecific( teb_key );
 }
 
 #endif  /* __aarch64__ */
diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
index b65beb7215..e576182ebf 100644
--- a/dlls/ntdll/signal_i386.c
+++ b/dlls/ntdll/signal_i386.c
@@ -20,21 +20,51 @@
 
 #ifdef __i386__
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <errno.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYSCALL_H
+# include <syscall.h>
+#else
+# ifdef HAVE_SYS_SYSCALL_H
+#  include <sys/syscall.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SIGNAL_H
+# include <sys/signal.h>
+#endif
+#ifdef HAVE_SYS_UCONTEXT_H
+# include <sys/ucontext.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
+#include "wine/library.h"
 #include "ntdll_misc.h"
 #include "wine/exception.h"
 #include "wine/debug.h"
 
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
+#undef ERR  /* Solaris needs to define this */
+
 WINE_DEFAULT_DEBUG_CHANNEL(seh);
+WINE_DECLARE_DEBUG_CHANNEL(relay);
 
 /* not defined for x86, so copy the x86_64 definition */
 typedef struct DECLSPEC_ALIGN(16) _M128A
@@ -63,6 +93,435 @@ typedef struct
     BYTE Reserved4[96];
 } XMM_SAVE_AREA32;
 
+/***********************************************************************
+ * signal context platform-specific definitions
+ */
+
+#ifdef __linux__
+
+#ifndef HAVE_SYS_UCONTEXT_H
+
+enum
+{
+    REG_GS, REG_FS, REG_ES, REG_DS, REG_EDI, REG_ESI, REG_EBP, REG_ESP,
+    REG_EBX, REG_EDX, REG_ECX, REG_EAX, REG_TRAPNO, REG_ERR, REG_EIP,
+    REG_CS, REG_EFL, REG_UESP, REG_SS, NGREG
+};
+
+typedef int greg_t;
+typedef greg_t gregset_t[NGREG];
+
+struct _libc_fpreg
+{
+    unsigned short significand[4];
+    unsigned short exponent;
+};
+
+struct _libc_fpstate
+{
+    unsigned long cw;
+    unsigned long sw;
+    unsigned long tag;
+    unsigned long ipoff;
+    unsigned long cssel;
+    unsigned long dataoff;
+    unsigned long datasel;
+    struct _libc_fpreg _st[8];
+    unsigned long status;
+};
+
+typedef struct _libc_fpstate* fpregset_t;
+
+typedef struct
+{
+    gregset_t     gregs;
+    fpregset_t    fpregs;
+    unsigned long oldmask;
+    unsigned long cr2;
+} mcontext_t;
+
+typedef struct ucontext
+{
+    unsigned long     uc_flags;
+    struct ucontext  *uc_link;
+    stack_t           uc_stack;
+    mcontext_t        uc_mcontext;
+    sigset_t          uc_sigmask;
+} ucontext_t;
+#endif /* HAVE_SYS_UCONTEXT_H */
+
+#define EAX_sig(context)     ((context)->uc_mcontext.gregs[REG_EAX])
+#define EBX_sig(context)     ((context)->uc_mcontext.gregs[REG_EBX])
+#define ECX_sig(context)     ((context)->uc_mcontext.gregs[REG_ECX])
+#define EDX_sig(context)     ((context)->uc_mcontext.gregs[REG_EDX])
+#define ESI_sig(context)     ((context)->uc_mcontext.gregs[REG_ESI])
+#define EDI_sig(context)     ((context)->uc_mcontext.gregs[REG_EDI])
+#define EBP_sig(context)     ((context)->uc_mcontext.gregs[REG_EBP])
+#define ESP_sig(context)     ((context)->uc_mcontext.gregs[REG_ESP])
+
+#define CS_sig(context)      ((context)->uc_mcontext.gregs[REG_CS])
+#define DS_sig(context)      ((context)->uc_mcontext.gregs[REG_DS])
+#define ES_sig(context)      ((context)->uc_mcontext.gregs[REG_ES])
+#define SS_sig(context)      ((context)->uc_mcontext.gregs[REG_SS])
+#define FS_sig(context)      ((context)->uc_mcontext.gregs[REG_FS])
+#define GS_sig(context)      ((context)->uc_mcontext.gregs[REG_GS])
+
+#define EFL_sig(context)     ((context)->uc_mcontext.gregs[REG_EFL])
+#define EIP_sig(context)     ((context)->uc_mcontext.gregs[REG_EIP])
+#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[REG_TRAPNO])
+#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[REG_ERR])
+
+#define FPU_sig(context)     ((FLOATING_SAVE_AREA*)((context)->uc_mcontext.fpregs))
+#define FPUX_sig(context)    (FPU_sig(context) && !((context)->uc_mcontext.fpregs->status >> 16) ? (XMM_SAVE_AREA32 *)(FPU_sig(context) + 1) : NULL)
+
+#ifdef __ANDROID__
+/* custom signal restorer since we may have unmapped the one in vdso, and bionic doesn't check for that */
+void rt_sigreturn(void);
+__ASM_GLOBAL_FUNC( rt_sigreturn,
+                   "movl $173,%eax\n\t"  /* NR_rt_sigreturn */
+                   "int $0x80" );
+#endif
+
+struct modify_ldt_s
+{
+    unsigned int  entry_number;
+    void         *base_addr;
+    unsigned int  limit;
+    unsigned int  seg_32bit : 1;
+    unsigned int  contents : 2;
+    unsigned int  read_exec_only : 1;
+    unsigned int  limit_in_pages : 1;
+    unsigned int  seg_not_present : 1;
+    unsigned int  usable : 1;
+    unsigned int  garbage : 25;
+};
+
+static inline int modify_ldt( int func, struct modify_ldt_s *ptr, unsigned long count )
+{
+    return syscall( 123 /* SYS_modify_ldt */, func, ptr, count );
+}
+
+static inline int set_thread_area( struct modify_ldt_s *ptr )
+{
+    return syscall( 243 /* SYS_set_thread_area */, ptr );
+}
+
+#elif defined (__BSDI__)
+
+#include <machine/frame.h>
+typedef struct trapframe ucontext_t;
+
+#define EAX_sig(context)     ((context)->tf_eax)
+#define EBX_sig(context)     ((context)->tf_ebx)
+#define ECX_sig(context)     ((context)->tf_ecx)
+#define EDX_sig(context)     ((context)->tf_edx)
+#define ESI_sig(context)     ((context)->tf_esi)
+#define EDI_sig(context)     ((context)->tf_edi)
+#define EBP_sig(context)     ((context)->tf_ebp)
+
+#define CS_sig(context)      ((context)->tf_cs)
+#define DS_sig(context)      ((context)->tf_ds)
+#define ES_sig(context)      ((context)->tf_es)
+#define SS_sig(context)      ((context)->tf_ss)
+
+#define EFL_sig(context)     ((context)->tf_eflags)
+
+#define EIP_sig(context)     (*((unsigned long*)&(context)->tf_eip))
+#define ESP_sig(context)     (*((unsigned long*)&(context)->tf_esp))
+
+#define FPU_sig(context)     NULL  /* FIXME */
+#define FPUX_sig(context)    NULL  /* FIXME */
+
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+
+#include <machine/trap.h>
+#include <machine/segments.h>
+#include <machine/sysarch.h>
+
+#define EAX_sig(context)     ((context)->uc_mcontext.mc_eax)
+#define EBX_sig(context)     ((context)->uc_mcontext.mc_ebx)
+#define ECX_sig(context)     ((context)->uc_mcontext.mc_ecx)
+#define EDX_sig(context)     ((context)->uc_mcontext.mc_edx)
+#define ESI_sig(context)     ((context)->uc_mcontext.mc_esi)
+#define EDI_sig(context)     ((context)->uc_mcontext.mc_edi)
+#define EBP_sig(context)     ((context)->uc_mcontext.mc_ebp)
+
+#define CS_sig(context)      ((context)->uc_mcontext.mc_cs)
+#define DS_sig(context)      ((context)->uc_mcontext.mc_ds)
+#define ES_sig(context)      ((context)->uc_mcontext.mc_es)
+#define FS_sig(context)      ((context)->uc_mcontext.mc_fs)
+#define GS_sig(context)      ((context)->uc_mcontext.mc_gs)
+#define SS_sig(context)      ((context)->uc_mcontext.mc_ss)
+
+#define TRAP_sig(context)    ((context)->uc_mcontext.mc_trapno)
+#define ERROR_sig(context)   ((context)->uc_mcontext.mc_err)
+#define EFL_sig(context)     ((context)->uc_mcontext.mc_eflags)
+
+#define EIP_sig(context)     ((context)->uc_mcontext.mc_eip)
+#define ESP_sig(context)     ((context)->uc_mcontext.mc_esp)
+
+#define FPU_sig(context)     NULL  /* FIXME */
+#define FPUX_sig(context)    NULL  /* FIXME */
+
+#elif defined (__OpenBSD__)
+
+#include <machine/segments.h>
+#include <machine/sysarch.h>
+
+#define EAX_sig(context)     ((context)->sc_eax)
+#define EBX_sig(context)     ((context)->sc_ebx)
+#define ECX_sig(context)     ((context)->sc_ecx)
+#define EDX_sig(context)     ((context)->sc_edx)
+#define ESI_sig(context)     ((context)->sc_esi)
+#define EDI_sig(context)     ((context)->sc_edi)
+#define EBP_sig(context)     ((context)->sc_ebp)
+
+#define CS_sig(context)      ((context)->sc_cs)
+#define DS_sig(context)      ((context)->sc_ds)
+#define ES_sig(context)      ((context)->sc_es)
+#define FS_sig(context)      ((context)->sc_fs)
+#define GS_sig(context)      ((context)->sc_gs)
+#define SS_sig(context)      ((context)->sc_ss)
+
+#define TRAP_sig(context)    ((context)->sc_trapno)
+#define ERROR_sig(context)   ((context)->sc_err)
+#define EFL_sig(context)     ((context)->sc_eflags)
+
+#define EIP_sig(context)     ((context)->sc_eip)
+#define ESP_sig(context)     ((context)->sc_esp)
+
+#define FPU_sig(context)     NULL  /* FIXME */
+#define FPUX_sig(context)    NULL  /* FIXME */
+
+#define T_MCHK T_MACHK
+#define T_XMMFLT T_XFTRAP
+
+#elif defined(__svr4__) || defined(_SCO_DS) || defined(__sun)
+
+#if defined(_SCO_DS) || defined(__sun)
+#include <sys/regset.h>
+#endif
+
+#ifdef _SCO_DS
+#define gregs regs
+#endif
+
+#define EAX_sig(context)     ((context)->uc_mcontext.gregs[EAX])
+#define EBX_sig(context)     ((context)->uc_mcontext.gregs[EBX])
+#define ECX_sig(context)     ((context)->uc_mcontext.gregs[ECX])
+#define EDX_sig(context)     ((context)->uc_mcontext.gregs[EDX])
+#define ESI_sig(context)     ((context)->uc_mcontext.gregs[ESI])
+#define EDI_sig(context)     ((context)->uc_mcontext.gregs[EDI])
+#define EBP_sig(context)     ((context)->uc_mcontext.gregs[EBP])
+
+#define CS_sig(context)      ((context)->uc_mcontext.gregs[CS])
+#define DS_sig(context)      ((context)->uc_mcontext.gregs[DS])
+#define ES_sig(context)      ((context)->uc_mcontext.gregs[ES])
+#define SS_sig(context)      ((context)->uc_mcontext.gregs[SS])
+
+#define FS_sig(context)      ((context)->uc_mcontext.gregs[FS])
+#define GS_sig(context)      ((context)->uc_mcontext.gregs[GS])
+
+#define EFL_sig(context)     ((context)->uc_mcontext.gregs[EFL])
+
+#define EIP_sig(context)     ((context)->uc_mcontext.gregs[EIP])
+#ifdef UESP
+#define ESP_sig(context)     ((context)->uc_mcontext.gregs[UESP])
+#elif defined(R_ESP)
+#define ESP_sig(context)     ((context)->uc_mcontext.gregs[R_ESP])
+#else
+#define ESP_sig(context)     ((context)->uc_mcontext.gregs[ESP])
+#endif
+#ifdef ERR
+#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[ERR])
+#endif
+#ifdef TRAPNO
+#define TRAP_sig(context)     ((context)->uc_mcontext.gregs[TRAPNO])
+#endif
+
+#define FPU_sig(context)     NULL  /* FIXME */
+#define FPUX_sig(context)    NULL  /* FIXME */
+
+#elif defined (__APPLE__)
+
+#include <i386/user_ldt.h>
+
+/* work around silly renaming of struct members in OS X 10.5 */
+#if __DARWIN_UNIX03 && defined(_STRUCT_X86_EXCEPTION_STATE32)
+#define EAX_sig(context)     ((context)->uc_mcontext->__ss.__eax)
+#define EBX_sig(context)     ((context)->uc_mcontext->__ss.__ebx)
+#define ECX_sig(context)     ((context)->uc_mcontext->__ss.__ecx)
+#define EDX_sig(context)     ((context)->uc_mcontext->__ss.__edx)
+#define ESI_sig(context)     ((context)->uc_mcontext->__ss.__esi)
+#define EDI_sig(context)     ((context)->uc_mcontext->__ss.__edi)
+#define EBP_sig(context)     ((context)->uc_mcontext->__ss.__ebp)
+#define CS_sig(context)      ((context)->uc_mcontext->__ss.__cs)
+#define DS_sig(context)      ((context)->uc_mcontext->__ss.__ds)
+#define ES_sig(context)      ((context)->uc_mcontext->__ss.__es)
+#define FS_sig(context)      ((context)->uc_mcontext->__ss.__fs)
+#define GS_sig(context)      ((context)->uc_mcontext->__ss.__gs)
+#define SS_sig(context)      ((context)->uc_mcontext->__ss.__ss)
+#define EFL_sig(context)     ((context)->uc_mcontext->__ss.__eflags)
+#define EIP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__eip))
+#define ESP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__esp))
+#define TRAP_sig(context)    ((context)->uc_mcontext->__es.__trapno)
+#define ERROR_sig(context)   ((context)->uc_mcontext->__es.__err)
+#define FPU_sig(context)     NULL
+#define FPUX_sig(context)    ((XMM_SAVE_AREA32 *)&(context)->uc_mcontext->__fs.__fpu_fcw)
+#else
+#define EAX_sig(context)     ((context)->uc_mcontext->ss.eax)
+#define EBX_sig(context)     ((context)->uc_mcontext->ss.ebx)
+#define ECX_sig(context)     ((context)->uc_mcontext->ss.ecx)
+#define EDX_sig(context)     ((context)->uc_mcontext->ss.edx)
+#define ESI_sig(context)     ((context)->uc_mcontext->ss.esi)
+#define EDI_sig(context)     ((context)->uc_mcontext->ss.edi)
+#define EBP_sig(context)     ((context)->uc_mcontext->ss.ebp)
+#define CS_sig(context)      ((context)->uc_mcontext->ss.cs)
+#define DS_sig(context)      ((context)->uc_mcontext->ss.ds)
+#define ES_sig(context)      ((context)->uc_mcontext->ss.es)
+#define FS_sig(context)      ((context)->uc_mcontext->ss.fs)
+#define GS_sig(context)      ((context)->uc_mcontext->ss.gs)
+#define SS_sig(context)      ((context)->uc_mcontext->ss.ss)
+#define EFL_sig(context)     ((context)->uc_mcontext->ss.eflags)
+#define EIP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->ss.eip))
+#define ESP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->ss.esp))
+#define TRAP_sig(context)    ((context)->uc_mcontext->es.trapno)
+#define ERROR_sig(context)   ((context)->uc_mcontext->es.err)
+#define FPU_sig(context)     NULL
+#define FPUX_sig(context)    ((XMM_SAVE_AREA32 *)&(context)->uc_mcontext->fs.fpu_fcw)
+#endif
+
+#elif defined(__NetBSD__)
+
+#include <machine/segments.h>
+#include <machine/sysarch.h>
+
+#define EAX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EAX])
+#define EBX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EBX])
+#define ECX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_ECX])
+#define EDX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EDX])
+#define ESI_sig(context)       ((context)->uc_mcontext.__gregs[_REG_ESI])
+#define EDI_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EDI])
+#define EBP_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EBP])
+#define ESP_sig(context)       _UC_MACHINE_SP(context)
+
+#define CS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_CS])
+#define DS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_DS])
+#define ES_sig(context)        ((context)->uc_mcontext.__gregs[_REG_ES])
+#define SS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_SS])
+#define FS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_FS])
+#define GS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_GS])
+
+#define EFL_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EFL])
+#define EIP_sig(context)       _UC_MACHINE_PC(context)
+#define TRAP_sig(context)      ((context)->uc_mcontext.__gregs[_REG_TRAPNO])
+#define ERROR_sig(context)     ((context)->uc_mcontext.__gregs[_REG_ERR])
+
+#define FPU_sig(context)     NULL
+#define FPUX_sig(context)    ((XMM_SAVE_AREA32 *)&((context)->uc_mcontext.__fpregs))
+
+#define T_MCHK T_MCA
+#define T_XMMFLT T_XMM
+
+#elif defined(__GNU__)
+
+#include <mach/i386/mach_i386.h>
+#include <mach/mach_traps.h>
+
+#define EAX_sig(context)     ((context)->uc_mcontext.gregs[REG_EAX])
+#define EBX_sig(context)     ((context)->uc_mcontext.gregs[REG_EBX])
+#define ECX_sig(context)     ((context)->uc_mcontext.gregs[REG_ECX])
+#define EDX_sig(context)     ((context)->uc_mcontext.gregs[REG_EDX])
+#define ESI_sig(context)     ((context)->uc_mcontext.gregs[REG_ESI])
+#define EDI_sig(context)     ((context)->uc_mcontext.gregs[REG_EDI])
+#define EBP_sig(context)     ((context)->uc_mcontext.gregs[REG_EBP])
+#define ESP_sig(context)     ((context)->uc_mcontext.gregs[REG_ESP])
+
+#define CS_sig(context)      ((context)->uc_mcontext.gregs[REG_CS])
+#define DS_sig(context)      ((context)->uc_mcontext.gregs[REG_DS])
+#define ES_sig(context)      ((context)->uc_mcontext.gregs[REG_ES])
+#define SS_sig(context)      ((context)->uc_mcontext.gregs[REG_SS])
+#define FS_sig(context)      ((context)->uc_mcontext.gregs[REG_FS])
+#define GS_sig(context)      ((context)->uc_mcontext.gregs[REG_GS])
+
+#define EFL_sig(context)     ((context)->uc_mcontext.gregs[REG_EFL])
+#define EIP_sig(context)     ((context)->uc_mcontext.gregs[REG_EIP])
+#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[REG_TRAPNO])
+#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[REG_ERR])
+
+#define FPU_sig(context)     ((FLOATING_SAVE_AREA *)&(context)->uc_mcontext.fpregs.fp_reg_set.fpchip_state)
+#define FPUX_sig(context)    NULL
+
+#else
+#error You must define the signal context functions for your platform
+#endif /* linux */
+
+/* stack layout when calling an exception raise function */
+struct stack_layout
+{
+    void             *ret_addr;      /* return address from raise_generic_exception */
+    EXCEPTION_RECORD *rec_ptr;       /* first arg for raise_generic_exception */
+    CONTEXT          *context_ptr;   /* second arg for raise_generic_exception */
+    CONTEXT           context;
+    EXCEPTION_RECORD  rec;
+    DWORD             ebp;
+    DWORD             eip;
+};
+
+typedef int (*wine_signal_handler)(unsigned int sig);
+
+static const size_t teb_size = 4096;  /* we reserve one page for the TEB */
+
+static ULONG first_ldt_entry = 32;
+
+static wine_signal_handler handlers[256];
+
+enum i386_trap_code
+{
+    TRAP_x86_UNKNOWN    = -1,  /* Unknown fault (TRAP_sig not defined) */
+#if defined(__FreeBSD__) || defined (__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
+    TRAP_x86_DIVIDE     = T_DIVIDE,     /* Division by zero exception */
+    TRAP_x86_TRCTRAP    = T_TRCTRAP,    /* Single-step exception */
+    TRAP_x86_NMI        = T_NMI,        /* NMI interrupt */
+    TRAP_x86_BPTFLT     = T_BPTFLT,     /* Breakpoint exception */
+    TRAP_x86_OFLOW      = T_OFLOW,      /* Overflow exception */
+    TRAP_x86_BOUND      = T_BOUND,      /* Bound range exception */
+    TRAP_x86_PRIVINFLT  = T_PRIVINFLT,  /* Invalid opcode exception */
+    TRAP_x86_DNA        = T_DNA,        /* Device not available exception */
+    TRAP_x86_DOUBLEFLT  = T_DOUBLEFLT,  /* Double fault exception */
+    TRAP_x86_FPOPFLT    = T_FPOPFLT,    /* Coprocessor segment overrun */
+    TRAP_x86_TSSFLT     = T_TSSFLT,     /* Invalid TSS exception */
+    TRAP_x86_SEGNPFLT   = T_SEGNPFLT,   /* Segment not present exception */
+    TRAP_x86_STKFLT     = T_STKFLT,     /* Stack fault */
+    TRAP_x86_PROTFLT    = T_PROTFLT,    /* General protection fault */
+    TRAP_x86_PAGEFLT    = T_PAGEFLT,    /* Page fault */
+    TRAP_x86_ARITHTRAP  = T_ARITHTRAP,  /* Floating point exception */
+    TRAP_x86_ALIGNFLT   = T_ALIGNFLT,   /* Alignment check exception */
+    TRAP_x86_MCHK       = T_MCHK,       /* Machine check exception */
+    TRAP_x86_CACHEFLT   = T_XMMFLT      /* Cache flush exception */
+#else
+    TRAP_x86_DIVIDE     = 0,   /* Division by zero exception */
+    TRAP_x86_TRCTRAP    = 1,   /* Single-step exception */
+    TRAP_x86_NMI        = 2,   /* NMI interrupt */
+    TRAP_x86_BPTFLT     = 3,   /* Breakpoint exception */
+    TRAP_x86_OFLOW      = 4,   /* Overflow exception */
+    TRAP_x86_BOUND      = 5,   /* Bound range exception */
+    TRAP_x86_PRIVINFLT  = 6,   /* Invalid opcode exception */
+    TRAP_x86_DNA        = 7,   /* Device not available exception */
+    TRAP_x86_DOUBLEFLT  = 8,   /* Double fault exception */
+    TRAP_x86_FPOPFLT    = 9,   /* Coprocessor segment overrun */
+    TRAP_x86_TSSFLT     = 10,  /* Invalid TSS exception */
+    TRAP_x86_SEGNPFLT   = 11,  /* Segment not present exception */
+    TRAP_x86_STKFLT     = 12,  /* Stack fault */
+    TRAP_x86_PROTFLT    = 13,  /* General protection fault */
+    TRAP_x86_PAGEFLT    = 14,  /* Page fault */
+    TRAP_x86_ARITHTRAP  = 16,  /* Floating point exception */
+    TRAP_x86_ALIGNFLT   = 17,  /* Alignment check exception */
+    TRAP_x86_MCHK       = 18,  /* Machine check exception */
+    TRAP_x86_CACHEFLT   = 19   /* SIMD exception (via SIGFPE) if CPU is SSE capable
+                                  otherwise Cache flush exception (via SIGSEV) */
+#endif
+};
 
 struct x86_thread_data
 {
@@ -75,18 +534,23 @@ struct x86_thread_data
     DWORD              dr6;           /* 1ec */
     DWORD              dr7;           /* 1f0 */
     void              *exit_frame;    /* 1f4 exit frame pointer */
+    /* the ntdll_thread_data structure follows here */
 };
 
-C_ASSERT( sizeof(struct x86_thread_data) <= 16 * sizeof(void *) );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct x86_thread_data, gs ) == 0x1d8 );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct x86_thread_data, exit_frame ) == 0x1f4 );
+C_ASSERT( offsetof( TEB, SystemReserved2 ) + offsetof( struct x86_thread_data, gs ) == 0x1d8 );
+C_ASSERT( offsetof( TEB, SystemReserved2 ) + offsetof( struct x86_thread_data, exit_frame ) == 0x1f4 );
 
 static inline struct x86_thread_data *x86_thread_data(void)
 {
-    return (struct x86_thread_data *)&NtCurrentTeb()->GdiTebBatch;
+    return (struct x86_thread_data *)NtCurrentTeb()->SystemReserved2;
 }
 
-struct ldt_copy *__wine_ldt_copy = NULL;
+static inline WORD get_cs(void) { WORD res; __asm__( "movw %%cs,%0" : "=r" (res) ); return res; }
+static inline WORD get_ds(void) { WORD res; __asm__( "movw %%ds,%0" : "=r" (res) ); return res; }
+static inline WORD get_fs(void) { WORD res; __asm__( "movw %%fs,%0" : "=r" (res) ); return res; }
+static inline WORD get_gs(void) { WORD res; __asm__( "movw %%gs,%0" : "=r" (res) ); return res; }
+static inline void set_fs( WORD val ) { __asm__( "mov %0,%%fs" :: "r" (val)); }
+static inline void set_gs( WORD val ) { __asm__( "mov %0,%%gs" :: "r" (val)); }
 
 /* Exception record for handling exceptions happening inside exception handlers */
 typedef struct
@@ -99,6 +563,93 @@ extern DWORD EXC_CallHandler( EXCEPTION_RECORD *record, EXCEPTION_REGISTRATION_R
                               CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher,
                               PEXCEPTION_HANDLER handler, PEXCEPTION_HANDLER nested_handler );
 
+/***********************************************************************
+ *           is_gdt_sel
+ */
+static inline int is_gdt_sel( WORD sel )
+{
+    return !(sel & 4);
+}
+
+/***********************************************************************
+ *           ldt_is_system
+ */
+static inline int ldt_is_system( WORD sel )
+{
+    return is_gdt_sel( sel ) || ((sel >> 3) < first_ldt_entry);
+}
+
+/***********************************************************************
+ *           dispatch_signal
+ */
+static inline int dispatch_signal(unsigned int sig)
+{
+    if (handlers[sig] == NULL) return 0;
+    return handlers[sig](sig);
+}
+
+
+/***********************************************************************
+ *           get_trap_code
+ *
+ * Get the trap code for a signal.
+ */
+static inline enum i386_trap_code get_trap_code( const ucontext_t *sigcontext )
+{
+#ifdef TRAP_sig
+    return TRAP_sig(sigcontext);
+#else
+    return TRAP_x86_UNKNOWN;  /* unknown trap code */
+#endif
+}
+
+/***********************************************************************
+ *           get_error_code
+ *
+ * Get the error code for a signal.
+ */
+static inline WORD get_error_code( const ucontext_t *sigcontext )
+{
+#ifdef ERROR_sig
+    return ERROR_sig(sigcontext);
+#else
+    return 0;
+#endif
+}
+
+/***********************************************************************
+ *           get_signal_stack
+ *
+ * Get the base of the signal stack for the current thread.
+ */
+static inline void *get_signal_stack(void)
+{
+    return (char *)NtCurrentTeb() + 4096;
+}
+
+
+/***********************************************************************
+ *           has_fpux
+ */
+static inline int has_fpux(void)
+{
+    return (cpu_info.FeatureSet & CPU_FEATURE_FXSR);
+}
+
+
+/***********************************************************************
+ *           get_current_teb
+ *
+ * Get the current teb based on the stack pointer.
+ */
+static inline TEB *get_current_teb(void)
+{
+    unsigned long esp;
+    __asm__("movl %%esp,%0" : "=g" (esp) );
+    return (TEB *)(esp & ~signal_stack_mask);
+}
+
+
 /*******************************************************************
  *         is_valid_frame
  */
@@ -196,55 +747,176 @@ static NTSTATUS call_stack_handlers( EXCEPTION_RECORD *rec, CONTEXT *context )
 
 
 /*******************************************************************
- *		KiUserExceptionDispatcher (NTDLL.@)
+ *		raise_exception
+ *
+ * Implementation of NtRaiseException.
  */
-NTSTATUS WINAPI dispatch_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
+static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
 {
     NTSTATUS status;
-    DWORD c;
 
-    TRACE( "code=%x flags=%x addr=%p ip=%08x tid=%04x\n",
-           rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
-           context->Eip, GetCurrentThreadId() );
-    for (c = 0; c < rec->NumberParameters; c++)
-        TRACE( " info[%d]=%08lx\n", c, rec->ExceptionInformation[c] );
-
-    if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+    if (first_chance)
     {
-        if (rec->ExceptionInformation[1] >> 16)
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+        DWORD c;
+
+        TRACE( "code=%x flags=%x addr=%p ip=%08x tid=%04x\n",
+               rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
+               context->Eip, GetCurrentThreadId() );
+        for (c = 0; c < rec->NumberParameters; c++)
+            TRACE( " info[%d]=%08lx\n", c, rec->ExceptionInformation[c] );
+        if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+        {
+            if (rec->ExceptionInformation[1] >> 16)
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+            else
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+        }
         else
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+        {
+            TRACE(" eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n",
+                  context->Eax, context->Ebx, context->Ecx,
+                  context->Edx, context->Esi, context->Edi );
+            TRACE(" ebp=%08x esp=%08x cs=%04x ds=%04x es=%04x fs=%04x gs=%04x flags=%08x\n",
+                  context->Ebp, context->Esp, context->SegCs, context->SegDs,
+                  context->SegEs, context->SegFs, context->SegGs, context->EFlags );
+        }
+
+        /* fix up instruction pointer in context for EXCEPTION_BREAKPOINT */
+        if (rec->ExceptionCode == EXCEPTION_BREAKPOINT) context->Eip--;
+
+        if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION) goto done;
+
+        if ((status = call_stack_handlers( rec, context )) == STATUS_SUCCESS) goto done;
+        if (status != STATUS_UNHANDLED_EXCEPTION) return status;
     }
-    else
+
+    /* last chance exception */
+
+    status = send_debug_event( rec, FALSE, context );
+    if (status != DBG_CONTINUE)
     {
-        TRACE(" eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n",
-              context->Eax, context->Ebx, context->Ecx,
-              context->Edx, context->Esi, context->Edi );
-        TRACE(" ebp=%08x esp=%08x cs=%04x ds=%04x es=%04x fs=%04x gs=%04x flags=%08x\n",
-              context->Ebp, context->Esp, context->SegCs, context->SegDs,
-              context->SegEs, context->SegFs, context->SegGs, context->EFlags );
+        if (rec->ExceptionFlags & EH_STACK_INVALID)
+            WINE_ERR("Exception frame is not in stack limits => unable to dispatch exception.\n");
+        else if (rec->ExceptionCode == STATUS_NONCONTINUABLE_EXCEPTION)
+            WINE_ERR("Process attempted to continue execution after noncontinuable exception.\n");
+        else
+            WINE_ERR("Unhandled exception code %x flags %x addr %p\n",
+                     rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress );
+        NtTerminateProcess( NtCurrentProcess(), rec->ExceptionCode );
     }
+done:
+    return NtSetContextThread( GetCurrentThread(), context );
+}
+
+
+#ifdef __sun
+
+/* We have to workaround two Solaris breakages:
+ * - Solaris doesn't restore %ds and %es before calling the signal handler so exceptions in 16-bit
+ *   code crash badly.
+ * - Solaris inserts a libc trampoline to call our handler, but the trampoline expects that registers
+ *   are setup correctly. So we need to insert our own trampoline below the libc trampoline to set %gs.
+ */
+
+extern int sigaction_syscall( int sig, const struct sigaction *new, struct sigaction *old );
+__ASM_GLOBAL_FUNC( sigaction_syscall,
+                  "movl $0x62,%eax\n\t"
+                  "int $0x91\n\t"
+                  "ret" )
+
+/* assume the same libc handler is used for all signals */
+static void (*libc_sigacthandler)( int signal, siginfo_t *siginfo, void *context );
+
+static void wine_sigacthandler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    struct x86_thread_data *thread_data;
+
+    __asm__ __volatile__("mov %ss,%ax; mov %ax,%ds; mov %ax,%es");
+
+    thread_data = (struct x86_thread_data *)get_current_teb()->SystemReserved2;
+    set_fs( thread_data->fs );
+    set_gs( thread_data->gs );
+
+    libc_sigacthandler( signal, siginfo, sigcontext );
+}
+
+static int solaris_sigaction( int sig, const struct sigaction *new, struct sigaction *old )
+{
+    struct sigaction real_act;
+
+    if (sigaction( sig, new, old ) == -1) return -1;
+
+    /* retrieve the real handler and flags with a direct syscall */
+    sigaction_syscall( sig, NULL, &real_act );
+    libc_sigacthandler = real_act.sa_sigaction;
+    real_act.sa_sigaction = wine_sigacthandler;
+    sigaction_syscall( sig, &real_act, NULL );
+    return 0;
+}
+#define sigaction(sig,new,old) solaris_sigaction(sig,new,old)
+
+#endif
+
+extern void clear_alignment_flag(void);
+__ASM_GLOBAL_FUNC( clear_alignment_flag,
+                   "pushfl\n\t"
+                   __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+                   "andl $~0x40000,(%esp)\n\t"
+                   "popfl\n\t"
+                   __ASM_CFI(".cfi_adjust_cfa_offset -4\n\t")
+                   "ret" )
 
-    if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION)
-        NtContinue( context, FALSE );
 
-    if ((status = call_stack_handlers( rec, context )) == STATUS_SUCCESS)
-        NtContinue( context, FALSE );
+/***********************************************************************
+ *           init_handler
+ *
+ * Handler initialization when the full context is not needed.
+ * Return the stack pointer to use for pushing the exception data.
+ */
+static inline void *init_handler( const ucontext_t *sigcontext, WORD *fs, WORD *gs )
+{
+    TEB *teb = get_current_teb();
+
+    clear_alignment_flag();
+
+    /* get %fs and %gs at time of the fault */
+#ifdef FS_sig
+    *fs = LOWORD(FS_sig(sigcontext));
+#else
+    *fs = get_fs();
+#endif
+#ifdef GS_sig
+    *gs = LOWORD(GS_sig(sigcontext));
+#else
+    *gs = get_gs();
+#endif
+
+#ifndef __sun  /* see above for Solaris handling */
+    {
+        struct x86_thread_data *thread_data = (struct x86_thread_data *)teb->SystemReserved2;
+        set_fs( thread_data->fs );
+        set_gs( thread_data->gs );
+    }
+#endif
 
-    if (status != STATUS_UNHANDLED_EXCEPTION) RtlRaiseStatus( status );
-    return NtRaiseException( rec, context, FALSE );
+    if (!ldt_is_system(CS_sig(sigcontext)) || !ldt_is_system(SS_sig(sigcontext)))  /* 16-bit mode */
+    {
+        /*
+         * Win16 or DOS protected mode. Note that during switch
+         * from 16-bit mode to linear mode, CS may be set to system
+         * segment before FS is restored. Fortunately, in this case
+         * SS is still non-system segment. This is why both CS and SS
+         * are checked.
+         */
+        return teb->WOW32Reserved;
+    }
+    return (void *)(ESP_sig(sigcontext) & ~3);
 }
 
-__ASM_STDCALL_FUNC( KiUserExceptionDispatcher, 8,
-                    "pushl 4(%esp)\n\t"
-                    "pushl 4(%esp)\n\t"
-                    "call " __ASM_STDCALL("dispatch_exception", 8) "\n\t"
-                    "int3" )
 
 /***********************************************************************
  *           save_fpu
@@ -290,6 +962,7 @@ static inline void save_fpux( CONTEXT *context )
     char buffer[sizeof(XMM_SAVE_AREA32) + 16];
     XMM_SAVE_AREA32 *state = (XMM_SAVE_AREA32 *)(((ULONG_PTR)buffer + 15) & ~15);
 
+    if (!has_fpux()) return;
     context->ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
     __asm__ __volatile__( "fxsave %0" : "=m" (*state) );
     memcpy( context->ExtendedRegisters, state, sizeof(*state) );
@@ -297,6 +970,185 @@ static inline void save_fpux( CONTEXT *context )
 }
 
 
+/***********************************************************************
+ *           restore_fpu
+ *
+ * Restore the FPU context to a sigcontext.
+ */
+static inline void restore_fpu( const CONTEXT *context )
+{
+    FLOATING_SAVE_AREA float_status = context->FloatSave;
+    /* reset the current interrupt status */
+    float_status.StatusWord &= float_status.ControlWord | 0xffffff80;
+#ifdef __GNUC__
+    __asm__ __volatile__( "frstor %0; fwait" : : "m" (float_status) );
+#endif  /* __GNUC__ */
+}
+
+
+/***********************************************************************
+ *           restore_fpux
+ *
+ * Restore the FPU extended context to a sigcontext.
+ */
+static inline void restore_fpux( const CONTEXT *context )
+{
+#ifdef __GNUC__
+    /* we have to enforce alignment by hand */
+    char buffer[sizeof(XMM_SAVE_AREA32) + 16];
+    XMM_SAVE_AREA32 *state = (XMM_SAVE_AREA32 *)(((ULONG_PTR)buffer + 15) & ~15);
+
+    memcpy( state, context->ExtendedRegisters, sizeof(*state) );
+    /* reset the current interrupt status */
+    state->StatusWord &= state->ControlWord | 0xff80;
+    __asm__ __volatile__( "fxrstor %0" : : "m" (*state) );
+#endif
+}
+
+
+/***********************************************************************
+ *           fpux_to_fpu
+ *
+ * Build a standard FPU context from an extended one.
+ */
+static void fpux_to_fpu( FLOATING_SAVE_AREA *fpu, const XMM_SAVE_AREA32 *fpux )
+{
+    unsigned int i, tag, stack_top;
+
+    fpu->ControlWord   = fpux->ControlWord | 0xffff0000;
+    fpu->StatusWord    = fpux->StatusWord | 0xffff0000;
+    fpu->ErrorOffset   = fpux->ErrorOffset;
+    fpu->ErrorSelector = fpux->ErrorSelector | (fpux->ErrorOpcode << 16);
+    fpu->DataOffset    = fpux->DataOffset;
+    fpu->DataSelector  = fpux->DataSelector;
+    fpu->Cr0NpxState   = fpux->StatusWord | 0xffff0000;
+
+    stack_top = (fpux->StatusWord >> 11) & 7;
+    fpu->TagWord = 0xffff0000;
+    for (i = 0; i < 8; i++)
+    {
+        memcpy( &fpu->RegisterArea[10 * i], &fpux->FloatRegisters[i], 10 );
+        if (!(fpux->TagWord & (1 << i))) tag = 3;  /* empty */
+        else
+        {
+            const M128A *reg = &fpux->FloatRegisters[(i - stack_top) & 7];
+            if ((reg->High & 0x7fff) == 0x7fff)  /* exponent all ones */
+            {
+                tag = 2;  /* special */
+            }
+            else if (!(reg->High & 0x7fff))  /* exponent all zeroes */
+            {
+                if (reg->Low) tag = 2;  /* special */
+                else tag = 1;  /* zero */
+            }
+            else
+            {
+                if (reg->Low >> 63) tag = 0;  /* valid */
+                else tag = 2;  /* special */
+            }
+        }
+        fpu->TagWord |= tag << (2 * i);
+    }
+}
+
+
+/***********************************************************************
+ *           save_context
+ *
+ * Build a context structure from the signal info.
+ */
+static inline void save_context( CONTEXT *context, const ucontext_t *sigcontext, WORD fs, WORD gs )
+{
+    FLOATING_SAVE_AREA *fpu = FPU_sig(sigcontext);
+    XMM_SAVE_AREA32 *fpux = FPUX_sig(sigcontext);
+
+    memset(context, 0, sizeof(*context));
+    context->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
+    context->Eax          = EAX_sig(sigcontext);
+    context->Ebx          = EBX_sig(sigcontext);
+    context->Ecx          = ECX_sig(sigcontext);
+    context->Edx          = EDX_sig(sigcontext);
+    context->Esi          = ESI_sig(sigcontext);
+    context->Edi          = EDI_sig(sigcontext);
+    context->Ebp          = EBP_sig(sigcontext);
+    context->EFlags       = EFL_sig(sigcontext);
+    context->Eip          = EIP_sig(sigcontext);
+    context->Esp          = ESP_sig(sigcontext);
+    context->SegCs        = LOWORD(CS_sig(sigcontext));
+    context->SegDs        = LOWORD(DS_sig(sigcontext));
+    context->SegEs        = LOWORD(ES_sig(sigcontext));
+    context->SegFs        = fs;
+    context->SegGs        = gs;
+    context->SegSs        = LOWORD(SS_sig(sigcontext));
+    context->Dr0          = x86_thread_data()->dr0;
+    context->Dr1          = x86_thread_data()->dr1;
+    context->Dr2          = x86_thread_data()->dr2;
+    context->Dr3          = x86_thread_data()->dr3;
+    context->Dr6          = x86_thread_data()->dr6;
+    context->Dr7          = x86_thread_data()->dr7;
+
+    if (fpu)
+    {
+        context->ContextFlags |= CONTEXT_FLOATING_POINT;
+        context->FloatSave = *fpu;
+    }
+    if (fpux)
+    {
+        context->ContextFlags |= CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;
+        memcpy( context->ExtendedRegisters, fpux, sizeof(*fpux) );
+        if (!fpu) fpux_to_fpu( &context->FloatSave, fpux );
+    }
+    if (!fpu && !fpux) save_fpu( context );
+}
+
+
+/***********************************************************************
+ *           restore_context
+ *
+ * Restore the signal info from the context.
+ */
+static inline void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
+{
+    FLOATING_SAVE_AREA *fpu = FPU_sig(sigcontext);
+    XMM_SAVE_AREA32 *fpux = FPUX_sig(sigcontext);
+
+    x86_thread_data()->dr0 = context->Dr0;
+    x86_thread_data()->dr1 = context->Dr1;
+    x86_thread_data()->dr2 = context->Dr2;
+    x86_thread_data()->dr3 = context->Dr3;
+    x86_thread_data()->dr6 = context->Dr6;
+    x86_thread_data()->dr7 = context->Dr7;
+    EAX_sig(sigcontext) = context->Eax;
+    EBX_sig(sigcontext) = context->Ebx;
+    ECX_sig(sigcontext) = context->Ecx;
+    EDX_sig(sigcontext) = context->Edx;
+    ESI_sig(sigcontext) = context->Esi;
+    EDI_sig(sigcontext) = context->Edi;
+    EBP_sig(sigcontext) = context->Ebp;
+    EFL_sig(sigcontext) = context->EFlags;
+    EIP_sig(sigcontext) = context->Eip;
+    ESP_sig(sigcontext) = context->Esp;
+    CS_sig(sigcontext)  = context->SegCs;
+    DS_sig(sigcontext)  = context->SegDs;
+    ES_sig(sigcontext)  = context->SegEs;
+    SS_sig(sigcontext)  = context->SegSs;
+#ifdef GS_sig
+    GS_sig(sigcontext)  = context->SegGs;
+#else
+    set_gs( context->SegGs );
+#endif
+#ifdef FS_sig
+    FS_sig(sigcontext)  = context->SegFs;
+#else
+    set_fs( context->SegFs );
+#endif
+
+    if (fpu) *fpu = context->FloatSave;
+    if (fpux) memcpy( fpux, context->ExtendedRegisters, sizeof(*fpux) );
+    if (!fpu && !fpux) restore_fpu( context );
+}
+
+
 /***********************************************************************
  *		RtlCaptureContext (NTDLL.@)
  */
@@ -330,25 +1182,1493 @@ __ASM_STDCALL_FUNC( RtlCaptureContext, 4,
                     __ASM_CFI(".cfi_adjust_cfa_offset -4\n\t")
                     "ret $4" )
 
+/***********************************************************************
+ *           set_full_cpu_context
+ *
+ * Set the new CPU context.
+ */
+extern void set_full_cpu_context( const CONTEXT *context );
+__ASM_GLOBAL_FUNC( set_full_cpu_context,
+                   "movl 4(%esp),%ecx\n\t"
+                   "movw 0x8c(%ecx),%gs\n\t"  /* SegGs */
+                   "movw 0x90(%ecx),%fs\n\t"  /* SegFs */
+                   "movw 0x94(%ecx),%es\n\t"  /* SegEs */
+                   "movl 0x9c(%ecx),%edi\n\t" /* Edi */
+                   "movl 0xa0(%ecx),%esi\n\t" /* Esi */
+                   "movl 0xa4(%ecx),%ebx\n\t" /* Ebx */
+                   "movl 0xb4(%ecx),%ebp\n\t" /* Ebp */
+                   "movw %ss,%ax\n\t"
+                   "cmpw 0xc8(%ecx),%ax\n\t"  /* SegSs */
+                   "jne 1f\n\t"
+                   /* As soon as we have switched stacks the context structure could
+                    * be invalid (when signal handlers are executed for example). Copy
+                    * values on the target stack before changing ESP. */
+                   "movl 0xc4(%ecx),%eax\n\t" /* Esp */
+                   "leal -4*4(%eax),%eax\n\t"
+                   "movl 0xc0(%ecx),%edx\n\t" /* EFlags */
+                   "movl %edx,3*4(%eax)\n\t"
+                   "movl 0xbc(%ecx),%edx\n\t" /* SegCs */
+                   "movl %edx,2*4(%eax)\n\t"
+                   "movl 0xb8(%ecx),%edx\n\t" /* Eip */
+                   "movl %edx,1*4(%eax)\n\t"
+                   "movl 0xb0(%ecx),%edx\n\t" /* Eax */
+                   "movl %edx,0*4(%eax)\n\t"
+                   "pushl 0x98(%ecx)\n\t"     /* SegDs */
+                   "movl 0xa8(%ecx),%edx\n\t" /* Edx */
+                   "movl 0xac(%ecx),%ecx\n\t" /* Ecx */
+                   "popl %ds\n\t"
+                   "movl %eax,%esp\n\t"
+                   "popl %eax\n\t"
+                   "iret\n"
+                   /* Restore the context when the stack segment changes. We can't use
+                    * the same code as above because we do not know if the stack segment
+                    * is 16 or 32 bit, and 'movl' will throw an exception when we try to
+                    * access memory above the limit. */
+                   "1:\n\t"
+                   "movl 0xa8(%ecx),%edx\n\t" /* Edx */
+                   "movl 0xb0(%ecx),%eax\n\t" /* Eax */
+                   "movw 0xc8(%ecx),%ss\n\t"  /* SegSs */
+                   "movl 0xc4(%ecx),%esp\n\t" /* Esp */
+                   "pushl 0xc0(%ecx)\n\t"     /* EFlags */
+                   "pushl 0xbc(%ecx)\n\t"     /* SegCs */
+                   "pushl 0xb8(%ecx)\n\t"     /* Eip */
+                   "pushl 0x98(%ecx)\n\t"     /* SegDs */
+                   "movl 0xac(%ecx),%ecx\n\t" /* Ecx */
+                   "popl %ds\n\t"
+                   "iret" )
+
 
-/*******************************************************************
- *		RtlUnwind (NTDLL.@)
+/***********************************************************************
+ *           set_cpu_context
+ *
+ * Set the new CPU context. Used by NtSetContextThread.
  */
-void WINAPI DECLSPEC_HIDDEN __regs_RtlUnwind( EXCEPTION_REGISTRATION_RECORD* pEndFrame, PVOID targetIp,
-                                              PEXCEPTION_RECORD pRecord, PVOID retval, CONTEXT *context )
+void DECLSPEC_HIDDEN set_cpu_context( const CONTEXT *context )
 {
-    EXCEPTION_RECORD record;
-    EXCEPTION_REGISTRATION_RECORD *frame, *dispatch;
-    DWORD res;
+    DWORD flags = context->ContextFlags & ~CONTEXT_i386;
 
-    context->Eax = (DWORD)retval;
+    if ((flags & CONTEXT_EXTENDED_REGISTERS) && has_fpux()) restore_fpux( context );
+    else if (flags & CONTEXT_FLOATING_POINT) restore_fpu( context );
 
-    /* build an exception record, if we do not have one */
-    if (!pRecord)
+    if (flags & CONTEXT_DEBUG_REGISTERS)
     {
-        record.ExceptionCode    = STATUS_UNWIND;
-        record.ExceptionFlags   = 0;
-        record.ExceptionRecord  = NULL;
+        x86_thread_data()->dr0 = context->Dr0;
+        x86_thread_data()->dr1 = context->Dr1;
+        x86_thread_data()->dr2 = context->Dr2;
+        x86_thread_data()->dr3 = context->Dr3;
+        x86_thread_data()->dr6 = context->Dr6;
+        x86_thread_data()->dr7 = context->Dr7;
+    }
+    if (flags & CONTEXT_FULL)
+    {
+        if (!(flags & CONTEXT_CONTROL))
+            FIXME( "setting partial context (%x) not supported\n", flags );
+        else if (flags & CONTEXT_SEGMENTS)
+            set_full_cpu_context( context );
+        else
+        {
+            CONTEXT newcontext = *context;
+            newcontext.SegDs = get_ds();
+            newcontext.SegEs = get_ds();
+            newcontext.SegFs = get_fs();
+            newcontext.SegGs = get_gs();
+            set_full_cpu_context( &newcontext );
+        }
+    }
+}
+
+
+/***********************************************************************
+ *           get_server_context_flags
+ *
+ * Convert CPU-specific flags to generic server flags
+ */
+static unsigned int get_server_context_flags( DWORD flags )
+{
+    unsigned int ret = 0;
+
+    flags &= ~CONTEXT_i386;  /* get rid of CPU id */
+    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
+    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
+    if (flags & CONTEXT_SEGMENTS) ret |= SERVER_CTX_SEGMENTS;
+    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
+    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
+    if (flags & CONTEXT_EXTENDED_REGISTERS) ret |= SERVER_CTX_EXTENDED_REGISTERS;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           context_to_server
+ *
+ * Convert a register context to the server format.
+ */
+NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
+{
+    DWORD flags = from->ContextFlags & ~CONTEXT_i386;  /* get rid of CPU id */
+
+    memset( to, 0, sizeof(*to) );
+    to->cpu = CPU_x86;
+
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->flags |= SERVER_CTX_CONTROL;
+        to->ctl.i386_regs.ebp    = from->Ebp;
+        to->ctl.i386_regs.esp    = from->Esp;
+        to->ctl.i386_regs.eip    = from->Eip;
+        to->ctl.i386_regs.cs     = from->SegCs;
+        to->ctl.i386_regs.ss     = from->SegSs;
+        to->ctl.i386_regs.eflags = from->EFlags;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->flags |= SERVER_CTX_INTEGER;
+        to->integer.i386_regs.eax = from->Eax;
+        to->integer.i386_regs.ebx = from->Ebx;
+        to->integer.i386_regs.ecx = from->Ecx;
+        to->integer.i386_regs.edx = from->Edx;
+        to->integer.i386_regs.esi = from->Esi;
+        to->integer.i386_regs.edi = from->Edi;
+    }
+    if (flags & CONTEXT_SEGMENTS)
+    {
+        to->flags |= SERVER_CTX_SEGMENTS;
+        to->seg.i386_regs.ds = from->SegDs;
+        to->seg.i386_regs.es = from->SegEs;
+        to->seg.i386_regs.fs = from->SegFs;
+        to->seg.i386_regs.gs = from->SegGs;
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->flags |= SERVER_CTX_FLOATING_POINT;
+        to->fp.i386_regs.ctrl     = from->FloatSave.ControlWord;
+        to->fp.i386_regs.status   = from->FloatSave.StatusWord;
+        to->fp.i386_regs.tag      = from->FloatSave.TagWord;
+        to->fp.i386_regs.err_off  = from->FloatSave.ErrorOffset;
+        to->fp.i386_regs.err_sel  = from->FloatSave.ErrorSelector;
+        to->fp.i386_regs.data_off = from->FloatSave.DataOffset;
+        to->fp.i386_regs.data_sel = from->FloatSave.DataSelector;
+        to->fp.i386_regs.cr0npx   = from->FloatSave.Cr0NpxState;
+        memcpy( to->fp.i386_regs.regs, from->FloatSave.RegisterArea, sizeof(to->fp.i386_regs.regs) );
+    }
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
+        to->debug.i386_regs.dr0 = from->Dr0;
+        to->debug.i386_regs.dr1 = from->Dr1;
+        to->debug.i386_regs.dr2 = from->Dr2;
+        to->debug.i386_regs.dr3 = from->Dr3;
+        to->debug.i386_regs.dr6 = from->Dr6;
+        to->debug.i386_regs.dr7 = from->Dr7;
+    }
+    if (flags & CONTEXT_EXTENDED_REGISTERS)
+    {
+        to->flags |= SERVER_CTX_EXTENDED_REGISTERS;
+        memcpy( to->ext.i386_regs, from->ExtendedRegisters, sizeof(to->ext.i386_regs) );
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           context_from_server
+ *
+ * Convert a register context from the server format.
+ */
+NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
+{
+    if (from->cpu != CPU_x86) return STATUS_INVALID_PARAMETER;
+
+    to->ContextFlags = CONTEXT_i386;
+    if (from->flags & SERVER_CTX_CONTROL)
+    {
+        to->ContextFlags |= CONTEXT_CONTROL;
+        to->Ebp    = from->ctl.i386_regs.ebp;
+        to->Esp    = from->ctl.i386_regs.esp;
+        to->Eip    = from->ctl.i386_regs.eip;
+        to->SegCs  = from->ctl.i386_regs.cs;
+        to->SegSs  = from->ctl.i386_regs.ss;
+        to->EFlags = from->ctl.i386_regs.eflags;
+    }
+    if (from->flags & SERVER_CTX_INTEGER)
+    {
+        to->ContextFlags |= CONTEXT_INTEGER;
+        to->Eax = from->integer.i386_regs.eax;
+        to->Ebx = from->integer.i386_regs.ebx;
+        to->Ecx = from->integer.i386_regs.ecx;
+        to->Edx = from->integer.i386_regs.edx;
+        to->Esi = from->integer.i386_regs.esi;
+        to->Edi = from->integer.i386_regs.edi;
+    }
+    if (from->flags & SERVER_CTX_SEGMENTS)
+    {
+        to->ContextFlags |= CONTEXT_SEGMENTS;
+        to->SegDs = from->seg.i386_regs.ds;
+        to->SegEs = from->seg.i386_regs.es;
+        to->SegFs = from->seg.i386_regs.fs;
+        to->SegGs = from->seg.i386_regs.gs;
+    }
+    if (from->flags & SERVER_CTX_FLOATING_POINT)
+    {
+        to->ContextFlags |= CONTEXT_FLOATING_POINT;
+        to->FloatSave.ControlWord   = from->fp.i386_regs.ctrl;
+        to->FloatSave.StatusWord    = from->fp.i386_regs.status;
+        to->FloatSave.TagWord       = from->fp.i386_regs.tag;
+        to->FloatSave.ErrorOffset   = from->fp.i386_regs.err_off;
+        to->FloatSave.ErrorSelector = from->fp.i386_regs.err_sel;
+        to->FloatSave.DataOffset    = from->fp.i386_regs.data_off;
+        to->FloatSave.DataSelector  = from->fp.i386_regs.data_sel;
+        to->FloatSave.Cr0NpxState   = from->fp.i386_regs.cr0npx;
+        memcpy( to->FloatSave.RegisterArea, from->fp.i386_regs.regs, sizeof(to->FloatSave.RegisterArea) );
+    }
+    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
+    {
+        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
+        to->Dr0 = from->debug.i386_regs.dr0;
+        to->Dr1 = from->debug.i386_regs.dr1;
+        to->Dr2 = from->debug.i386_regs.dr2;
+        to->Dr3 = from->debug.i386_regs.dr3;
+        to->Dr6 = from->debug.i386_regs.dr6;
+        to->Dr7 = from->debug.i386_regs.dr7;
+    }
+    if (from->flags & SERVER_CTX_EXTENDED_REGISTERS)
+    {
+        to->ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
+        memcpy( to->ExtendedRegisters, from->ext.i386_regs, sizeof(to->ExtendedRegisters) );
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *              NtSetContextThread  (NTDLL.@)
+ *              ZwSetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
+{
+    NTSTATUS ret = STATUS_SUCCESS;
+    BOOL self = (handle == GetCurrentThread());
+
+    /* debug registers require a server call */
+    if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386)))
+        self = (x86_thread_data()->dr0 == context->Dr0 &&
+                x86_thread_data()->dr1 == context->Dr1 &&
+                x86_thread_data()->dr2 == context->Dr2 &&
+                x86_thread_data()->dr3 == context->Dr3 &&
+                x86_thread_data()->dr6 == context->Dr6 &&
+                x86_thread_data()->dr7 == context->Dr7);
+
+    if (!self)
+    {
+        context_t server_context;
+        context_to_server( &server_context, context );
+        ret = set_thread_context( handle, &server_context, &self );
+    }
+
+    if (self && ret == STATUS_SUCCESS) set_cpu_context( context );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              NtGetContextThread  (NTDLL.@)
+ *              ZwGetContextThread  (NTDLL.@)
+ *
+ * Note: we use a small assembly wrapper to save the necessary registers
+ *       in case we are fetching the context of the current thread.
+ */
+NTSTATUS CDECL DECLSPEC_HIDDEN __regs_NtGetContextThread( DWORD edi, DWORD esi, DWORD ebx, DWORD eflags,
+                                                          DWORD ebp, DWORD retaddr, HANDLE handle,
+                                                          CONTEXT *context )
+{
+    NTSTATUS ret;
+    DWORD needed_flags = context->ContextFlags & ~CONTEXT_i386;
+    BOOL self = (handle == GetCurrentThread());
+
+    /* debug registers require a server call */
+    if (needed_flags & CONTEXT_DEBUG_REGISTERS) self = FALSE;
+
+    if (!self)
+    {
+        context_t server_context;
+        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
+
+        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
+        if ((ret = context_from_server( context, &server_context ))) return ret;
+        needed_flags &= ~context->ContextFlags;
+    }
+
+    if (self)
+    {
+        if (needed_flags & CONTEXT_INTEGER)
+        {
+            context->Eax = 0;
+            context->Ebx = ebx;
+            context->Ecx = 0;
+            context->Edx = 0;
+            context->Esi = esi;
+            context->Edi = edi;
+            context->ContextFlags |= CONTEXT_INTEGER;
+        }
+        if (needed_flags & CONTEXT_CONTROL)
+        {
+            context->Ebp    = ebp;
+            context->Esp    = (DWORD)&retaddr;
+            context->Eip    = *(&edi - 1);
+            context->SegCs  = get_cs();
+            context->SegSs  = get_ds();
+            context->EFlags = eflags;
+            context->ContextFlags |= CONTEXT_CONTROL;
+        }
+        if (needed_flags & CONTEXT_SEGMENTS)
+        {
+            context->SegDs = get_ds();
+            context->SegEs = get_ds();
+            context->SegFs = get_fs();
+            context->SegGs = get_gs();
+            context->ContextFlags |= CONTEXT_SEGMENTS;
+        }
+        if (needed_flags & CONTEXT_FLOATING_POINT) save_fpu( context );
+        if (needed_flags & CONTEXT_EXTENDED_REGISTERS) save_fpux( context );
+        /* FIXME: xstate */
+        /* update the cached version of the debug registers */
+        if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
+        {
+            x86_thread_data()->dr0 = context->Dr0;
+            x86_thread_data()->dr1 = context->Dr1;
+            x86_thread_data()->dr2 = context->Dr2;
+            x86_thread_data()->dr3 = context->Dr3;
+            x86_thread_data()->dr6 = context->Dr6;
+            x86_thread_data()->dr7 = context->Dr7;
+        }
+    }
+
+    if (context->ContextFlags & (CONTEXT_INTEGER & ~CONTEXT_i386))
+        TRACE( "%p: eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n", handle,
+               context->Eax, context->Ebx, context->Ecx, context->Edx, context->Esi, context->Edi );
+    if (context->ContextFlags & (CONTEXT_CONTROL & ~CONTEXT_i386))
+        TRACE( "%p: ebp=%08x esp=%08x eip=%08x cs=%04x ss=%04x flags=%08x\n", handle,
+               context->Ebp, context->Esp, context->Eip, context->SegCs, context->SegSs, context->EFlags );
+    if (context->ContextFlags & (CONTEXT_SEGMENTS & ~CONTEXT_i386))
+        TRACE( "%p: ds=%04x es=%04x fs=%04x gs=%04x\n", handle,
+               context->SegDs, context->SegEs, context->SegFs, context->SegGs );
+    if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
+        TRACE( "%p: dr0=%08x dr1=%08x dr2=%08x dr3=%08x dr6=%08x dr7=%08x\n", handle,
+               context->Dr0, context->Dr1, context->Dr2, context->Dr3, context->Dr6, context->Dr7 );
+
+    return STATUS_SUCCESS;
+}
+__ASM_STDCALL_FUNC( NtGetContextThread, 8,
+                    "pushl %ebp\n\t"
+                    __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+                    __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+                    "movl %esp,%ebp\n\t"
+                    __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
+                    "pushfl\n\t"
+                    "pushl %ebx\n\t"
+                    __ASM_CFI(".cfi_rel_offset %ebx,-8\n\t")
+                    "pushl %esi\n\t"
+                    __ASM_CFI(".cfi_rel_offset %esi,-12\n\t")
+                    "pushl %edi\n\t"
+                    __ASM_CFI(".cfi_rel_offset %edi,-16\n\t")
+                    "call " __ASM_NAME("__regs_NtGetContextThread") "\n\t"
+                    "leave\n\t"
+                    __ASM_CFI(".cfi_def_cfa %esp,4\n\t")
+                    __ASM_CFI(".cfi_same_value %ebp\n\t")
+                    "ret $8" )
+
+
+/***********************************************************************
+ *           is_privileged_instr
+ *
+ * Check if the fault location is a privileged instruction.
+ * Based on the instruction emulation code in dlls/kernel/instr.c.
+ */
+static inline DWORD is_privileged_instr( CONTEXT *context )
+{
+    BYTE instr[16];
+    unsigned int i, len, prefix_count = 0;
+
+    if (!ldt_is_system( context->SegCs )) return 0;
+    len = virtual_uninterrupted_read_memory( (BYTE *)context->Eip, instr, sizeof(instr) );
+
+    for (i = 0; i < len; i++) switch (instr[i])
+    {
+    /* instruction prefixes */
+    case 0x2e:  /* %cs: */
+    case 0x36:  /* %ss: */
+    case 0x3e:  /* %ds: */
+    case 0x26:  /* %es: */
+    case 0x64:  /* %fs: */
+    case 0x65:  /* %gs: */
+    case 0x66:  /* opcode size */
+    case 0x67:  /* addr size */
+    case 0xf0:  /* lock */
+    case 0xf2:  /* repne */
+    case 0xf3:  /* repe */
+        if (++prefix_count >= 15) return EXCEPTION_ILLEGAL_INSTRUCTION;
+        continue;
+
+    case 0x0f: /* extended instruction */
+        if (i == len - 1) return 0;
+        switch(instr[i + 1])
+        {
+        case 0x20: /* mov crX, reg */
+        case 0x21: /* mov drX, reg */
+        case 0x22: /* mov reg, crX */
+        case 0x23: /* mov reg drX */
+            return EXCEPTION_PRIV_INSTRUCTION;
+        }
+        return 0;
+    case 0x6c: /* insb (%dx) */
+    case 0x6d: /* insl (%dx) */
+    case 0x6e: /* outsb (%dx) */
+    case 0x6f: /* outsl (%dx) */
+    case 0xcd: /* int $xx */
+    case 0xe4: /* inb al,XX */
+    case 0xe5: /* in (e)ax,XX */
+    case 0xe6: /* outb XX,al */
+    case 0xe7: /* out XX,(e)ax */
+    case 0xec: /* inb (%dx),%al */
+    case 0xed: /* inl (%dx),%eax */
+    case 0xee: /* outb %al,(%dx) */
+    case 0xef: /* outl %eax,(%dx) */
+    case 0xf4: /* hlt */
+    case 0xfa: /* cli */
+    case 0xfb: /* sti */
+        return EXCEPTION_PRIV_INSTRUCTION;
+    default:
+        return 0;
+    }
+    return 0;
+}
+
+
+/***********************************************************************
+ *           check_invalid_gs
+ *
+ * Check for fault caused by invalid %gs value (some copy protection schemes mess with it).
+ */
+static inline BOOL check_invalid_gs( ucontext_t *sigcontext, CONTEXT *context )
+{
+    unsigned int prefix_count = 0;
+    const BYTE *instr = (BYTE *)context->Eip;
+    WORD system_gs = x86_thread_data()->gs;
+
+    if (context->SegGs == system_gs) return FALSE;
+    if (!ldt_is_system( context->SegCs )) return FALSE;
+    /* only handle faults in system libraries */
+    if (virtual_is_valid_code_address( instr, 1 )) return FALSE;
+
+    for (;;) switch(*instr)
+    {
+    /* instruction prefixes */
+    case 0x2e:  /* %cs: */
+    case 0x36:  /* %ss: */
+    case 0x3e:  /* %ds: */
+    case 0x26:  /* %es: */
+    case 0x64:  /* %fs: */
+    case 0x66:  /* opcode size */
+    case 0x67:  /* addr size */
+    case 0xf0:  /* lock */
+    case 0xf2:  /* repne */
+    case 0xf3:  /* repe */
+        if (++prefix_count >= 15) return FALSE;
+        instr++;
+        continue;
+    case 0x65:  /* %gs: */
+        TRACE( "%04x/%04x at %p, fixing up\n", context->SegGs, system_gs, instr );
+#ifdef GS_sig
+        GS_sig(sigcontext) = system_gs;
+#endif
+        return TRUE;
+    default:
+        return FALSE;
+    }
+}
+
+
+#include "pshpack1.h"
+union atl_thunk
+{
+    struct
+    {
+        DWORD movl;  /* movl this,4(%esp) */
+        DWORD this;
+        BYTE  jmp;   /* jmp func */
+        int   func;
+    } t1;
+    struct
+    {
+        BYTE  movl;  /* movl this,ecx */
+        DWORD this;
+        BYTE  jmp;   /* jmp func */
+        int   func;
+    } t2;
+    struct
+    {
+        BYTE  movl1; /* movl this,edx */
+        DWORD this;
+        BYTE  movl2; /* movl func,ecx */
+        DWORD func;
+        WORD  jmp;   /* jmp ecx */
+    } t3;
+    struct
+    {
+        BYTE  movl1; /* movl this,ecx */
+        DWORD this;
+        BYTE  movl2; /* movl func,eax */
+        DWORD func;
+        WORD  jmp;   /* jmp eax */
+    } t4;
+    struct
+    {
+        DWORD inst1; /* pop ecx
+                      * pop eax
+                      * push ecx
+                      * jmp 4(%eax) */
+        WORD  inst2;
+    } t5;
+};
+#include "poppack.h"
+
+/**********************************************************************
+ *		check_atl_thunk
+ *
+ * Check if code destination is an ATL thunk, and emulate it if so.
+ */
+static BOOL check_atl_thunk( ucontext_t *sigcontext, struct stack_layout *stack )
+{
+    const union atl_thunk *thunk = (const union atl_thunk *)stack->rec.ExceptionInformation[1];
+    union atl_thunk thunk_copy;
+    SIZE_T thunk_len;
+
+    thunk_len = virtual_uninterrupted_read_memory( thunk, &thunk_copy, sizeof(*thunk) );
+    if (!thunk_len) return FALSE;
+
+    if (thunk_len >= sizeof(thunk_copy.t1) && thunk_copy.t1.movl == 0x042444c7 &&
+                                              thunk_copy.t1.jmp == 0xe9)
+    {
+        if (!virtual_uninterrupted_write_memory( (DWORD *)stack->context.Esp + 1,
+                                                 &thunk_copy.t1.this, sizeof(DWORD) ))
+        {
+            EIP_sig(sigcontext) = (DWORD_PTR)(&thunk->t1.func + 1) + thunk_copy.t1.func;
+            TRACE( "emulating ATL thunk type 1 at %p, func=%08x arg=%08x\n",
+                   thunk, EIP_sig(sigcontext), thunk_copy.t1.this );
+            return TRUE;
+        }
+    }
+    else if (thunk_len >= sizeof(thunk_copy.t2) && thunk_copy.t2.movl == 0xb9 &&
+                                                   thunk_copy.t2.jmp == 0xe9)
+    {
+        ECX_sig(sigcontext) = thunk_copy.t2.this;
+        EIP_sig(sigcontext) = (DWORD_PTR)(&thunk->t2.func + 1) + thunk_copy.t2.func;
+        TRACE( "emulating ATL thunk type 2 at %p, func=%08x ecx=%08x\n",
+               thunk, EIP_sig(sigcontext), ECX_sig(sigcontext) );
+        return TRUE;
+    }
+    else if (thunk_len >= sizeof(thunk_copy.t3) && thunk_copy.t3.movl1 == 0xba &&
+                                                   thunk_copy.t3.movl2 == 0xb9 &&
+                                                   thunk_copy.t3.jmp == 0xe1ff)
+    {
+        EDX_sig(sigcontext) = thunk_copy.t3.this;
+        ECX_sig(sigcontext) = thunk_copy.t3.func;
+        EIP_sig(sigcontext) = thunk_copy.t3.func;
+        TRACE( "emulating ATL thunk type 3 at %p, func=%08x ecx=%08x edx=%08x\n",
+               thunk, EIP_sig(sigcontext), ECX_sig(sigcontext), EDX_sig(sigcontext) );
+        return TRUE;
+    }
+    else if (thunk_len >= sizeof(thunk_copy.t4) && thunk_copy.t4.movl1 == 0xb9 &&
+                                                   thunk_copy.t4.movl2 == 0xb8 &&
+                                                   thunk_copy.t4.jmp == 0xe0ff)
+    {
+        ECX_sig(sigcontext) = thunk_copy.t4.this;
+        EAX_sig(sigcontext) = thunk_copy.t4.func;
+        EIP_sig(sigcontext) = thunk_copy.t4.func;
+        TRACE( "emulating ATL thunk type 4 at %p, func=%08x eax=%08x ecx=%08x\n",
+               thunk, EIP_sig(sigcontext), EAX_sig(sigcontext), ECX_sig(sigcontext) );
+        return TRUE;
+    }
+    else if (thunk_len >= sizeof(thunk_copy.t5) && thunk_copy.t5.inst1 == 0xff515859 &&
+                                                   thunk_copy.t5.inst2 == 0x0460)
+    {
+        DWORD func, sp[2];
+        if (virtual_uninterrupted_read_memory( (DWORD *)stack->context.Esp, sp, sizeof(sp) ) == sizeof(sp) &&
+            virtual_uninterrupted_read_memory( (DWORD *)sp[1] + 1, &func, sizeof(DWORD) ) == sizeof(DWORD) &&
+            !virtual_uninterrupted_write_memory( (DWORD *)stack->context.Esp + 1, &sp[0], sizeof(sp[0]) ))
+        {
+            ECX_sig(sigcontext) = sp[0];
+            EAX_sig(sigcontext) = sp[1];
+            ESP_sig(sigcontext) += sizeof(DWORD);
+            EIP_sig(sigcontext) = func;
+            TRACE( "emulating ATL thunk type 5 at %p, func=%08x eax=%08x ecx=%08x esp=%08x\n",
+                   thunk, EIP_sig(sigcontext), EAX_sig(sigcontext),
+                   ECX_sig(sigcontext), ESP_sig(sigcontext) );
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/***********************************************************************
+ *           setup_exception_record
+ *
+ * Setup the exception record and context on the thread stack.
+ */
+static struct stack_layout *setup_exception_record( ucontext_t *sigcontext, void *stack_ptr,
+                                                 WORD fs, WORD gs )
+{
+    struct stack_layout *stack = stack_ptr;
+    DWORD exception_code = 0;
+
+    /* stack sanity checks */
+
+    if ((char *)stack >= (char *)get_signal_stack() &&
+        (char *)stack < (char *)get_signal_stack() + signal_stack_size)
+    {
+        WINE_ERR( "nested exception on signal stack in thread %04x eip %08x esp %08x stack %p-%p\n",
+                  GetCurrentThreadId(), (unsigned int) EIP_sig(sigcontext),
+                  (unsigned int) ESP_sig(sigcontext), NtCurrentTeb()->Tib.StackLimit,
+                  NtCurrentTeb()->Tib.StackBase );
+        abort_thread(1);
+    }
+
+    if (stack - 1 > stack || /* check for overflow in subtraction */
+        (char *)stack <= (char *)NtCurrentTeb()->DeallocationStack ||
+        (char *)stack > (char *)NtCurrentTeb()->Tib.StackBase)
+    {
+        WARN( "exception outside of stack limits in thread %04x eip %08x esp %08x stack %p-%p\n",
+              GetCurrentThreadId(), (unsigned int) EIP_sig(sigcontext),
+              (unsigned int) ESP_sig(sigcontext), NtCurrentTeb()->Tib.StackLimit,
+              NtCurrentTeb()->Tib.StackBase );
+    }
+    else if ((char *)(stack - 1) < (char *)NtCurrentTeb()->DeallocationStack + 4096)
+    {
+        /* stack overflow on last page, unrecoverable */
+        UINT diff = (char *)NtCurrentTeb()->DeallocationStack + 4096 - (char *)(stack - 1);
+        WINE_ERR( "stack overflow %u bytes in thread %04x eip %08x esp %08x stack %p-%p-%p\n",
+                  diff, GetCurrentThreadId(), (unsigned int) EIP_sig(sigcontext),
+                  (unsigned int) ESP_sig(sigcontext), NtCurrentTeb()->DeallocationStack,
+                  NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
+        abort_thread(1);
+    }
+    else if ((char *)(stack - 1) < (char *)NtCurrentTeb()->Tib.StackLimit)
+    {
+        /* stack access below stack limit, may be recoverable */
+        switch (virtual_handle_stack_fault( stack - 1 ))
+        {
+        case 0:  /* not handled */
+        {
+            UINT diff = (char *)NtCurrentTeb()->Tib.StackLimit - (char *)(stack - 1);
+            WINE_ERR( "stack overflow %u bytes in thread %04x eip %08x esp %08x stack %p-%p-%p\n",
+                      diff, GetCurrentThreadId(), (unsigned int) EIP_sig(sigcontext),
+                      (unsigned int) ESP_sig(sigcontext), NtCurrentTeb()->DeallocationStack,
+                      NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
+            abort_thread(1);
+        }
+        case -1:  /* overflow */
+            exception_code = EXCEPTION_STACK_OVERFLOW;
+            break;
+        }
+    }
+
+    stack--;  /* push the stack_layout structure */
+#if defined(VALGRIND_MAKE_MEM_UNDEFINED)
+    VALGRIND_MAKE_MEM_UNDEFINED(stack, sizeof(*stack));
+#elif defined(VALGRIND_MAKE_WRITABLE)
+    VALGRIND_MAKE_WRITABLE(stack, sizeof(*stack));
+#endif
+    stack->rec.ExceptionRecord  = NULL;
+    stack->rec.ExceptionCode    = exception_code;
+    stack->rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    stack->rec.ExceptionAddress = (LPVOID)EIP_sig(sigcontext);
+    stack->rec.NumberParameters = 0;
+
+    save_context( &stack->context, sigcontext, fs, gs );
+    return stack;
+}
+
+
+/***********************************************************************
+ *           setup_exception
+ *
+ * Setup a proper stack frame for the raise function, and modify the
+ * sigcontext so that the return from the signal handler will call
+ * the raise function.
+ */
+static struct stack_layout *setup_exception( ucontext_t *sigcontext )
+{
+    WORD fs, gs;
+    void *stack = init_handler( sigcontext, &fs, &gs );
+
+    return setup_exception_record( sigcontext, stack, fs, gs );
+}
+
+
+/**********************************************************************
+ *		raise_generic_exception
+ *
+ * Generic raise function for exceptions that don't need special treatment.
+ */
+static void WINAPI raise_generic_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
+{
+    NTSTATUS status;
+
+    status = raise_exception( rec, context, TRUE );
+    raise_status( status, rec );
+}
+
+
+/***********************************************************************
+ *           setup_raise_exception
+ *
+ * Change context to setup a call to a raise exception function.
+ */
+static void setup_raise_exception( ucontext_t *sigcontext, struct stack_layout *stack )
+{
+    NTSTATUS status = send_debug_event( &stack->rec, TRUE, &stack->context );
+
+    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
+    {
+        restore_context( &stack->context, sigcontext );
+        return;
+    }
+    ESP_sig(sigcontext) = (DWORD)stack;
+    EIP_sig(sigcontext) = (DWORD)raise_generic_exception;
+    /* clear single-step, direction, and align check flag */
+    EFL_sig(sigcontext) &= ~(0x100|0x400|0x40000);
+    CS_sig(sigcontext)  = get_cs();
+    DS_sig(sigcontext)  = get_ds();
+    ES_sig(sigcontext)  = get_ds();
+    FS_sig(sigcontext)  = get_fs();
+    GS_sig(sigcontext)  = get_gs();
+    SS_sig(sigcontext)  = get_ds();
+    stack->ret_addr     = (void *)0xdeadbabe;  /* raise_generic_exception must not return */
+    stack->rec_ptr      = &stack->rec;         /* arguments for raise_generic_exception */
+    stack->context_ptr  = &stack->context;
+}
+
+
+/**********************************************************************
+ *		get_fpu_code
+ *
+ * Get the FPU exception code from the FPU status.
+ */
+static inline DWORD get_fpu_code( const CONTEXT *context )
+{
+    DWORD status = context->FloatSave.StatusWord & ~(context->FloatSave.ControlWord & 0x3f);
+
+    if (status & 0x01)  /* IE */
+    {
+        if (status & 0x40)  /* SF */
+            return EXCEPTION_FLT_STACK_CHECK;
+        else
+            return EXCEPTION_FLT_INVALID_OPERATION;
+    }
+    if (status & 0x02) return EXCEPTION_FLT_DENORMAL_OPERAND;  /* DE flag */
+    if (status & 0x04) return EXCEPTION_FLT_DIVIDE_BY_ZERO;    /* ZE flag */
+    if (status & 0x08) return EXCEPTION_FLT_OVERFLOW;          /* OE flag */
+    if (status & 0x10) return EXCEPTION_FLT_UNDERFLOW;         /* UE flag */
+    if (status & 0x20) return EXCEPTION_FLT_INEXACT_RESULT;    /* PE flag */
+    return EXCEPTION_FLT_INVALID_OPERATION;  /* generic error */
+}
+
+
+/***********************************************************************
+ *           handle_interrupt
+ *
+ * Handle an interrupt.
+ */
+static BOOL handle_interrupt( unsigned int interrupt, ucontext_t *sigcontext, struct stack_layout *stack )
+{
+    switch(interrupt)
+    {
+    case 0x2d:
+        if (!is_wow64)
+        {
+            /* On Wow64, the upper DWORD of Rax contains garbage, and the debug
+             * service is usually not recognized when called from usermode. */
+            switch (stack->context.Eax)
+            {
+                case 1: /* BREAKPOINT_PRINT */
+                case 3: /* BREAKPOINT_LOAD_SYMBOLS */
+                case 4: /* BREAKPOINT_UNLOAD_SYMBOLS */
+                case 5: /* BREAKPOINT_COMMAND_STRING (>= Win2003) */
+                    EIP_sig(sigcontext) += 3;
+                    return TRUE;
+            }
+        }
+        stack->context.Eip += 3;
+        stack->rec.ExceptionCode = EXCEPTION_BREAKPOINT;
+        stack->rec.ExceptionAddress = (void *)stack->context.Eip;
+        stack->rec.NumberParameters = is_wow64 ? 1 : 3;
+        stack->rec.ExceptionInformation[0] = stack->context.Eax;
+        stack->rec.ExceptionInformation[1] = stack->context.Ecx;
+        stack->rec.ExceptionInformation[2] = stack->context.Edx;
+        setup_raise_exception( sigcontext, stack );
+        return TRUE;
+    default:
+        return FALSE;
+    }
+}
+
+
+/**********************************************************************
+ *		segv_handler
+ *
+ * Handler for SIGSEGV and related errors.
+ */
+static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    WORD fs, gs;
+    struct stack_layout *stack;
+    ucontext_t *context = sigcontext;
+    void *stack_ptr = init_handler( sigcontext, &fs, &gs );
+
+    /* check for exceptions on the signal stack caused by write watches */
+    if (get_trap_code(context) == TRAP_x86_PAGEFLT &&
+        (char *)stack_ptr >= (char *)get_signal_stack() &&
+        (char *)stack_ptr < (char *)get_signal_stack() + signal_stack_size &&
+        !virtual_handle_fault( siginfo->si_addr, (get_error_code(context) >> 1) & 0x09, TRUE ))
+    {
+        return;
+    }
+
+    /* check for page fault inside the thread stack */
+    if (get_trap_code(context) == TRAP_x86_PAGEFLT)
+    {
+        switch (virtual_handle_stack_fault( siginfo->si_addr ))
+        {
+        case 1:  /* handled */
+            return;
+        case -1:  /* overflow */
+            stack = setup_exception_record( context, stack_ptr, fs, gs );
+            stack->rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
+            goto done;
+        }
+    }
+
+    stack = setup_exception_record( context, stack_ptr, fs, gs );
+    if (stack->rec.ExceptionCode == EXCEPTION_STACK_OVERFLOW) goto done;
+
+    switch(get_trap_code(context))
+    {
+    case TRAP_x86_OFLOW:   /* Overflow exception */
+        stack->rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
+        break;
+    case TRAP_x86_BOUND:   /* Bound range exception */
+        stack->rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
+        break;
+    case TRAP_x86_PRIVINFLT:   /* Invalid opcode exception */
+        stack->rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    case TRAP_x86_STKFLT:  /* Stack fault */
+        stack->rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
+        break;
+    case TRAP_x86_SEGNPFLT:  /* Segment not present exception */
+    case TRAP_x86_PROTFLT:   /* General protection fault */
+    case TRAP_x86_UNKNOWN:   /* Unknown fault code */
+        {
+            WORD err = get_error_code(context);
+            if (!err && (stack->rec.ExceptionCode = is_privileged_instr( &stack->context ))) break;
+            if ((err & 7) == 2 && handle_interrupt( err >> 3, context, stack )) return;
+            stack->rec.ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
+            stack->rec.NumberParameters = 2;
+            stack->rec.ExceptionInformation[0] = 0;
+            /* if error contains a LDT selector, use that as fault address */
+            if ((err & 7) == 4 && !ldt_is_system( err | 7 ))
+                stack->rec.ExceptionInformation[1] = err & ~7;
+            else
+            {
+                stack->rec.ExceptionInformation[1] = 0xffffffff;
+                if (check_invalid_gs( context, &stack->context )) return;
+            }
+        }
+        break;
+    case TRAP_x86_PAGEFLT:  /* Page fault */
+        stack->rec.NumberParameters = 2;
+        stack->rec.ExceptionInformation[0] = (get_error_code(context) >> 1) & 0x09;
+        stack->rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
+        stack->rec.ExceptionCode = virtual_handle_fault( (void *)stack->rec.ExceptionInformation[1],
+                                                         stack->rec.ExceptionInformation[0], FALSE );
+        if (!stack->rec.ExceptionCode) return;
+        if (stack->rec.ExceptionCode == EXCEPTION_ACCESS_VIOLATION &&
+            stack->rec.ExceptionInformation[0] == EXCEPTION_EXECUTE_FAULT)
+        {
+            ULONG flags;
+            NtQueryInformationProcess( GetCurrentProcess(), ProcessExecuteFlags,
+                                       &flags, sizeof(flags), NULL );
+            if (!(flags & MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION) && check_atl_thunk( context, stack ))
+                return;
+
+            /* send EXCEPTION_EXECUTE_FAULT only if data execution prevention is enabled */
+            if (!(flags & MEM_EXECUTE_OPTION_DISABLE))
+                stack->rec.ExceptionInformation[0] = EXCEPTION_READ_FAULT;
+        }
+        break;
+    case TRAP_x86_ALIGNFLT:  /* Alignment check exception */
+        /* FIXME: pass through exception handler first? */
+        if (stack->context.EFlags & 0x00040000)
+        {
+            EFL_sig(context) &= ~0x00040000;  /* disable AC flag */
+            return;
+        }
+        stack->rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
+        break;
+    default:
+        WINE_ERR( "Got unexpected trap %d\n", get_trap_code(context) );
+        /* fall through */
+    case TRAP_x86_NMI:       /* NMI interrupt */
+    case TRAP_x86_DNA:       /* Device not available exception */
+    case TRAP_x86_DOUBLEFLT: /* Double fault exception */
+    case TRAP_x86_TSSFLT:    /* Invalid TSS exception */
+    case TRAP_x86_MCHK:      /* Machine check exception */
+    case TRAP_x86_CACHEFLT:  /* Cache flush exception */
+        stack->rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    }
+done:
+    setup_raise_exception( context, stack );
+}
+
+
+/**********************************************************************
+ *		trap_handler
+ *
+ * Handler for SIGTRAP.
+ */
+static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    ucontext_t *context = sigcontext;
+    struct stack_layout *stack = setup_exception( context );
+
+    switch(get_trap_code(context))
+    {
+    case TRAP_x86_TRCTRAP:  /* Single-step exception */
+        stack->rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
+        /* when single stepping can't tell whether this is a hw bp or a
+         * single step interrupt. try to avoid as much overhead as possible
+         * and only do a server call if there is any hw bp enabled. */
+        if (!(stack->context.EFlags & 0x100) || (stack->context.Dr7 & 0xff))
+        {
+            /* (possible) hardware breakpoint, fetch the debug registers */
+            DWORD saved_flags = stack->context.ContextFlags;
+            stack->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
+            NtGetContextThread( GetCurrentThread(), &stack->context );
+            stack->context.ContextFlags |= saved_flags;  /* restore flags */
+        }
+        stack->context.EFlags &= ~0x100;  /* clear single-step flag */
+        break;
+    case TRAP_x86_BPTFLT:   /* Breakpoint exception */
+        stack->rec.ExceptionAddress = (char *)stack->rec.ExceptionAddress - 1;  /* back up over the int3 instruction */
+        /* fall through */
+    default:
+        stack->rec.ExceptionCode = EXCEPTION_BREAKPOINT;
+        stack->rec.NumberParameters = is_wow64 ? 1 : 3;
+        stack->rec.ExceptionInformation[0] = 0;
+        stack->rec.ExceptionInformation[1] = 0; /* FIXME */
+        stack->rec.ExceptionInformation[2] = 0; /* FIXME */
+        break;
+    }
+    setup_raise_exception( context, stack );
+}
+
+
+/**********************************************************************
+ *		fpe_handler
+ *
+ * Handler for SIGFPE.
+ */
+static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    ucontext_t *context = sigcontext;
+    struct stack_layout *stack = setup_exception( context );
+
+    switch(get_trap_code(context))
+    {
+    case TRAP_x86_DIVIDE:   /* Division by zero exception */
+        stack->rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
+        break;
+    case TRAP_x86_FPOPFLT:   /* Coprocessor segment overrun */
+        stack->rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
+        break;
+    case TRAP_x86_ARITHTRAP:  /* Floating point exception */
+    case TRAP_x86_UNKNOWN:    /* Unknown fault code */
+        stack->rec.ExceptionCode = get_fpu_code( &stack->context );
+        stack->rec.ExceptionAddress = (LPVOID)stack->context.FloatSave.ErrorOffset;
+        break;
+    case TRAP_x86_CACHEFLT:  /* SIMD exception */
+        /* TODO:
+         * Behaviour only tested for divide-by-zero exceptions
+         * Check for other SIMD exceptions as well */
+        if(siginfo->si_code != FPE_FLTDIV && siginfo->si_code != FPE_FLTINV)
+            FIXME("untested SIMD exception: %#x. Might not work correctly\n",
+                  siginfo->si_code);
+
+        stack->rec.ExceptionCode = STATUS_FLOAT_MULTIPLE_TRAPS;
+        stack->rec.NumberParameters = 1;
+        /* no idea what meaning is actually behind this but that's what native does */
+        stack->rec.ExceptionInformation[0] = 0;
+        break;
+    default:
+        WINE_ERR( "Got unexpected trap %d\n", get_trap_code(context) );
+        stack->rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
+        break;
+    }
+
+    setup_raise_exception( context, stack );
+}
+
+
+/**********************************************************************
+ *		int_handler
+ *
+ * Handler for SIGINT.
+ *
+ * FIXME: should not be calling external functions on the signal stack.
+ */
+static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    WORD fs, gs;
+    void *stack_ptr = init_handler( sigcontext, &fs, &gs );
+    if (!dispatch_signal(SIGINT))
+    {
+        struct stack_layout *stack = setup_exception_record( sigcontext, stack_ptr, fs, gs );
+        stack->rec.ExceptionCode = CONTROL_C_EXIT;
+        setup_raise_exception( sigcontext, stack );
+    }
+}
+
+/**********************************************************************
+ *		abrt_handler
+ *
+ * Handler for SIGABRT.
+ */
+static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    struct stack_layout *stack = setup_exception( sigcontext );
+    stack->rec.ExceptionCode  = EXCEPTION_WINE_ASSERTION;
+    stack->rec.ExceptionFlags = EH_NONCONTINUABLE;
+    setup_raise_exception( sigcontext, stack );
+}
+
+
+/**********************************************************************
+ *		quit_handler
+ *
+ * Handler for SIGQUIT.
+ */
+static void quit_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    WORD fs, gs;
+    init_handler( sigcontext, &fs, &gs );
+    abort_thread(0);
+}
+
+
+/**********************************************************************
+ *		usr1_handler
+ *
+ * Handler for SIGUSR1, used to signal a thread that it got suspended.
+ */
+static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    CONTEXT context;
+    WORD fs, gs;
+
+    init_handler( sigcontext, &fs, &gs );
+    save_context( &context, sigcontext, fs, gs );
+    wait_suspend( &context );
+    restore_context( &context, sigcontext );
+}
+
+
+/***********************************************************************
+ *           __wine_set_signal_handler   (NTDLL.@)
+ */
+int CDECL __wine_set_signal_handler(unsigned int sig, wine_signal_handler wsh)
+{
+    if (sig >= ARRAY_SIZE(handlers)) return -1;
+    if (handlers[sig] != NULL) return -2;
+    handlers[sig] = wsh;
+    return 0;
+}
+
+
+/***********************************************************************
+ *           LDT support
+ */
+
+#define LDT_SIZE 8192
+
+#define LDT_FLAGS_DATA      0x13  /* Data segment */
+#define LDT_FLAGS_CODE      0x1b  /* Code segment */
+#define LDT_FLAGS_32BIT     0x40  /* Segment is 32-bit (code or stack) */
+#define LDT_FLAGS_ALLOCATED 0x80  /* Segment is allocated */
+
+struct ldt_copy
+{
+    void         *base[LDT_SIZE];
+    unsigned int  limit[LDT_SIZE];
+    unsigned char flags[LDT_SIZE];
+} __wine_ldt_copy;
+
+static WORD gdt_fs_sel;
+
+static RTL_CRITICAL_SECTION ldt_section;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &ldt_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": ldt_section") }
+};
+static RTL_CRITICAL_SECTION ldt_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static const LDT_ENTRY null_entry;
+
+static inline void *ldt_get_base( LDT_ENTRY ent )
+{
+    return (void *)(ent.BaseLow |
+                    (ULONG_PTR)ent.HighWord.Bits.BaseMid << 16 |
+                    (ULONG_PTR)ent.HighWord.Bits.BaseHi << 24);
+}
+
+static inline unsigned int ldt_get_limit( LDT_ENTRY ent )
+{
+    unsigned int limit = ent.LimitLow | (ent.HighWord.Bits.LimitHi << 16);
+    if (ent.HighWord.Bits.Granularity) limit = (limit << 12) | 0xfff;
+    return limit;
+}
+
+static LDT_ENTRY ldt_make_entry( void *base, unsigned int limit, unsigned char flags )
+{
+    LDT_ENTRY entry;
+
+    entry.BaseLow                   = (WORD)(ULONG_PTR)base;
+    entry.HighWord.Bits.BaseMid     = (BYTE)((ULONG_PTR)base >> 16);
+    entry.HighWord.Bits.BaseHi      = (BYTE)((ULONG_PTR)base >> 24);
+    if ((entry.HighWord.Bits.Granularity = (limit >= 0x100000))) limit >>= 12;
+    entry.LimitLow                  = (WORD)limit;
+    entry.HighWord.Bits.LimitHi     = limit >> 16;
+    entry.HighWord.Bits.Dpl         = 3;
+    entry.HighWord.Bits.Pres        = 1;
+    entry.HighWord.Bits.Type        = flags;
+    entry.HighWord.Bits.Sys         = 0;
+    entry.HighWord.Bits.Reserved_0  = 0;
+    entry.HighWord.Bits.Default_Big = (flags & LDT_FLAGS_32BIT) != 0;
+    return entry;
+}
+
+static void ldt_set_entry( WORD sel, LDT_ENTRY entry )
+{
+    int index = sel >> 3;
+
+#ifdef linux
+    struct modify_ldt_s ldt_info = { index };
+
+    ldt_info.base_addr       = ldt_get_base( entry );
+    ldt_info.limit           = entry.LimitLow | (entry.HighWord.Bits.LimitHi << 16);
+    ldt_info.seg_32bit       = entry.HighWord.Bits.Default_Big;
+    ldt_info.contents        = (entry.HighWord.Bits.Type >> 2) & 3;
+    ldt_info.read_exec_only  = !(entry.HighWord.Bits.Type & 2);
+    ldt_info.limit_in_pages  = entry.HighWord.Bits.Granularity;
+    ldt_info.seg_not_present = !entry.HighWord.Bits.Pres;
+    ldt_info.usable          = entry.HighWord.Bits.Sys;
+    if (modify_ldt( 0x11, &ldt_info, sizeof(ldt_info) ) < 0) perror( "modify_ldt" );
+#elif defined(__NetBSD__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__)
+    /* The kernel will only let us set LDTs with user priority level */
+    if (entry.HighWord.Bits.Pres && entry.HighWord.Bits.Dpl != 3) entry.HighWord.Bits.Dpl = 3;
+    if (i386_set_ldt(index, (union descriptor *)&entry, 1) < 0)
+    {
+        perror("i386_set_ldt");
+        fprintf( stderr, "Did you reconfigure the kernel with \"options USER_LDT\"?\n" );
+        exit(1);
+    }
+#elif defined(__svr4__) || defined(_SCO_DS)
+    struct ssd ldt_mod;
+
+    ldt_mod.sel  = sel;
+    ldt_mod.bo   = (unsigned long)ldt_get_base( entry );
+    ldt_mod.ls   = entry.LimitLow | (entry.HighWord.Bits.LimitHi << 16);
+    ldt_mod.acc1 = entry.HighWord.Bytes.Flags1;
+    ldt_mod.acc2 = entry.HighWord.Bytes.Flags2 >> 4;
+    if (sysi86(SI86DSCR, &ldt_mod) == -1) perror("sysi86");
+#elif defined(__APPLE__)
+    if (i386_set_ldt(index, (union ldt_entry *)&entry, 1) < 0) perror("i386_set_ldt");
+#elif defined(__GNU__)
+    if (i386_set_ldt(mach_thread_self(), sel, (descriptor_list_t)&entry, 1) != KERN_SUCCESS)
+        perror("i386_set_ldt");
+#else
+    fprintf( stderr, "No LDT support on this platform\n" );
+    exit(1);
+#endif
+
+    __wine_ldt_copy.base[index]  = ldt_get_base( entry );
+    __wine_ldt_copy.limit[index] = ldt_get_limit( entry );
+    __wine_ldt_copy.flags[index] = (entry.HighWord.Bits.Type |
+                                    (entry.HighWord.Bits.Default_Big ? LDT_FLAGS_32BIT : 0) |
+                                    LDT_FLAGS_ALLOCATED);
+}
+
+static void ldt_set_fs( WORD sel, TEB *teb )
+{
+    if (sel == gdt_fs_sel)
+    {
+#ifdef __linux__
+        struct modify_ldt_s ldt_info = { sel >> 3 };
+
+        ldt_info.base_addr = teb;
+        ldt_info.limit     = teb_size - 1;
+        ldt_info.seg_32bit = 1;
+        if (set_thread_area( &ldt_info ) < 0) perror( "set_thread_area" );
+#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__) || defined(__DragonFly__)
+        i386_set_fsbase( teb );
+#endif
+    }
+    set_fs( sel );
+}
+
+
+/**********************************************************************
+ *           get_thread_ldt_entry
+ */
+NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
+{
+    THREAD_DESCRIPTOR_INFORMATION *info = data;
+    NTSTATUS status = STATUS_SUCCESS;
+
+    if (len < sizeof(*info)) return STATUS_INFO_LENGTH_MISMATCH;
+    if (info->Selector >> 16) return STATUS_UNSUCCESSFUL;
+
+    if (is_gdt_sel( info->Selector ))
+    {
+        if (!(info->Selector & ~3))
+            info->Entry = null_entry;
+        else if ((info->Selector | 3) == get_cs())
+            info->Entry = ldt_make_entry( 0, ~0u, LDT_FLAGS_CODE | LDT_FLAGS_32BIT );
+        else if ((info->Selector | 3) == get_ds())
+            info->Entry = ldt_make_entry( 0, ~0u, LDT_FLAGS_DATA | LDT_FLAGS_32BIT );
+        else if ((info->Selector | 3) == get_fs())
+            info->Entry = ldt_make_entry( NtCurrentTeb(), 0xfff, LDT_FLAGS_DATA | LDT_FLAGS_32BIT );
+        else
+            return STATUS_UNSUCCESSFUL;
+    }
+    else
+    {
+        SERVER_START_REQ( get_selector_entry )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->entry = info->Selector >> 3;
+            status = wine_server_call( req );
+            if (!status)
+            {
+                if (reply->flags)
+                    info->Entry = ldt_make_entry( (void *)reply->base, reply->limit, reply->flags );
+                else
+                    status = STATUS_UNSUCCESSFUL;
+            }
+        }
+        SERVER_END_REQ;
+    }
+    if (status == STATUS_SUCCESS && ret_len)
+        /* yes, that's a bit strange, but it's the way it is */
+        *ret_len = sizeof(info->Entry);
+
+    return status;
+}
+
+
+/******************************************************************************
+ *           NtSetLdtEntries   (NTDLL.@)
+ *           ZwSetLdtEntries   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
+{
+    sigset_t sigset;
+
+    if (sel1 >> 16 || sel2 >> 16) return STATUS_INVALID_LDT_DESCRIPTOR;
+    if (sel1 && (sel1 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
+    if (sel2 && (sel2 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
+
+    server_enter_uninterrupted_section( &ldt_section, &sigset );
+    if (sel1) ldt_set_entry( sel1, entry1 );
+    if (sel2) ldt_set_entry( sel2, entry2 );
+    server_leave_uninterrupted_section( &ldt_section, &sigset );
+   return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *             signal_init_threading
+ */
+void signal_init_threading(void)
+{
+#ifdef __linux__
+    /* the preloader may have allocated it already */
+    gdt_fs_sel = get_fs();
+    if (!gdt_fs_sel || !is_gdt_sel( gdt_fs_sel ))
+    {
+        struct modify_ldt_s ldt_info = { -1 };
+
+        ldt_info.seg_32bit = 1;
+        ldt_info.usable = 1;
+        if (set_thread_area( &ldt_info ) >= 0) gdt_fs_sel = (ldt_info.entry_number << 3) | 3;
+        else gdt_fs_sel = 0;
+    }
+#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__)
+    gdt_fs_sel = GSEL( GUFS_SEL, SEL_UPL );
+#endif
+}
+
+
+/**********************************************************************
+ *		signal_alloc_thread
+ */
+NTSTATUS signal_alloc_thread( TEB *teb )
+{
+    struct x86_thread_data *thread_data = (struct x86_thread_data *)teb->SystemReserved2;
+
+    if (!gdt_fs_sel)
+    {
+        static int first_thread = 1;
+        sigset_t sigset;
+        int idx;
+        LDT_ENTRY entry = ldt_make_entry( teb, teb_size - 1, LDT_FLAGS_DATA | LDT_FLAGS_32BIT );
+
+        if (first_thread)  /* no locking for first thread */
+        {
+            /* leave some space if libc is using the LDT for %gs */
+            if (!is_gdt_sel( get_gs() )) first_ldt_entry = 512;
+            idx = first_ldt_entry;
+            ldt_set_entry( (idx << 3) | 7, entry );
+            first_thread = 0;
+        }
+        else
+        {
+            server_enter_uninterrupted_section( &ldt_section, &sigset );
+            for (idx = first_ldt_entry; idx < LDT_SIZE; idx++)
+            {
+                if (__wine_ldt_copy.flags[idx]) continue;
+                ldt_set_entry( (idx << 3) | 7, entry );
+                break;
+            }
+            server_leave_uninterrupted_section( &ldt_section, &sigset );
+            if (idx == LDT_SIZE) return STATUS_TOO_MANY_THREADS;
+        }
+        thread_data->fs = (idx << 3) | 7;
+    }
+    else thread_data->fs = gdt_fs_sel;
+
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *		signal_free_thread
+ */
+void signal_free_thread( TEB *teb )
+{
+    struct x86_thread_data *thread_data = (struct x86_thread_data *)teb->SystemReserved2;
+    sigset_t sigset;
+
+    if (gdt_fs_sel) return;
+
+    server_enter_uninterrupted_section( &ldt_section, &sigset );
+    __wine_ldt_copy.flags[thread_data->fs >> 3] = 0;
+    server_leave_uninterrupted_section( &ldt_section, &sigset );
+}
+
+
+/**********************************************************************
+ *		signal_init_thread
+ */
+void signal_init_thread( TEB *teb )
+{
+    const WORD fpu_cw = 0x27f;
+    struct x86_thread_data *thread_data = (struct x86_thread_data *)teb->SystemReserved2;
+    stack_t ss;
+
+    ss.ss_sp    = (char *)teb + teb_size;
+    ss.ss_size  = signal_stack_size;
+    ss.ss_flags = 0;
+    if (sigaltstack(&ss, NULL) == -1) perror( "sigaltstack" );
+
+    ldt_set_fs( thread_data->fs, teb );
+    thread_data->gs = get_gs();
+
+#ifdef __GNUC__
+    __asm__ volatile ("fninit; fldcw %0" : : "m" (fpu_cw));
+#else
+    FIXME("FPU setup not implemented for this platform.\n");
+#endif
+}
+
+/**********************************************************************
+ *		signal_init_process
+ */
+void signal_init_process(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_SIGINFO | SA_RESTART;
+#ifdef SA_ONSTACK
+    sig_act.sa_flags |= SA_ONSTACK;
+#endif
+#ifdef __ANDROID__
+    sig_act.sa_flags |= SA_RESTORER;
+    sig_act.sa_restorer = rt_sigreturn;
+#endif
+    sig_act.sa_sigaction = int_handler;
+    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = fpe_handler;
+    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = abrt_handler;
+    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = quit_handler;
+    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
+
+    sig_act.sa_sigaction = segv_handler;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
+    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
+#ifdef SIGBUS
+    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+#endif
+
+#ifdef SIGTRAP
+    sig_act.sa_sigaction = trap_handler;
+    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
+#endif
+    return;
+
+ error:
+    perror("sigaction");
+    exit(1);
+}
+
+
+/*******************************************************************
+ *		RtlUnwind (NTDLL.@)
+ */
+void WINAPI DECLSPEC_HIDDEN __regs_RtlUnwind( EXCEPTION_REGISTRATION_RECORD* pEndFrame, PVOID targetIp,
+                                              PEXCEPTION_RECORD pRecord, PVOID retval, CONTEXT *context )
+{
+    EXCEPTION_RECORD record;
+    EXCEPTION_REGISTRATION_RECORD *frame, *dispatch;
+    DWORD res;
+
+    context->Eax = (DWORD)retval;
+
+    /* build an exception record, if we do not have one */
+    if (!pRecord)
+    {
+        record.ExceptionCode    = STATUS_UNWIND;
+        record.ExceptionFlags   = 0;
+        record.ExceptionRecord  = NULL;
         record.ExceptionAddress = (void *)context->Eip;
         record.NumberParameters = 0;
         pRecord = &record;
@@ -392,7 +2712,8 @@ void WINAPI DECLSPEC_HIDDEN __regs_RtlUnwind( EXCEPTION_REGISTRATION_RECORD* pEn
         }
         frame = __wine_pop_frame( frame );
     }
-    NtContinue( context, FALSE );
+
+    NtSetContextThread( GetCurrentThread(), context );
 }
 __ASM_STDCALL_FUNC( RtlUnwind, 16,
                     "pushl %ebp\n\t"
@@ -419,6 +2740,21 @@ __ASM_STDCALL_FUNC( RtlUnwind, 16,
                     "ret $16" )  /* actually never returns */
 
 
+/*******************************************************************
+ *		NtRaiseException (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRaiseException( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+{
+    if (first_chance)
+    {
+        NTSTATUS status = send_debug_event( rec, TRUE, context );
+        if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
+            NtSetContextThread( GetCurrentThread(), context );
+    }
+    return raise_exception( rec, context, first_chance );
+}
+
+
 /*******************************************************************
  *		raise_exception_full_context
  *
@@ -498,6 +2834,203 @@ USHORT WINAPI RtlCaptureStackBackTrace( ULONG skip, ULONG count, PVOID *buffer,
 }
 
 
+extern void DECLSPEC_NORETURN start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend,
+                                            void *relay );
+__ASM_GLOBAL_FUNC( start_thread,
+                   "pushl %ebp\n\t"
+                   __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+                   __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+                   "movl %esp,%ebp\n\t"
+                   __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
+                   "pushl %ebx\n\t"
+                   __ASM_CFI(".cfi_rel_offset %ebx,-4\n\t")
+                   "pushl %esi\n\t"
+                   __ASM_CFI(".cfi_rel_offset %esi,-8\n\t")
+                   "pushl %edi\n\t"
+                   __ASM_CFI(".cfi_rel_offset %edi,-12\n\t")
+                   /* store exit frame */
+                   "movl %ebp,%fs:0x1f4\n\t"    /* x86_thread_data()->exit_frame */
+                   /* switch to thread stack */
+                   "movl %fs:4,%eax\n\t"        /* NtCurrentTeb()->StackBase */
+                   "leal -0x1000(%eax),%esp\n\t"
+                   /* attach dlls */
+                   "pushl 20(%ebp)\n\t"         /* relay */
+                   "pushl 16(%ebp)\n\t"         /* suspend */
+                   "pushl 12(%ebp)\n\t"         /* arg */
+                   "pushl 8(%ebp)\n\t"          /* entry */
+                   "xorl %ebp,%ebp\n\t"
+                   "call " __ASM_NAME("attach_thread") "\n\t"
+                   "movl %eax,%esi\n\t"
+                   "leal -12(%eax),%esp\n\t"
+                   /* clear the stack */
+                   "andl $~0xfff,%eax\n\t"  /* round down to page size */
+                   "movl %eax,(%esp)\n\t"
+                   "call " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
+                   /* switch to the initial context */
+                   "movl %esi,(%esp)\n\t"
+                   "call " __ASM_NAME("set_cpu_context") )
+
+extern void DECLSPEC_NORETURN call_thread_exit_func( int status, void (*func)(int) );
+__ASM_GLOBAL_FUNC( call_thread_exit_func,
+                   "movl 8(%esp),%ecx\n\t"
+                   /* fetch exit frame */
+                   "movl %fs:0x1f4,%edx\n\t"    /* x86_thread_data()->exit_frame */
+                   "testl %edx,%edx\n\t"
+                   "jnz 1f\n\t"
+                   "jmp *%ecx\n\t"
+                   /* switch to exit frame stack */
+                   "1:\tmovl 4(%esp),%eax\n\t"
+                   "movl $0,%fs:0x1f4\n\t"
+                   "movl %edx,%ebp\n\t"
+                   __ASM_CFI(".cfi_def_cfa %ebp,4\n\t")
+                   __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+                   __ASM_CFI(".cfi_rel_offset %ebx,-4\n\t")
+                   __ASM_CFI(".cfi_rel_offset %esi,-8\n\t")
+                   __ASM_CFI(".cfi_rel_offset %edi,-12\n\t")
+                   "leal -20(%ebp),%esp\n\t"
+                   "pushl %eax\n\t"
+                   "call *%ecx" )
+
+extern void call_thread_entry(void) DECLSPEC_HIDDEN;
+__ASM_GLOBAL_FUNC( call_thread_entry,
+                   "pushl %ebp\n\t"
+                   __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+                   __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+                   "movl %esp,%ebp\n\t"
+                   __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
+                   "pushl %ebx\n\t"  /* arg */
+                   "pushl %eax\n\t"  /* entry */
+                   "call " __ASM_NAME("call_thread_func") )
+
+/* wrapper for apps that don't declare the thread function correctly */
+extern DWORD call_thread_func_wrapper( LPTHREAD_START_ROUTINE entry, void *arg );
+__ASM_GLOBAL_FUNC(call_thread_func_wrapper,
+                  "pushl %ebp\n\t"
+                  __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+                  __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+                  "movl %esp,%ebp\n\t"
+                  __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
+                  "subl $4,%esp\n\t"
+                  "pushl 12(%ebp)\n\t"
+                  "call *8(%ebp)\n\t"
+                  "leave\n\t"
+                  __ASM_CFI(".cfi_def_cfa %esp,4\n\t")
+                  __ASM_CFI(".cfi_same_value %ebp\n\t")
+                  "ret" )
+
+/***********************************************************************
+ *           call_thread_func
+ */
+void DECLSPEC_HIDDEN call_thread_func( LPTHREAD_START_ROUTINE entry, void *arg )
+{
+    __TRY
+    {
+        TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", entry, arg );
+        RtlExitUserThread( call_thread_func_wrapper( entry, arg ));
+    }
+    __EXCEPT(call_unhandled_exception_filter)
+    {
+        NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+    }
+    __ENDTRY
+    abort();  /* should not be reached */
+}
+
+
+/***********************************************************************
+ *           init_thread_context
+ */
+static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
+{
+    context->SegCs  = get_cs();
+    context->SegDs  = get_ds();
+    context->SegEs  = get_ds();
+    context->SegFs  = get_fs();
+    context->SegGs  = get_gs();
+    context->SegSs  = get_ds();
+    context->EFlags = 0x202;
+    context->Eax    = (DWORD)entry;
+    context->Ebx    = (DWORD)arg;
+    context->Esp    = (DWORD)NtCurrentTeb()->Tib.StackBase - 16;
+    context->Eip    = (DWORD)relay;
+    context->FloatSave.ControlWord = 0x27f;
+    ((XMM_SAVE_AREA32 *)context->ExtendedRegisters)->ControlWord = 0x27f;
+    ((XMM_SAVE_AREA32 *)context->ExtendedRegisters)->MxCsr = 0x1f80;
+}
+
+
+/***********************************************************************
+ *           attach_thread
+ */
+PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
+                                        BOOL suspend, void *relay )
+{
+    CONTEXT *ctx;
+
+    if (suspend)
+    {
+        CONTEXT context = { CONTEXT_ALL };
+
+        init_thread_context( &context, entry, arg, relay );
+        wait_suspend( &context );
+        ctx = (CONTEXT *)((ULONG_PTR)context.Esp & ~15) - 1;
+        *ctx = context;
+    }
+    else
+    {
+        ctx = (CONTEXT *)((char *)NtCurrentTeb()->Tib.StackBase - 16) - 1;
+        init_thread_context( ctx, entry, arg, relay );
+    }
+    ctx->ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;
+    LdrInitializeThunk( ctx, (void **)&ctx->Eax, 0, 0 );
+    return ctx;
+}
+
+
+/***********************************************************************
+ *           signal_start_thread
+ *
+ * Thread startup sequence:
+ * signal_start_thread()
+ *   -> start_thread()
+ *     -> call_thread_entry()
+ *       -> call_thread_func()
+ */
+void signal_start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend )
+{
+    start_thread( entry, arg, suspend, call_thread_entry );
+}
+
+/**********************************************************************
+ *		signal_start_process
+ *
+ * Process startup sequence:
+ * signal_start_process()
+ *   -> start_thread()
+ *     -> kernel32_start_process()
+ */
+void signal_start_process( LPTHREAD_START_ROUTINE entry, BOOL suspend )
+{
+    start_thread( entry, NtCurrentTeb()->Peb, suspend, kernel32_start_process );
+}
+
+
+/***********************************************************************
+ *           signal_exit_thread
+ */
+void signal_exit_thread( int status )
+{
+    call_thread_exit_func( status, exit_thread );
+}
+
+/***********************************************************************
+ *           signal_exit_process
+ */
+void signal_exit_process( int status )
+{
+    call_thread_exit_func( status, exit );
+}
+
 /**********************************************************************
  *		DbgBreakPoint   (NTDLL.@)
  */
diff --git a/dlls/ntdll/signal_powerpc.c b/dlls/ntdll/signal_powerpc.c
new file mode 100644
index 0000000000..9df6eff31f
--- /dev/null
+++ b/dlls/ntdll/signal_powerpc.c
@@ -0,0 +1,1278 @@
+/*
+ * PowerPC signal handling routines
+ *
+ * Copyright 2002 Marcus Meissner, SuSE Linux AG
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __powerpc__
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYSCALL_H
+# include <syscall.h>
+#else
+# ifdef HAVE_SYS_SYSCALL_H
+#  include <sys/syscall.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SIGNAL_H
+# include <sys/signal.h>
+#endif
+#ifdef HAVE_SYS_UCONTEXT_H
+# include <sys/ucontext.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+#include "wine/library.h"
+#include "wine/exception.h"
+#include "ntdll_misc.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(seh);
+WINE_DECLARE_DEBUG_CHANNEL(relay);
+
+static pthread_key_t teb_key;
+
+/***********************************************************************
+ * signal context platform-specific definitions
+ */
+#ifdef linux
+
+/* All Registers access - only for local access */
+# define REG_sig(reg_name, context)		((context)->uc_mcontext.regs->reg_name)
+
+
+/* Gpr Registers access  */
+# define GPR_sig(reg_num, context)		REG_sig(gpr[reg_num], context)
+
+# define IAR_sig(context)			REG_sig(nip, context)	/* Program counter */
+# define MSR_sig(context)			REG_sig(msr, context)   /* Machine State Register (Supervisor) */
+# define CTR_sig(context)			REG_sig(ctr, context)   /* Count register */
+
+# define XER_sig(context)			REG_sig(xer, context) /* User's integer exception register */
+# define LR_sig(context)			REG_sig(link, context) /* Link register */
+# define CR_sig(context)			REG_sig(ccr, context) /* Condition register */
+
+/* Float Registers access  */
+# define FLOAT_sig(reg_num, context)		(((double*)((char*)((context)->uc_mcontext.regs+48*4)))[reg_num])
+
+# define FPSCR_sig(context)			(*(int*)((char*)((context)->uc_mcontext.regs+(48+32*2)*4)))
+
+/* Exception Registers access */
+# define DAR_sig(context)			REG_sig(dar, context)
+# define DSISR_sig(context)			REG_sig(dsisr, context)
+# define TRAP_sig(context)			REG_sig(trap, context)
+
+#endif /* linux */
+
+#ifdef __APPLE__
+
+/* All Registers access - only for local access */
+# define REG_sig(reg_name, context)		((context)->uc_mcontext->ss.reg_name)
+# define FLOATREG_sig(reg_name, context)	((context)->uc_mcontext->fs.reg_name)
+# define EXCEPREG_sig(reg_name, context)	((context)->uc_mcontext->es.reg_name)
+# define VECREG_sig(reg_name, context)		((context)->uc_mcontext->vs.reg_name)
+
+/* Gpr Registers access */
+# define GPR_sig(reg_num, context)		REG_sig(r##reg_num, context)
+
+# define IAR_sig(context)			REG_sig(srr0, context)	/* Program counter */
+# define MSR_sig(context)			REG_sig(srr1, context)  /* Machine State Register (Supervisor) */
+# define CTR_sig(context)			REG_sig(ctr, context)
+
+# define XER_sig(context)			REG_sig(xer, context) /* Link register */
+# define LR_sig(context)			REG_sig(lr, context)  /* User's integer exception register */
+# define CR_sig(context)			REG_sig(cr, context)  /* Condition register */
+
+/* Float Registers access */
+# define FLOAT_sig(reg_num, context)		FLOATREG_sig(fpregs[reg_num], context)
+
+# define FPSCR_sig(context)			FLOATREG_sig(fpscr, context)
+
+/* Exception Registers access */
+# define DAR_sig(context)			EXCEPREG_sig(dar, context)     /* Fault registers for coredump */
+# define DSISR_sig(context)			EXCEPREG_sig(dsisr, context)
+# define TRAP_sig(context)			EXCEPREG_sig(exception, context) /* number of powerpc exception taken */
+
+/* Signal defs : Those are undefined on darwin
+SIGBUS
+#undef BUS_ADRERR
+#undef BUS_OBJERR
+SIGILL
+#undef ILL_ILLOPN
+#undef ILL_ILLTRP
+#undef ILL_ILLADR
+#undef ILL_COPROC
+#undef ILL_PRVREG
+#undef ILL_BADSTK
+SIGTRAP
+#undef TRAP_BRKPT
+#undef TRAP_TRACE
+SIGFPE
+*/
+
+#endif /* __APPLE__ */
+
+
+
+typedef int (*wine_signal_handler)(unsigned int sig);
+
+static wine_signal_handler handlers[256];
+
+/***********************************************************************
+ *           dispatch_signal
+ */
+static inline int dispatch_signal(unsigned int sig)
+{
+    if (handlers[sig] == NULL) return 0;
+    return handlers[sig](sig);
+}
+
+/***********************************************************************
+ *           save_context
+ *
+ * Set the register values from a sigcontext.
+ */
+static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
+{
+
+#define C(x) context->Gpr##x = GPR_sig(x,sigcontext)
+        /* Save Gpr registers */
+	C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
+	C(11); C(12); C(13); C(14); C(15); C(16); C(17); C(18); C(19); C(20);
+	C(21); C(22); C(23); C(24); C(25); C(26); C(27); C(28); C(29); C(30);
+	C(31);
+#undef C
+
+	context->Iar = IAR_sig(sigcontext);  /* Program Counter */
+	context->Msr = MSR_sig(sigcontext);  /* Machine State Register (Supervisor) */
+	context->Ctr = CTR_sig(sigcontext);
+        
+        context->Xer = XER_sig(sigcontext);
+	context->Lr  = LR_sig(sigcontext);
+	context->Cr  = CR_sig(sigcontext);
+        
+        /* Saving Exception regs */
+        context->Dar   = DAR_sig(sigcontext);
+        context->Dsisr = DSISR_sig(sigcontext);
+        context->Trap  = TRAP_sig(sigcontext);
+}
+
+
+/***********************************************************************
+ *           restore_context
+ *
+ * Build a sigcontext from the register values.
+ */
+static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
+{
+
+#define C(x)  GPR_sig(x,sigcontext) = context->Gpr##x
+	C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
+	C(11); C(12); C(13); C(14); C(15); C(16); C(17); C(18); C(19); C(20);
+	C(21); C(22); C(23); C(24); C(25); C(26); C(27); C(28); C(29); C(30);
+	C(31);
+#undef C
+
+        IAR_sig(sigcontext) = context->Iar;  /* Program Counter */
+        MSR_sig(sigcontext) = context->Msr;  /* Machine State Register (Supervisor) */
+        CTR_sig(sigcontext) = context->Ctr;
+        
+        XER_sig(sigcontext) = context->Xer;
+        LR_sig(sigcontext) = context->Lr;
+	CR_sig(sigcontext) = context->Cr;
+        
+        /* Setting Exception regs */
+        DAR_sig(sigcontext) = context->Dar;
+        DSISR_sig(sigcontext) = context->Dsisr;
+        TRAP_sig(sigcontext) = context->Trap;
+}
+
+
+/***********************************************************************
+ *           save_fpu
+ *
+ * Set the FPU context from a sigcontext.
+ */
+static inline void save_fpu( CONTEXT *context, const ucontext_t *sigcontext )
+{
+#define C(x)   context->Fpr##x = FLOAT_sig(x,sigcontext)
+        C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
+	C(11); C(12); C(13); C(14); C(15); C(16); C(17); C(18); C(19); C(20);
+	C(21); C(22); C(23); C(24); C(25); C(26); C(27); C(28); C(29); C(30);
+	C(31);
+#undef C
+        context->Fpscr = FPSCR_sig(sigcontext);
+}
+
+
+/***********************************************************************
+ *           restore_fpu
+ *
+ * Restore the FPU context to a sigcontext.
+ */
+static inline void restore_fpu( CONTEXT *context, const ucontext_t *sigcontext )
+{
+#define C(x)  FLOAT_sig(x,sigcontext) = context->Fpr##x
+        C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
+	C(11); C(12); C(13); C(14); C(15); C(16); C(17); C(18); C(19); C(20);
+	C(21); C(22); C(23); C(24); C(25); C(26); C(27); C(28); C(29); C(30);
+	C(31);
+#undef C
+        FPSCR_sig(sigcontext) = context->Fpscr;
+}
+
+
+/***********************************************************************
+ *		RtlCaptureContext (NTDLL.@)
+ */
+void WINAPI RtlCaptureContext( CONTEXT *context )
+{
+    FIXME("not implemented\n");
+    memset( context, 0, sizeof(*context) );
+}
+
+
+/***********************************************************************
+ *           set_cpu_context
+ *
+ * Set the new CPU context.
+ */
+static void set_cpu_context( const CONTEXT *context )
+{
+    FIXME("not implemented\n");
+}
+
+
+/***********************************************************************
+ *           get_server_context_flags
+ *
+ * Convert CPU-specific flags to generic server flags
+ */
+static unsigned int get_server_context_flags( DWORD flags )
+{
+    unsigned int ret = 0;
+
+    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
+    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
+    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
+    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           copy_context
+ *
+ * Copy a register context according to the flags.
+ */
+static void copy_context( CONTEXT *to, const CONTEXT *from, DWORD flags )
+{
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->Msr   = from->Msr;
+        to->Ctr   = from->Ctr;
+        to->Iar   = from->Iar;
+        to->Lr    = from->Lr;
+        to->Dar   = from->Dar;
+        to->Dsisr = from->Dsisr;
+        to->Trap  = from->Trap;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->Gpr0  = from->Gpr0;
+        to->Gpr1  = from->Gpr1;
+        to->Gpr2  = from->Gpr2;
+        to->Gpr3  = from->Gpr3;
+        to->Gpr4  = from->Gpr4;
+        to->Gpr5  = from->Gpr5;
+        to->Gpr6  = from->Gpr6;
+        to->Gpr7  = from->Gpr7;
+        to->Gpr8  = from->Gpr8;
+        to->Gpr9  = from->Gpr9;
+        to->Gpr10 = from->Gpr10;
+        to->Gpr11 = from->Gpr11;
+        to->Gpr12 = from->Gpr12;
+        to->Gpr13 = from->Gpr13;
+        to->Gpr14 = from->Gpr14;
+        to->Gpr15 = from->Gpr15;
+        to->Gpr16 = from->Gpr16;
+        to->Gpr17 = from->Gpr17;
+        to->Gpr18 = from->Gpr18;
+        to->Gpr19 = from->Gpr19;
+        to->Gpr20 = from->Gpr20;
+        to->Gpr21 = from->Gpr21;
+        to->Gpr22 = from->Gpr22;
+        to->Gpr23 = from->Gpr23;
+        to->Gpr24 = from->Gpr24;
+        to->Gpr25 = from->Gpr25;
+        to->Gpr26 = from->Gpr26;
+        to->Gpr27 = from->Gpr27;
+        to->Gpr28 = from->Gpr28;
+        to->Gpr29 = from->Gpr29;
+        to->Gpr30 = from->Gpr30;
+        to->Gpr31 = from->Gpr31;
+        to->Xer   = from->Xer;
+        to->Cr    = from->Cr;
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->Fpr0  = from->Fpr0;
+        to->Fpr1  = from->Fpr1;
+        to->Fpr2  = from->Fpr2;
+        to->Fpr3  = from->Fpr3;
+        to->Fpr4  = from->Fpr4;
+        to->Fpr5  = from->Fpr5;
+        to->Fpr6  = from->Fpr6;
+        to->Fpr7  = from->Fpr7;
+        to->Fpr8  = from->Fpr8;
+        to->Fpr9  = from->Fpr9;
+        to->Fpr10 = from->Fpr10;
+        to->Fpr11 = from->Fpr11;
+        to->Fpr12 = from->Fpr12;
+        to->Fpr13 = from->Fpr13;
+        to->Fpr14 = from->Fpr14;
+        to->Fpr15 = from->Fpr15;
+        to->Fpr16 = from->Fpr16;
+        to->Fpr17 = from->Fpr17;
+        to->Fpr18 = from->Fpr18;
+        to->Fpr19 = from->Fpr19;
+        to->Fpr20 = from->Fpr20;
+        to->Fpr21 = from->Fpr21;
+        to->Fpr22 = from->Fpr22;
+        to->Fpr23 = from->Fpr23;
+        to->Fpr24 = from->Fpr24;
+        to->Fpr25 = from->Fpr25;
+        to->Fpr26 = from->Fpr26;
+        to->Fpr27 = from->Fpr27;
+        to->Fpr28 = from->Fpr28;
+        to->Fpr29 = from->Fpr29;
+        to->Fpr30 = from->Fpr30;
+        to->Fpr31 = from->Fpr31;
+        to->Fpscr = from->Fpscr;
+    }
+}
+
+
+/***********************************************************************
+ *           context_to_server
+ *
+ * Convert a register context to the server format.
+ */
+NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
+{
+    DWORD flags = from->ContextFlags;  /* no CPU id? */
+
+    memset( to, 0, sizeof(*to) );
+    to->cpu = CPU_POWERPC;
+
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->flags |= SERVER_CTX_CONTROL;
+        to->ctl.powerpc_regs.iar   = from->Iar;
+        to->ctl.powerpc_regs.msr   = from->Msr;
+        to->ctl.powerpc_regs.ctr   = from->Ctr;
+        to->ctl.powerpc_regs.lr    = from->Lr;
+        to->ctl.powerpc_regs.dar   = from->Dar;
+        to->ctl.powerpc_regs.dsisr = from->Dsisr;
+        to->ctl.powerpc_regs.trap  = from->Trap;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->flags |= SERVER_CTX_INTEGER;
+        to->integer.powerpc_regs.gpr[0]  = from->Gpr0;
+        to->integer.powerpc_regs.gpr[1]  = from->Gpr1;
+        to->integer.powerpc_regs.gpr[2]  = from->Gpr2;
+        to->integer.powerpc_regs.gpr[3]  = from->Gpr3;
+        to->integer.powerpc_regs.gpr[4]  = from->Gpr4;
+        to->integer.powerpc_regs.gpr[5]  = from->Gpr5;
+        to->integer.powerpc_regs.gpr[6]  = from->Gpr6;
+        to->integer.powerpc_regs.gpr[7]  = from->Gpr7;
+        to->integer.powerpc_regs.gpr[8]  = from->Gpr8;
+        to->integer.powerpc_regs.gpr[9]  = from->Gpr9;
+        to->integer.powerpc_regs.gpr[10] = from->Gpr10;
+        to->integer.powerpc_regs.gpr[11] = from->Gpr11;
+        to->integer.powerpc_regs.gpr[12] = from->Gpr12;
+        to->integer.powerpc_regs.gpr[13] = from->Gpr13;
+        to->integer.powerpc_regs.gpr[14] = from->Gpr14;
+        to->integer.powerpc_regs.gpr[15] = from->Gpr15;
+        to->integer.powerpc_regs.gpr[16] = from->Gpr16;
+        to->integer.powerpc_regs.gpr[17] = from->Gpr17;
+        to->integer.powerpc_regs.gpr[18] = from->Gpr18;
+        to->integer.powerpc_regs.gpr[19] = from->Gpr19;
+        to->integer.powerpc_regs.gpr[20] = from->Gpr20;
+        to->integer.powerpc_regs.gpr[21] = from->Gpr21;
+        to->integer.powerpc_regs.gpr[22] = from->Gpr22;
+        to->integer.powerpc_regs.gpr[23] = from->Gpr23;
+        to->integer.powerpc_regs.gpr[24] = from->Gpr24;
+        to->integer.powerpc_regs.gpr[25] = from->Gpr25;
+        to->integer.powerpc_regs.gpr[26] = from->Gpr26;
+        to->integer.powerpc_regs.gpr[27] = from->Gpr27;
+        to->integer.powerpc_regs.gpr[28] = from->Gpr28;
+        to->integer.powerpc_regs.gpr[29] = from->Gpr29;
+        to->integer.powerpc_regs.gpr[30] = from->Gpr30;
+        to->integer.powerpc_regs.gpr[31] = from->Gpr31;
+        to->integer.powerpc_regs.xer     = from->Xer;
+        to->integer.powerpc_regs.cr      = from->Cr;
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->flags |= SERVER_CTX_FLOATING_POINT;
+        to->fp.powerpc_regs.fpr[0]  = from->Fpr0;
+        to->fp.powerpc_regs.fpr[1]  = from->Fpr1;
+        to->fp.powerpc_regs.fpr[2]  = from->Fpr2;
+        to->fp.powerpc_regs.fpr[3]  = from->Fpr3;
+        to->fp.powerpc_regs.fpr[4]  = from->Fpr4;
+        to->fp.powerpc_regs.fpr[5]  = from->Fpr5;
+        to->fp.powerpc_regs.fpr[6]  = from->Fpr6;
+        to->fp.powerpc_regs.fpr[7]  = from->Fpr7;
+        to->fp.powerpc_regs.fpr[8]  = from->Fpr8;
+        to->fp.powerpc_regs.fpr[9]  = from->Fpr9;
+        to->fp.powerpc_regs.fpr[10] = from->Fpr10;
+        to->fp.powerpc_regs.fpr[11] = from->Fpr11;
+        to->fp.powerpc_regs.fpr[12] = from->Fpr12;
+        to->fp.powerpc_regs.fpr[13] = from->Fpr13;
+        to->fp.powerpc_regs.fpr[14] = from->Fpr14;
+        to->fp.powerpc_regs.fpr[15] = from->Fpr15;
+        to->fp.powerpc_regs.fpr[16] = from->Fpr16;
+        to->fp.powerpc_regs.fpr[17] = from->Fpr17;
+        to->fp.powerpc_regs.fpr[18] = from->Fpr18;
+        to->fp.powerpc_regs.fpr[19] = from->Fpr19;
+        to->fp.powerpc_regs.fpr[20] = from->Fpr20;
+        to->fp.powerpc_regs.fpr[21] = from->Fpr21;
+        to->fp.powerpc_regs.fpr[22] = from->Fpr22;
+        to->fp.powerpc_regs.fpr[23] = from->Fpr23;
+        to->fp.powerpc_regs.fpr[24] = from->Fpr24;
+        to->fp.powerpc_regs.fpr[25] = from->Fpr25;
+        to->fp.powerpc_regs.fpr[26] = from->Fpr26;
+        to->fp.powerpc_regs.fpr[27] = from->Fpr27;
+        to->fp.powerpc_regs.fpr[28] = from->Fpr28;
+        to->fp.powerpc_regs.fpr[29] = from->Fpr29;
+        to->fp.powerpc_regs.fpr[30] = from->Fpr30;
+        to->fp.powerpc_regs.fpr[31] = from->Fpr31;
+        to->fp.powerpc_regs.fpscr   = from->Fpscr;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           context_from_server
+ *
+ * Convert a register context from the server format.
+ */
+NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
+{
+    if (from->cpu != CPU_POWERPC) return STATUS_INVALID_PARAMETER;
+
+    to->ContextFlags = 0;  /* no CPU id? */
+    if (from->flags & SERVER_CTX_CONTROL)
+    {
+        to->ContextFlags |= CONTEXT_CONTROL;
+        to->Msr   = from->ctl.powerpc_regs.msr;
+        to->Ctr   = from->ctl.powerpc_regs.ctr;
+        to->Iar   = from->ctl.powerpc_regs.iar;
+        to->Lr    = from->ctl.powerpc_regs.lr;
+        to->Dar   = from->ctl.powerpc_regs.dar;
+        to->Dsisr = from->ctl.powerpc_regs.dsisr;
+        to->Trap  = from->ctl.powerpc_regs.trap;
+    }
+    if (from->flags & SERVER_CTX_INTEGER)
+    {
+        to->ContextFlags |= CONTEXT_INTEGER;
+        to->Gpr0  = from->integer.powerpc_regs.gpr[0];
+        to->Gpr1  = from->integer.powerpc_regs.gpr[1];
+        to->Gpr2  = from->integer.powerpc_regs.gpr[2];
+        to->Gpr3  = from->integer.powerpc_regs.gpr[3];
+        to->Gpr4  = from->integer.powerpc_regs.gpr[4];
+        to->Gpr5  = from->integer.powerpc_regs.gpr[5];
+        to->Gpr6  = from->integer.powerpc_regs.gpr[6];
+        to->Gpr7  = from->integer.powerpc_regs.gpr[7];
+        to->Gpr8  = from->integer.powerpc_regs.gpr[8];
+        to->Gpr9  = from->integer.powerpc_regs.gpr[9];
+        to->Gpr10 = from->integer.powerpc_regs.gpr[10];
+        to->Gpr11 = from->integer.powerpc_regs.gpr[11];
+        to->Gpr12 = from->integer.powerpc_regs.gpr[12];
+        to->Gpr13 = from->integer.powerpc_regs.gpr[13];
+        to->Gpr14 = from->integer.powerpc_regs.gpr[14];
+        to->Gpr15 = from->integer.powerpc_regs.gpr[15];
+        to->Gpr16 = from->integer.powerpc_regs.gpr[16];
+        to->Gpr17 = from->integer.powerpc_regs.gpr[17];
+        to->Gpr18 = from->integer.powerpc_regs.gpr[18];
+        to->Gpr19 = from->integer.powerpc_regs.gpr[19];
+        to->Gpr20 = from->integer.powerpc_regs.gpr[20];
+        to->Gpr21 = from->integer.powerpc_regs.gpr[21];
+        to->Gpr22 = from->integer.powerpc_regs.gpr[22];
+        to->Gpr23 = from->integer.powerpc_regs.gpr[23];
+        to->Gpr24 = from->integer.powerpc_regs.gpr[24];
+        to->Gpr25 = from->integer.powerpc_regs.gpr[25];
+        to->Gpr26 = from->integer.powerpc_regs.gpr[26];
+        to->Gpr27 = from->integer.powerpc_regs.gpr[27];
+        to->Gpr28 = from->integer.powerpc_regs.gpr[28];
+        to->Gpr29 = from->integer.powerpc_regs.gpr[29];
+        to->Gpr30 = from->integer.powerpc_regs.gpr[30];
+        to->Gpr31 = from->integer.powerpc_regs.gpr[31];
+        to->Xer   = from->integer.powerpc_regs.xer;
+        to->Cr    = from->integer.powerpc_regs.cr;
+    }
+    if (from->flags & SERVER_CTX_FLOATING_POINT)
+    {
+        to->ContextFlags |= CONTEXT_FLOATING_POINT;
+        to->Fpr0  = from->fp.powerpc_regs.fpr[0];
+        to->Fpr1  = from->fp.powerpc_regs.fpr[1];
+        to->Fpr2  = from->fp.powerpc_regs.fpr[2];
+        to->Fpr3  = from->fp.powerpc_regs.fpr[3];
+        to->Fpr4  = from->fp.powerpc_regs.fpr[4];
+        to->Fpr5  = from->fp.powerpc_regs.fpr[5];
+        to->Fpr6  = from->fp.powerpc_regs.fpr[6];
+        to->Fpr7  = from->fp.powerpc_regs.fpr[7];
+        to->Fpr8  = from->fp.powerpc_regs.fpr[8];
+        to->Fpr9  = from->fp.powerpc_regs.fpr[9];
+        to->Fpr10 = from->fp.powerpc_regs.fpr[10];
+        to->Fpr11 = from->fp.powerpc_regs.fpr[11];
+        to->Fpr12 = from->fp.powerpc_regs.fpr[12];
+        to->Fpr13 = from->fp.powerpc_regs.fpr[13];
+        to->Fpr14 = from->fp.powerpc_regs.fpr[14];
+        to->Fpr15 = from->fp.powerpc_regs.fpr[15];
+        to->Fpr16 = from->fp.powerpc_regs.fpr[16];
+        to->Fpr17 = from->fp.powerpc_regs.fpr[17];
+        to->Fpr18 = from->fp.powerpc_regs.fpr[18];
+        to->Fpr19 = from->fp.powerpc_regs.fpr[19];
+        to->Fpr20 = from->fp.powerpc_regs.fpr[20];
+        to->Fpr21 = from->fp.powerpc_regs.fpr[21];
+        to->Fpr22 = from->fp.powerpc_regs.fpr[22];
+        to->Fpr23 = from->fp.powerpc_regs.fpr[23];
+        to->Fpr24 = from->fp.powerpc_regs.fpr[24];
+        to->Fpr25 = from->fp.powerpc_regs.fpr[25];
+        to->Fpr26 = from->fp.powerpc_regs.fpr[26];
+        to->Fpr27 = from->fp.powerpc_regs.fpr[27];
+        to->Fpr28 = from->fp.powerpc_regs.fpr[28];
+        to->Fpr29 = from->fp.powerpc_regs.fpr[29];
+        to->Fpr30 = from->fp.powerpc_regs.fpr[30];
+        to->Fpr31 = from->fp.powerpc_regs.fpr[31];
+        to->Fpscr = from->fp.powerpc_regs.fpscr;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *              NtSetContextThread  (NTDLL.@)
+ *              ZwSetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
+{
+    NTSTATUS ret;
+    BOOL self;
+    context_t server_context;
+
+    context_to_server( &server_context, context );
+    ret = set_thread_context( handle, &server_context, &self );
+    if (self && ret == STATUS_SUCCESS) set_cpu_context( context );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              NtGetContextThread  (NTDLL.@)
+ *              ZwGetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
+{
+    NTSTATUS ret;
+    DWORD needed_flags = context->ContextFlags;
+    BOOL self = (handle == GetCurrentThread());
+
+    if (!self)
+    {
+        context_t server_context;
+        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
+
+        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
+        if ((ret = context_from_server( context, &server_context ))) return ret;
+        needed_flags &= ~context->ContextFlags;
+    }
+
+    if (self && needed_flags)
+    {
+        CONTEXT ctx;
+        RtlCaptureContext( &ctx );
+        copy_context( context, &ctx, ctx.ContextFlags & needed_flags );
+        context->ContextFlags |= ctx.ContextFlags & needed_flags;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *           call_stack_handlers
+ *
+ * Call the stack handlers chain.
+ */
+static NTSTATUS call_stack_handlers( EXCEPTION_RECORD *rec, CONTEXT *context )
+{
+    EXCEPTION_POINTERS ptrs;
+
+    FIXME( "not implemented on PowerPC\n" );
+
+    /* hack: call unhandled exception filter directly */
+    ptrs.ExceptionRecord = rec;
+    ptrs.ContextRecord = context;
+    call_unhandled_exception_filter( &ptrs );
+    return STATUS_UNHANDLED_EXCEPTION;
+}
+
+
+/*******************************************************************
+ *		raise_exception
+ *
+ * Implementation of NtRaiseException.
+ */
+static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+{
+    NTSTATUS status;
+
+    if (first_chance)
+    {
+        DWORD c;
+
+        TRACE( "code=%x flags=%x addr=%p ip=%x tid=%04x\n",
+               rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
+               context->Iar, GetCurrentThreadId() );
+        for (c = 0; c < rec->NumberParameters; c++)
+            TRACE( " info[%d]=%08lx\n", c, rec->ExceptionInformation[c] );
+        if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+        {
+            if (rec->ExceptionInformation[1] >> 16)
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+            else
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+        }
+        else
+        {
+            /* FIXME: dump context */
+        }
+
+        status = send_debug_event( rec, TRUE, context );
+        if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
+            return STATUS_SUCCESS;
+
+        if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION)
+            return STATUS_SUCCESS;
+
+        if ((status = call_stack_handlers( rec, context )) != STATUS_UNHANDLED_EXCEPTION)
+            return status;
+    }
+
+    /* last chance exception */
+
+    status = send_debug_event( rec, FALSE, context );
+    if (status != DBG_CONTINUE)
+    {
+        if (rec->ExceptionFlags & EH_STACK_INVALID)
+            ERR("Exception frame is not in stack limits => unable to dispatch exception.\n");
+        else if (rec->ExceptionCode == STATUS_NONCONTINUABLE_EXCEPTION)
+            ERR("Process attempted to continue execution after noncontinuable exception.\n");
+        else
+            ERR("Unhandled exception code %x flags %x addr %p\n",
+                rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress );
+        NtTerminateProcess( NtCurrentProcess(), rec->ExceptionCode );
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *		segv_handler
+ *
+ * Handler for SIGSEGV and related errors.
+ */
+static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    EXCEPTION_RECORD rec;
+    CONTEXT context;
+    NTSTATUS status;
+
+    save_context( &context, sigcontext );
+
+    rec.ExceptionRecord  = NULL;
+    rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    rec.ExceptionAddress = (LPVOID)context.Iar;
+    rec.NumberParameters = 0;
+
+    switch (signal)
+    {
+    case SIGSEGV:
+    	switch (siginfo->si_code & 0xffff)
+        {
+	case SEGV_MAPERR:
+	case SEGV_ACCERR:
+            rec.NumberParameters = 2;
+            rec.ExceptionInformation[0] = 0; /* FIXME ? */
+            rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
+            if (!(rec.ExceptionCode = virtual_handle_fault(siginfo->si_addr, rec.ExceptionInformation[0], FALSE)))
+                goto done;
+            break;
+	default:
+            FIXME("Unhandled SIGSEGV/%x\n",siginfo->si_code);
+            break;
+	}
+    	break;
+    case SIGBUS:
+    	switch (siginfo->si_code & 0xffff)
+        {
+	case BUS_ADRALN:
+            rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
+            break;
+#ifdef BUS_ADRERR
+	case BUS_ADRERR:
+#endif
+#ifdef BUS_OBJERR
+	case BUS_OBJERR:
+            /* FIXME: correct for all cases ? */
+            rec.NumberParameters = 2;
+            rec.ExceptionInformation[0] = 0; /* FIXME ? */
+            rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
+            if (!(rec.ExceptionCode = virtual_handle_fault(siginfo->si_addr, rec.ExceptionInformation[0], FALSE)))
+                goto done;
+            break;
+#endif
+	default:
+            FIXME("Unhandled SIGBUS/%x\n",siginfo->si_code);
+            break;
+	}
+    	break;
+    case SIGILL:
+    	switch (siginfo->si_code & 0xffff)
+        {
+	case ILL_ILLOPC: /* illegal opcode */
+#ifdef ILL_ILLOPN
+	case ILL_ILLOPN: /* illegal operand */
+#endif
+#ifdef ILL_ILLADR
+	case ILL_ILLADR: /* illegal addressing mode */
+#endif
+#ifdef ILL_ILLTRP
+	case ILL_ILLTRP: /* illegal trap */
+#endif
+#ifdef ILL_COPROC
+	case ILL_COPROC: /* coprocessor error */
+#endif
+            rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+            break;
+	case ILL_PRVOPC: /* privileged opcode */
+#ifdef ILL_PRVREG
+	case ILL_PRVREG: /* privileged register */
+#endif
+            rec.ExceptionCode = EXCEPTION_PRIV_INSTRUCTION;
+            break;
+#ifdef ILL_BADSTK
+	case ILL_BADSTK: /* internal stack error */
+            rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
+            break;
+#endif
+	default:
+            FIXME("Unhandled SIGILL/%x\n", siginfo->si_code);
+            break;
+	}
+    	break;
+    }
+    status = raise_exception( &rec, &context, TRUE );
+    if (status) raise_status( status, &rec );
+done:
+    restore_context( &context, sigcontext );
+}
+
+/**********************************************************************
+ *		trap_handler
+ *
+ * Handler for SIGTRAP.
+ */
+static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    EXCEPTION_RECORD rec;
+    CONTEXT context;
+    NTSTATUS status;
+
+    save_context( &context, sigcontext );
+
+    rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    rec.ExceptionRecord  = NULL;
+    rec.ExceptionAddress = (LPVOID)context.Iar;
+    rec.NumberParameters = 0;
+
+    /* FIXME: check if we might need to modify PC */
+    switch (siginfo->si_code & 0xffff)
+    {
+#ifdef TRAP_BRKPT
+    case TRAP_BRKPT:
+        rec.ExceptionCode = EXCEPTION_BREAKPOINT;
+    	break;
+#endif
+#ifdef TRAP_TRACE
+    case TRAP_TRACE:
+        rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
+    	break;
+#endif
+    default:
+        FIXME("Unhandled SIGTRAP/%x\n", siginfo->si_code);
+        break;
+    }
+    status = raise_exception( &rec, &context, TRUE );
+    if (status) raise_status( status, &rec );
+    restore_context( &context, sigcontext );
+}
+
+/**********************************************************************
+ *		fpe_handler
+ *
+ * Handler for SIGFPE.
+ */
+static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    EXCEPTION_RECORD rec;
+    CONTEXT context;
+    NTSTATUS status;
+
+    save_fpu( &context, sigcontext );
+    save_context( &context, sigcontext );
+
+    switch (siginfo->si_code & 0xffff )
+    {
+#ifdef FPE_FLTSUB
+    case FPE_FLTSUB:
+        rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
+        break;
+#endif
+#ifdef FPE_INTDIV
+    case FPE_INTDIV:
+        rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
+        break;
+#endif
+#ifdef FPE_INTOVF
+    case FPE_INTOVF:
+        rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTDIV
+    case FPE_FLTDIV:
+        rec.ExceptionCode = EXCEPTION_FLT_DIVIDE_BY_ZERO;
+        break;
+#endif
+#ifdef FPE_FLTOVF
+    case FPE_FLTOVF:
+        rec.ExceptionCode = EXCEPTION_FLT_OVERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTUND
+    case FPE_FLTUND:
+        rec.ExceptionCode = EXCEPTION_FLT_UNDERFLOW;
+        break;
+#endif
+#ifdef FPE_FLTRES
+    case FPE_FLTRES:
+        rec.ExceptionCode = EXCEPTION_FLT_INEXACT_RESULT;
+        break;
+#endif
+#ifdef FPE_FLTINV
+    case FPE_FLTINV:
+#endif
+    default:
+        rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
+        break;
+    }
+    rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    rec.ExceptionRecord  = NULL;
+    rec.ExceptionAddress = (LPVOID)context.Iar;
+    rec.NumberParameters = 0;
+    status = raise_exception( &rec, &context, TRUE );
+    if (status) raise_status( status, &rec );
+
+    restore_context( &context, sigcontext );
+    restore_fpu( &context, sigcontext );
+}
+
+/**********************************************************************
+ *		int_handler
+ *
+ * Handler for SIGINT.
+ */
+static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    if (!dispatch_signal(SIGINT))
+    {
+        EXCEPTION_RECORD rec;
+        CONTEXT context;
+        NTSTATUS status;
+
+        save_context( &context, sigcontext );
+        rec.ExceptionCode    = CONTROL_C_EXIT;
+        rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+        rec.ExceptionRecord  = NULL;
+        rec.ExceptionAddress = (LPVOID)context.Iar;
+        rec.NumberParameters = 0;
+        status = raise_exception( &rec, &context, TRUE );
+        if (status) raise_status( status, &rec );
+        restore_context( &context, sigcontext );
+    }
+}
+
+
+/**********************************************************************
+ *		abrt_handler
+ *
+ * Handler for SIGABRT.
+ */
+static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    EXCEPTION_RECORD rec;
+    CONTEXT context;
+    NTSTATUS status;
+
+    save_context( &context, sigcontext );
+    rec.ExceptionCode    = EXCEPTION_WINE_ASSERTION;
+    rec.ExceptionFlags   = EH_NONCONTINUABLE;
+    rec.ExceptionRecord  = NULL;
+    rec.ExceptionAddress = (LPVOID)context.Iar;
+    rec.NumberParameters = 0;
+    status = raise_exception( &rec, &context, TRUE );
+    if (status) raise_status( status, &rec );
+    restore_context( &context, sigcontext );
+}
+
+
+/**********************************************************************
+ *		quit_handler
+ *
+ * Handler for SIGQUIT.
+ */
+static void quit_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    abort_thread(0);
+}
+
+
+/**********************************************************************
+ *		usr1_handler
+ *
+ * Handler for SIGUSR1, used to signal a thread that it got suspended.
+ */
+static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    CONTEXT context;
+
+    save_context( &context, sigcontext );
+    wait_suspend( &context );
+    restore_context( &context, sigcontext );
+}
+
+
+/***********************************************************************
+ *           __wine_set_signal_handler   (NTDLL.@)
+ */
+int CDECL __wine_set_signal_handler(unsigned int sig, wine_signal_handler wsh)
+{
+    if (sig >= ARRAY_SIZE(handlers)) return -1;
+    if (handlers[sig] != NULL) return -2;
+    handlers[sig] = wsh;
+    return 0;
+}
+
+
+/**********************************************************************
+ *             signal_init_threading
+ */
+void signal_init_threading(void)
+{
+    pthread_key_create( &teb_key, NULL );
+}
+
+
+/**********************************************************************
+ *		signal_alloc_thread
+ */
+NTSTATUS signal_alloc_thread( TEB *teb )
+{
+    return STATUS_SUCCESS;
+}
+
+
+/**********************************************************************
+ *		signal_free_thread
+ */
+void signal_free_thread( TEB *teb )
+{
+}
+
+
+/**********************************************************************
+ *		signal_init_thread
+ */
+void signal_init_thread( TEB *teb )
+{
+    pthread_setspecific( teb_key, teb );
+}
+
+
+/**********************************************************************
+ *		signal_init_process
+ */
+void signal_init_process(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_RESTART | SA_SIGINFO;
+
+    sig_act.sa_sigaction = int_handler;
+    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = fpe_handler;
+    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = abrt_handler;
+    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = quit_handler;
+    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
+
+    sig_act.sa_sigaction = segv_handler;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
+    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
+#ifdef SIGBUS
+    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+#endif
+
+#ifdef SIGTRAP
+    sig_act.sa_sigaction = trap_handler;
+    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
+#endif
+    return;
+
+ error:
+    perror("sigaction");
+    exit(1);
+}
+
+
+/***********************************************************************
+ *            RtlUnwind  (NTDLL.@)
+ */
+void WINAPI RtlUnwind( PVOID pEndFrame, PVOID targetIp, PEXCEPTION_RECORD pRecord, PVOID retval )
+{
+    FIXME( "Not implemented on PowerPC\n" );
+}
+
+/*******************************************************************
+ *		NtRaiseException (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRaiseException( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+{
+    NTSTATUS status = raise_exception( rec, context, first_chance );
+    if (status == STATUS_SUCCESS) NtSetContextThread( GetCurrentThread(), context );
+    return status;
+}
+
+/***********************************************************************
+ *		RtlRaiseException (NTDLL.@)
+ */
+void WINAPI RtlRaiseException( EXCEPTION_RECORD *rec )
+{
+    CONTEXT context;
+    NTSTATUS status;
+
+    RtlCaptureContext( &context );
+    rec->ExceptionAddress = (void *)context.Iar;
+    status = raise_exception( rec, &context, TRUE );
+    if (status) raise_status( status, rec );
+}
+
+/*************************************************************************
+ *		RtlCaptureStackBackTrace (NTDLL.@)
+ */
+USHORT WINAPI RtlCaptureStackBackTrace( ULONG skip, ULONG count, PVOID *buffer, ULONG *hash )
+{
+    FIXME( "(%d, %d, %p, %p) stub!\n", skip, count, buffer, hash );
+    return 0;
+}
+
+/***********************************************************************
+ *           call_thread_entry_point
+ */
+static void WINAPI call_thread_entry_point( LPTHREAD_START_ROUTINE entry, void *arg )
+{
+    __TRY
+    {
+        TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", entry, arg );
+        RtlExitUserThread( entry( arg ));
+    }
+    __EXCEPT(call_unhandled_exception_filter)
+    {
+        NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+    }
+    __ENDTRY
+    abort();  /* should not be reached */
+}
+
+typedef void (WINAPI *thread_start_func)(LPTHREAD_START_ROUTINE,void *);
+
+struct startup_info
+{
+    thread_start_func      start;
+    LPTHREAD_START_ROUTINE entry;
+    void                  *arg;
+    BOOL                   suspend;
+};
+
+/* FIXME: should set the full context instead */
+extern void DECLSPEC_NORETURN switch_to_stack( void (*func)(void *), void *arg, void *stack );
+__ASM_GLOBAL_FUNC( switch_to_stack,
+                   "subi 5, 5, 16\n\t"  /* reserve space on new stack */
+                   "mtctr 3\n\t"        /* func -> ctr */
+                   "mr 3,4\n\t"         /* args -> function param 1 (r3) */
+                   "mr 1,5\n\t"         /* stack */
+                   "li 0, 0\n\t"        /* zero */
+                   "stw 0, 0(1)\n\t"    /* bottom of stack */
+                   "stwu 1, -16(1)\n\t" /* create a frame for this function */
+                   "bctrl" )            /* call ctr */
+
+/***********************************************************************
+ *           thread_startup
+ */
+static void thread_startup( void *param )
+{
+    CONTEXT context = { 0 };
+    struct startup_info *info = param;
+
+    /* build the initial context */
+    context.ContextFlags = CONTEXT_FULL;
+    context.Gpr1 = (DWORD)NtCurrentTeb()->Tib.StackBase;
+    context.Gpr3 = (DWORD)info->entry;
+    context.Gpr4 = (DWORD)info->arg;
+    context.Iar  = (DWORD)info->start;
+
+    if (info->suspend) wait_suspend( &context );
+    LdrInitializeThunk( &context, (void **)&context.Gpr3, 0, 0 );
+
+    ((thread_start_func)context.Iar)( (LPTHREAD_START_ROUTINE)context.Gpr3, (void *)context.Gpr4 );
+}
+
+/***********************************************************************
+ *           signal_start_thread
+ *
+ * Thread startup sequence:
+ * signal_start_thread()
+ *   -> thread_startup()
+ *     -> call_thread_entry_point()
+ */
+void signal_start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend )
+{
+    struct startup_info info = { call_thread_entry_point, entry, arg, suspend };
+    switch_to_stack( thread_startup, &info, NtCurrentTeb()->Tib.StackBase );
+}
+
+/**********************************************************************
+ *		signal_start_process
+ *
+ * Process startup sequence:
+ * signal_start_process()
+ *   -> thread_startup()
+ *     -> kernel32_start_process()
+ */
+void signal_start_process( LPTHREAD_START_ROUTINE entry, BOOL suspend )
+{
+    struct startup_info info = { kernel32_start_process, entry, NtCurrentTeb()->Peb, suspend };
+    switch_to_stack( thread_startup, &info, NtCurrentTeb()->Tib.StackBase );
+}
+
+/***********************************************************************
+ *           signal_exit_thread
+ */
+void signal_exit_thread( int status )
+{
+    exit_thread( status );
+}
+
+/***********************************************************************
+ *           signal_exit_process
+ */
+void signal_exit_process( int status )
+{
+    exit( status );
+}
+
+/**********************************************************************
+ *           get_thread_ldt_entry
+ */
+NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *           NtSetLdtEntries   (NTDLL.@)
+ *           ZwSetLdtEntries   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/**********************************************************************
+ *              DbgBreakPoint   (NTDLL.@)
+ */
+void WINAPI DbgBreakPoint(void)
+{
+     kill(getpid(), SIGTRAP);
+}
+
+/**********************************************************************
+ *              DbgUserBreakPoint   (NTDLL.@)
+ */
+void WINAPI DbgUserBreakPoint(void)
+{
+     kill(getpid(), SIGTRAP);
+}
+
+/**********************************************************************
+ *           NtCurrentTeb   (NTDLL.@)
+ */
+TEB * WINAPI NtCurrentTeb(void)
+{
+    return pthread_getspecific( teb_key );
+}
+
+#endif  /* __powerpc__ */
diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index faf24b93b5..d9eeb6552a 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -20,8 +20,44 @@
 
 #ifdef __x86_64__
 
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_MACHINE_SYSARCH_H
+# include <machine/sysarch.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYSCALL_H
+# include <syscall.h>
+#else
+# ifdef HAVE_SYS_SYSCALL_H
+#  include <sys/syscall.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SIGNAL_H
+# include <sys/signal.h>
+#endif
+#ifdef HAVE_SYS_UCONTEXT_H
+# include <sys/ucontext.h>
+#endif
+#ifdef HAVE_LIBUNWIND
+# define UNW_LOCAL_ONLY
+# include <libunwind.h>
+#endif
+#ifdef __APPLE__
+# include <mach/mach.h>
+#endif
 
 #define NONAMELESSUNION
 #define NONAMELESSSTRUCT
@@ -29,12 +65,18 @@
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winternl.h"
+#include "wine/library.h"
 #include "wine/exception.h"
 #include "wine/list.h"
 #include "ntdll_misc.h"
 #include "wine/debug.h"
 
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
 WINE_DEFAULT_DEBUG_CHANNEL(seh);
+WINE_DECLARE_DEBUG_CHANNEL(relay);
 
 typedef struct _SCOPE_TABLE
 {
@@ -76,6 +118,243 @@ struct MSVCRT_JUMP_BUFFER
     M128A   Xmm15;
 };
 
+/***********************************************************************
+ * signal context platform-specific definitions
+ */
+#ifdef linux
+
+#include <asm/prctl.h>
+static inline int arch_prctl( int func, void *ptr ) { return syscall( __NR_arch_prctl, func, ptr ); }
+
+#define RAX_sig(context)     ((context)->uc_mcontext.gregs[REG_RAX])
+#define RBX_sig(context)     ((context)->uc_mcontext.gregs[REG_RBX])
+#define RCX_sig(context)     ((context)->uc_mcontext.gregs[REG_RCX])
+#define RDX_sig(context)     ((context)->uc_mcontext.gregs[REG_RDX])
+#define RSI_sig(context)     ((context)->uc_mcontext.gregs[REG_RSI])
+#define RDI_sig(context)     ((context)->uc_mcontext.gregs[REG_RDI])
+#define RBP_sig(context)     ((context)->uc_mcontext.gregs[REG_RBP])
+#define R8_sig(context)      ((context)->uc_mcontext.gregs[REG_R8])
+#define R9_sig(context)      ((context)->uc_mcontext.gregs[REG_R9])
+#define R10_sig(context)     ((context)->uc_mcontext.gregs[REG_R10])
+#define R11_sig(context)     ((context)->uc_mcontext.gregs[REG_R11])
+#define R12_sig(context)     ((context)->uc_mcontext.gregs[REG_R12])
+#define R13_sig(context)     ((context)->uc_mcontext.gregs[REG_R13])
+#define R14_sig(context)     ((context)->uc_mcontext.gregs[REG_R14])
+#define R15_sig(context)     ((context)->uc_mcontext.gregs[REG_R15])
+
+#define CS_sig(context)      (*((WORD *)&(context)->uc_mcontext.gregs[REG_CSGSFS] + 0))
+#define GS_sig(context)      (*((WORD *)&(context)->uc_mcontext.gregs[REG_CSGSFS] + 1))
+#define FS_sig(context)      (*((WORD *)&(context)->uc_mcontext.gregs[REG_CSGSFS] + 2))
+
+#define RSP_sig(context)     ((context)->uc_mcontext.gregs[REG_RSP])
+#define RIP_sig(context)     ((context)->uc_mcontext.gregs[REG_RIP])
+#define EFL_sig(context)     ((context)->uc_mcontext.gregs[REG_EFL])
+#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[REG_TRAPNO])
+#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[REG_ERR])
+
+#define FPU_sig(context)     ((XMM_SAVE_AREA32 *)((context)->uc_mcontext.fpregs))
+
+#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__)
+
+#define RAX_sig(context)     ((context)->uc_mcontext.mc_rax)
+#define RBX_sig(context)     ((context)->uc_mcontext.mc_rbx)
+#define RCX_sig(context)     ((context)->uc_mcontext.mc_rcx)
+#define RDX_sig(context)     ((context)->uc_mcontext.mc_rdx)
+#define RSI_sig(context)     ((context)->uc_mcontext.mc_rsi)
+#define RDI_sig(context)     ((context)->uc_mcontext.mc_rdi)
+#define RBP_sig(context)     ((context)->uc_mcontext.mc_rbp)
+#define R8_sig(context)      ((context)->uc_mcontext.mc_r8)
+#define R9_sig(context)      ((context)->uc_mcontext.mc_r9)
+#define R10_sig(context)     ((context)->uc_mcontext.mc_r10)
+#define R11_sig(context)     ((context)->uc_mcontext.mc_r11)
+#define R12_sig(context)     ((context)->uc_mcontext.mc_r12)
+#define R13_sig(context)     ((context)->uc_mcontext.mc_r13)
+#define R14_sig(context)     ((context)->uc_mcontext.mc_r14)
+#define R15_sig(context)     ((context)->uc_mcontext.mc_r15)
+
+#define CS_sig(context)      ((context)->uc_mcontext.mc_cs)
+#define DS_sig(context)      ((context)->uc_mcontext.mc_ds)
+#define ES_sig(context)      ((context)->uc_mcontext.mc_es)
+#define FS_sig(context)      ((context)->uc_mcontext.mc_fs)
+#define GS_sig(context)      ((context)->uc_mcontext.mc_gs)
+#define SS_sig(context)      ((context)->uc_mcontext.mc_ss)
+
+#define EFL_sig(context)     ((context)->uc_mcontext.mc_rflags)
+
+#define RIP_sig(context)     ((context)->uc_mcontext.mc_rip)
+#define RSP_sig(context)     ((context)->uc_mcontext.mc_rsp)
+#define TRAP_sig(context)    ((context)->uc_mcontext.mc_trapno)
+#define ERROR_sig(context)   ((context)->uc_mcontext.mc_err)
+
+#define FPU_sig(context)   ((XMM_SAVE_AREA32 *)((context)->uc_mcontext.mc_fpstate))
+
+#elif defined(__NetBSD__)
+
+#define RAX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RAX])
+#define RBX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RBX])
+#define RCX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RCX])
+#define RDX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RDX])
+#define RSI_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RSI])
+#define RDI_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RDI])
+#define RBP_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RBP])
+#define R8_sig(context)     ((context)->uc_mcontext.__gregs[_REG_R8])
+#define R9_sig(context)     ((context)->uc_mcontext.__gregs[_REG_R9])
+#define R10_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R10])
+#define R11_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R11])
+#define R12_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R12])
+#define R13_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R13])
+#define R14_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R14])
+#define R15_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R15])
+
+#define CS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_CS])
+#define DS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_DS])
+#define ES_sig(context)     ((context)->uc_mcontext.__gregs[_REG_ES])
+#define FS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_FS])
+#define GS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_GS])
+#define SS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_SS])
+
+#define EFL_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RFL])
+
+#define RIP_sig(context)    (*((unsigned long*)&(context)->uc_mcontext.__gregs[_REG_RIP]))
+#define RSP_sig(context)    (*((unsigned long*)&(context)->uc_mcontext.__gregs[_REG_URSP]))
+
+#define TRAP_sig(context)   ((context)->uc_mcontext.__gregs[_REG_TRAPNO])
+#define ERROR_sig(context)  ((context)->uc_mcontext.__gregs[_REG_ERR])
+
+#define FPU_sig(context)   ((XMM_SAVE_AREA32 *)((context)->uc_mcontext.__fpregs))
+#elif defined (__APPLE__)
+#define RAX_sig(context)     ((context)->uc_mcontext->__ss.__rax)
+#define RBX_sig(context)     ((context)->uc_mcontext->__ss.__rbx)
+#define RCX_sig(context)     ((context)->uc_mcontext->__ss.__rcx)
+#define RDX_sig(context)     ((context)->uc_mcontext->__ss.__rdx)
+#define RSI_sig(context)     ((context)->uc_mcontext->__ss.__rsi)
+#define RDI_sig(context)     ((context)->uc_mcontext->__ss.__rdi)
+#define RBP_sig(context)     ((context)->uc_mcontext->__ss.__rbp)
+#define R8_sig(context)      ((context)->uc_mcontext->__ss.__r8)
+#define R9_sig(context)      ((context)->uc_mcontext->__ss.__r9)
+#define R10_sig(context)     ((context)->uc_mcontext->__ss.__r10)
+#define R11_sig(context)     ((context)->uc_mcontext->__ss.__r11)
+#define R12_sig(context)     ((context)->uc_mcontext->__ss.__r12)
+#define R13_sig(context)     ((context)->uc_mcontext->__ss.__r13)
+#define R14_sig(context)     ((context)->uc_mcontext->__ss.__r14)
+#define R15_sig(context)     ((context)->uc_mcontext->__ss.__r15)
+
+#define CS_sig(context)      ((context)->uc_mcontext->__ss.__cs)
+#define FS_sig(context)      ((context)->uc_mcontext->__ss.__fs)
+#define GS_sig(context)      ((context)->uc_mcontext->__ss.__gs)
+
+#define EFL_sig(context)     ((context)->uc_mcontext->__ss.__rflags)
+
+#define RIP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__rip))
+#define RSP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__rsp))
+
+#define TRAP_sig(context)    ((context)->uc_mcontext->__es.__trapno)
+#define ERROR_sig(context)   ((context)->uc_mcontext->__es.__err)
+
+#define FPU_sig(context)     ((XMM_SAVE_AREA32 *)&(context)->uc_mcontext->__fs.__fpu_fcw)
+
+#else
+#error You must define the signal context functions for your platform
+#endif
+
+enum i386_trap_code
+{
+    TRAP_x86_UNKNOWN    = -1,  /* Unknown fault (TRAP_sig not defined) */
+    TRAP_x86_DIVIDE     = 0,   /* Division by zero exception */
+    TRAP_x86_TRCTRAP    = 1,   /* Single-step exception */
+    TRAP_x86_NMI        = 2,   /* NMI interrupt */
+    TRAP_x86_BPTFLT     = 3,   /* Breakpoint exception */
+    TRAP_x86_OFLOW      = 4,   /* Overflow exception */
+    TRAP_x86_BOUND      = 5,   /* Bound range exception */
+    TRAP_x86_PRIVINFLT  = 6,   /* Invalid opcode exception */
+    TRAP_x86_DNA        = 7,   /* Device not available exception */
+    TRAP_x86_DOUBLEFLT  = 8,   /* Double fault exception */
+    TRAP_x86_FPOPFLT    = 9,   /* Coprocessor segment overrun */
+    TRAP_x86_TSSFLT     = 10,  /* Invalid TSS exception */
+    TRAP_x86_SEGNPFLT   = 11,  /* Segment not present exception */
+    TRAP_x86_STKFLT     = 12,  /* Stack fault */
+    TRAP_x86_PROTFLT    = 13,  /* General protection fault */
+    TRAP_x86_PAGEFLT    = 14,  /* Page fault */
+    TRAP_x86_ARITHTRAP  = 16,  /* Floating point exception */
+    TRAP_x86_ALIGNFLT   = 17,  /* Alignment check exception */
+    TRAP_x86_MCHK       = 18,  /* Machine check exception */
+    TRAP_x86_CACHEFLT   = 19   /* Cache flush exception */
+};
+
+static const size_t teb_size = 0x2000;  /* we reserve two pages for the TEB */
+
+typedef void (*raise_func)( EXCEPTION_RECORD *rec, CONTEXT *context );
+
+/* stack layout when calling an exception raise function */
+struct stack_layout
+{
+    CONTEXT           context;
+    EXCEPTION_RECORD  rec;
+    ULONG64           rsi;
+    ULONG64           rdi;
+    ULONG64           rbp;
+    ULONG64           rip;
+    ULONG64           red_zone[16];
+};
+
+typedef int (*wine_signal_handler)(unsigned int sig);
+
+static wine_signal_handler handlers[256];
+
+struct amd64_thread_data
+{
+    DWORD_PTR dr0;           /* debug registers */
+    DWORD_PTR dr1;
+    DWORD_PTR dr2;
+    DWORD_PTR dr3;
+    DWORD_PTR dr6;
+    DWORD_PTR dr7;
+    void     *exit_frame;    /* exit frame pointer */
+};
+
+C_ASSERT( sizeof(struct amd64_thread_data) <= sizeof(((TEB *)0)->SystemReserved2) );
+C_ASSERT( offsetof( TEB, SystemReserved2 ) + offsetof( struct amd64_thread_data, exit_frame ) == 0x330 );
+
+static inline struct amd64_thread_data *amd64_thread_data(void)
+{
+    return (struct amd64_thread_data *)NtCurrentTeb()->SystemReserved2;
+}
+
+static inline void set_sigcontext( const CONTEXT *context, ucontext_t *sigcontext )
+{
+    RAX_sig(sigcontext) = context->Rax;
+    RCX_sig(sigcontext) = context->Rcx;
+    RDX_sig(sigcontext) = context->Rdx;
+    RBX_sig(sigcontext) = context->Rbx;
+    RSP_sig(sigcontext) = context->Rsp;
+    RBP_sig(sigcontext) = context->Rbp;
+    RSI_sig(sigcontext) = context->Rsi;
+    RDI_sig(sigcontext) = context->Rdi;
+    R8_sig(sigcontext)  = context->R8;
+    R9_sig(sigcontext)  = context->R9;
+    R10_sig(sigcontext) = context->R10;
+    R11_sig(sigcontext) = context->R11;
+    R12_sig(sigcontext) = context->R12;
+    R13_sig(sigcontext) = context->R13;
+    R14_sig(sigcontext) = context->R14;
+    R15_sig(sigcontext) = context->R15;
+    RIP_sig(sigcontext) = context->Rip;
+    CS_sig(sigcontext)  = context->SegCs;
+    FS_sig(sigcontext)  = context->SegFs;
+    GS_sig(sigcontext)  = context->SegGs;
+    EFL_sig(sigcontext) = context->EFlags;
+#ifdef DS_sig
+    DS_sig(sigcontext) = context->SegDs;
+#endif
+#ifdef ES_sig
+    ES_sig(sigcontext) = context->SegEs;
+#endif
+#ifdef SS_sig
+    SS_sig(sigcontext) = context->SegSs;
+#endif
+}
+
+
 /***********************************************************************
  * Definitions for Win32 unwind tables
  */
@@ -250,73 +529,1243 @@ static void dump_scope_table( ULONG64 base, const SCOPE_TABLE *table )
 
 
 /***********************************************************************
- *           virtual_unwind
+ * Definitions for Dwarf unwind tables
  */
-static NTSTATUS virtual_unwind( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEXT *context )
+
+enum dwarf_call_frame_info
 {
-    LDR_DATA_TABLE_ENTRY *module;
-    NTSTATUS status;
+    DW_CFA_advance_loc = 0x40,
+    DW_CFA_offset = 0x80,
+    DW_CFA_restore = 0xc0,
+    DW_CFA_nop = 0x00,
+    DW_CFA_set_loc = 0x01,
+    DW_CFA_advance_loc1 = 0x02,
+    DW_CFA_advance_loc2 = 0x03,
+    DW_CFA_advance_loc4 = 0x04,
+    DW_CFA_offset_extended = 0x05,
+    DW_CFA_restore_extended = 0x06,
+    DW_CFA_undefined = 0x07,
+    DW_CFA_same_value = 0x08,
+    DW_CFA_register = 0x09,
+    DW_CFA_remember_state = 0x0a,
+    DW_CFA_restore_state = 0x0b,
+    DW_CFA_def_cfa = 0x0c,
+    DW_CFA_def_cfa_register = 0x0d,
+    DW_CFA_def_cfa_offset = 0x0e,
+    DW_CFA_def_cfa_expression = 0x0f,
+    DW_CFA_expression = 0x10,
+    DW_CFA_offset_extended_sf = 0x11,
+    DW_CFA_def_cfa_sf = 0x12,
+    DW_CFA_def_cfa_offset_sf = 0x13,
+    DW_CFA_val_offset = 0x14,
+    DW_CFA_val_offset_sf = 0x15,
+    DW_CFA_val_expression = 0x16,
+};
 
-    dispatch->ImageBase = 0;
-    dispatch->ScopeIndex = 0;
-    dispatch->ControlPc = context->Rip;
+enum dwarf_operation
+{
+    DW_OP_addr                 = 0x03,
+    DW_OP_deref                = 0x06,
+    DW_OP_const1u              = 0x08,
+    DW_OP_const1s              = 0x09,
+    DW_OP_const2u              = 0x0a,
+    DW_OP_const2s              = 0x0b,
+    DW_OP_const4u              = 0x0c,
+    DW_OP_const4s              = 0x0d,
+    DW_OP_const8u              = 0x0e,
+    DW_OP_const8s              = 0x0f,
+    DW_OP_constu               = 0x10,
+    DW_OP_consts               = 0x11,
+    DW_OP_dup                  = 0x12,
+    DW_OP_drop                 = 0x13,
+    DW_OP_over                 = 0x14,
+    DW_OP_pick                 = 0x15,
+    DW_OP_swap                 = 0x16,
+    DW_OP_rot                  = 0x17,
+    DW_OP_xderef               = 0x18,
+    DW_OP_abs                  = 0x19,
+    DW_OP_and                  = 0x1a,
+    DW_OP_div                  = 0x1b,
+    DW_OP_minus                = 0x1c,
+    DW_OP_mod                  = 0x1d,
+    DW_OP_mul                  = 0x1e,
+    DW_OP_neg                  = 0x1f,
+    DW_OP_not                  = 0x20,
+    DW_OP_or                   = 0x21,
+    DW_OP_plus                 = 0x22,
+    DW_OP_plus_uconst          = 0x23,
+    DW_OP_shl                  = 0x24,
+    DW_OP_shr                  = 0x25,
+    DW_OP_shra                 = 0x26,
+    DW_OP_xor                  = 0x27,
+    DW_OP_bra                  = 0x28,
+    DW_OP_eq                   = 0x29,
+    DW_OP_ge                   = 0x2a,
+    DW_OP_gt                   = 0x2b,
+    DW_OP_le                   = 0x2c,
+    DW_OP_lt                   = 0x2d,
+    DW_OP_ne                   = 0x2e,
+    DW_OP_skip                 = 0x2f,
+    DW_OP_lit0                 = 0x30,
+    DW_OP_lit1                 = 0x31,
+    DW_OP_lit2                 = 0x32,
+    DW_OP_lit3                 = 0x33,
+    DW_OP_lit4                 = 0x34,
+    DW_OP_lit5                 = 0x35,
+    DW_OP_lit6                 = 0x36,
+    DW_OP_lit7                 = 0x37,
+    DW_OP_lit8                 = 0x38,
+    DW_OP_lit9                 = 0x39,
+    DW_OP_lit10                = 0x3a,
+    DW_OP_lit11                = 0x3b,
+    DW_OP_lit12                = 0x3c,
+    DW_OP_lit13                = 0x3d,
+    DW_OP_lit14                = 0x3e,
+    DW_OP_lit15                = 0x3f,
+    DW_OP_lit16                = 0x40,
+    DW_OP_lit17                = 0x41,
+    DW_OP_lit18                = 0x42,
+    DW_OP_lit19                = 0x43,
+    DW_OP_lit20                = 0x44,
+    DW_OP_lit21                = 0x45,
+    DW_OP_lit22                = 0x46,
+    DW_OP_lit23                = 0x47,
+    DW_OP_lit24                = 0x48,
+    DW_OP_lit25                = 0x49,
+    DW_OP_lit26                = 0x4a,
+    DW_OP_lit27                = 0x4b,
+    DW_OP_lit28                = 0x4c,
+    DW_OP_lit29                = 0x4d,
+    DW_OP_lit30                = 0x4e,
+    DW_OP_lit31                = 0x4f,
+    DW_OP_reg0                 = 0x50,
+    DW_OP_reg1                 = 0x51,
+    DW_OP_reg2                 = 0x52,
+    DW_OP_reg3                 = 0x53,
+    DW_OP_reg4                 = 0x54,
+    DW_OP_reg5                 = 0x55,
+    DW_OP_reg6                 = 0x56,
+    DW_OP_reg7                 = 0x57,
+    DW_OP_reg8                 = 0x58,
+    DW_OP_reg9                 = 0x59,
+    DW_OP_reg10                = 0x5a,
+    DW_OP_reg11                = 0x5b,
+    DW_OP_reg12                = 0x5c,
+    DW_OP_reg13                = 0x5d,
+    DW_OP_reg14                = 0x5e,
+    DW_OP_reg15                = 0x5f,
+    DW_OP_reg16                = 0x60,
+    DW_OP_reg17                = 0x61,
+    DW_OP_reg18                = 0x62,
+    DW_OP_reg19                = 0x63,
+    DW_OP_reg20                = 0x64,
+    DW_OP_reg21                = 0x65,
+    DW_OP_reg22                = 0x66,
+    DW_OP_reg23                = 0x67,
+    DW_OP_reg24                = 0x68,
+    DW_OP_reg25                = 0x69,
+    DW_OP_reg26                = 0x6a,
+    DW_OP_reg27                = 0x6b,
+    DW_OP_reg28                = 0x6c,
+    DW_OP_reg29                = 0x6d,
+    DW_OP_reg30                = 0x6e,
+    DW_OP_reg31                = 0x6f,
+    DW_OP_breg0                = 0x70,
+    DW_OP_breg1                = 0x71,
+    DW_OP_breg2                = 0x72,
+    DW_OP_breg3                = 0x73,
+    DW_OP_breg4                = 0x74,
+    DW_OP_breg5                = 0x75,
+    DW_OP_breg6                = 0x76,
+    DW_OP_breg7                = 0x77,
+    DW_OP_breg8                = 0x78,
+    DW_OP_breg9                = 0x79,
+    DW_OP_breg10               = 0x7a,
+    DW_OP_breg11               = 0x7b,
+    DW_OP_breg12               = 0x7c,
+    DW_OP_breg13               = 0x7d,
+    DW_OP_breg14               = 0x7e,
+    DW_OP_breg15               = 0x7f,
+    DW_OP_breg16               = 0x80,
+    DW_OP_breg17               = 0x81,
+    DW_OP_breg18               = 0x82,
+    DW_OP_breg19               = 0x83,
+    DW_OP_breg20               = 0x84,
+    DW_OP_breg21               = 0x85,
+    DW_OP_breg22               = 0x86,
+    DW_OP_breg23               = 0x87,
+    DW_OP_breg24               = 0x88,
+    DW_OP_breg25               = 0x89,
+    DW_OP_breg26               = 0x8a,
+    DW_OP_breg27               = 0x8b,
+    DW_OP_breg28               = 0x8c,
+    DW_OP_breg29               = 0x8d,
+    DW_OP_breg30               = 0x8e,
+    DW_OP_breg31               = 0x8f,
+    DW_OP_regx                 = 0x90,
+    DW_OP_fbreg                = 0x91,
+    DW_OP_bregx                = 0x92,
+    DW_OP_piece                = 0x93,
+    DW_OP_deref_size           = 0x94,
+    DW_OP_xderef_size          = 0x95,
+    DW_OP_nop                  = 0x96,
+    DW_OP_push_object_address  = 0x97,
+    DW_OP_call2                = 0x98,
+    DW_OP_call4                = 0x99,
+    DW_OP_call_ref             = 0x9a,
+    DW_OP_form_tls_address     = 0x9b,
+    DW_OP_call_frame_cfa       = 0x9c,
+    DW_OP_bit_piece            = 0x9d,
+    DW_OP_lo_user              = 0xe0,
+    DW_OP_hi_user              = 0xff,
+    DW_OP_GNU_push_tls_address = 0xe0,
+    DW_OP_GNU_uninit           = 0xf0,
+    DW_OP_GNU_encoded_addr     = 0xf1,
+};
 
-    /* first look for PE exception information */
+#define DW_EH_PE_native   0x00
+#define DW_EH_PE_leb128   0x01
+#define DW_EH_PE_data2    0x02
+#define DW_EH_PE_data4    0x03
+#define DW_EH_PE_data8    0x04
+#define DW_EH_PE_signed   0x08
+#define DW_EH_PE_abs      0x00
+#define DW_EH_PE_pcrel    0x10
+#define DW_EH_PE_textrel  0x20
+#define DW_EH_PE_datarel  0x30
+#define DW_EH_PE_funcrel  0x40
+#define DW_EH_PE_aligned  0x50
+#define DW_EH_PE_indirect 0x80
+#define DW_EH_PE_omit     0xff
+
+struct dwarf_eh_bases
+{
+    void *tbase;
+    void *dbase;
+    void *func;
+};
 
-    if ((dispatch->FunctionEntry = lookup_function_info( context->Rip, &dispatch->ImageBase, &module )))
+struct dwarf_cie
+{
+    unsigned int  length;
+    int           id;
+    unsigned char version;
+    unsigned char augmentation[1];
+};
+
+struct dwarf_fde
+{
+    unsigned int length;
+    unsigned int cie_offset;
+};
+
+extern const struct dwarf_fde *_Unwind_Find_FDE (void *, struct dwarf_eh_bases *);
+
+static unsigned char dwarf_get_u1( const unsigned char **p )
+{
+    return *(*p)++;
+}
+
+static unsigned short dwarf_get_u2( const unsigned char **p )
+{
+    unsigned int ret = (*p)[0] | ((*p)[1] << 8);
+    (*p) += 2;
+    return ret;
+}
+
+static unsigned int dwarf_get_u4( const unsigned char **p )
+{
+    unsigned int ret = (*p)[0] | ((*p)[1] << 8) | ((*p)[2] << 16) | ((*p)[3] << 24);
+    (*p) += 4;
+    return ret;
+}
+
+static ULONG64 dwarf_get_u8( const unsigned char **p )
+{
+    ULONG64 low  = dwarf_get_u4( p );
+    ULONG64 high = dwarf_get_u4( p );
+    return low | (high << 32);
+}
+
+static ULONG_PTR dwarf_get_uleb128( const unsigned char **p )
+{
+    ULONG_PTR ret = 0;
+    unsigned int shift = 0;
+    unsigned char byte;
+
+    do
     {
-        dispatch->LanguageHandler = RtlVirtualUnwind( type, dispatch->ImageBase, context->Rip,
-                                                      dispatch->FunctionEntry, context,
-                                                      &dispatch->HandlerData, &dispatch->EstablisherFrame,
-                                                      NULL );
-        return STATUS_SUCCESS;
+        byte = **p;
+        ret |= (ULONG_PTR)(byte & 0x7f) << shift;
+        shift += 7;
+        (*p)++;
+    } while (byte & 0x80);
+    return ret;
+}
+
+static LONG_PTR dwarf_get_sleb128( const unsigned char **p )
+{
+    ULONG_PTR ret = 0;
+    unsigned int shift = 0;
+    unsigned char byte;
+
+    do
+    {
+        byte = **p;
+        ret |= (ULONG_PTR)(byte & 0x7f) << shift;
+        shift += 7;
+        (*p)++;
+    } while (byte & 0x80);
+
+    if ((shift < 8 * sizeof(ret)) && (byte & 0x40)) ret |= -((ULONG_PTR)1 << shift);
+    return ret;
+}
+
+static ULONG_PTR dwarf_get_ptr( const unsigned char **p, unsigned char encoding )
+{
+    ULONG_PTR base;
+
+    if (encoding == DW_EH_PE_omit) return 0;
+
+    switch (encoding & 0xf0)
+    {
+    case DW_EH_PE_abs:
+        base = 0;
+        break;
+    case DW_EH_PE_pcrel:
+        base = (ULONG_PTR)*p;
+        break;
+    default:
+        FIXME( "unsupported encoding %02x\n", encoding );
+        return 0;
     }
 
-    /* then look for host system exception information */
+    switch (encoding & 0x0f)
+    {
+    case DW_EH_PE_native:
+        return base + dwarf_get_u8( p );
+    case DW_EH_PE_leb128:
+        return base + dwarf_get_uleb128( p );
+    case DW_EH_PE_data2:
+        return base + dwarf_get_u2( p );
+    case DW_EH_PE_data4:
+        return base + dwarf_get_u4( p );
+    case DW_EH_PE_data8:
+        return base + dwarf_get_u8( p );
+    case DW_EH_PE_signed|DW_EH_PE_leb128:
+        return base + dwarf_get_sleb128( p );
+    case DW_EH_PE_signed|DW_EH_PE_data2:
+        return base + (signed short)dwarf_get_u2( p );
+    case DW_EH_PE_signed|DW_EH_PE_data4:
+        return base + (signed int)dwarf_get_u4( p );
+    case DW_EH_PE_signed|DW_EH_PE_data8:
+        return base + (LONG64)dwarf_get_u8( p );
+    default:
+        FIXME( "unsupported encoding %02x\n", encoding );
+        return 0;
+    }
+}
 
-    if (!module || (module->Flags & LDR_WINE_INTERNAL))
+enum reg_rule
+{
+    RULE_UNSET,          /* not set at all */
+    RULE_UNDEFINED,      /* undefined value */
+    RULE_SAME,           /* same value as previous frame */
+    RULE_CFA_OFFSET,     /* stored at cfa offset */
+    RULE_OTHER_REG,      /* stored in other register */
+    RULE_EXPRESSION,     /* address specified by expression */
+    RULE_VAL_EXPRESSION  /* value specified by expression */
+};
+
+#define NB_FRAME_REGS 41
+#define MAX_SAVED_STATES 16
+
+struct frame_state
+{
+    ULONG_PTR     cfa_offset;
+    unsigned char cfa_reg;
+    enum reg_rule cfa_rule;
+    enum reg_rule rules[NB_FRAME_REGS];
+    ULONG64       regs[NB_FRAME_REGS];
+};
+
+struct frame_info
+{
+    ULONG_PTR     ip;
+    ULONG_PTR     code_align;
+    LONG_PTR      data_align;
+    unsigned char retaddr_reg;
+    unsigned char fde_encoding;
+    unsigned char signal_frame;
+    unsigned char state_sp;
+    struct frame_state state;
+    struct frame_state *state_stack;
+};
+
+static const char *dwarf_reg_names[NB_FRAME_REGS] =
+{
+/*  0-7  */ "%rax", "%rdx", "%rcx", "%rbx", "%rsi", "%rdi", "%rbp", "%rsp",
+/*  8-16 */ "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15", "%rip",
+/* 17-24 */ "%xmm0", "%xmm1", "%xmm2", "%xmm3", "%xmm4", "%xmm5", "%xmm6", "%xmm7",
+/* 25-32 */ "%xmm8", "%xmm9", "%xmm10", "%xmm11", "%xmm12", "%xmm13", "%xmm14", "%xmm15",
+/* 33-40 */ "%st0", "%st1", "%st2", "%st3", "%st4", "%st5", "%st6", "%st7"
+};
+
+static BOOL valid_reg( ULONG_PTR reg )
+{
+    if (reg >= NB_FRAME_REGS) FIXME( "unsupported reg %lx\n", reg );
+    return (reg < NB_FRAME_REGS);
+}
+
+static void execute_cfa_instructions( const unsigned char *ptr, const unsigned char *end,
+                                      ULONG_PTR last_ip, struct frame_info *info )
+{
+    while (ptr < end && info->ip < last_ip + info->signal_frame)
+    {
+        enum dwarf_call_frame_info op = *ptr++;
+
+        if (op & 0xc0)
+        {
+            switch (op & 0xc0)
+            {
+            case DW_CFA_advance_loc:
+            {
+                ULONG_PTR offset = (op & 0x3f) * info->code_align;
+                TRACE( "%lx: DW_CFA_advance_loc %lu\n", info->ip, offset );
+                info->ip += offset;
+                break;
+            }
+            case DW_CFA_offset:
+            {
+                ULONG_PTR reg = op & 0x3f;
+                LONG_PTR offset = dwarf_get_uleb128( &ptr ) * info->data_align;
+                if (!valid_reg( reg )) break;
+                TRACE( "%lx: DW_CFA_offset %s, %ld\n", info->ip, dwarf_reg_names[reg], offset );
+                info->state.regs[reg]  = offset;
+                info->state.rules[reg] = RULE_CFA_OFFSET;
+                break;
+            }
+            case DW_CFA_restore:
+            {
+                ULONG_PTR reg = op & 0x3f;
+                if (!valid_reg( reg )) break;
+                TRACE( "%lx: DW_CFA_restore %s\n", info->ip, dwarf_reg_names[reg] );
+                info->state.rules[reg] = RULE_UNSET;
+                break;
+            }
+            }
+        }
+        else switch (op)
+        {
+        case DW_CFA_nop:
+            break;
+        case DW_CFA_set_loc:
+        {
+            ULONG_PTR loc = dwarf_get_ptr( &ptr, info->fde_encoding );
+            TRACE( "%lx: DW_CFA_set_loc %lx\n", info->ip, loc );
+            info->ip = loc;
+            break;
+        }
+        case DW_CFA_advance_loc1:
+        {
+            ULONG_PTR offset = *ptr++ * info->code_align;
+            TRACE( "%lx: DW_CFA_advance_loc1 %lu\n", info->ip, offset );
+            info->ip += offset;
+            break;
+        }
+        case DW_CFA_advance_loc2:
+        {
+            ULONG_PTR offset = dwarf_get_u2( &ptr ) * info->code_align;
+            TRACE( "%lx: DW_CFA_advance_loc2 %lu\n", info->ip, offset );
+            info->ip += offset;
+            break;
+        }
+        case DW_CFA_advance_loc4:
+        {
+            ULONG_PTR offset = dwarf_get_u4( &ptr ) * info->code_align;
+            TRACE( "%lx: DW_CFA_advance_loc4 %lu\n", info->ip, offset );
+            info->ip += offset;
+            break;
+        }
+        case DW_CFA_offset_extended:
+        case DW_CFA_offset_extended_sf:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            LONG_PTR offset = (op == DW_CFA_offset_extended) ? dwarf_get_uleb128( &ptr ) * info->data_align
+                                                             : dwarf_get_sleb128( &ptr ) * info->data_align;
+            if (!valid_reg( reg )) break;
+            TRACE( "%lx: DW_CFA_offset_extended %s, %ld\n", info->ip, dwarf_reg_names[reg], offset );
+            info->state.regs[reg]  = offset;
+            info->state.rules[reg] = RULE_CFA_OFFSET;
+            break;
+        }
+        case DW_CFA_restore_extended:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            if (!valid_reg( reg )) break;
+            TRACE( "%lx: DW_CFA_restore_extended %s\n", info->ip, dwarf_reg_names[reg] );
+            info->state.rules[reg] = RULE_UNSET;
+            break;
+        }
+        case DW_CFA_undefined:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            if (!valid_reg( reg )) break;
+            TRACE( "%lx: DW_CFA_undefined %s\n", info->ip, dwarf_reg_names[reg] );
+            info->state.rules[reg] = RULE_UNDEFINED;
+            break;
+        }
+        case DW_CFA_same_value:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            if (!valid_reg( reg )) break;
+            TRACE( "%lx: DW_CFA_same_value %s\n", info->ip, dwarf_reg_names[reg] );
+            info->state.regs[reg]  = reg;
+            info->state.rules[reg] = RULE_SAME;
+            break;
+        }
+        case DW_CFA_register:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            ULONG_PTR reg2 = dwarf_get_uleb128( &ptr );
+            if (!valid_reg( reg ) || !valid_reg( reg2 )) break;
+            TRACE( "%lx: DW_CFA_register %s == %s\n", info->ip, dwarf_reg_names[reg], dwarf_reg_names[reg2] );
+            info->state.regs[reg]  = reg2;
+            info->state.rules[reg] = RULE_OTHER_REG;
+            break;
+        }
+        case DW_CFA_remember_state:
+            TRACE( "%lx: DW_CFA_remember_state\n", info->ip );
+            if (info->state_sp >= MAX_SAVED_STATES)
+                FIXME( "%lx: DW_CFA_remember_state too many nested saves\n", info->ip );
+            else
+                info->state_stack[info->state_sp++] = info->state;
+            break;
+        case DW_CFA_restore_state:
+            TRACE( "%lx: DW_CFA_restore_state\n", info->ip );
+            if (!info->state_sp)
+                FIXME( "%lx: DW_CFA_restore_state without corresponding save\n", info->ip );
+            else
+                info->state = info->state_stack[--info->state_sp];
+            break;
+        case DW_CFA_def_cfa:
+        case DW_CFA_def_cfa_sf:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            ULONG_PTR offset = (op == DW_CFA_def_cfa) ? dwarf_get_uleb128( &ptr )
+                                                      : dwarf_get_sleb128( &ptr ) * info->data_align;
+            if (!valid_reg( reg )) break;
+            TRACE( "%lx: DW_CFA_def_cfa %s, %lu\n", info->ip, dwarf_reg_names[reg], offset );
+            info->state.cfa_reg    = reg;
+            info->state.cfa_offset = offset;
+            info->state.cfa_rule   = RULE_CFA_OFFSET;
+            break;
+        }
+        case DW_CFA_def_cfa_register:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            if (!valid_reg( reg )) break;
+            TRACE( "%lx: DW_CFA_def_cfa_register %s\n", info->ip, dwarf_reg_names[reg] );
+            info->state.cfa_reg = reg;
+            info->state.cfa_rule = RULE_CFA_OFFSET;
+            break;
+        }
+        case DW_CFA_def_cfa_offset:
+        case DW_CFA_def_cfa_offset_sf:
+        {
+            ULONG_PTR offset = (op == DW_CFA_def_cfa_offset) ? dwarf_get_uleb128( &ptr )
+                                                             : dwarf_get_sleb128( &ptr ) * info->data_align;
+            TRACE( "%lx: DW_CFA_def_cfa_offset %lu\n", info->ip, offset );
+            info->state.cfa_offset = offset;
+            info->state.cfa_rule = RULE_CFA_OFFSET;
+            break;
+        }
+        case DW_CFA_def_cfa_expression:
+        {
+            ULONG_PTR expr = (ULONG_PTR)ptr;
+            ULONG_PTR len = dwarf_get_uleb128( &ptr );
+            TRACE( "%lx: DW_CFA_def_cfa_expression %lx-%lx\n", info->ip, expr, expr+len );
+            info->state.cfa_offset = expr;
+            info->state.cfa_rule = RULE_VAL_EXPRESSION;
+            ptr += len;
+            break;
+        }
+        case DW_CFA_expression:
+        case DW_CFA_val_expression:
+        {
+            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
+            ULONG_PTR expr = (ULONG_PTR)ptr;
+            ULONG_PTR len = dwarf_get_uleb128( &ptr );
+            if (!valid_reg( reg )) break;
+            TRACE( "%lx: DW_CFA_%sexpression %s %lx-%lx\n",
+                   info->ip, (op == DW_CFA_expression) ? "" : "val_", dwarf_reg_names[reg], expr, expr+len );
+            info->state.regs[reg]  = expr;
+            info->state.rules[reg] = (op == DW_CFA_expression) ? RULE_EXPRESSION : RULE_VAL_EXPRESSION;
+            ptr += len;
+            break;
+        }
+        default:
+            FIXME( "%lx: unknown CFA opcode %02x\n", info->ip, op );
+            break;
+        }
+    }
+}
+
+/* retrieve a context register from its dwarf number */
+static void *get_context_reg( CONTEXT *context, ULONG_PTR dw_reg )
+{
+    switch (dw_reg)
+    {
+    case 0:  return &context->Rax;
+    case 1:  return &context->Rdx;
+    case 2:  return &context->Rcx;
+    case 3:  return &context->Rbx;
+    case 4:  return &context->Rsi;
+    case 5:  return &context->Rdi;
+    case 6:  return &context->Rbp;
+    case 7:  return &context->Rsp;
+    case 8:  return &context->R8;
+    case 9:  return &context->R9;
+    case 10: return &context->R10;
+    case 11: return &context->R11;
+    case 12: return &context->R12;
+    case 13: return &context->R13;
+    case 14: return &context->R14;
+    case 15: return &context->R15;
+    case 16: return &context->Rip;
+    case 17: return &context->u.s.Xmm0;
+    case 18: return &context->u.s.Xmm1;
+    case 19: return &context->u.s.Xmm2;
+    case 20: return &context->u.s.Xmm3;
+    case 21: return &context->u.s.Xmm4;
+    case 22: return &context->u.s.Xmm5;
+    case 23: return &context->u.s.Xmm6;
+    case 24: return &context->u.s.Xmm7;
+    case 25: return &context->u.s.Xmm8;
+    case 26: return &context->u.s.Xmm9;
+    case 27: return &context->u.s.Xmm10;
+    case 28: return &context->u.s.Xmm11;
+    case 29: return &context->u.s.Xmm12;
+    case 30: return &context->u.s.Xmm13;
+    case 31: return &context->u.s.Xmm14;
+    case 32: return &context->u.s.Xmm15;
+    case 33: return &context->u.s.Legacy[0];
+    case 34: return &context->u.s.Legacy[1];
+    case 35: return &context->u.s.Legacy[2];
+    case 36: return &context->u.s.Legacy[3];
+    case 37: return &context->u.s.Legacy[4];
+    case 38: return &context->u.s.Legacy[5];
+    case 39: return &context->u.s.Legacy[6];
+    case 40: return &context->u.s.Legacy[7];
+    default: return NULL;
+    }
+}
+
+/* set a context register from its dwarf number */
+static void set_context_reg( CONTEXT *context, ULONG_PTR dw_reg, void *val )
+{
+    switch (dw_reg)
     {
-        status = unix_funcs->unwind_builtin_dll( type, dispatch, context );
+    case 0:  context->Rax = *(ULONG64 *)val; break;
+    case 1:  context->Rdx = *(ULONG64 *)val; break;
+    case 2:  context->Rcx = *(ULONG64 *)val; break;
+    case 3:  context->Rbx = *(ULONG64 *)val; break;
+    case 4:  context->Rsi = *(ULONG64 *)val; break;
+    case 5:  context->Rdi = *(ULONG64 *)val; break;
+    case 6:  context->Rbp = *(ULONG64 *)val; break;
+    case 7:  context->Rsp = *(ULONG64 *)val; break;
+    case 8:  context->R8  = *(ULONG64 *)val; break;
+    case 9:  context->R9  = *(ULONG64 *)val; break;
+    case 10: context->R10 = *(ULONG64 *)val; break;
+    case 11: context->R11 = *(ULONG64 *)val; break;
+    case 12: context->R12 = *(ULONG64 *)val; break;
+    case 13: context->R13 = *(ULONG64 *)val; break;
+    case 14: context->R14 = *(ULONG64 *)val; break;
+    case 15: context->R15 = *(ULONG64 *)val; break;
+    case 16: context->Rip = *(ULONG64 *)val; break;
+    case 17: memcpy( &context->u.s.Xmm0, val, sizeof(M128A) ); break;
+    case 18: memcpy( &context->u.s.Xmm1, val, sizeof(M128A) ); break;
+    case 19: memcpy( &context->u.s.Xmm2, val, sizeof(M128A) ); break;
+    case 20: memcpy( &context->u.s.Xmm3, val, sizeof(M128A) ); break;
+    case 21: memcpy( &context->u.s.Xmm4, val, sizeof(M128A) ); break;
+    case 22: memcpy( &context->u.s.Xmm5, val, sizeof(M128A) ); break;
+    case 23: memcpy( &context->u.s.Xmm6, val, sizeof(M128A) ); break;
+    case 24: memcpy( &context->u.s.Xmm7, val, sizeof(M128A) ); break;
+    case 25: memcpy( &context->u.s.Xmm8, val, sizeof(M128A) ); break;
+    case 26: memcpy( &context->u.s.Xmm9, val, sizeof(M128A) ); break;
+    case 27: memcpy( &context->u.s.Xmm10, val, sizeof(M128A) ); break;
+    case 28: memcpy( &context->u.s.Xmm11, val, sizeof(M128A) ); break;
+    case 29: memcpy( &context->u.s.Xmm12, val, sizeof(M128A) ); break;
+    case 30: memcpy( &context->u.s.Xmm13, val, sizeof(M128A) ); break;
+    case 31: memcpy( &context->u.s.Xmm14, val, sizeof(M128A) ); break;
+    case 32: memcpy( &context->u.s.Xmm15, val, sizeof(M128A) ); break;
+    case 33: memcpy( &context->u.s.Legacy[0], val, sizeof(M128A) ); break;
+    case 34: memcpy( &context->u.s.Legacy[1], val, sizeof(M128A) ); break;
+    case 35: memcpy( &context->u.s.Legacy[2], val, sizeof(M128A) ); break;
+    case 36: memcpy( &context->u.s.Legacy[3], val, sizeof(M128A) ); break;
+    case 37: memcpy( &context->u.s.Legacy[4], val, sizeof(M128A) ); break;
+    case 38: memcpy( &context->u.s.Legacy[5], val, sizeof(M128A) ); break;
+    case 39: memcpy( &context->u.s.Legacy[6], val, sizeof(M128A) ); break;
+    case 40: memcpy( &context->u.s.Legacy[7], val, sizeof(M128A) ); break;
+    }
+}
+
+static ULONG_PTR eval_expression( const unsigned char *p, CONTEXT *context )
+{
+    ULONG_PTR reg, tmp, stack[64];
+    int sp = -1;
+    ULONG_PTR len = dwarf_get_uleb128(&p);
+    const unsigned char *end = p + len;
 
-        if (!status && dispatch->LanguageHandler && !module)
+    while (p < end)
+    {
+        unsigned char opcode = dwarf_get_u1(&p);
+
+        if (opcode >= DW_OP_lit0 && opcode <= DW_OP_lit31)
+            stack[++sp] = opcode - DW_OP_lit0;
+        else if (opcode >= DW_OP_reg0 && opcode <= DW_OP_reg31)
+            stack[++sp] = *(ULONG_PTR *)get_context_reg( context, opcode - DW_OP_reg0 );
+        else if (opcode >= DW_OP_breg0 && opcode <= DW_OP_breg31)
+            stack[++sp] = *(ULONG_PTR *)get_context_reg( context, opcode - DW_OP_breg0 ) + dwarf_get_sleb128(&p);
+        else switch (opcode)
         {
-            FIXME( "calling personality routine in system library not supported yet\n" );
-            dispatch->LanguageHandler = NULL;
+        case DW_OP_nop:         break;
+        case DW_OP_addr:        stack[++sp] = dwarf_get_u8(&p); break;
+        case DW_OP_const1u:     stack[++sp] = dwarf_get_u1(&p); break;
+        case DW_OP_const1s:     stack[++sp] = (signed char)dwarf_get_u1(&p); break;
+        case DW_OP_const2u:     stack[++sp] = dwarf_get_u2(&p); break;
+        case DW_OP_const2s:     stack[++sp] = (short)dwarf_get_u2(&p); break;
+        case DW_OP_const4u:     stack[++sp] = dwarf_get_u4(&p); break;
+        case DW_OP_const4s:     stack[++sp] = (signed int)dwarf_get_u4(&p); break;
+        case DW_OP_const8u:     stack[++sp] = dwarf_get_u8(&p); break;
+        case DW_OP_const8s:     stack[++sp] = (LONG_PTR)dwarf_get_u8(&p); break;
+        case DW_OP_constu:      stack[++sp] = dwarf_get_uleb128(&p); break;
+        case DW_OP_consts:      stack[++sp] = dwarf_get_sleb128(&p); break;
+        case DW_OP_deref:       stack[sp] = *(ULONG_PTR *)stack[sp]; break;
+        case DW_OP_dup:         stack[sp + 1] = stack[sp]; sp++; break;
+        case DW_OP_drop:        sp--; break;
+        case DW_OP_over:        stack[sp + 1] = stack[sp - 1]; sp++; break;
+        case DW_OP_pick:        stack[sp + 1] = stack[sp - dwarf_get_u1(&p)]; sp++; break;
+        case DW_OP_swap:        tmp = stack[sp]; stack[sp] = stack[sp-1]; stack[sp-1] = tmp; break;
+        case DW_OP_rot:         tmp = stack[sp]; stack[sp] = stack[sp-1]; stack[sp-1] = stack[sp-2]; stack[sp-2] = tmp; break;
+        case DW_OP_abs:         stack[sp] = labs(stack[sp]); break;
+        case DW_OP_neg:         stack[sp] = -stack[sp]; break;
+        case DW_OP_not:         stack[sp] = ~stack[sp]; break;
+        case DW_OP_and:         stack[sp-1] &= stack[sp]; sp--; break;
+        case DW_OP_or:          stack[sp-1] |= stack[sp]; sp--; break;
+        case DW_OP_minus:       stack[sp-1] -= stack[sp]; sp--; break;
+        case DW_OP_mul:         stack[sp-1] *= stack[sp]; sp--; break;
+        case DW_OP_plus:        stack[sp-1] += stack[sp]; sp--; break;
+        case DW_OP_xor:         stack[sp-1] ^= stack[sp]; sp--; break;
+        case DW_OP_shl:         stack[sp-1] <<= stack[sp]; sp--; break;
+        case DW_OP_shr:         stack[sp-1] >>= stack[sp]; sp--; break;
+        case DW_OP_plus_uconst: stack[sp] += dwarf_get_uleb128(&p); break;
+        case DW_OP_shra:        stack[sp-1] = (LONG_PTR)stack[sp-1] / (1 << stack[sp]); sp--; break;
+        case DW_OP_div:         stack[sp-1] = (LONG_PTR)stack[sp-1] / (LONG_PTR)stack[sp]; sp--; break;
+        case DW_OP_mod:         stack[sp-1] = (LONG_PTR)stack[sp-1] % (LONG_PTR)stack[sp]; sp--; break;
+        case DW_OP_ge:          stack[sp-1] = ((LONG_PTR)stack[sp-1] >= (LONG_PTR)stack[sp]); sp--; break;
+        case DW_OP_gt:          stack[sp-1] = ((LONG_PTR)stack[sp-1] >  (LONG_PTR)stack[sp]); sp--; break;
+        case DW_OP_le:          stack[sp-1] = ((LONG_PTR)stack[sp-1] <= (LONG_PTR)stack[sp]); sp--; break;
+        case DW_OP_lt:          stack[sp-1] = ((LONG_PTR)stack[sp-1] <  (LONG_PTR)stack[sp]); sp--; break;
+        case DW_OP_eq:          stack[sp-1] = (stack[sp-1] == stack[sp]); sp--; break;
+        case DW_OP_ne:          stack[sp-1] = (stack[sp-1] != stack[sp]); sp--; break;
+        case DW_OP_skip:        tmp = (short)dwarf_get_u2(&p); p += tmp; break;
+        case DW_OP_bra:         tmp = (short)dwarf_get_u2(&p); if (!stack[sp--]) p += tmp; break;
+        case DW_OP_GNU_encoded_addr: tmp = *p++; stack[++sp] = dwarf_get_ptr( &p, tmp ); break;
+        case DW_OP_regx:        stack[++sp] = *(ULONG_PTR *)get_context_reg( context, dwarf_get_uleb128(&p) ); break;
+        case DW_OP_bregx:
+            reg = dwarf_get_uleb128(&p);
+            tmp = dwarf_get_sleb128(&p);
+            stack[++sp] = *(ULONG_PTR *)get_context_reg( context, reg ) + tmp;
+            break;
+        case DW_OP_deref_size:
+            switch (*p++)
+            {
+            case 1: stack[sp] = *(unsigned char *)stack[sp]; break;
+            case 2: stack[sp] = *(unsigned short *)stack[sp]; break;
+            case 4: stack[sp] = *(unsigned int *)stack[sp]; break;
+            case 8: stack[sp] = *(ULONG_PTR *)stack[sp]; break;
+            }
+            break;
+        default:
+            FIXME( "unhandled opcode %02x\n", opcode );
         }
-        if (status != STATUS_UNSUCCESSFUL) return status;
     }
-    else WARN( "exception data not found in %s\n", debugstr_w(module->BaseDllName.Buffer) );
+    return stack[sp];
+}
 
-    /* no exception information, treat as a leaf function */
+/* apply the computed frame info to the actual context */
+static void apply_frame_state( CONTEXT *context, struct frame_state *state )
+{
+    unsigned int i;
+    ULONG_PTR cfa, value;
+    CONTEXT new_context = *context;
 
-    dispatch->EstablisherFrame = context->Rsp;
-    dispatch->LanguageHandler = NULL;
-    context->Rip = *(ULONG64 *)context->Rsp;
-    context->Rsp = context->Rsp + sizeof(ULONG64);
-    return STATUS_SUCCESS;
+    switch (state->cfa_rule)
+    {
+    case RULE_EXPRESSION:
+        cfa = *(ULONG_PTR *)eval_expression( (const unsigned char *)state->cfa_offset, context );
+        break;
+    case RULE_VAL_EXPRESSION:
+        cfa = eval_expression( (const unsigned char *)state->cfa_offset, context );
+        break;
+    default:
+        cfa = *(ULONG_PTR *)get_context_reg( context, state->cfa_reg ) + state->cfa_offset;
+        break;
+    }
+    if (!cfa) return;
+
+    for (i = 0; i < NB_FRAME_REGS; i++)
+    {
+        switch (state->rules[i])
+        {
+        case RULE_UNSET:
+        case RULE_UNDEFINED:
+        case RULE_SAME:
+            break;
+        case RULE_CFA_OFFSET:
+            set_context_reg( &new_context, i, (char *)cfa + state->regs[i] );
+            break;
+        case RULE_OTHER_REG:
+            set_context_reg( &new_context, i, get_context_reg( context, state->regs[i] ));
+            break;
+        case RULE_EXPRESSION:
+            value = eval_expression( (const unsigned char *)state->regs[i], context );
+            set_context_reg( &new_context, i, (void *)value );
+            break;
+        case RULE_VAL_EXPRESSION:
+            value = eval_expression( (const unsigned char *)state->regs[i], context );
+            set_context_reg( &new_context, i, &value );
+            break;
+        }
+    }
+    new_context.Rsp = cfa;
+    *context = new_context;
 }
 
 
-/**************************************************************************
- *		__chkstk (NTDLL.@)
+/***********************************************************************
+ *           dwarf_virtual_unwind
  *
- * Supposed to touch all the stack pages, but we shouldn't need that.
+ * Equivalent of RtlVirtualUnwind for builtin modules.
  */
-__ASM_GLOBAL_FUNC( __chkstk, "ret" );
+static NTSTATUS dwarf_virtual_unwind( ULONG64 ip, ULONG64 *frame,CONTEXT *context,
+                                      const struct dwarf_fde *fde, const struct dwarf_eh_bases *bases,
+                                      PEXCEPTION_ROUTINE *handler, void **handler_data )
+{
+    const struct dwarf_cie *cie;
+    const unsigned char *ptr, *augmentation, *end;
+    ULONG_PTR len, code_end;
+    struct frame_info info;
+    struct frame_state state_stack[MAX_SAVED_STATES];
+    int aug_z_format = 0;
+    unsigned char lsda_encoding = DW_EH_PE_omit;
+
+    memset( &info, 0, sizeof(info) );
+    info.state_stack = state_stack;
+    info.ip = (ULONG_PTR)bases->func;
+    *handler = NULL;
+
+    cie = (const struct dwarf_cie *)((const char *)&fde->cie_offset - fde->cie_offset);
+
+    /* parse the CIE first */
+
+    if (cie->version != 1 && cie->version != 3)
+    {
+        FIXME( "unknown CIE version %u at %p\n", cie->version, cie );
+        return STATUS_INVALID_DISPOSITION;
+    }
+    ptr = cie->augmentation + strlen((const char *)cie->augmentation) + 1;
+
+    info.code_align = dwarf_get_uleb128( &ptr );
+    info.data_align = dwarf_get_sleb128( &ptr );
+    if (cie->version == 1)
+        info.retaddr_reg = *ptr++;
+    else
+        info.retaddr_reg = dwarf_get_uleb128( &ptr );
+    info.state.cfa_rule = RULE_CFA_OFFSET;
 
+    TRACE( "function %lx base %p cie %p len %x id %x version %x aug '%s' code_align %lu data_align %ld retaddr %s\n",
+           ip, bases->func, cie, cie->length, cie->id, cie->version, cie->augmentation,
+           info.code_align, info.data_align, dwarf_reg_names[info.retaddr_reg] );
 
+    end = NULL;
+    for (augmentation = cie->augmentation; *augmentation; augmentation++)
+    {
+        switch (*augmentation)
+        {
+        case 'z':
+            len = dwarf_get_uleb128( &ptr );
+            end = ptr + len;
+            aug_z_format = 1;
+            continue;
+        case 'L':
+            lsda_encoding = *ptr++;
+            continue;
+        case 'P':
+        {
+            unsigned char encoding = *ptr++;
+            *handler = (void *)dwarf_get_ptr( &ptr, encoding );
+            continue;
+        }
+        case 'R':
+            info.fde_encoding = *ptr++;
+            continue;
+        case 'S':
+            info.signal_frame = 1;
+            continue;
+        }
+        FIXME( "unknown augmentation '%c'\n", *augmentation );
+        if (!end) return STATUS_INVALID_DISPOSITION;  /* cannot continue */
+        break;
+    }
+    if (end) ptr = end;
+
+    end = (const unsigned char *)(&cie->length + 1) + cie->length;
+    execute_cfa_instructions( ptr, end, ip, &info );
+
+    ptr = (const unsigned char *)(fde + 1);
+    info.ip = dwarf_get_ptr( &ptr, info.fde_encoding );  /* fde code start */
+    code_end = info.ip + dwarf_get_ptr( &ptr, info.fde_encoding & 0x0f );  /* fde code length */
+
+    if (aug_z_format)  /* get length of augmentation data */
+    {
+        len = dwarf_get_uleb128( &ptr );
+        end = ptr + len;
+    }
+    else end = NULL;
+
+    *handler_data = (void *)dwarf_get_ptr( &ptr, lsda_encoding );
+    if (end) ptr = end;
+
+    end = (const unsigned char *)(&fde->length + 1) + fde->length;
+    TRACE( "fde %p len %x personality %p lsda %p code %lx-%lx\n",
+           fde, fde->length, *handler, *handler_data, info.ip, code_end );
+    execute_cfa_instructions( ptr, end, ip, &info );
+    *frame = context->Rsp;
+    apply_frame_state( context, &info.state );
+
+    TRACE( "next function rip=%016lx\n", context->Rip );
+    TRACE( "  rax=%016lx rbx=%016lx rcx=%016lx rdx=%016lx\n",
+           context->Rax, context->Rbx, context->Rcx, context->Rdx );
+    TRACE( "  rsi=%016lx rdi=%016lx rbp=%016lx rsp=%016lx\n",
+           context->Rsi, context->Rdi, context->Rbp, context->Rsp );
+    TRACE( "   r8=%016lx  r9=%016lx r10=%016lx r11=%016lx\n",
+           context->R8, context->R9, context->R10, context->R11 );
+    TRACE( "  r12=%016lx r13=%016lx r14=%016lx r15=%016lx\n",
+           context->R12, context->R13, context->R14, context->R15 );
+
+    return STATUS_SUCCESS;
+}
+
+
+#ifdef HAVE_LIBUNWIND
 /***********************************************************************
- *		RtlCaptureContext (NTDLL.@)
+ *           libunwind_virtual_unwind
+ *
+ * Equivalent of RtlVirtualUnwind for builtin modules.
  */
-__ASM_GLOBAL_FUNC( RtlCaptureContext,
-                   "pushfq\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset 8\n\t")
-                   "movl $0x10000f,0x30(%rcx)\n\t"  /* context->ContextFlags */
-                   "stmxcsr 0x34(%rcx)\n\t"         /* context->MxCsr */
-                   "movw %cs,0x38(%rcx)\n\t"        /* context->SegCs */
-                   "movw %ds,0x3a(%rcx)\n\t"        /* context->SegDs */
-                   "movw %es,0x3c(%rcx)\n\t"        /* context->SegEs */
-                   "movw %fs,0x3e(%rcx)\n\t"        /* context->SegFs */
+static NTSTATUS libunwind_virtual_unwind( ULONG64 ip, BOOL* got_info, ULONG64 *frame, CONTEXT *context,
+                                          PEXCEPTION_ROUTINE *handler, void **handler_data )
+{
+    unw_context_t unw_context;
+    unw_cursor_t cursor;
+    unw_proc_info_t info;
+    int rc;
+
+#ifdef __APPLE__
+    rc = unw_getcontext( &unw_context );
+    if (rc == UNW_ESUCCESS)
+        rc = unw_init_local( &cursor, &unw_context );
+    if (rc == UNW_ESUCCESS)
+    {
+        unw_set_reg( &cursor, UNW_REG_IP,     context->Rip );
+        unw_set_reg( &cursor, UNW_REG_SP,     context->Rsp );
+        unw_set_reg( &cursor, UNW_X86_64_RAX, context->Rax );
+        unw_set_reg( &cursor, UNW_X86_64_RDX, context->Rdx );
+        unw_set_reg( &cursor, UNW_X86_64_RCX, context->Rcx );
+        unw_set_reg( &cursor, UNW_X86_64_RBX, context->Rbx );
+        unw_set_reg( &cursor, UNW_X86_64_RSI, context->Rsi );
+        unw_set_reg( &cursor, UNW_X86_64_RDI, context->Rdi );
+        unw_set_reg( &cursor, UNW_X86_64_RBP, context->Rbp );
+        unw_set_reg( &cursor, UNW_X86_64_R8,  context->R8 );
+        unw_set_reg( &cursor, UNW_X86_64_R9,  context->R9 );
+        unw_set_reg( &cursor, UNW_X86_64_R10, context->R10 );
+        unw_set_reg( &cursor, UNW_X86_64_R11, context->R11 );
+        unw_set_reg( &cursor, UNW_X86_64_R12, context->R12 );
+        unw_set_reg( &cursor, UNW_X86_64_R13, context->R13 );
+        unw_set_reg( &cursor, UNW_X86_64_R14, context->R14 );
+        unw_set_reg( &cursor, UNW_X86_64_R15, context->R15 );
+    }
+#else
+    set_sigcontext( context, &unw_context );
+    rc = unw_init_local( &cursor, &unw_context );
+#endif
+    if (rc != UNW_ESUCCESS)
+    {
+        WARN( "setup failed: %d\n", rc );
+        return STATUS_INVALID_DISPOSITION;
+    }
+
+    rc = unw_get_proc_info(&cursor, &info);
+    if (rc != UNW_ESUCCESS && rc != UNW_ENOINFO)
+    {
+        WARN( "failed to get info: %d\n", rc );
+        return STATUS_INVALID_DISPOSITION;
+    }
+    if (rc == UNW_ENOINFO || ip < info.start_ip || ip > info.end_ip || info.end_ip == info.start_ip + 1)
+    {
+        *got_info = FALSE;
+        return STATUS_SUCCESS;
+    }
+
+    TRACE( "ip %#lx function %#lx-%#lx personality %#lx lsda %#lx fde %#lx\n",
+           ip, (unsigned long)info.start_ip, (unsigned long)info.end_ip, (unsigned long)info.handler,
+           (unsigned long)info.lsda, (unsigned long)info.unwind_info );
+
+    if (!(rc = unw_step( &cursor )))
+    {
+        WARN( "last frame\n" );
+        *got_info = FALSE;
+        return STATUS_SUCCESS;
+    }
+    if (rc < 0)
+    {
+        WARN( "failed to unwind: %d\n", rc );
+        return STATUS_INVALID_DISPOSITION;
+    }
+
+    *frame = context->Rsp;
+    unw_get_reg( &cursor, UNW_REG_IP,     (unw_word_t *)&context->Rip );
+    unw_get_reg( &cursor, UNW_REG_SP,     (unw_word_t *)&context->Rsp );
+    unw_get_reg( &cursor, UNW_X86_64_RAX, (unw_word_t *)&context->Rax );
+    unw_get_reg( &cursor, UNW_X86_64_RDX, (unw_word_t *)&context->Rdx );
+    unw_get_reg( &cursor, UNW_X86_64_RCX, (unw_word_t *)&context->Rcx );
+    unw_get_reg( &cursor, UNW_X86_64_RBX, (unw_word_t *)&context->Rbx );
+    unw_get_reg( &cursor, UNW_X86_64_RSI, (unw_word_t *)&context->Rsi );
+    unw_get_reg( &cursor, UNW_X86_64_RDI, (unw_word_t *)&context->Rdi );
+    unw_get_reg( &cursor, UNW_X86_64_RBP, (unw_word_t *)&context->Rbp );
+    unw_get_reg( &cursor, UNW_X86_64_R8,  (unw_word_t *)&context->R8 );
+    unw_get_reg( &cursor, UNW_X86_64_R9,  (unw_word_t *)&context->R9 );
+    unw_get_reg( &cursor, UNW_X86_64_R10, (unw_word_t *)&context->R10 );
+    unw_get_reg( &cursor, UNW_X86_64_R11, (unw_word_t *)&context->R11 );
+    unw_get_reg( &cursor, UNW_X86_64_R12, (unw_word_t *)&context->R12 );
+    unw_get_reg( &cursor, UNW_X86_64_R13, (unw_word_t *)&context->R13 );
+    unw_get_reg( &cursor, UNW_X86_64_R14, (unw_word_t *)&context->R14 );
+    unw_get_reg( &cursor, UNW_X86_64_R15, (unw_word_t *)&context->R15 );
+    *handler = (void*)info.handler;
+    *handler_data = (void*)info.lsda;
+    *got_info = TRUE;
+
+    TRACE( "next function rip=%016lx\n", context->Rip );
+    TRACE( "  rax=%016lx rbx=%016lx rcx=%016lx rdx=%016lx\n",
+           context->Rax, context->Rbx, context->Rcx, context->Rdx );
+    TRACE( "  rsi=%016lx rdi=%016lx rbp=%016lx rsp=%016lx\n",
+           context->Rsi, context->Rdi, context->Rbp, context->Rsp );
+    TRACE( "   r8=%016lx  r9=%016lx r10=%016lx r11=%016lx\n",
+           context->R8, context->R9, context->R10, context->R11 );
+    TRACE( "  r12=%016lx r13=%016lx r14=%016lx r15=%016lx\n",
+           context->R12, context->R13, context->R14, context->R15 );
+
+    return STATUS_SUCCESS;
+}
+#endif
+
+
+/***********************************************************************
+ *           virtual_unwind
+ */
+static NTSTATUS virtual_unwind( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEXT *context )
+{
+    LDR_DATA_TABLE_ENTRY *module;
+    NTSTATUS status;
+
+    dispatch->ImageBase = 0;
+    dispatch->ScopeIndex = 0;
+    dispatch->ControlPc = context->Rip;
+
+    /* first look for PE exception information */
+
+    if ((dispatch->FunctionEntry = lookup_function_info( context->Rip, &dispatch->ImageBase, &module )))
+    {
+        dispatch->LanguageHandler = RtlVirtualUnwind( type, dispatch->ImageBase, context->Rip,
+                                                      dispatch->FunctionEntry, context,
+                                                      &dispatch->HandlerData, &dispatch->EstablisherFrame,
+                                                      NULL );
+        return STATUS_SUCCESS;
+    }
+
+    /* then look for host system exception information */
+
+    if (!module || (module->Flags & LDR_WINE_INTERNAL))
+    {
+        BOOL got_info = FALSE;
+        struct dwarf_eh_bases bases;
+        const struct dwarf_fde *fde = _Unwind_Find_FDE( (void *)(context->Rip - 1), &bases );
+
+        if (fde)
+        {
+            status = dwarf_virtual_unwind( context->Rip, &dispatch->EstablisherFrame, context, fde,
+                                           &bases, &dispatch->LanguageHandler, &dispatch->HandlerData );
+            if (status != STATUS_SUCCESS) return status;
+            got_info = TRUE;
+        }
+#ifdef HAVE_LIBUNWIND
+        else
+        {
+            status = libunwind_virtual_unwind( context->Rip, &got_info, &dispatch->EstablisherFrame,
+                                               context, &dispatch->LanguageHandler, &dispatch->HandlerData );
+            if (status != STATUS_SUCCESS) return status;
+        }
+#endif
+        if (got_info)
+        {
+            if (dispatch->LanguageHandler && !module)
+            {
+                FIXME( "calling personality routine in system library not supported yet\n" );
+                dispatch->LanguageHandler = NULL;
+            }
+            return STATUS_SUCCESS;
+        }
+    }
+    else WARN( "exception data not found in %s\n", debugstr_w(module->BaseDllName.Buffer) );
+
+    /* no exception information, treat as a leaf function */
+
+    dispatch->EstablisherFrame = context->Rsp;
+    dispatch->LanguageHandler = NULL;
+    context->Rip = *(ULONG64 *)context->Rsp;
+    context->Rsp = context->Rsp + sizeof(ULONG64);
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           dispatch_signal
+ */
+static inline int dispatch_signal(unsigned int sig)
+{
+    if (handlers[sig] == NULL) return 0;
+    return handlers[sig](sig);
+}
+
+/***********************************************************************
+ *           get_signal_stack
+ *
+ * Get the base of the signal stack for the current thread.
+ */
+static inline void *get_signal_stack(void)
+{
+    return (char *)NtCurrentTeb() + teb_size;
+}
+
+/***********************************************************************
+ *           is_inside_signal_stack
+ *
+ * Check if pointer is inside the signal stack.
+ */
+static inline BOOL is_inside_signal_stack( void *ptr )
+{
+    return ((char *)ptr >= (char *)get_signal_stack() &&
+            (char *)ptr < (char *)get_signal_stack() + signal_stack_size);
+}
+
+/***********************************************************************
+ *           save_context
+ *
+ * Set the register values from a sigcontext.
+ */
+static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
+{
+    context->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_DEBUG_REGISTERS;
+    context->Rax    = RAX_sig(sigcontext);
+    context->Rcx    = RCX_sig(sigcontext);
+    context->Rdx    = RDX_sig(sigcontext);
+    context->Rbx    = RBX_sig(sigcontext);
+    context->Rsp    = RSP_sig(sigcontext);
+    context->Rbp    = RBP_sig(sigcontext);
+    context->Rsi    = RSI_sig(sigcontext);
+    context->Rdi    = RDI_sig(sigcontext);
+    context->R8     = R8_sig(sigcontext);
+    context->R9     = R9_sig(sigcontext);
+    context->R10    = R10_sig(sigcontext);
+    context->R11    = R11_sig(sigcontext);
+    context->R12    = R12_sig(sigcontext);
+    context->R13    = R13_sig(sigcontext);
+    context->R14    = R14_sig(sigcontext);
+    context->R15    = R15_sig(sigcontext);
+    context->Rip    = RIP_sig(sigcontext);
+    context->SegCs  = CS_sig(sigcontext);
+    context->SegFs  = FS_sig(sigcontext);
+    context->SegGs  = GS_sig(sigcontext);
+    context->EFlags = EFL_sig(sigcontext);
+#ifdef DS_sig
+    context->SegDs  = DS_sig(sigcontext);
+#else
+    __asm__("movw %%ds,%0" : "=m" (context->SegDs));
+#endif
+#ifdef ES_sig
+    context->SegEs  = ES_sig(sigcontext);
+#else
+    __asm__("movw %%es,%0" : "=m" (context->SegEs));
+#endif
+#ifdef SS_sig
+    context->SegSs  = SS_sig(sigcontext);
+#else
+    __asm__("movw %%ss,%0" : "=m" (context->SegSs));
+#endif
+    context->Dr0    = amd64_thread_data()->dr0;
+    context->Dr1    = amd64_thread_data()->dr1;
+    context->Dr2    = amd64_thread_data()->dr2;
+    context->Dr3    = amd64_thread_data()->dr3;
+    context->Dr6    = amd64_thread_data()->dr6;
+    context->Dr7    = amd64_thread_data()->dr7;
+    if (FPU_sig(sigcontext))
+    {
+        context->ContextFlags |= CONTEXT_FLOATING_POINT;
+        context->u.FltSave = *FPU_sig(sigcontext);
+        context->MxCsr = context->u.FltSave.MxCsr;
+    }
+}
+
+
+/***********************************************************************
+ *           restore_context
+ *
+ * Build a sigcontext from the register values.
+ */
+static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
+{
+    amd64_thread_data()->dr0 = context->Dr0;
+    amd64_thread_data()->dr1 = context->Dr1;
+    amd64_thread_data()->dr2 = context->Dr2;
+    amd64_thread_data()->dr3 = context->Dr3;
+    amd64_thread_data()->dr6 = context->Dr6;
+    amd64_thread_data()->dr7 = context->Dr7;
+    set_sigcontext( context, sigcontext );
+    if (FPU_sig(sigcontext)) *FPU_sig(sigcontext) = context->u.FltSave;
+}
+
+
+/**************************************************************************
+ *		__chkstk (NTDLL.@)
+ *
+ * Supposed to touch all the stack pages, but we shouldn't need that.
+ */
+__ASM_GLOBAL_FUNC( __chkstk, "ret" );
+
+
+/***********************************************************************
+ *		RtlCaptureContext (NTDLL.@)
+ */
+__ASM_GLOBAL_FUNC( RtlCaptureContext,
+                   "pushfq\n\t"
+                   __ASM_CFI(".cfi_adjust_cfa_offset 8\n\t")
+                   "movl $0x001000f,0x30(%rcx)\n\t" /* context->ContextFlags */
+                   "stmxcsr 0x34(%rcx)\n\t"         /* context->MxCsr */
+                   "movw %cs,0x38(%rcx)\n\t"        /* context->SegCs */
+                   "movw %ds,0x3a(%rcx)\n\t"        /* context->SegDs */
+                   "movw %es,0x3c(%rcx)\n\t"        /* context->SegEs */
+                   "movw %fs,0x3e(%rcx)\n\t"        /* context->SegFs */
                    "movw %gs,0x40(%rcx)\n\t"        /* context->SegGs */
                    "movw %ss,0x42(%rcx)\n\t"        /* context->SegSs */
                    "popq 0x44(%rcx)\n\t"            /* context->Eflags */
@@ -359,250 +1808,1482 @@ __ASM_GLOBAL_FUNC( RtlCaptureContext,
                    "movdqa %xmm15,0x290(%rcx)\n\t"  /* context->Xmm15 */
                    "ret" );
 
-/******************************************************************************
- *              RtlWow64GetThreadContext  (NTDLL.@)
+/***********************************************************************
+ *           set_full_cpu_context
+ *
+ * Set the new CPU context.
+ */
+extern void set_full_cpu_context( const CONTEXT *context );
+__ASM_GLOBAL_FUNC( set_full_cpu_context,
+                   "subq $40,%rsp\n\t"
+                   __ASM_SEH(".seh_stackalloc 0x40\n\t")
+                   __ASM_SEH(".seh_endprologue\n\t")
+                   __ASM_CFI(".cfi_adjust_cfa_offset 40\n\t")
+                   "ldmxcsr 0x34(%rdi)\n\t"         /* context->MxCsr */
+                   "movw 0x38(%rdi),%ax\n\t"        /* context->SegCs */
+                   "movq %rax,8(%rsp)\n\t"
+                   "movw 0x42(%rdi),%ax\n\t"        /* context->SegSs */
+                   "movq %rax,32(%rsp)\n\t"
+                   "movq 0x44(%rdi),%rax\n\t"       /* context->Eflags */
+                   "movq %rax,16(%rsp)\n\t"
+                   "movq 0x80(%rdi),%rcx\n\t"       /* context->Rcx */
+                   "movq 0x88(%rdi),%rdx\n\t"       /* context->Rdx */
+                   "movq 0x90(%rdi),%rbx\n\t"       /* context->Rbx */
+                   "movq 0x98(%rdi),%rax\n\t"       /* context->Rsp */
+                   "movq %rax,24(%rsp)\n\t"
+                   "movq 0xa0(%rdi),%rbp\n\t"       /* context->Rbp */
+                   "movq 0xa8(%rdi),%rsi\n\t"       /* context->Rsi */
+                   "movq 0xb8(%rdi),%r8\n\t"        /* context->R8 */
+                   "movq 0xc0(%rdi),%r9\n\t"        /* context->R9 */
+                   "movq 0xc8(%rdi),%r10\n\t"       /* context->R10 */
+                   "movq 0xd0(%rdi),%r11\n\t"       /* context->R11 */
+                   "movq 0xd8(%rdi),%r12\n\t"       /* context->R12 */
+                   "movq 0xe0(%rdi),%r13\n\t"       /* context->R13 */
+                   "movq 0xe8(%rdi),%r14\n\t"       /* context->R14 */
+                   "movq 0xf0(%rdi),%r15\n\t"       /* context->R15 */
+                   "movq 0xf8(%rdi),%rax\n\t"       /* context->Rip */
+                   "movq %rax,(%rsp)\n\t"
+                   "fxrstor 0x100(%rdi)\n\t"        /* context->FtlSave */
+                   "movdqa 0x1a0(%rdi),%xmm0\n\t"   /* context->Xmm0 */
+                   "movdqa 0x1b0(%rdi),%xmm1\n\t"   /* context->Xmm1 */
+                   "movdqa 0x1c0(%rdi),%xmm2\n\t"   /* context->Xmm2 */
+                   "movdqa 0x1d0(%rdi),%xmm3\n\t"   /* context->Xmm3 */
+                   "movdqa 0x1e0(%rdi),%xmm4\n\t"   /* context->Xmm4 */
+                   "movdqa 0x1f0(%rdi),%xmm5\n\t"   /* context->Xmm5 */
+                   "movdqa 0x200(%rdi),%xmm6\n\t"   /* context->Xmm6 */
+                   "movdqa 0x210(%rdi),%xmm7\n\t"   /* context->Xmm7 */
+                   "movdqa 0x220(%rdi),%xmm8\n\t"   /* context->Xmm8 */
+                   "movdqa 0x230(%rdi),%xmm9\n\t"   /* context->Xmm9 */
+                   "movdqa 0x240(%rdi),%xmm10\n\t"  /* context->Xmm10 */
+                   "movdqa 0x250(%rdi),%xmm11\n\t"  /* context->Xmm11 */
+                   "movdqa 0x260(%rdi),%xmm12\n\t"  /* context->Xmm12 */
+                   "movdqa 0x270(%rdi),%xmm13\n\t"  /* context->Xmm13 */
+                   "movdqa 0x280(%rdi),%xmm14\n\t"  /* context->Xmm14 */
+                   "movdqa 0x290(%rdi),%xmm15\n\t"  /* context->Xmm15 */
+                   "movq 0x78(%rdi),%rax\n\t"       /* context->Rax */
+                   "movq 0xb0(%rdi),%rdi\n\t"       /* context->Rdi */
+                   "iretq" );
+
+
+/***********************************************************************
+ *           set_cpu_context
+ *
+ * Set the new CPU context. Used by NtSetContextThread.
+ */
+void DECLSPEC_HIDDEN set_cpu_context( const CONTEXT *context )
+{
+    DWORD flags = context->ContextFlags & ~CONTEXT_AMD64;
+
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        amd64_thread_data()->dr0 = context->Dr0;
+        amd64_thread_data()->dr1 = context->Dr1;
+        amd64_thread_data()->dr2 = context->Dr2;
+        amd64_thread_data()->dr3 = context->Dr3;
+        amd64_thread_data()->dr6 = context->Dr6;
+        amd64_thread_data()->dr7 = context->Dr7;
+    }
+    if (flags & CONTEXT_FULL)
+    {
+        if (!(flags & CONTEXT_CONTROL))
+            FIXME( "setting partial context (%x) not supported\n", flags );
+        else
+            set_full_cpu_context( context );
+    }
+}
+
+
+/***********************************************************************
+ *           get_server_context_flags
+ *
+ * Convert CPU-specific flags to generic server flags
+ */
+static unsigned int get_server_context_flags( DWORD flags )
+{
+    unsigned int ret = 0;
+
+    flags &= ~CONTEXT_AMD64;  /* get rid of CPU id */
+    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
+    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
+    if (flags & CONTEXT_SEGMENTS) ret |= SERVER_CTX_SEGMENTS;
+    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
+    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           copy_context
+ *
+ * Copy a register context according to the flags.
+ */
+static void copy_context( CONTEXT *to, const CONTEXT *from, DWORD flags )
+{
+    flags &= ~CONTEXT_AMD64;  /* get rid of CPU id */
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->Rbp    = from->Rbp;
+        to->Rip    = from->Rip;
+        to->Rsp    = from->Rsp;
+        to->SegCs  = from->SegCs;
+        to->SegSs  = from->SegSs;
+        to->EFlags = from->EFlags;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->Rax = from->Rax;
+        to->Rcx = from->Rcx;
+        to->Rdx = from->Rdx;
+        to->Rbx = from->Rbx;
+        to->Rsi = from->Rsi;
+        to->Rdi = from->Rdi;
+        to->R8  = from->R8;
+        to->R9  = from->R9;
+        to->R10 = from->R10;
+        to->R11 = from->R11;
+        to->R12 = from->R12;
+        to->R13 = from->R13;
+        to->R14 = from->R14;
+        to->R15 = from->R15;
+    }
+    if (flags & CONTEXT_SEGMENTS)
+    {
+        to->SegDs = from->SegDs;
+        to->SegEs = from->SegEs;
+        to->SegFs = from->SegFs;
+        to->SegGs = from->SegGs;
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->MxCsr = from->MxCsr;
+        to->u.FltSave = from->u.FltSave;
+    }
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        to->Dr0 = from->Dr0;
+        to->Dr1 = from->Dr1;
+        to->Dr2 = from->Dr2;
+        to->Dr3 = from->Dr3;
+        to->Dr6 = from->Dr6;
+        to->Dr7 = from->Dr7;
+    }
+}
+
+
+/***********************************************************************
+ *           context_to_server
+ *
+ * Convert a register context to the server format.
+ */
+NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
+{
+    DWORD flags = from->ContextFlags & ~CONTEXT_AMD64;  /* get rid of CPU id */
+
+    memset( to, 0, sizeof(*to) );
+    to->cpu = CPU_x86_64;
+
+    if (flags & CONTEXT_CONTROL)
+    {
+        to->flags |= SERVER_CTX_CONTROL;
+        to->ctl.x86_64_regs.rbp   = from->Rbp;
+        to->ctl.x86_64_regs.rip   = from->Rip;
+        to->ctl.x86_64_regs.rsp   = from->Rsp;
+        to->ctl.x86_64_regs.cs    = from->SegCs;
+        to->ctl.x86_64_regs.ss    = from->SegSs;
+        to->ctl.x86_64_regs.flags = from->EFlags;
+    }
+    if (flags & CONTEXT_INTEGER)
+    {
+        to->flags |= SERVER_CTX_INTEGER;
+        to->integer.x86_64_regs.rax = from->Rax;
+        to->integer.x86_64_regs.rcx = from->Rcx;
+        to->integer.x86_64_regs.rdx = from->Rdx;
+        to->integer.x86_64_regs.rbx = from->Rbx;
+        to->integer.x86_64_regs.rsi = from->Rsi;
+        to->integer.x86_64_regs.rdi = from->Rdi;
+        to->integer.x86_64_regs.r8  = from->R8;
+        to->integer.x86_64_regs.r9  = from->R9;
+        to->integer.x86_64_regs.r10 = from->R10;
+        to->integer.x86_64_regs.r11 = from->R11;
+        to->integer.x86_64_regs.r12 = from->R12;
+        to->integer.x86_64_regs.r13 = from->R13;
+        to->integer.x86_64_regs.r14 = from->R14;
+        to->integer.x86_64_regs.r15 = from->R15;
+    }
+    if (flags & CONTEXT_SEGMENTS)
+    {
+        to->flags |= SERVER_CTX_SEGMENTS;
+        to->seg.x86_64_regs.ds = from->SegDs;
+        to->seg.x86_64_regs.es = from->SegEs;
+        to->seg.x86_64_regs.fs = from->SegFs;
+        to->seg.x86_64_regs.gs = from->SegGs;
+    }
+    if (flags & CONTEXT_FLOATING_POINT)
+    {
+        to->flags |= SERVER_CTX_FLOATING_POINT;
+        memcpy( to->fp.x86_64_regs.fpregs, &from->u.FltSave, sizeof(to->fp.x86_64_regs.fpregs) );
+    }
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
+        to->debug.x86_64_regs.dr0 = from->Dr0;
+        to->debug.x86_64_regs.dr1 = from->Dr1;
+        to->debug.x86_64_regs.dr2 = from->Dr2;
+        to->debug.x86_64_regs.dr3 = from->Dr3;
+        to->debug.x86_64_regs.dr6 = from->Dr6;
+        to->debug.x86_64_regs.dr7 = from->Dr7;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           context_from_server
+ *
+ * Convert a register context from the server format.
+ */
+NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
+{
+    if (from->cpu != CPU_x86_64) return STATUS_INVALID_PARAMETER;
+
+    to->ContextFlags = CONTEXT_AMD64;
+    if (from->flags & SERVER_CTX_CONTROL)
+    {
+        to->ContextFlags |= CONTEXT_CONTROL;
+        to->Rbp    = from->ctl.x86_64_regs.rbp;
+        to->Rip    = from->ctl.x86_64_regs.rip;
+        to->Rsp    = from->ctl.x86_64_regs.rsp;
+        to->SegCs  = from->ctl.x86_64_regs.cs;
+        to->SegSs  = from->ctl.x86_64_regs.ss;
+        to->EFlags = from->ctl.x86_64_regs.flags;
+    }
+
+    if (from->flags & SERVER_CTX_INTEGER)
+    {
+        to->ContextFlags |= CONTEXT_INTEGER;
+        to->Rax = from->integer.x86_64_regs.rax;
+        to->Rcx = from->integer.x86_64_regs.rcx;
+        to->Rdx = from->integer.x86_64_regs.rdx;
+        to->Rbx = from->integer.x86_64_regs.rbx;
+        to->Rsi = from->integer.x86_64_regs.rsi;
+        to->Rdi = from->integer.x86_64_regs.rdi;
+        to->R8  = from->integer.x86_64_regs.r8;
+        to->R9  = from->integer.x86_64_regs.r9;
+        to->R10 = from->integer.x86_64_regs.r10;
+        to->R11 = from->integer.x86_64_regs.r11;
+        to->R12 = from->integer.x86_64_regs.r12;
+        to->R13 = from->integer.x86_64_regs.r13;
+        to->R14 = from->integer.x86_64_regs.r14;
+        to->R15 = from->integer.x86_64_regs.r15;
+    }
+    if (from->flags & SERVER_CTX_SEGMENTS)
+    {
+        to->ContextFlags |= CONTEXT_SEGMENTS;
+        to->SegDs = from->seg.x86_64_regs.ds;
+        to->SegEs = from->seg.x86_64_regs.es;
+        to->SegFs = from->seg.x86_64_regs.fs;
+        to->SegGs = from->seg.x86_64_regs.gs;
+    }
+    if (from->flags & SERVER_CTX_FLOATING_POINT)
+    {
+        to->ContextFlags |= CONTEXT_FLOATING_POINT;
+        memcpy( &to->u.FltSave, from->fp.x86_64_regs.fpregs, sizeof(from->fp.x86_64_regs.fpregs) );
+        to->MxCsr = to->u.FltSave.MxCsr;
+    }
+    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
+    {
+        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
+        to->Dr0 = from->debug.x86_64_regs.dr0;
+        to->Dr1 = from->debug.x86_64_regs.dr1;
+        to->Dr2 = from->debug.x86_64_regs.dr2;
+        to->Dr3 = from->debug.x86_64_regs.dr3;
+        to->Dr6 = from->debug.x86_64_regs.dr6;
+        to->Dr7 = from->debug.x86_64_regs.dr7;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *              NtSetContextThread  (NTDLL.@)
+ *              ZwSetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
+{
+    NTSTATUS ret = STATUS_SUCCESS;
+    BOOL self = (handle == GetCurrentThread());
+
+    /* debug registers require a server call */
+    if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)))
+        self = (amd64_thread_data()->dr0 == context->Dr0 &&
+                amd64_thread_data()->dr1 == context->Dr1 &&
+                amd64_thread_data()->dr2 == context->Dr2 &&
+                amd64_thread_data()->dr3 == context->Dr3 &&
+                amd64_thread_data()->dr6 == context->Dr6 &&
+                amd64_thread_data()->dr7 == context->Dr7);
+
+    if (!self)
+    {
+        context_t server_context;
+        context_to_server( &server_context, context );
+        ret = set_thread_context( handle, &server_context, &self );
+    }
+    if (self && ret == STATUS_SUCCESS) set_cpu_context( context );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              NtGetContextThread  (NTDLL.@)
+ *              ZwGetContextThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
+{
+    NTSTATUS ret;
+    DWORD needed_flags;
+    BOOL self = (handle == GetCurrentThread());
+
+    if (!context) return STATUS_INVALID_PARAMETER;
+
+    needed_flags = context->ContextFlags;
+
+    /* debug registers require a server call */
+    if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)) self = FALSE;
+
+    if (!self)
+    {
+        context_t server_context;
+        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
+
+        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
+        if ((ret = context_from_server( context, &server_context ))) return ret;
+        needed_flags &= ~context->ContextFlags;
+    }
+
+    if (self)
+    {
+        if (needed_flags)
+        {
+            CONTEXT ctx;
+            RtlCaptureContext( &ctx );
+            copy_context( context, &ctx, ctx.ContextFlags & needed_flags );
+            context->ContextFlags |= ctx.ContextFlags & needed_flags;
+        }
+        /* update the cached version of the debug registers */
+        if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64))
+        {
+            amd64_thread_data()->dr0 = context->Dr0;
+            amd64_thread_data()->dr1 = context->Dr1;
+            amd64_thread_data()->dr2 = context->Dr2;
+            amd64_thread_data()->dr3 = context->Dr3;
+            amd64_thread_data()->dr6 = context->Dr6;
+            amd64_thread_data()->dr7 = context->Dr7;
+        }
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           wow64_get_server_context_flags
+ */
+static unsigned int wow64_get_server_context_flags( DWORD flags )
+{
+    unsigned int ret = 0;
+
+    flags &= ~WOW64_CONTEXT_i386;  /* get rid of CPU id */
+    if (flags & WOW64_CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
+    if (flags & WOW64_CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
+    if (flags & WOW64_CONTEXT_SEGMENTS) ret |= SERVER_CTX_SEGMENTS;
+    if (flags & WOW64_CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
+    if (flags & WOW64_CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
+    if (flags & WOW64_CONTEXT_EXTENDED_REGISTERS) ret |= SERVER_CTX_EXTENDED_REGISTERS;
+    return ret;
+}
+
+/***********************************************************************
+ *           wow64_context_from_server
+ */
+static NTSTATUS wow64_context_from_server( WOW64_CONTEXT *to, const context_t *from )
+{
+    if (from->cpu != CPU_x86) return STATUS_INVALID_PARAMETER;
+
+    to->ContextFlags = WOW64_CONTEXT_i386;
+    if (from->flags & SERVER_CTX_CONTROL)
+    {
+        to->ContextFlags |= WOW64_CONTEXT_CONTROL;
+        to->Ebp    = from->ctl.i386_regs.ebp;
+        to->Esp    = from->ctl.i386_regs.esp;
+        to->Eip    = from->ctl.i386_regs.eip;
+        to->SegCs  = from->ctl.i386_regs.cs;
+        to->SegSs  = from->ctl.i386_regs.ss;
+        to->EFlags = from->ctl.i386_regs.eflags;
+    }
+    if (from->flags & SERVER_CTX_INTEGER)
+    {
+        to->ContextFlags |= WOW64_CONTEXT_INTEGER;
+        to->Eax = from->integer.i386_regs.eax;
+        to->Ebx = from->integer.i386_regs.ebx;
+        to->Ecx = from->integer.i386_regs.ecx;
+        to->Edx = from->integer.i386_regs.edx;
+        to->Esi = from->integer.i386_regs.esi;
+        to->Edi = from->integer.i386_regs.edi;
+    }
+    if (from->flags & SERVER_CTX_SEGMENTS)
+    {
+        to->ContextFlags |= WOW64_CONTEXT_SEGMENTS;
+        to->SegDs = from->seg.i386_regs.ds;
+        to->SegEs = from->seg.i386_regs.es;
+        to->SegFs = from->seg.i386_regs.fs;
+        to->SegGs = from->seg.i386_regs.gs;
+    }
+    if (from->flags & SERVER_CTX_FLOATING_POINT)
+    {
+        to->ContextFlags |= WOW64_CONTEXT_FLOATING_POINT;
+        to->FloatSave.ControlWord   = from->fp.i386_regs.ctrl;
+        to->FloatSave.StatusWord    = from->fp.i386_regs.status;
+        to->FloatSave.TagWord       = from->fp.i386_regs.tag;
+        to->FloatSave.ErrorOffset   = from->fp.i386_regs.err_off;
+        to->FloatSave.ErrorSelector = from->fp.i386_regs.err_sel;
+        to->FloatSave.DataOffset    = from->fp.i386_regs.data_off;
+        to->FloatSave.DataSelector  = from->fp.i386_regs.data_sel;
+        to->FloatSave.Cr0NpxState   = from->fp.i386_regs.cr0npx;
+        memcpy( to->FloatSave.RegisterArea, from->fp.i386_regs.regs, sizeof(to->FloatSave.RegisterArea) );
+    }
+    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
+    {
+        to->ContextFlags |= WOW64_CONTEXT_DEBUG_REGISTERS;
+        to->Dr0 = from->debug.i386_regs.dr0;
+        to->Dr1 = from->debug.i386_regs.dr1;
+        to->Dr2 = from->debug.i386_regs.dr2;
+        to->Dr3 = from->debug.i386_regs.dr3;
+        to->Dr6 = from->debug.i386_regs.dr6;
+        to->Dr7 = from->debug.i386_regs.dr7;
+    }
+    if (from->flags & SERVER_CTX_EXTENDED_REGISTERS)
+    {
+        to->ContextFlags |= WOW64_CONTEXT_EXTENDED_REGISTERS;
+        memcpy( to->ExtendedRegisters, from->ext.i386_regs, sizeof(to->ExtendedRegisters) );
+    }
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           wow64_context_to_server
+ */
+static void wow64_context_to_server( context_t *to, const WOW64_CONTEXT *from )
+{
+    DWORD flags = from->ContextFlags & ~WOW64_CONTEXT_i386;  /* get rid of CPU id */
+
+    memset( to, 0, sizeof(*to) );
+    to->cpu = CPU_x86;
+
+    if (flags & WOW64_CONTEXT_CONTROL)
+    {
+        to->flags |= SERVER_CTX_CONTROL;
+        to->ctl.i386_regs.ebp    = from->Ebp;
+        to->ctl.i386_regs.esp    = from->Esp;
+        to->ctl.i386_regs.eip    = from->Eip;
+        to->ctl.i386_regs.cs     = from->SegCs;
+        to->ctl.i386_regs.ss     = from->SegSs;
+        to->ctl.i386_regs.eflags = from->EFlags;
+    }
+    if (flags & WOW64_CONTEXT_INTEGER)
+    {
+        to->flags |= SERVER_CTX_INTEGER;
+        to->integer.i386_regs.eax = from->Eax;
+        to->integer.i386_regs.ebx = from->Ebx;
+        to->integer.i386_regs.ecx = from->Ecx;
+        to->integer.i386_regs.edx = from->Edx;
+        to->integer.i386_regs.esi = from->Esi;
+        to->integer.i386_regs.edi = from->Edi;
+    }
+    if (flags & WOW64_CONTEXT_SEGMENTS)
+    {
+        to->flags |= SERVER_CTX_SEGMENTS;
+        to->seg.i386_regs.ds = from->SegDs;
+        to->seg.i386_regs.es = from->SegEs;
+        to->seg.i386_regs.fs = from->SegFs;
+        to->seg.i386_regs.gs = from->SegGs;
+    }
+    if (flags & WOW64_CONTEXT_FLOATING_POINT)
+    {
+        to->flags |= SERVER_CTX_FLOATING_POINT;
+        to->fp.i386_regs.ctrl     = from->FloatSave.ControlWord;
+        to->fp.i386_regs.status   = from->FloatSave.StatusWord;
+        to->fp.i386_regs.tag      = from->FloatSave.TagWord;
+        to->fp.i386_regs.err_off  = from->FloatSave.ErrorOffset;
+        to->fp.i386_regs.err_sel  = from->FloatSave.ErrorSelector;
+        to->fp.i386_regs.data_off = from->FloatSave.DataOffset;
+        to->fp.i386_regs.data_sel = from->FloatSave.DataSelector;
+        to->fp.i386_regs.cr0npx   = from->FloatSave.Cr0NpxState;
+        memcpy( to->fp.i386_regs.regs, from->FloatSave.RegisterArea, sizeof(to->fp.i386_regs.regs) );
+    }
+    if (flags & WOW64_CONTEXT_DEBUG_REGISTERS)
+    {
+        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
+        to->debug.i386_regs.dr0 = from->Dr0;
+        to->debug.i386_regs.dr1 = from->Dr1;
+        to->debug.i386_regs.dr2 = from->Dr2;
+        to->debug.i386_regs.dr3 = from->Dr3;
+        to->debug.i386_regs.dr6 = from->Dr6;
+        to->debug.i386_regs.dr7 = from->Dr7;
+    }
+    if (flags & WOW64_CONTEXT_EXTENDED_REGISTERS)
+    {
+        to->flags |= SERVER_CTX_EXTENDED_REGISTERS;
+        memcpy( to->ext.i386_regs, from->ExtendedRegisters, sizeof(to->ext.i386_regs) );
+    }
+}
+
+
+/******************************************************************************
+ *              RtlWow64GetThreadContext  (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64GetThreadContext( HANDLE handle, WOW64_CONTEXT *context )
+{
+    BOOL self;
+    NTSTATUS ret;
+    context_t server_context;
+    unsigned int server_flags = wow64_get_server_context_flags( context->ContextFlags );
+
+    if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
+    if (self) return STATUS_INVALID_PARAMETER;
+    return wow64_context_from_server( context, &server_context );
+}
+
+
+/******************************************************************************
+ *              RtlWow64SetThreadContext  (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64SetThreadContext( HANDLE handle, const WOW64_CONTEXT *context )
+{
+    BOOL self;
+    context_t server_context;
+
+    wow64_context_to_server( &server_context, context );
+    return set_thread_context( handle, &server_context, &self );
+}
+
+
+static DWORD __cdecl nested_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
+                                               CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher )
+{
+    if (rec->ExceptionFlags & (EH_UNWINDING | EH_EXIT_UNWIND)) return ExceptionContinueSearch;
+
+    /* FIXME */
+    return ExceptionNestedException;
+}
+
+/**********************************************************************
+ *           call_handler
+ *
+ * Call a single exception handler.
+ * FIXME: Handle nested exceptions.
+ */
+static DWORD call_handler( EXCEPTION_RECORD *rec, CONTEXT *context, DISPATCHER_CONTEXT *dispatch )
+{
+    EXCEPTION_REGISTRATION_RECORD frame;
+    DWORD res;
+
+    frame.Handler = nested_exception_handler;
+    __wine_push_frame( &frame );
+
+    TRACE( "calling handler %p (rec=%p, frame=0x%lx context=%p, dispatch=%p)\n",
+           dispatch->LanguageHandler, rec, dispatch->EstablisherFrame, dispatch->ContextRecord, dispatch );
+    res = dispatch->LanguageHandler( rec, (void *)dispatch->EstablisherFrame, context, dispatch );
+    TRACE( "handler at %p returned %u\n", dispatch->LanguageHandler, res );
+
+    rec->ExceptionFlags &= EH_NONCONTINUABLE;
+    __wine_pop_frame( &frame );
+    return res;
+}
+
+
+/**********************************************************************
+ *           call_teb_handler
+ *
+ * Call a single exception handler from the TEB chain.
+ * FIXME: Handle nested exceptions.
+ */
+static DWORD call_teb_handler( EXCEPTION_RECORD *rec, CONTEXT *context, DISPATCHER_CONTEXT *dispatch,
+                                  EXCEPTION_REGISTRATION_RECORD *teb_frame )
+{
+    DWORD res;
+
+    TRACE( "calling TEB handler %p (rec=%p, frame=%p context=%p, dispatch=%p)\n",
+           teb_frame->Handler, rec, teb_frame, dispatch->ContextRecord, dispatch );
+    res = teb_frame->Handler( rec, teb_frame, context, (EXCEPTION_REGISTRATION_RECORD**)dispatch );
+    TRACE( "handler at %p returned %u\n", teb_frame->Handler, res );
+    return res;
+}
+
+
+/**********************************************************************
+ *           call_stack_handlers
+ *
+ * Call the stack handlers chain.
+ */
+static NTSTATUS call_stack_handlers( EXCEPTION_RECORD *rec, CONTEXT *orig_context )
+{
+    EXCEPTION_REGISTRATION_RECORD *teb_frame = NtCurrentTeb()->Tib.ExceptionList;
+    UNWIND_HISTORY_TABLE table;
+    DISPATCHER_CONTEXT dispatch;
+    CONTEXT context;
+    NTSTATUS status;
+
+    context = *orig_context;
+    dispatch.TargetIp      = 0;
+    dispatch.ContextRecord = &context;
+    dispatch.HistoryTable  = &table;
+    for (;;)
+    {
+        status = virtual_unwind( UNW_FLAG_EHANDLER, &dispatch, &context );
+        if (status != STATUS_SUCCESS) return status;
+
+    unwind_done:
+        if (!dispatch.EstablisherFrame) break;
+
+        if ((dispatch.EstablisherFrame & 7) ||
+            dispatch.EstablisherFrame < (ULONG64)NtCurrentTeb()->Tib.StackLimit ||
+            dispatch.EstablisherFrame > (ULONG64)NtCurrentTeb()->Tib.StackBase)
+        {
+            ERR( "invalid frame %lx (%p-%p)\n", dispatch.EstablisherFrame,
+                 NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
+            rec->ExceptionFlags |= EH_STACK_INVALID;
+            break;
+        }
+
+        if (dispatch.LanguageHandler)
+        {
+            switch (call_handler( rec, orig_context, &dispatch ))
+            {
+            case ExceptionContinueExecution:
+                if (rec->ExceptionFlags & EH_NONCONTINUABLE) return STATUS_NONCONTINUABLE_EXCEPTION;
+                return STATUS_SUCCESS;
+            case ExceptionContinueSearch:
+                break;
+            case ExceptionNestedException:
+                FIXME( "nested exception\n" );
+                break;
+            case ExceptionCollidedUnwind: {
+                ULONG64 frame;
+
+                context = *dispatch.ContextRecord;
+                dispatch.ContextRecord = &context;
+                RtlVirtualUnwind( UNW_FLAG_NHANDLER, dispatch.ImageBase,
+                        dispatch.ControlPc, dispatch.FunctionEntry,
+                        &context, NULL, &frame, NULL );
+                goto unwind_done;
+            }
+            default:
+                return STATUS_INVALID_DISPOSITION;
+            }
+        }
+        /* hack: call wine handlers registered in the tib list */
+        else while ((ULONG64)teb_frame < context.Rsp)
+        {
+            TRACE( "found wine frame %p rsp %lx handler %p\n",
+                    teb_frame, context.Rsp, teb_frame->Handler );
+            dispatch.EstablisherFrame = (ULONG64)teb_frame;
+            switch (call_teb_handler( rec, orig_context, &dispatch, teb_frame ))
+            {
+            case ExceptionContinueExecution:
+                if (rec->ExceptionFlags & EH_NONCONTINUABLE) return STATUS_NONCONTINUABLE_EXCEPTION;
+                return STATUS_SUCCESS;
+            case ExceptionContinueSearch:
+                break;
+            case ExceptionNestedException:
+                FIXME( "nested exception\n" );
+                break;
+            case ExceptionCollidedUnwind: {
+                ULONG64 frame;
+
+                context = *dispatch.ContextRecord;
+                dispatch.ContextRecord = &context;
+                RtlVirtualUnwind( UNW_FLAG_NHANDLER, dispatch.ImageBase,
+                        dispatch.ControlPc, dispatch.FunctionEntry,
+                        &context, NULL, &frame, NULL );
+                teb_frame = teb_frame->Prev;
+                goto unwind_done;
+            }
+            default:
+                return STATUS_INVALID_DISPOSITION;
+            }
+            teb_frame = teb_frame->Prev;
+        }
+
+        if (context.Rsp == (ULONG64)NtCurrentTeb()->Tib.StackBase) break;
+    }
+    return STATUS_UNHANDLED_EXCEPTION;
+}
+
+
+static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+{
+    NTSTATUS status;
+
+    if (first_chance)
+    {
+        DWORD c;
+
+        TRACE( "code=%x flags=%x addr=%p ip=%lx tid=%04x\n",
+               rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
+               context->Rip, GetCurrentThreadId() );
+        for (c = 0; c < min( EXCEPTION_MAXIMUM_PARAMETERS, rec->NumberParameters ); c++)
+            TRACE( " info[%d]=%016lx\n", c, rec->ExceptionInformation[c] );
+        if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+        {
+            if (rec->ExceptionInformation[1] >> 16)
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
+            else
+                MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
+                         rec->ExceptionAddress,
+                         (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+        }
+        else
+        {
+            TRACE(" rax=%016lx rbx=%016lx rcx=%016lx rdx=%016lx\n",
+                  context->Rax, context->Rbx, context->Rcx, context->Rdx );
+            TRACE(" rsi=%016lx rdi=%016lx rbp=%016lx rsp=%016lx\n",
+                  context->Rsi, context->Rdi, context->Rbp, context->Rsp );
+            TRACE("  r8=%016lx  r9=%016lx r10=%016lx r11=%016lx\n",
+                  context->R8, context->R9, context->R10, context->R11 );
+            TRACE(" r12=%016lx r13=%016lx r14=%016lx r15=%016lx\n",
+                  context->R12, context->R13, context->R14, context->R15 );
+        }
+
+        /* fix up instruction pointer in context for EXCEPTION_BREAKPOINT */
+        if (rec->ExceptionCode == EXCEPTION_BREAKPOINT) context->Rip--;
+
+        if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION) goto done;
+
+        if ((status = call_stack_handlers( rec, context )) == STATUS_SUCCESS) goto done;
+        if (status != STATUS_UNHANDLED_EXCEPTION) return status;
+    }
+
+    /* last chance exception */
+
+    status = send_debug_event( rec, FALSE, context );
+    if (status != DBG_CONTINUE)
+    {
+        if (rec->ExceptionFlags & EH_STACK_INVALID)
+            ERR("Exception frame is not in stack limits => unable to dispatch exception.\n");
+        else if (rec->ExceptionCode == STATUS_NONCONTINUABLE_EXCEPTION)
+            ERR("Process attempted to continue execution after noncontinuable exception.\n");
+        else
+            ERR("Unhandled exception code %x flags %x addr %p\n",
+                rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress );
+        NtTerminateProcess( NtCurrentProcess(), rec->ExceptionCode );
+    }
+
+done:
+    return NtSetContextThread( GetCurrentThread(), context );
+}
+
+
+/*******************************************************************
+ *		NtRaiseException (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRaiseException( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+{
+    NTSTATUS status;
+
+    if (first_chance)
+    {
+        status = send_debug_event( rec, TRUE, context );
+        if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
+            return NtSetContextThread( GetCurrentThread(), context );
+    }
+
+    return raise_exception( rec, context, first_chance);
+}
+
+
+/**********************************************************************
+ *		raise_generic_exception
+ *
+ * Generic raise function for exceptions that don't need special treatment.
+ */
+static void raise_generic_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
+{
+    NTSTATUS status = raise_exception( rec, context, TRUE );
+    raise_status( status, rec );
+}
+
+
+extern void raise_func_trampoline( EXCEPTION_RECORD *rec, CONTEXT *context, raise_func func );
+__ASM_GLOBAL_FUNC( raise_func_trampoline,
+                   __ASM_CFI(".cfi_signal_frame\n\t")
+                   __ASM_CFI(".cfi_def_cfa %rbp,160\n\t")  /* red zone + rip + rbp + rdi + rsi */
+                   __ASM_CFI(".cfi_rel_offset %rip,24\n\t")
+                   __ASM_CFI(".cfi_rel_offset %rbp,16\n\t")
+                   __ASM_CFI(".cfi_rel_offset %rdi,8\n\t")
+                   __ASM_CFI(".cfi_rel_offset %rsi,0\n\t")
+                   "call *%rdx\n\t"
+                   "int $3")
+
+/***********************************************************************
+ *           setup_exception
+ *
+ * Setup a proper stack frame for the raise function, and modify the
+ * sigcontext so that the return from the signal handler will call
+ * the raise function.
+ */
+static struct stack_layout *setup_exception( ucontext_t *sigcontext )
+{
+    struct stack_layout *stack;
+    DWORD exception_code = 0;
+
+    stack = (struct stack_layout *)(RSP_sig(sigcontext) & ~15);
+
+    /* stack sanity checks */
+
+    if (is_inside_signal_stack( stack ))
+    {
+        ERR( "nested exception on signal stack in thread %04x eip %016lx esp %016lx stack %p-%p\n",
+             GetCurrentThreadId(), (ULONG_PTR)RIP_sig(sigcontext), (ULONG_PTR)RSP_sig(sigcontext),
+             NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
+        abort_thread(1);
+    }
+
+    if (stack - 1 > stack || /* check for overflow in subtraction */
+        (char *)stack <= (char *)NtCurrentTeb()->DeallocationStack ||
+        (char *)stack > (char *)NtCurrentTeb()->Tib.StackBase)
+    {
+        WARN( "exception outside of stack limits in thread %04x eip %016lx esp %016lx stack %p-%p\n",
+              GetCurrentThreadId(), (ULONG_PTR)RIP_sig(sigcontext), (ULONG_PTR)RSP_sig(sigcontext),
+              NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
+    }
+    else if ((char *)(stack - 1) < (char *)NtCurrentTeb()->DeallocationStack + 4096)
+    {
+        /* stack overflow on last page, unrecoverable */
+        UINT diff = (char *)NtCurrentTeb()->DeallocationStack + 4096 - (char *)(stack - 1);
+        ERR( "stack overflow %u bytes in thread %04x eip %016lx esp %016lx stack %p-%p-%p\n",
+             diff, GetCurrentThreadId(), (ULONG_PTR)RIP_sig(sigcontext),
+             (ULONG_PTR)RSP_sig(sigcontext), NtCurrentTeb()->DeallocationStack,
+             NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
+        abort_thread(1);
+    }
+    else if ((char *)(stack - 1) < (char *)NtCurrentTeb()->Tib.StackLimit)
+    {
+        /* stack access below stack limit, may be recoverable */
+        switch (virtual_handle_stack_fault( stack - 1 ))
+        {
+        case 0:  /* not handled */
+        {
+            UINT diff = (char *)NtCurrentTeb()->Tib.StackLimit - (char *)(stack - 1);
+            ERR( "stack overflow %u bytes in thread %04x eip %016lx esp %016lx stack %p-%p-%p\n",
+                 diff, GetCurrentThreadId(), (ULONG_PTR)RIP_sig(sigcontext),
+                 (ULONG_PTR)RSP_sig(sigcontext), NtCurrentTeb()->DeallocationStack,
+                 NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
+            abort_thread(1);
+        }
+        case -1:  /* overflow */
+            exception_code = EXCEPTION_STACK_OVERFLOW;
+            break;
+        }
+    }
+
+    stack--;  /* push the stack_layout structure */
+#if defined(VALGRIND_MAKE_MEM_UNDEFINED)
+    VALGRIND_MAKE_MEM_UNDEFINED(stack, sizeof(*stack));
+#elif defined(VALGRIND_MAKE_WRITABLE)
+    VALGRIND_MAKE_WRITABLE(stack, sizeof(*stack));
+#endif
+    stack->rec.ExceptionRecord  = NULL;
+    stack->rec.ExceptionCode    = exception_code;
+    stack->rec.ExceptionFlags   = EXCEPTION_CONTINUABLE;
+    stack->rec.ExceptionAddress = (void *)RIP_sig(sigcontext);
+    stack->rec.NumberParameters = 0;
+    save_context( &stack->context, sigcontext );
+
+    return stack;
+}
+
+static void setup_raise_exception( ucontext_t *sigcontext, struct stack_layout *stack )
+{
+    ULONG64 *rsp_ptr;
+    NTSTATUS status;
+
+    if (stack->rec.ExceptionCode == EXCEPTION_SINGLE_STEP)
+    {
+        /* when single stepping can't tell whether this is a hw bp or a
+         * single step interrupt. try to avoid as much overhead as possible
+         * and only do a server call if there is any hw bp enabled. */
+
+        if (!(stack->context.EFlags & 0x100) || (stack->context.Dr7 & 0xff))
+        {
+            /* (possible) hardware breakpoint, fetch the debug registers */
+            DWORD saved_flags = stack->context.ContextFlags;
+            stack->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
+            NtGetContextThread(GetCurrentThread(), &stack->context);
+            stack->context.ContextFlags |= saved_flags;  /* restore flags */
+        }
+
+        stack->context.EFlags &= ~0x100;  /* clear single-step flag */
+    }
+
+    status = send_debug_event( &stack->rec, TRUE, &stack->context );
+    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
+    {
+        restore_context( &stack->context, sigcontext );
+        return;
+    }
+
+    /* store return address and %rbp without aligning, so that the offset is fixed */
+    rsp_ptr = (ULONG64 *)RSP_sig(sigcontext) - 16;
+    *(--rsp_ptr) = stack->context.Rip;
+    *(--rsp_ptr) = stack->context.Rbp;
+    *(--rsp_ptr) = stack->context.Rdi;
+    *(--rsp_ptr) = stack->context.Rsi;
+
+    /* now modify the sigcontext to return to the raise function */
+    RIP_sig(sigcontext) = (ULONG_PTR)raise_func_trampoline;
+    RDI_sig(sigcontext) = (ULONG_PTR)&stack->rec;
+    RSI_sig(sigcontext) = (ULONG_PTR)&stack->context;
+    RDX_sig(sigcontext) = (ULONG_PTR)raise_generic_exception;
+    RBP_sig(sigcontext) = (ULONG_PTR)rsp_ptr;
+    RSP_sig(sigcontext) = (ULONG_PTR)stack;
+    /* clear single-step, direction, and align check flag */
+    EFL_sig(sigcontext) &= ~(0x100|0x400|0x40000);
+}
+
+
+/***********************************************************************
+ *           is_privileged_instr
+ *
+ * Check if the fault location is a privileged instruction.
+ */
+static inline DWORD is_privileged_instr( CONTEXT *context )
+{
+    BYTE instr[16];
+    unsigned int i, prefix_count = 0;
+    unsigned int len = virtual_uninterrupted_read_memory( (BYTE *)context->Rip, instr, sizeof(instr) );
+
+    for (i = 0; i < len; i++) switch (instr[i])
+    {
+    /* instruction prefixes */
+    case 0x2e:  /* %cs: */
+    case 0x36:  /* %ss: */
+    case 0x3e:  /* %ds: */
+    case 0x26:  /* %es: */
+    case 0x40:  /* rex */
+    case 0x41:  /* rex */
+    case 0x42:  /* rex */
+    case 0x43:  /* rex */
+    case 0x44:  /* rex */
+    case 0x45:  /* rex */
+    case 0x46:  /* rex */
+    case 0x47:  /* rex */
+    case 0x48:  /* rex */
+    case 0x49:  /* rex */
+    case 0x4a:  /* rex */
+    case 0x4b:  /* rex */
+    case 0x4c:  /* rex */
+    case 0x4d:  /* rex */
+    case 0x4e:  /* rex */
+    case 0x4f:  /* rex */
+    case 0x64:  /* %fs: */
+    case 0x65:  /* %gs: */
+    case 0x66:  /* opcode size */
+    case 0x67:  /* addr size */
+    case 0xf0:  /* lock */
+    case 0xf2:  /* repne */
+    case 0xf3:  /* repe */
+        if (++prefix_count >= 15) return EXCEPTION_ILLEGAL_INSTRUCTION;
+        continue;
+
+    case 0x0f: /* extended instruction */
+        if (i == len - 1) return 0;
+        switch (instr[i + 1])
+        {
+        case 0x06: /* clts */
+        case 0x08: /* invd */
+        case 0x09: /* wbinvd */
+        case 0x20: /* mov crX, reg */
+        case 0x21: /* mov drX, reg */
+        case 0x22: /* mov reg, crX */
+        case 0x23: /* mov reg drX */
+            return EXCEPTION_PRIV_INSTRUCTION;
+        }
+        return 0;
+    case 0x6c: /* insb (%dx) */
+    case 0x6d: /* insl (%dx) */
+    case 0x6e: /* outsb (%dx) */
+    case 0x6f: /* outsl (%dx) */
+    case 0xcd: /* int $xx */
+    case 0xe4: /* inb al,XX */
+    case 0xe5: /* in (e)ax,XX */
+    case 0xe6: /* outb XX,al */
+    case 0xe7: /* out XX,(e)ax */
+    case 0xec: /* inb (%dx),%al */
+    case 0xed: /* inl (%dx),%eax */
+    case 0xee: /* outb %al,(%dx) */
+    case 0xef: /* outl %eax,(%dx) */
+    case 0xf4: /* hlt */
+    case 0xfa: /* cli */
+    case 0xfb: /* sti */
+        return EXCEPTION_PRIV_INSTRUCTION;
+    default:
+        return 0;
+    }
+    return 0;
+}
+
+
+/***********************************************************************
+ *           handle_interrupt
+ *
+ * Handle an interrupt.
+ */
+static inline BOOL handle_interrupt( ucontext_t *sigcontext, struct stack_layout *stack )
+{
+    switch (ERROR_sig(sigcontext) >> 3)
+    {
+    case 0x2c:
+        stack->rec.ExceptionCode = STATUS_ASSERTION_FAILURE;
+        break;
+    case 0x2d:
+        switch (stack->context.Rax)
+        {
+            case 1: /* BREAKPOINT_PRINT */
+            case 3: /* BREAKPOINT_LOAD_SYMBOLS */
+            case 4: /* BREAKPOINT_UNLOAD_SYMBOLS */
+            case 5: /* BREAKPOINT_COMMAND_STRING (>= Win2003) */
+                RIP_sig(sigcontext) += 3;
+                return TRUE;
+        }
+        stack->context.Rip += 3;
+        stack->rec.ExceptionCode = EXCEPTION_BREAKPOINT;
+        stack->rec.ExceptionAddress = (void *)stack->context.Rip;
+        stack->rec.NumberParameters = 1;
+        stack->rec.ExceptionInformation[0] = stack->context.Rax;
+        break;
+    default:
+        return FALSE;
+    }
+    setup_raise_exception( sigcontext, stack );
+    return TRUE;
+}
+
+
+/**********************************************************************
+ *		segv_handler
+ *
+ * Handler for SIGSEGV and related errors.
+ */
+static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    struct stack_layout *stack;
+    ucontext_t *ucontext = sigcontext;
+
+    stack = (struct stack_layout *)(RSP_sig(ucontext) & ~15);
+
+    /* check for exceptions on the signal stack caused by write watches */
+    if (TRAP_sig(ucontext) == TRAP_x86_PAGEFLT && is_inside_signal_stack( stack ) &&
+        !virtual_handle_fault( siginfo->si_addr, (ERROR_sig(ucontext) >> 1) & 0x09, TRUE ))
+    {
+        return;
+    }
+
+    /* check for page fault inside the thread stack */
+    if (TRAP_sig(ucontext) == TRAP_x86_PAGEFLT)
+    {
+        switch (virtual_handle_stack_fault( siginfo->si_addr ))
+        {
+        case 1:  /* handled */
+            return;
+        case -1:  /* overflow */
+            stack = setup_exception( sigcontext );
+            stack->rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
+            goto done;
+        }
+    }
+
+    stack = setup_exception( sigcontext );
+    if (stack->rec.ExceptionCode == EXCEPTION_STACK_OVERFLOW) goto done;
+
+    switch(TRAP_sig(ucontext))
+    {
+    case TRAP_x86_OFLOW:   /* Overflow exception */
+        stack->rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
+        break;
+    case TRAP_x86_BOUND:   /* Bound range exception */
+        stack->rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
+        break;
+    case TRAP_x86_PRIVINFLT:   /* Invalid opcode exception */
+        stack->rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    case TRAP_x86_STKFLT:  /* Stack fault */
+        stack->rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
+        break;
+    case TRAP_x86_SEGNPFLT:  /* Segment not present exception */
+    case TRAP_x86_PROTFLT:   /* General protection fault */
+    case TRAP_x86_UNKNOWN:   /* Unknown fault code */
+        {
+            WORD err = ERROR_sig(ucontext);
+            if (!err && (stack->rec.ExceptionCode = is_privileged_instr( &stack->context ))) break;
+            if ((err & 7) == 2 && handle_interrupt( ucontext, stack )) return;
+            stack->rec.ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
+            stack->rec.NumberParameters = 2;
+            stack->rec.ExceptionInformation[0] = 0;
+            stack->rec.ExceptionInformation[1] = 0xffffffffffffffff;
+        }
+        break;
+    case TRAP_x86_PAGEFLT:  /* Page fault */
+        stack->rec.NumberParameters = 2;
+        stack->rec.ExceptionInformation[0] = (ERROR_sig(ucontext) >> 1) & 0x09;
+        stack->rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
+        if (!(stack->rec.ExceptionCode = virtual_handle_fault((void *)stack->rec.ExceptionInformation[1],
+                                                              stack->rec.ExceptionInformation[0], FALSE )))
+            return;
+        break;
+    case TRAP_x86_ALIGNFLT:  /* Alignment check exception */
+        stack->rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
+        break;
+    default:
+        ERR( "Got unexpected trap %ld\n", (ULONG_PTR)TRAP_sig(ucontext) );
+        /* fall through */
+    case TRAP_x86_NMI:       /* NMI interrupt */
+    case TRAP_x86_DNA:       /* Device not available exception */
+    case TRAP_x86_DOUBLEFLT: /* Double fault exception */
+    case TRAP_x86_TSSFLT:    /* Invalid TSS exception */
+    case TRAP_x86_MCHK:      /* Machine check exception */
+    case TRAP_x86_CACHEFLT:  /* Cache flush exception */
+        stack->rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+        break;
+    }
+done:
+    setup_raise_exception( sigcontext, stack );
+}
+
+/**********************************************************************
+ *		trap_handler
+ *
+ * Handler for SIGTRAP.
+ */
+static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    struct stack_layout *stack = setup_exception( sigcontext );
+
+    switch (siginfo->si_code)
+    {
+    case TRAP_TRACE:  /* Single-step exception */
+    case 4 /* TRAP_HWBKPT */: /* Hardware breakpoint exception */
+        stack->rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
+        break;
+    case TRAP_BRKPT:   /* Breakpoint exception */
+#ifdef SI_KERNEL
+    case SI_KERNEL:
+#endif
+        /* Check if this is actually icebp instruction */
+        if (((unsigned char *)stack->rec.ExceptionAddress)[-1] == 0xF1)
+        {
+            stack->rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
+            break;
+        }
+        stack->rec.ExceptionAddress = (char *)stack->rec.ExceptionAddress - 1;  /* back up over the int3 instruction */
+        /* fall through */
+    default:
+        stack->rec.ExceptionCode = EXCEPTION_BREAKPOINT;
+        stack->rec.NumberParameters = 1;
+        stack->rec.ExceptionInformation[0] = 0;
+        break;
+    }
+
+    setup_raise_exception( sigcontext, stack );
+}
+
+/**********************************************************************
+ *		fpe_handler
+ *
+ * Handler for SIGFPE.
+ */
+static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    struct stack_layout *stack = setup_exception( sigcontext );
+
+    switch (siginfo->si_code)
+    {
+    case FPE_FLTSUB:
+        stack->rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
+        break;
+    case FPE_INTDIV:
+        stack->rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
+        break;
+    case FPE_INTOVF:
+        stack->rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
+        break;
+    case FPE_FLTDIV:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_DIVIDE_BY_ZERO;
+        break;
+    case FPE_FLTOVF:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_OVERFLOW;
+        break;
+    case FPE_FLTUND:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_UNDERFLOW;
+        break;
+    case FPE_FLTRES:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_INEXACT_RESULT;
+        break;
+    case FPE_FLTINV:
+    default:
+        stack->rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
+        break;
+    }
+
+    setup_raise_exception( sigcontext, stack );
+}
+
+/**********************************************************************
+ *		int_handler
+ *
+ * Handler for SIGINT.
  */
-NTSTATUS WINAPI RtlWow64GetThreadContext( HANDLE handle, WOW64_CONTEXT *context )
+static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
-    return NtQueryInformationThread( handle, ThreadWow64Context, context, sizeof(*context), NULL );
+    if (!dispatch_signal(SIGINT))
+    {
+        struct stack_layout *stack = setup_exception( sigcontext );
+        stack->rec.ExceptionCode = CONTROL_C_EXIT;
+        setup_raise_exception( sigcontext, stack );
+    }
 }
 
 
-/******************************************************************************
- *              RtlWow64SetThreadContext  (NTDLL.@)
+/**********************************************************************
+ *		abrt_handler
+ *
+ * Handler for SIGABRT.
  */
-NTSTATUS WINAPI RtlWow64SetThreadContext( HANDLE handle, const WOW64_CONTEXT *context )
+static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
-    return NtSetInformationThread( handle, ThreadWow64Context, context, sizeof(*context) );
+    struct stack_layout *stack = setup_exception( sigcontext );
+    stack->rec.ExceptionCode = EXCEPTION_WINE_ASSERTION;
+    stack->rec.ExceptionFlags = EH_NONCONTINUABLE;
+    setup_raise_exception( sigcontext, stack );
 }
 
 
-static DWORD __cdecl nested_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
-                                               CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher )
+/**********************************************************************
+ *		quit_handler
+ *
+ * Handler for SIGQUIT.
+ */
+static void quit_handler( int signal, siginfo_t *siginfo, void *ucontext )
 {
-    if (!(rec->ExceptionFlags & (EH_UNWINDING | EH_EXIT_UNWIND)))
-        rec->ExceptionFlags |= EH_NESTED_CALL;
-
-    return ExceptionContinueSearch;
+    abort_thread(0);
 }
 
+
 /**********************************************************************
- *           call_handler
+ *		usr1_handler
  *
- * Call a single exception handler.
- * FIXME: Handle nested exceptions.
+ * Handler for SIGUSR1, used to signal a thread that it got suspended.
  */
-static DWORD call_handler( EXCEPTION_RECORD *rec, CONTEXT *context, DISPATCHER_CONTEXT *dispatch )
+static void usr1_handler( int signal, siginfo_t *siginfo, void *ucontext )
 {
-    EXCEPTION_REGISTRATION_RECORD frame;
-    DWORD res;
+    CONTEXT context;
 
-    frame.Handler = nested_exception_handler;
-    __wine_push_frame( &frame );
+    save_context( &context, ucontext );
+    wait_suspend( &context );
+    restore_context( &context, ucontext );
+}
 
-    TRACE( "calling handler %p (rec=%p, frame=0x%lx context=%p, dispatch=%p)\n",
-           dispatch->LanguageHandler, rec, dispatch->EstablisherFrame, dispatch->ContextRecord, dispatch );
-    res = dispatch->LanguageHandler( rec, (void *)dispatch->EstablisherFrame, context, dispatch );
-    TRACE( "handler at %p returned %u\n", dispatch->LanguageHandler, res );
 
-    rec->ExceptionFlags &= EH_NONCONTINUABLE;
-    __wine_pop_frame( &frame );
-    return res;
+/***********************************************************************
+ *           __wine_set_signal_handler   (NTDLL.@)
+ */
+int CDECL __wine_set_signal_handler(unsigned int sig, wine_signal_handler wsh)
+{
+    if (sig >= ARRAY_SIZE(handlers)) return -1;
+    if (handlers[sig] != NULL) return -2;
+    handlers[sig] = wsh;
+    return 0;
 }
 
 
 /**********************************************************************
- *           call_teb_handler
- *
- * Call a single exception handler from the TEB chain.
- * FIXME: Handle nested exceptions.
+ *             signal_init_threading
  */
-static DWORD call_teb_handler( EXCEPTION_RECORD *rec, CONTEXT *context, DISPATCHER_CONTEXT *dispatch,
-                                  EXCEPTION_REGISTRATION_RECORD *teb_frame )
+void signal_init_threading(void)
 {
-    DWORD res;
+}
 
-    TRACE( "calling TEB handler %p (rec=%p, frame=%p context=%p, dispatch=%p)\n",
-           teb_frame->Handler, rec, teb_frame, dispatch->ContextRecord, dispatch );
-    res = teb_frame->Handler( rec, teb_frame, context, (EXCEPTION_REGISTRATION_RECORD**)dispatch );
-    TRACE( "handler at %p returned %u\n", teb_frame->Handler, res );
-    return res;
+
+/**********************************************************************
+ *		signal_alloc_thread
+ */
+NTSTATUS signal_alloc_thread( TEB *teb )
+{
+    return STATUS_SUCCESS;
 }
 
 
 /**********************************************************************
- *           call_stack_handlers
- *
- * Call the stack handlers chain.
+ *		signal_free_thread
  */
-static NTSTATUS call_stack_handlers( EXCEPTION_RECORD *rec, CONTEXT *orig_context )
+void signal_free_thread( TEB *teb )
 {
-    EXCEPTION_REGISTRATION_RECORD *teb_frame = NtCurrentTeb()->Tib.ExceptionList;
-    UNWIND_HISTORY_TABLE table;
-    DISPATCHER_CONTEXT dispatch;
-    CONTEXT context;
-    NTSTATUS status;
+}
 
-    context = *orig_context;
-    dispatch.TargetIp      = 0;
-    dispatch.ContextRecord = &context;
-    dispatch.HistoryTable  = &table;
-    for (;;)
-    {
-        status = virtual_unwind( UNW_FLAG_EHANDLER, &dispatch, &context );
-        if (status != STATUS_SUCCESS) return status;
+#ifdef __APPLE__
+/**********************************************************************
+ *		mac_thread_gsbase
+ */
+static void *mac_thread_gsbase(void)
+{
+    struct thread_identifier_info tiinfo;
+    unsigned int info_count = THREAD_IDENTIFIER_INFO_COUNT;
+    static int gsbase_offset = -1;
+    void *ret;
 
-    unwind_done:
-        if (!dispatch.EstablisherFrame) break;
+    kern_return_t kr = thread_info(mach_thread_self(), THREAD_IDENTIFIER_INFO, (thread_info_t) &tiinfo, &info_count);
+    if (kr == KERN_SUCCESS)
+    {
+        TRACE("pthread_self() %p thread ID %llx gsbase %llx\n", pthread_self(), tiinfo.thread_id, tiinfo.thread_handle);
+        return (void*)tiinfo.thread_handle;
+    }
 
-        if ((dispatch.EstablisherFrame & 7) ||
-            dispatch.EstablisherFrame < (ULONG64)NtCurrentTeb()->Tib.StackLimit ||
-            dispatch.EstablisherFrame > (ULONG64)NtCurrentTeb()->Tib.StackBase)
+    if (gsbase_offset < 0)
+    {
+        /* Search for the array of TLS slots within the pthread data structure.
+           That's what the macOS pthread implementation uses for gsbase. */
+        const void* const sentinel1 = (const void*)0x2bffb6b4f11228ae;
+        const void* const sentinel2 = (const void*)0x0845a7ff6ab76707;
+        int rc;
+        pthread_key_t key;
+        const void** p = (const void**)pthread_self();
+        int i;
+
+        gsbase_offset = 0;
+        if ((rc = pthread_key_create(&key, NULL)))
         {
-            ERR( "invalid frame %lx (%p-%p)\n", dispatch.EstablisherFrame,
-                 NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
-            rec->ExceptionFlags |= EH_STACK_INVALID;
-            break;
+            ERR("failed to create sentinel key for gsbase search: %d\n", rc);
+            return NULL;
         }
 
-        if (dispatch.LanguageHandler)
-        {
-            switch (call_handler( rec, orig_context, &dispatch ))
-            {
-            case ExceptionContinueExecution:
-                if (rec->ExceptionFlags & EH_NONCONTINUABLE) return STATUS_NONCONTINUABLE_EXCEPTION;
-                return STATUS_SUCCESS;
-            case ExceptionContinueSearch:
-                break;
-            case ExceptionNestedException:
-                FIXME( "nested exception\n" );
-                break;
-            case ExceptionCollidedUnwind: {
-                ULONG64 frame;
+        pthread_setspecific(key, sentinel1);
 
-                context = *dispatch.ContextRecord;
-                dispatch.ContextRecord = &context;
-                RtlVirtualUnwind( UNW_FLAG_NHANDLER, dispatch.ImageBase,
-                        dispatch.ControlPc, dispatch.FunctionEntry,
-                        &context, NULL, &frame, NULL );
-                goto unwind_done;
-            }
-            default:
-                return STATUS_INVALID_DISPOSITION;
-            }
-        }
-        /* hack: call wine handlers registered in the tib list */
-        else while ((ULONG64)teb_frame < context.Rsp)
+        for (i = key + 1; i < 2000; i++) /* arbitrary limit */
         {
-            TRACE( "found wine frame %p rsp %lx handler %p\n",
-                    teb_frame, context.Rsp, teb_frame->Handler );
-            dispatch.EstablisherFrame = (ULONG64)teb_frame;
-            switch (call_teb_handler( rec, orig_context, &dispatch, teb_frame ))
+            if (p[i] == sentinel1)
             {
-            case ExceptionContinueExecution:
-                if (rec->ExceptionFlags & EH_NONCONTINUABLE) return STATUS_NONCONTINUABLE_EXCEPTION;
-                return STATUS_SUCCESS;
-            case ExceptionContinueSearch:
-                break;
-            case ExceptionNestedException:
-                FIXME( "nested exception\n" );
-                break;
-            case ExceptionCollidedUnwind: {
-                ULONG64 frame;
+                pthread_setspecific(key, sentinel2);
 
-                context = *dispatch.ContextRecord;
-                dispatch.ContextRecord = &context;
-                RtlVirtualUnwind( UNW_FLAG_NHANDLER, dispatch.ImageBase,
-                        dispatch.ControlPc, dispatch.FunctionEntry,
-                        &context, NULL, &frame, NULL );
-                teb_frame = teb_frame->Prev;
-                goto unwind_done;
-            }
-            default:
-                return STATUS_INVALID_DISPOSITION;
+                if (p[i] == sentinel2)
+                {
+                    gsbase_offset = (i - key) * sizeof(*p);
+                    break;
+                }
+
+                pthread_setspecific(key, sentinel1);
             }
-            teb_frame = teb_frame->Prev;
         }
 
-        if (context.Rsp == (ULONG64)NtCurrentTeb()->Tib.StackBase) break;
+        pthread_key_delete(key);
     }
-    return STATUS_UNHANDLED_EXCEPTION;
-}
-
-
-NTSTATUS WINAPI dispatch_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
-{
-    NTSTATUS status;
-    DWORD c;
 
-    TRACE( "code=%x flags=%x addr=%p ip=%lx tid=%04x\n",
-           rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress,
-           context->Rip, GetCurrentThreadId() );
-    for (c = 0; c < min( EXCEPTION_MAXIMUM_PARAMETERS, rec->NumberParameters ); c++)
-        TRACE( " info[%d]=%016lx\n", c, rec->ExceptionInformation[c] );
-
-    if (rec->ExceptionCode == EXCEPTION_WINE_STUB)
+    if (gsbase_offset)
     {
-        if (rec->ExceptionInformation[1] >> 16)
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%s, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], (char*)rec->ExceptionInformation[1] );
-        else
-            MESSAGE( "wine: Call from %p to unimplemented function %s.%ld, aborting\n",
-                     rec->ExceptionAddress,
-                     (char*)rec->ExceptionInformation[0], rec->ExceptionInformation[1] );
+        ret = (char*)pthread_self() + gsbase_offset;
+        TRACE("pthread_self() %p + offset 0x%08x -> gsbase %p\n", pthread_self(), gsbase_offset, ret);
     }
     else
     {
-        TRACE(" rax=%016lx rbx=%016lx rcx=%016lx rdx=%016lx\n",
-              context->Rax, context->Rbx, context->Rcx, context->Rdx );
-        TRACE(" rsi=%016lx rdi=%016lx rbp=%016lx rsp=%016lx\n",
-              context->Rsi, context->Rdi, context->Rbp, context->Rsp );
-        TRACE("  r8=%016lx  r9=%016lx r10=%016lx r11=%016lx\n",
-              context->R8, context->R9, context->R10, context->R11 );
-        TRACE(" r12=%016lx r13=%016lx r14=%016lx r15=%016lx\n",
-              context->R12, context->R13, context->R14, context->R15 );
+        ret = NULL;
+        ERR("failed to locate gsbase; won't be able to poke ThreadLocalStoragePointer into pthread TLS; expect crashes\n");
     }
 
-    if (call_vectored_handlers( rec, context ) == EXCEPTION_CONTINUE_EXECUTION)
-        NtContinue( context, FALSE );
+    return ret;
+}
+#endif
 
-    if ((status = call_stack_handlers( rec, context )) == STATUS_SUCCESS)
-        NtContinue( context, FALSE );
 
-    if (status != STATUS_UNHANDLED_EXCEPTION) RtlRaiseStatus( status );
-    return NtRaiseException( rec, context, FALSE );
+/**********************************************************************
+ *		signal_init_thread
+ */
+void signal_init_thread( TEB *teb )
+{
+    const WORD fpu_cw = 0x27f;
+    stack_t ss;
+
+#if defined __linux__
+    arch_prctl( ARCH_SET_GS, teb );
+#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
+    amd64_set_gsbase( teb );
+#elif defined(__NetBSD__)
+    sysarch( X86_64_SET_GSBASE, &teb );
+#elif defined (__APPLE__)
+    __asm__ volatile (".byte 0x65\n\tmovq %0,%c1"
+                      :
+                      : "r" (teb->Tib.Self), "n" (FIELD_OFFSET(TEB, Tib.Self)));
+    __asm__ volatile (".byte 0x65\n\tmovq %0,%c1"
+                      :
+                      : "r" (teb->ThreadLocalStoragePointer), "n" (FIELD_OFFSET(TEB, ThreadLocalStoragePointer)));
+
+    /* alloc_tls_slot() needs to poke a value to an address relative to each
+       thread's gsbase.  Have each thread record its gsbase pointer into its
+       TEB so alloc_tls_slot() can find it. */
+    teb->Reserved5[0] = mac_thread_gsbase();
+#else
+# error Please define setting %gs for your architecture
+#endif
+
+    ss.ss_sp    = (char *)teb + teb_size;
+    ss.ss_size  = signal_stack_size;
+    ss.ss_flags = 0;
+    if (sigaltstack(&ss, NULL) == -1) perror( "sigaltstack" );
+
+#ifdef __GNUC__
+    __asm__ volatile ("fninit; fldcw %0" : : "m" (fpu_cw));
+#else
+    FIXME("FPU setup not implemented for this platform.\n");
+#endif
 }
 
+/**********************************************************************
+ *		signal_init_process
+ */
+void signal_init_process(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
+
+    sig_act.sa_sigaction = int_handler;
+    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = fpe_handler;
+    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = abrt_handler;
+    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = quit_handler;
+    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
+
+    sig_act.sa_sigaction = segv_handler;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
+    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
+#ifdef SIGBUS
+    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+#endif
+
+#ifdef SIGTRAP
+    sig_act.sa_sigaction = trap_handler;
+    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
+#endif
+    return;
+
+ error:
+    perror("sigaction");
+    exit(1);
+}
 
-/*******************************************************************
- *		KiUserExceptionDispatcher (NTDLL.@)
- */
-__ASM_GLOBAL_FUNC( KiUserExceptionDispatcher,
-                  "mov 0x98(%rsp),%rcx\n\t" /* context->Rsp */
-                  "mov 0xf8(%rsp),%rdx\n\t" /* context->Rip */
-                  "mov %rdx,-0x8(%rcx)\n\t"
-                  "mov %rbp,-0x10(%rcx)\n\t"
-                  "mov %rdi,-0x18(%rcx)\n\t"
-                  "mov %rsi,-0x20(%rcx)\n\t"
-                  "lea -0x20(%rcx),%rbp\n\t"
-                  "mov %rsp,%rdx\n\t" /* context */
-                  "lea 0x4f0(%rsp),%rcx\n\t" /* rec */
-                  __ASM_SEH(".seh_pushreg %rbp\n\t")
-                  __ASM_SEH(".seh_pushreg %rdi\n\t")
-                  __ASM_SEH(".seh_pushreg %rsi\n\t")
-                  __ASM_SEH(".seh_setframe %rbp,0\n\t")
-                  __ASM_SEH(".seh_endprologue\n\t")
-
-                  __ASM_CFI(".cfi_signal_frame\n\t")
-                  __ASM_CFI(".cfi_adjust_cfa_offset 0x20\n\t")
-                  __ASM_CFI(".cfi_def_cfa %rbp,0x20\n\t")
-                  __ASM_CFI(".cfi_rel_offset %rip,0x18\n\t")
-                  __ASM_CFI(".cfi_rel_offset %rbp,0x10\n\t")
-                  __ASM_CFI(".cfi_rel_offset %rdi,0x8\n\t")
-                  __ASM_CFI(".cfi_rel_offset %rsi,0\n\t")
-                   "call " __ASM_NAME("dispatch_exception") "\n\t"
-                  "int3")
 
 static ULONG64 get_int_reg( CONTEXT *context, int reg )
 {
@@ -792,7 +3473,6 @@ PVOID WINAPI RtlVirtualUnwind( ULONG type, ULONG64 base, ULONG64 pc,
     ULONG64 frame, off;
     struct UNWIND_INFO *info;
     unsigned int i, prolog_offset;
-    BOOL mach_frame = FALSE;
 
     TRACE( "type %x rip %lx rsp %lx\n", type, pc, context->Rsp );
     if (TRACE_ON(seh)) dump_unwind_info( base, function );
@@ -815,16 +3495,13 @@ PVOID WINAPI RtlVirtualUnwind( ULONG type, ULONG64 base, ULONG64 pc,
         /* check if in prolog */
         if (pc >= base + function->BeginAddress && pc < base + function->BeginAddress + info->prolog)
         {
-            TRACE("inside prolog.\n");
             prolog_offset = pc - base - function->BeginAddress;
         }
         else
         {
             prolog_offset = ~0;
-            /* Since Win10 1809 epilogue does not have a special treatment in case of zero opcode count. */
-            if (info->count && is_inside_epilog( (BYTE *)pc, base, function ))
+            if (is_inside_epilog( (BYTE *)pc, base, function ))
             {
-                TRACE("inside epilog.\n");
                 interpret_epilog( (BYTE *)pc, context, ctx_ptr );
                 *frame_ret = frame;
                 return NULL;
@@ -868,23 +3545,7 @@ PVOID WINAPI RtlVirtualUnwind( ULONG type, ULONG64 base, ULONG64 pc,
                 set_float_reg( context, ctx_ptr, info->opcodes[i].info, (M128A *)off );
                 break;
             case UWOP_PUSH_MACHFRAME:
-                if (info->flags & UNW_FLAG_CHAININFO)
-                {
-                    FIXME("PUSH_MACHFRAME with chained unwind info.\n");
-                    break;
-                }
-                if (i + get_opcode_size(info->opcodes[i]) < info->count )
-                {
-                    FIXME("PUSH_MACHFRAME is not the last opcode.\n");
-                    break;
-                }
-
-                if (info->opcodes[i].info)
-                    context->Rsp += 0x8;
-
-                context->Rip = *(ULONG64 *)context->Rsp;
-                context->Rsp = *(ULONG64 *)(context->Rsp + 24);
-                mach_frame = TRUE;
+                FIXME( "PUSH_MACHFRAME %u\n", info->opcodes[i].info );
                 break;
             case UWOP_EPILOG:
                 if (info->version == 2)
@@ -899,12 +3560,9 @@ PVOID WINAPI RtlVirtualUnwind( ULONG type, ULONG64 base, ULONG64 pc,
         function = &handler_data->chain;  /* restart with the chained info */
     }
 
-    if (!mach_frame)
-    {
-        /* now pop return address */
-        context->Rip = *(ULONG64 *)context->Rsp;
-        context->Rsp += sizeof(ULONG64);
-    }
+    /* now pop return address */
+    context->Rip = *(ULONG64 *)context->Rsp;
+    context->Rsp += sizeof(ULONG64);
 
     if (!(info->flags & type)) return NULL;  /* no matching handler */
     if (prolog_offset != ~0) return NULL;  /* inside prolog */
@@ -1014,8 +3672,8 @@ static DWORD call_teb_unwind_handler( EXCEPTION_RECORD *rec, DISPATCHER_CONTEXT
  * Wrapper function to call a consolidate callback from a fake frame.
  * If the callback executes RtlUnwindEx (like for example done in C++ handlers),
  * we have to skip all frames which were already processed. To do that we
- * trick the unwinding functions into thinking the call came from the specified
- * context. All CFI instructions are either DW_CFA_def_cfa_expression or
+ * trick the unwinding functions into thinking the call came from somewhere
+ * else. All CFI instructions are either DW_CFA_def_cfa_expression or
  * DW_CFA_expression, and the expressions have the following format:
  *
  * DW_OP_breg6; sleb128 0x10            | Load %rbp + 0x10
@@ -1028,26 +3686,15 @@ extern void * WINAPI call_consolidate_callback( CONTEXT *context,
                                                 EXCEPTION_RECORD *rec );
 __ASM_GLOBAL_FUNC( call_consolidate_callback,
                    "pushq %rbp\n\t"
+                   __ASM_SEH(".seh_pushreg %rbp\n\t")
                    __ASM_CFI(".cfi_adjust_cfa_offset 8\n\t")
                    __ASM_CFI(".cfi_rel_offset %rbp,0\n\t")
                    "movq %rsp,%rbp\n\t"
+                   __ASM_SEH(".seh_setframe %rbp,0\n\t")
                    __ASM_CFI(".cfi_def_cfa_register %rbp\n\t")
-
-                   /* Setup SEH machine frame. */
-                   "subq $0x28,%rsp\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset 0x28\n\t")
-                   "movq 0xf8(%rcx),%rax\n\t" /* Context->Rip */
-                   "movq %rax,(%rsp)\n\t"
-                   "movq 0x98(%rcx),%rax\n\t" /* context->Rsp */
-                   "movq %rax,0x18(%rsp)\n\t"
-                   __ASM_SEH(".seh_pushframe\n\t")
+                   "subq $0x20,%rsp\n\t"
+                   __ASM_SEH(".seh_stackalloc 0x20\n\t")
                    __ASM_SEH(".seh_endprologue\n\t")
-
-                   "subq $0xf8,%rsp\n\t" /* 10*16 (float regs) + 7*8 (int regs) + 32 (shadow store). */
-                   __ASM_SEH(".seh_stackalloc 0xf8\n\t")
-                   __ASM_CFI(".cfi_adjust_cfa_offset 0xf8\n\t")
-
-                   /* Setup CFI unwind to context. */
                    "movq %rcx,0x10(%rbp)\n\t"
                    __ASM_CFI(".cfi_remember_state\n\t")
                    __ASM_CFI(".cfi_escape 0x0f,0x07,0x76,0x10,0x06,0x23,0x98,0x01,0x06\n\t") /* CFA    */
@@ -1070,57 +3717,9 @@ __ASM_GLOBAL_FUNC( call_consolidate_callback,
                    __ASM_CFI(".cfi_escape 0x10,0x1e,0x06,0x76,0x10,0x06,0x23,0xf0,0x04\n\t") /* %xmm13 */
                    __ASM_CFI(".cfi_escape 0x10,0x1f,0x06,0x76,0x10,0x06,0x23,0x80,0x05\n\t") /* %xmm14 */
                    __ASM_CFI(".cfi_escape 0x10,0x20,0x06,0x76,0x10,0x06,0x23,0x90,0x05\n\t") /* %xmm15 */
-
-                   /* Setup SEH unwind registers restore. */
-                   "movq 0x90(%rcx),%rax\n\t" /* context->Rbx */
-                   "movq %rax,0x20(%rsp)\n\t"
-                   __ASM_SEH(".seh_savereg %rbx, 0x20\n\t")
-                   "movq 0xa8(%rcx),%rax\n\t" /* context->Rsi */
-                   "movq %rax,0x28(%rsp)\n\t"
-                   __ASM_SEH(".seh_savereg %rsi, 0x28\n\t")
-                   "movq 0xb0(%rcx),%rax\n\t" /* context->Rdi */
-                   "movq %rax,0x30(%rsp)\n\t"
-                   __ASM_SEH(".seh_savereg %rdi, 0x30\n\t")
-
-                   "movq 0xd8(%rcx),%rax\n\t" /* context->R12 */
-                   "movq %rax,0x38(%rsp)\n\t"
-                   __ASM_SEH(".seh_savereg %r12, 0x38\n\t")
-                   "movq 0xe0(%rcx),%rax\n\t" /* context->R13 */
-                   "movq %rax,0x40(%rsp)\n\t"
-                   __ASM_SEH(".seh_savereg %r13, 0x40\n\t")
-                   "movq 0xe8(%rcx),%rax\n\t" /* context->R14 */
-                   "movq %rax,0x48(%rsp)\n\t"
-                   __ASM_SEH(".seh_savereg %r14, 0x48\n\t")
-                   "movq 0xf0(%rcx),%rax\n\t" /* context->R15 */
-                   "movq %rax,0x50(%rsp)\n\t"
-                   __ASM_SEH(".seh_savereg %r15, 0x50\n\t")
-                   "pushq %rsi\n\t"
-                   "pushq %rdi\n\t"
-                   "leaq 0x200(%rcx),%rsi\n\t"
-                   "leaq 0x60(%rsp),%rdi\n\t"
-                   "movq $0x14,%rcx\n\t"
-                   "cld\n\t"
-                   "rep; movsq\n\t"
-                   "popq %rdi\n\t"
-                   "popq %rsi\n\t"
-                   __ASM_SEH(".seh_savexmm %xmm6, 0x60\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm7, 0x70\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm8, 0x80\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm9, 0x90\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm10, 0xa0\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm11, 0xb0\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm12, 0xc0\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm13, 0xd0\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm14, 0xe0\n\t")
-                   __ASM_SEH(".seh_savexmm %xmm15, 0xf0\n\t")
-
-                   /* call the callback. */
                    "movq %r8,%rcx\n\t"
                    "callq *%rdx\n\t"
                    __ASM_CFI(".cfi_restore_state\n\t")
-                   "nop\n\t" /* Otherwise RtlVirtualUnwind() will think we are inside epilogue and
-                              * interpret / execute the rest of opcodes here instead of unwind through
-                              * machine frame. */
                    "leaq 0(%rbp),%rsp\n\t"
                    __ASM_CFI(".cfi_def_cfa_register %rsp\n\t")
                    "popq %rbp\n\t"
@@ -1174,7 +3773,7 @@ void CDECL RtlRestoreContext( CONTEXT *context, EXCEPTION_RECORD *rec )
     }
 
     TRACE( "returning to %lx stack %lx\n", context->Rip, context->Rsp );
-    NtSetContextThread( GetCurrentThread(), context );
+    set_cpu_context( context );
 }
 
 
@@ -1233,6 +3832,14 @@ void WINAPI RtlUnwindEx( PVOID end_frame, PVOID target_ip, EXCEPTION_RECORD *rec
     unwind_done:
         if (!dispatch.EstablisherFrame) break;
 
+        if (is_inside_signal_stack( (void *)dispatch.EstablisherFrame ))
+        {
+            TRACE( "frame %lx is inside signal stack (%p-%p)\n", dispatch.EstablisherFrame,
+                   get_signal_stack(), (char *)get_signal_stack() + signal_stack_size );
+            *context = new_context;
+            continue;
+        }
+
         if ((dispatch.EstablisherFrame & 7) ||
             dispatch.EstablisherFrame < (ULONG64)NtCurrentTeb()->Tib.StackLimit ||
             dispatch.EstablisherFrame > (ULONG64)NtCurrentTeb()->Tib.StackBase)
@@ -1417,12 +4024,7 @@ __ASM_GLOBAL_FUNC( RtlRaiseException,
                    "movq %rax,0xf8(%rdx)\n\t"   /* context->Rip */
                    "movq %rax,0x10(%rcx)\n\t"   /* rec->ExceptionAddress */
                    "movl $1,%r8d\n\t"
-                   "movq %gs:(0x30),%rax\n\t"   /* Teb */
-                   "movq 0x60(%rax),%rax\n\t"   /* Peb */
-                   "cmpb $0,0x02(%rax)\n\t"     /* BeingDebugged */
-                   "jne 1f\n\t"
-                   "call " __ASM_NAME("dispatch_exception") "\n"
-                   "1:\tcall " __ASM_NAME("NtRaiseException") "\n\t"
+                   "call " __ASM_NAME("NtRaiseException") "\n\t"
                    "movq %rax,%rcx\n\t"
                    "call " __ASM_NAME("RtlRaiseStatus") /* does not return */ );
 
@@ -1493,6 +4095,189 @@ USHORT WINAPI RtlCaptureStackBackTrace( ULONG skip, ULONG count, PVOID *buffer,
 }
 
 
+/***********************************************************************
+ *           call_thread_func
+ */
+static void WINAPI call_thread_func( LPTHREAD_START_ROUTINE entry, void *arg )
+{
+    __TRY
+    {
+        TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", entry, arg );
+        RtlExitUserThread( entry( arg ));
+    }
+    __EXCEPT(call_unhandled_exception_filter)
+    {
+        NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+    }
+    __ENDTRY
+    abort();  /* should not be reached */
+}
+
+
+extern void DECLSPEC_NORETURN start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend,
+                                            void *relay );
+__ASM_GLOBAL_FUNC( start_thread,
+                   "subq $56,%rsp\n\t"
+                   __ASM_SEH(".seh_stackalloc 56\n\t")
+                   __ASM_SEH(".seh_endprologue\n\t")
+                   __ASM_CFI(".cfi_adjust_cfa_offset 56\n\t")
+                   "movq %rbp,48(%rsp)\n\t"
+                   __ASM_CFI(".cfi_rel_offset %rbp,48\n\t")
+                   "movq %rbx,40(%rsp)\n\t"
+                   __ASM_CFI(".cfi_rel_offset %rbx,40\n\t")
+                   "movq %r12,32(%rsp)\n\t"
+                   __ASM_CFI(".cfi_rel_offset %r12,32\n\t")
+                   "movq %r13,24(%rsp)\n\t"
+                   __ASM_CFI(".cfi_rel_offset %r13,24\n\t")
+                   "movq %r14,16(%rsp)\n\t"
+                   __ASM_CFI(".cfi_rel_offset %r14,16\n\t")
+                   "movq %r15,8(%rsp)\n\t"
+                   __ASM_CFI(".cfi_rel_offset %r15,8\n\t")
+                   /* store exit frame */
+                   "movq %gs:0x30,%rax\n\t"
+                   "movq %rsp,0x330(%rax)\n\t"      /* amd64_thread_data()->exit_frame */
+                   /* switch to thread stack */
+                   "movq 8(%rax),%rax\n\t"          /* NtCurrentTeb()->Tib.StackBase */
+                   "leaq -0x1000(%rax),%rsp\n\t"
+                   /* attach dlls */
+                   "call " __ASM_NAME("attach_thread") "\n\t"
+                   "movq %rax,%rsp\n\t"
+                   /* clear the stack */
+                   "andq $~0xfff,%rax\n\t"  /* round down to page size */
+                   "movq %rax,%rdi\n\t"
+                   "call " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
+                   /* switch to the initial context */
+                   "movq %rsp,%rdi\n\t"
+                   "call " __ASM_NAME("set_cpu_context") )
+
+extern void DECLSPEC_NORETURN call_thread_exit_func( int status, void (*func)(int) );
+__ASM_GLOBAL_FUNC( call_thread_exit_func,
+                   /* fetch exit frame */
+                   "movq %gs:0x30,%rax\n\t"
+                   "movq 0x330(%rax),%rdx\n\t"      /* amd64_thread_data()->exit_frame */
+                   "testq %rdx,%rdx\n\t"
+                   "jnz 1f\n\t"
+                   "jmp *%rsi\n"
+                   /* switch to exit frame stack */
+                   "1:\tmovq $0,0x330(%rax)\n\t"
+                   "movq %rdx,%rsp\n\t"
+                   __ASM_CFI(".cfi_adjust_cfa_offset 56\n\t")
+                   __ASM_CFI(".cfi_rel_offset %rbp,48\n\t")
+                   __ASM_CFI(".cfi_rel_offset %rbx,40\n\t")
+                   __ASM_CFI(".cfi_rel_offset %r12,32\n\t")
+                   __ASM_CFI(".cfi_rel_offset %r13,24\n\t")
+                   __ASM_CFI(".cfi_rel_offset %r14,16\n\t")
+                   __ASM_CFI(".cfi_rel_offset %r15,8\n\t")
+                   "call *%rsi" )
+
+
+/***********************************************************************
+ *           init_thread_context
+ */
+static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
+{
+    __asm__( "movw %%cs,%0" : "=m" (context->SegCs) );
+    __asm__( "movw %%ss,%0" : "=m" (context->SegSs) );
+    context->Rcx    = (ULONG_PTR)entry;
+    context->Rdx    = (ULONG_PTR)arg;
+    context->Rsp    = (ULONG_PTR)NtCurrentTeb()->Tib.StackBase - 0x28;
+    context->Rip    = (ULONG_PTR)relay;
+    context->EFlags = 0x200;
+    context->u.FltSave.ControlWord = 0x27f;
+    context->u.FltSave.MxCsr = context->MxCsr = 0x1f80;
+}
+
+
+/***********************************************************************
+ *           attach_thread
+ */
+PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
+                                        BOOL suspend, void *relay )
+{
+    CONTEXT *ctx;
+
+    if (suspend)
+    {
+        CONTEXT context = { 0 };
+
+        context.ContextFlags = CONTEXT_ALL;
+        init_thread_context( &context, entry, arg, relay );
+        wait_suspend( &context );
+        ctx = (CONTEXT *)((ULONG_PTR)context.Rsp & ~15) - 1;
+        *ctx = context;
+    }
+    else
+    {
+        ctx = (CONTEXT *)((char *)NtCurrentTeb()->Tib.StackBase - 0x30) - 1;
+        init_thread_context( ctx, entry, arg, relay );
+    }
+    ctx->ContextFlags = CONTEXT_FULL;
+    LdrInitializeThunk( ctx, (void **)&ctx->Rcx, 0, 0 );
+    return ctx;
+}
+
+
+/***********************************************************************
+ *           signal_start_thread
+ *
+ * Thread startup sequence:
+ * signal_start_thread()
+ *   -> start_thread()
+ *     -> call_thread_func()
+ */
+void signal_start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend )
+{
+    start_thread( entry, arg, suspend, call_thread_func );
+}
+
+
+/**********************************************************************
+ *		signal_start_process
+ *
+ * Process startup sequence:
+ * signal_start_process()
+ *   -> start_thread()
+ *     -> kernel32_start_process()
+ */
+void signal_start_process( LPTHREAD_START_ROUTINE entry, BOOL suspend )
+{
+    start_thread( entry, NtCurrentTeb()->Peb, suspend, kernel32_start_process );
+}
+
+
+/***********************************************************************
+ *           signal_exit_thread
+ */
+void signal_exit_thread( int status )
+{
+    call_thread_exit_func( status, exit_thread );
+}
+
+/***********************************************************************
+ *           signal_exit_process
+ */
+void signal_exit_process( int status )
+{
+    call_thread_exit_func( status, exit );
+}
+
+/**********************************************************************
+ *           get_thread_ldt_entry
+ */
+NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ *           NtSetLdtEntries   (NTDLL.@)
+ *           ZwSetLdtEntries   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
 /**********************************************************************
  *		DbgBreakPoint   (NTDLL.@)
  */
diff --git a/dlls/ntdll/string.c b/dlls/ntdll/string.c
index 588b5dd5de..709f0ebdbd 100644
--- a/dlls/ntdll/string.c
+++ b/dlls/ntdll/string.c
@@ -20,6 +20,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
+#include <ctype.h>
 #include <limits.h>
 #include <stdarg.h>
 #include <stdlib.h>
@@ -27,69 +31,24 @@
 #include <string.h>
 
 #include "windef.h"
-#include "winbase.h"
-#include "winnls.h"
 #include "winternl.h"
-#include "ntdll_misc.h"
-
-
-/* same as wctypes except for TAB, which doesn't have C1_BLANK for some reason... */
-static const unsigned short ctypes[257] =
-{
-    /* -1 */
-    0x0000,
-    /* 00 */
-    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
-    0x0020, 0x0028, 0x0028, 0x0028, 0x0028, 0x0028, 0x0020, 0x0020,
-    /* 10 */
-    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
-    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
-    /* 20 */
-    0x0048, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    /* 30 */
-    0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084,
-    0x0084, 0x0084, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    /* 40 */
-    0x0010, 0x0181, 0x0181, 0x0181, 0x0181, 0x0181, 0x0181, 0x0101,
-    0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,
-    /* 50 */
-    0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,
-    0x0101, 0x0101, 0x0101, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    /* 60 */
-    0x0010, 0x0182, 0x0182, 0x0182, 0x0182, 0x0182, 0x0182, 0x0102,
-    0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102,
-    /* 70 */
-    0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102,
-    0x0102, 0x0102, 0x0102, 0x0010, 0x0010, 0x0010, 0x0010, 0x0020
-};
 
 
 /*********************************************************************
  *                  memchr   (NTDLL.@)
  */
-void * __cdecl memchr( const void *ptr, int c, size_t n )
+void * __cdecl NTDLL_memchr( const void *ptr, int c, size_t n )
 {
-    const unsigned char *p = ptr;
-
-    for (p = ptr; n; n--, p++) if (*p == c) return (void *)(ULONG_PTR)p;
-    return NULL;
+    return memchr( ptr, c, n );
 }
 
 
 /*********************************************************************
  *                  memcmp   (NTDLL.@)
  */
-int __cdecl memcmp( const void *ptr1, const void *ptr2, size_t n )
+int __cdecl NTDLL_memcmp( const void *ptr1, const void *ptr2, size_t n )
 {
-    const unsigned char *p1, *p2;
-
-    for (p1 = ptr1, p2 = ptr2; n; n--, p1++, p2++)
-    {
-        if (*p1 < *p2) return -1;
-        if (*p1 > *p2) return 1;
-    }
-    return 0;
+    return memcmp( ptr1, ptr2, n );
 }
 
 
@@ -99,218 +58,153 @@ int __cdecl memcmp( const void *ptr1, const void *ptr2, size_t n )
  * NOTES
  *  Behaves like memmove.
  */
-void * __cdecl memcpy( void *dst, const void *src, size_t n )
+void * __cdecl NTDLL_memcpy( void *dst, const void *src, size_t n )
 {
-    volatile unsigned char *d = dst;  /* avoid gcc optimizations */
-    const unsigned char *s = src;
-
-    if ((size_t)dst - (size_t)src >= n)
-    {
-        while (n--) *d++ = *s++;
-    }
-    else
-    {
-        d += n - 1;
-        s += n - 1;
-        while (n--) *d-- = *s--;
-    }
-    return dst;
+    return memmove( dst, src, n );
 }
 
 
 /*********************************************************************
  *                  memmove   (NTDLL.@)
  */
-void * __cdecl memmove( void *dst, const void *src, size_t n )
+void * __cdecl NTDLL_memmove( void *dst, const void *src, size_t n )
 {
-    volatile unsigned char *d = dst;  /* avoid gcc optimizations */
-    const unsigned char *s = src;
-
-    if ((size_t)dst - (size_t)src >= n)
-    {
-        while (n--) *d++ = *s++;
-    }
-    else
-    {
-        d += n - 1;
-        s += n - 1;
-        while (n--) *d-- = *s--;
-    }
-    return dst;
+    return memmove( dst, src, n );
 }
 
 
 /*********************************************************************
  *                  memset   (NTDLL.@)
  */
-void * __cdecl memset( void *dst, int c, size_t n )
+void * __cdecl NTDLL_memset( void *dst, int c, size_t n )
 {
-    volatile unsigned char *d = dst;  /* avoid gcc optimizations */
-    while (n--) *d++ = c;
-    return dst;
+    return memset( dst, c, n );
 }
 
 
 /*********************************************************************
  *                  strcat   (NTDLL.@)
  */
-char * __cdecl strcat( char *dst, const char *src )
+char * __cdecl NTDLL_strcat( char *dst, const char *src )
 {
-    char *d = dst;
-    while (*d) d++;
-    while ((*d++ = *src++));
-    return dst;
+    return strcat( dst, src );
 }
 
 
 /*********************************************************************
  *                  strchr   (NTDLL.@)
  */
-char * __cdecl strchr( const char *str, int c )
+char * __cdecl NTDLL_strchr( const char *str, int c )
 {
-    do { if (*str == (char)c) return (char *)(ULONG_PTR)str; } while (*str++);
-    return NULL;
+    return strchr( str, c );
 }
 
 
 /*********************************************************************
  *                  strcmp   (NTDLL.@)
  */
-int __cdecl strcmp( const char *str1, const char *str2 )
+int __cdecl NTDLL_strcmp( const char *str1, const char *str2 )
 {
-    while (*str1 && *str1 == *str2) { str1++; str2++; }
-    if ((unsigned char)*str1 > (unsigned char)*str2) return 1;
-    if ((unsigned char)*str1 < (unsigned char)*str2) return -1;
-    return 0;
+    return strcmp( str1, str2 );
 }
 
 
 /*********************************************************************
  *                  strcpy   (NTDLL.@)
  */
-char * __cdecl strcpy( char *dst, const char *src )
+char * __cdecl NTDLL_strcpy( char *dst, const char *src )
 {
-    char *d = dst;
-    while ((*d++ = *src++));
-    return dst;
+    return strcpy( dst, src );
 }
 
 
 /*********************************************************************
  *                  strcspn   (NTDLL.@)
  */
-size_t __cdecl strcspn( const char *str, const char *reject )
+size_t __cdecl NTDLL_strcspn( const char *str, const char *reject )
 {
-    const char *ptr;
-    for (ptr = str; *ptr; ptr++) if (strchr( reject, *ptr )) break;
-    return ptr - str;
+    return strcspn( str, reject );
 }
 
 
 /*********************************************************************
  *                  strlen   (NTDLL.@)
  */
-size_t __cdecl strlen( const char *str )
+size_t __cdecl NTDLL_strlen( const char *str )
 {
-    const char *s = str;
-    while (*s) s++;
-    return s - str;
+    return strlen( str );
 }
 
 
 /*********************************************************************
  *                  strncat   (NTDLL.@)
  */
-char * __cdecl strncat( char *dst, const char *src, size_t len )
+char * __cdecl NTDLL_strncat( char *dst, const char *src, size_t len )
 {
-    char *d = dst;
-    while (*d) d++;
-    for ( ; len && *src; d++, src++, len--) *d = *src;
-    *d = 0;
-    return dst;
+    return strncat( dst, src, len );
 }
 
 
 /*********************************************************************
  *                  strncmp   (NTDLL.@)
  */
-int __cdecl strncmp( const char *str1, const char *str2, size_t len )
+int __cdecl NTDLL_strncmp( const char *str1, const char *str2, size_t len )
 {
-    if (!len) return 0;
-    while (--len && *str1 && *str1 == *str2) { str1++; str2++; }
-    return (unsigned char)*str1 - (unsigned char)*str2;
+    return strncmp( str1, str2, len );
 }
 
 
 /*********************************************************************
  *                  strncpy   (NTDLL.@)
  */
-#undef strncpy
-char * __cdecl strncpy( char *dst, const char *src, size_t len )
+char * __cdecl NTDLL_strncpy( char *dst, const char *src, size_t len )
 {
-    char *d;
-    for (d = dst; len && *src; d++, src++, len--) *d = *src;
-    while (len--) *d++ = 0;
-    return dst;
+    return strncpy( dst, src, len );
 }
 
 
 /*********************************************************************
  *                  strnlen   (NTDLL.@)
  */
-size_t __cdecl strnlen( const char *str, size_t len )
+size_t __cdecl NTDLL_strnlen( const char *str, size_t len )
 {
-    const char *s = str;
-    for (s = str; len && *s; s++, len--) ;
-    return s - str;
+    return strnlen( str, len );
 }
 
 
 /*********************************************************************
  *                  strpbrk   (NTDLL.@)
  */
-char * __cdecl strpbrk( const char *str, const char *accept )
+char * __cdecl NTDLL_strpbrk( const char *str, const char *accept )
 {
-    for ( ; *str; str++) if (strchr( accept, *str )) return (char *)(ULONG_PTR)str;
-    return NULL;
+    return strpbrk( str, accept );
 }
 
 
 /*********************************************************************
  *                  strrchr   (NTDLL.@)
  */
-char * __cdecl strrchr( const char *str, int c )
+char * __cdecl NTDLL_strrchr( const char *str, int c )
 {
-    char *ret = NULL;
-    do { if (*str == (char)c) ret = (char *)(ULONG_PTR)str; } while (*str++);
-    return ret;
+    return strrchr( str, c );
 }
 
 
 /*********************************************************************
  *                  strspn   (NTDLL.@)
  */
-size_t __cdecl strspn( const char *str, const char *accept )
+size_t __cdecl NTDLL_strspn( const char *str, const char *accept )
 {
-    const char *ptr;
-    for (ptr = str; *ptr; ptr++) if (!strchr( accept, *ptr )) break;
-    return ptr - str;
+    return strspn( str, accept );
 }
 
 
 /*********************************************************************
  *                  strstr   (NTDLL.@)
  */
-char * __cdecl strstr( const char *str, const char *sub )
+char * __cdecl NTDLL_strstr( const char *haystack, const char *needle )
 {
-    while (*str)
-    {
-        const char *p1 = str, *p2 = sub;
-        while (*p1 && *p2 && *p1 == *p2) { p1++; p2++; }
-        if (!*p2) return (char *)str;
-        str++;
-    }
-    return NULL;
+    return strstr( haystack, needle );
 }
 
 
@@ -319,17 +213,14 @@ char * __cdecl strstr( const char *str, const char *sub )
  */
 void * __cdecl _memccpy( void *dst, const void *src, int c, size_t n )
 {
-    unsigned char *d = dst;
-    const unsigned char *s = src;
-    while (n--) if ((*d++ = *s++) == (unsigned char)c) return d;
-    return NULL;
+    return memccpy( dst, src, c, n );
 }
 
 
 /*********************************************************************
  *                  tolower   (NTDLL.@)
  */
-int __cdecl tolower( int c )
+int __cdecl NTDLL_tolower( int c )
 {
     return (char)c >= 'A' && (char)c <= 'Z' ? c - 'A' + 'a' : c;
 }
@@ -353,13 +244,12 @@ int __cdecl tolower( int c )
  *  Any Nul characters in s1 or s2 are ignored. This function always
  *  compares up to len bytes or the first place where s1 and s2 differ.
  */
-int __cdecl _memicmp( const void *str1, const void *str2, size_t len )
+INT __cdecl _memicmp( LPCSTR s1, LPCSTR s2, DWORD len )
 {
-    const unsigned char *s1 = str1, *s2 = str2;
     int ret = 0;
     while (len--)
     {
-        if ((ret = tolower(*s1) - tolower(*s2))) break;
+        if ((ret = NTDLL_tolower(*s1) - NTDLL_tolower(*s2))) break;
         s1++;
         s2++;
     }
@@ -376,8 +266,8 @@ int __cdecl _strnicmp( LPCSTR str1, LPCSTR str2, size_t n )
 
     while (n--)
     {
-        l1 = (unsigned char)tolower(*str1);
-        l2 = (unsigned char)tolower(*str2);
+        l1 = (unsigned char)NTDLL_tolower(*str1);
+        l2 = (unsigned char)NTDLL_tolower(*str2);
         if (l1 != l2)
         {
             if (sizeof(void *) > sizeof(int)) return l1 - l2;
@@ -436,7 +326,7 @@ LPSTR __cdecl _strupr( LPSTR str )
 LPSTR __cdecl _strlwr( LPSTR str )
 {
     LPSTR ret = str;
-    for ( ; *str; str++) *str = tolower(*str);
+    for ( ; *str; str++) *str = NTDLL_tolower(*str);
     return ret;
 }
 
@@ -444,7 +334,7 @@ LPSTR __cdecl _strlwr( LPSTR str )
 /*********************************************************************
  *                  toupper   (NTDLL.@)
  */
-int __cdecl toupper( int c )
+int __cdecl NTDLL_toupper( int c )
 {
     char str[2], *p = str;
     WCHAR wc;
@@ -463,106 +353,106 @@ int __cdecl toupper( int c )
 /*********************************************************************
  *                  isalnum   (NTDLL.@)
  */
-int __cdecl isalnum( int c )
+int __cdecl NTDLL_isalnum( int c )
 {
-    return ctypes[c + 1] & (C1_LOWER | C1_UPPER | C1_DIGIT);
+    return isalnum( c );
 }
 
 
 /*********************************************************************
  *                  isalpha   (NTDLL.@)
  */
-int __cdecl isalpha( int c )
+int __cdecl NTDLL_isalpha( int c )
 {
-    return ctypes[c + 1] & (C1_LOWER | C1_UPPER);
+    return isalpha( c );
 }
 
 
 /*********************************************************************
  *                  iscntrl   (NTDLL.@)
  */
-int __cdecl iscntrl( int c )
+int __cdecl NTDLL_iscntrl( int c )
 {
-    return ctypes[c + 1] & C1_CNTRL;
+    return iscntrl( c );
 }
 
 
 /*********************************************************************
  *                  isdigit   (NTDLL.@)
  */
-int __cdecl isdigit( int c )
+int __cdecl NTDLL_isdigit( int c )
 {
-    return ctypes[c + 1] & C1_DIGIT;
+    return isdigit( c );
 }
 
 
 /*********************************************************************
  *                  isgraph   (NTDLL.@)
  */
-int __cdecl isgraph( int c )
+int __cdecl NTDLL_isgraph( int c )
 {
-    return ctypes[c + 1] & (C1_LOWER | C1_UPPER | C1_DIGIT | C1_PUNCT);
+    return isgraph( c );
 }
 
 
 /*********************************************************************
  *                  islower   (NTDLL.@)
  */
-int __cdecl islower( int c )
+int __cdecl NTDLL_islower( int c )
 {
-    return ctypes[c + 1] & C1_LOWER;
+    return islower( c );
 }
 
 
 /*********************************************************************
  *                  isprint   (NTDLL.@)
  */
-int __cdecl isprint( int c )
+int __cdecl NTDLL_isprint( int c )
 {
-    return ctypes[c + 1] & (C1_LOWER | C1_UPPER | C1_DIGIT | C1_PUNCT | C1_BLANK);
+    return isprint( c );
 }
 
 
 /*********************************************************************
  *                  ispunct   (NTDLL.@)
  */
-int __cdecl ispunct( int c )
+int __cdecl NTDLL_ispunct( int c )
 {
-    return ctypes[c + 1] & C1_PUNCT;
+    return ispunct( c );
 }
 
 
 /*********************************************************************
  *                  isspace   (NTDLL.@)
  */
-int __cdecl isspace( int c )
+int __cdecl NTDLL_isspace( int c )
 {
-    return ctypes[c + 1] & C1_SPACE;
+    return isspace( c );
 }
 
 
 /*********************************************************************
  *                  isupper   (NTDLL.@)
  */
-int __cdecl isupper( int c )
+int __cdecl NTDLL_isupper( int c )
 {
-    return ctypes[c + 1] & C1_UPPER;
+    return isupper( c );
 }
 
 
 /*********************************************************************
  *                  isxdigit   (NTDLL.@)
  */
-int __cdecl isxdigit( int c )
+int __cdecl NTDLL_isxdigit( int c )
 {
-    return ctypes[c + 1] & C1_XDIGIT;
+    return isxdigit( c );
 }
 
 
 /*********************************************************************
  *		__isascii (NTDLL.@)
  */
-int CDECL __isascii(int c)
+int CDECL NTDLL___isascii(int c)
 {
     return (unsigned)c < 0x80;
 }
@@ -571,7 +461,7 @@ int CDECL __isascii(int c)
 /*********************************************************************
  *		__toascii (NTDLL.@)
  */
-int CDECL __toascii(int c)
+int CDECL NTDLL___toascii(int c)
 {
     return (unsigned)c & 0x7f;
 }
@@ -580,7 +470,7 @@ int CDECL __toascii(int c)
 /*********************************************************************
  *		__iscsym (NTDLL.@)
  */
-int CDECL __iscsym(int c)
+int CDECL NTDLL___iscsym(int c)
 {
     return (c < 127 && (isalnum(c) || c == '_'));
 }
@@ -589,7 +479,7 @@ int CDECL __iscsym(int c)
 /*********************************************************************
  *		__iscsymf (NTDLL.@)
  */
-int CDECL __iscsymf(int c)
+int CDECL NTDLL___iscsymf(int c)
 {
     return (c < 127 && (isalpha(c) || c == '_'));
 }
@@ -598,7 +488,7 @@ int CDECL __iscsymf(int c)
 /*********************************************************************
  *		_toupper (NTDLL.@)
  */
-int CDECL _toupper(int c)
+int CDECL NTDLL__toupper(int c)
 {
     return c - 0x20;  /* sic */
 }
@@ -607,108 +497,27 @@ int CDECL _toupper(int c)
 /*********************************************************************
  *		_tolower (NTDLL.@)
  */
-int CDECL _tolower(int c)
+int CDECL NTDLL__tolower(int c)
 {
     return c + 0x20;  /* sic */
 }
 
 
-static int char_to_int( char c )
-{
-    if ('0' <= c && c <= '9') return c - '0';
-    if ('A' <= c && c <= 'Z') return c - 'A' + 10;
-    if ('a' <= c && c <= 'z') return c - 'a' + 10;
-    return -1;
-}
-
 /*********************************************************************
  *                  strtol   (NTDLL.@)
  */
-__msvcrt_long __cdecl strtol( const char *s, char **end, int base )
+LONG __cdecl NTDLL_strtol( const char *nptr, char **endptr, int base )
 {
-    BOOL negative = FALSE, empty = TRUE;
-    LONG ret = 0;
-
-    if (base < 0 || base == 1 || base > 36) return 0;
-    if (end) *end = (char *)s;
-    while (isspace(*s)) s++;
-
-    if (*s == '-')
-    {
-        negative = TRUE;
-        s++;
-    }
-    else if (*s == '+') s++;
-
-    if ((base == 0 || base == 16) && !char_to_int( *s ) && (s[1] == 'x' || s[1] == 'X'))
-    {
-        base = 16;
-        s += 2;
-    }
-    if (base == 0) base = char_to_int( *s ) ? 10 : 8;
-
-    while (*s)
-    {
-        int v = char_to_int( *s );
-        if (v < 0 || v >= base) break;
-        if (negative) v = -v;
-        s++;
-        empty = FALSE;
-
-        if (!negative && (ret > MAXLONG / base || ret * base > MAXLONG - v))
-            ret = MAXLONG;
-        else if (negative && (ret < (LONG)MINLONG / base || ret * base < (LONG)(MINLONG - v)))
-            ret = MINLONG;
-        else
-            ret = ret * base + v;
-    }
-
-    if (end && !empty) *end = (char *)s;
-    return ret;
+    return strtol( nptr, endptr, base );
 }
 
 
 /*********************************************************************
  *                  strtoul   (NTDLL.@)
  */
-__msvcrt_ulong __cdecl strtoul( const char *s, char **end, int base )
+ULONG __cdecl NTDLL_strtoul( const char *nptr, char **endptr, int base )
 {
-    BOOL negative = FALSE, empty = TRUE;
-    ULONG ret = 0;
-
-    if (base < 0 || base == 1 || base > 36) return 0;
-    if (end) *end = (char *)s;
-    while (isspace(*s)) s++;
-
-    if (*s == '-')
-    {
-        negative = TRUE;
-        s++;
-    }
-    else if (*s == '+') s++;
-
-    if ((base == 0 || base == 16) && !char_to_int( *s ) && (s[1] == 'x' || s[1] == 'X'))
-    {
-        base = 16;
-        s += 2;
-    }
-    if (base == 0) base = char_to_int( *s ) ? 10 : 8;
-
-    while (*s)
-    {
-        int v = char_to_int( *s );
-        if (v < 0 || v >= base) break;
-        s++;
-        empty = FALSE;
-
-        if (ret > MAXDWORD / base || ret * base > MAXDWORD - v)
-            ret = MAXDWORD;
-        else
-            ret = ret * base + v;
-    }
-
-    if (end && !empty) *end = (char *)s;
-    return negative ? -ret : ret;
+    return strtoul( nptr, endptr, base );
 }
 
 
@@ -726,7 +535,10 @@ __msvcrt_ulong __cdecl strtoul( const char *s, char **end, int base )
  *  - Does not check if radix is in the range of 2 to 36.
  *  - If str is NULL it crashes, as the native function does.
  */
-char * __cdecl _ultoa( __msvcrt_ulong value, char *str, int radix )
+char * __cdecl _ultoa(
+    ULONG value,         /* [I] Value to be converted */
+    char *str,           /* [O] Destination for the converted value */
+    int radix)           /* [I] Number base for conversion */
 {
     char buffer[33];
     char *pos;
@@ -765,7 +577,10 @@ char * __cdecl _ultoa( __msvcrt_ulong value, char *str, int radix )
  *  - Does not check if radix is in the range of 2 to 36.
  *  - If str is NULL it crashes, as the native function does.
  */
-char * __cdecl _ltoa( __msvcrt_long value, char *str, int radix )
+char * __cdecl _ltoa(
+    LONG value, /* [I] Value to be converted */
+    char *str,  /* [O] Destination for the converted value */
+    int radix)  /* [I] Number base for conversion */
 {
     ULONG val;
     int negative;
@@ -979,7 +794,7 @@ LONGLONG __cdecl _atoi64( const char *str )
 /*********************************************************************
  *                  atoi   (NTDLL.@)
  */
-int __cdecl atoi( const char *nptr )
+int __cdecl NTDLL_atoi( const char *nptr )
 {
     return _atoi64( nptr );
 }
@@ -988,7 +803,7 @@ int __cdecl atoi( const char *nptr )
 /*********************************************************************
  *                  atol   (NTDLL.@)
  */
-__msvcrt_long __cdecl atol( const char *nptr )
+LONG __cdecl NTDLL_atol( const char *nptr )
 {
     return _atoi64( nptr );
 }
@@ -1007,7 +822,7 @@ static int char2digit( char c, int base )
 }
 
 
-static int vsscanf( const char *str, const char *format, __ms_va_list ap)
+static int NTDLL_vsscanf( const char *str, const char *format, __ms_va_list ap)
 {
     int rd = 0, consumed = 0;
     int nch;
@@ -1442,12 +1257,12 @@ static int vsscanf( const char *str, const char *format, __ms_va_list ap)
 /*********************************************************************
  *                  sscanf   (NTDLL.@)
  */
-int WINAPIV sscanf( const char *str, const char *format, ... )
+int WINAPIV NTDLL_sscanf( const char *str, const char *format, ... )
 {
     int ret;
     __ms_va_list valist;
     __ms_va_start( valist, format );
-    ret = vsscanf( str, format, valist );
+    ret = NTDLL_vsscanf( str, format, valist );
     __ms_va_end( valist );
     return ret;
 }
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index edbdd91c1b..ad967d20e0 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -21,22 +21,1541 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <errno.h>
 #include <limits.h>
+#include <signal.h>
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+#ifdef HAVE_POLL_H
+#include <poll.h>
+#endif
+#ifdef HAVE_SYS_POLL_H
+# include <sys/poll.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SCHED_H
+# include <sched.h>
+#endif
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#define NONAMELESSUNION
-#include "windef.h"
-#include "winternl.h"
-#include "wine/server.h"
-#include "wine/debug.h"
-#include "ntdll_misc.h"
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#define NONAMELESSUNION
+#include "windef.h"
+#include "winternl.h"
+#include "wine/server.h"
+#include "wine/debug.h"
+#include "ntdll_misc.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(sync);
+
+HANDLE keyed_event = NULL;
+
+static const LARGE_INTEGER zero_timeout;
+
+#define TICKSPERSEC 10000000
+
+#ifdef __linux__
+
+#define FUTEX_WAIT 0
+#define FUTEX_WAKE 1
+#define FUTEX_WAIT_BITSET 9
+#define FUTEX_WAKE_BITSET 10
+
+static int futex_private = 128;
+
+static inline int futex_wait( const int *addr, int val, struct timespec *timeout )
+{
+    return syscall( __NR_futex, addr, FUTEX_WAIT | futex_private, val, timeout, 0, 0 );
+}
+
+static inline int futex_wake( const int *addr, int val )
+{
+    return syscall( __NR_futex, addr, FUTEX_WAKE | futex_private, val, NULL, 0, 0 );
+}
+
+static inline int futex_wait_bitset( const int *addr, int val, struct timespec *timeout, int mask )
+{
+    return syscall( __NR_futex, addr, FUTEX_WAIT_BITSET | futex_private, val, timeout, 0, mask );
+}
+
+static inline int futex_wake_bitset( const int *addr, int val, int mask )
+{
+    return syscall( __NR_futex, addr, FUTEX_WAKE_BITSET | futex_private, val, NULL, 0, mask );
+}
+
+static inline int use_futexes(void)
+{
+    static int supported = -1;
+
+    if (supported == -1)
+    {
+        futex_wait( &supported, 10, NULL );
+        if (errno == ENOSYS)
+        {
+            futex_private = 0;
+            futex_wait( &supported, 10, NULL );
+        }
+        supported = (errno != ENOSYS);
+    }
+    return supported;
+}
+
+static int *get_futex(void **ptr)
+{
+    if (sizeof(void *) == 8)
+        return (int *)((((ULONG_PTR)ptr) + 3) & ~3);
+    else if (!(((ULONG_PTR)ptr) & 3))
+        return (int *)ptr;
+    else
+        return NULL;
+}
+
+static void timespec_from_timeout( struct timespec *timespec, const LARGE_INTEGER *timeout )
+{
+    LARGE_INTEGER now;
+    timeout_t diff;
+
+    if (timeout->QuadPart > 0)
+    {
+        NtQuerySystemTime( &now );
+        diff = timeout->QuadPart - now.QuadPart;
+    }
+    else
+        diff = -timeout->QuadPart;
+
+    timespec->tv_sec  = diff / TICKSPERSEC;
+    timespec->tv_nsec = (diff % TICKSPERSEC) * 100;
+}
+#endif
+
+/* creates a struct security_descriptor and contained information in one contiguous piece of memory */
+NTSTATUS alloc_object_attributes( const OBJECT_ATTRIBUTES *attr, struct object_attributes **ret,
+                                  data_size_t *ret_len )
+{
+    unsigned int len = sizeof(**ret);
+    PSID owner = NULL, group = NULL;
+    ACL *dacl, *sacl;
+    BOOLEAN dacl_present, sacl_present, defaulted;
+    PSECURITY_DESCRIPTOR sd;
+    NTSTATUS status;
+
+    *ret = NULL;
+    *ret_len = 0;
+
+    if (!attr) return STATUS_SUCCESS;
+
+    if (attr->Length != sizeof(*attr)) return STATUS_INVALID_PARAMETER;
+
+    if ((sd = attr->SecurityDescriptor))
+    {
+        len += sizeof(struct security_descriptor);
+
+        if ((status = RtlGetOwnerSecurityDescriptor( sd, &owner, &defaulted ))) return status;
+        if ((status = RtlGetGroupSecurityDescriptor( sd, &group, &defaulted ))) return status;
+        if ((status = RtlGetSaclSecurityDescriptor( sd, &sacl_present, &sacl, &defaulted ))) return status;
+        if ((status = RtlGetDaclSecurityDescriptor( sd, &dacl_present, &dacl, &defaulted ))) return status;
+        if (owner) len += RtlLengthSid( owner );
+        if (group) len += RtlLengthSid( group );
+        if (sacl_present && sacl) len += sacl->AclSize;
+        if (dacl_present && dacl) len += dacl->AclSize;
+
+        /* fix alignment for the Unicode name that follows the structure */
+        len = (len + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1);
+    }
+
+    if (attr->ObjectName)
+    {
+        if (attr->ObjectName->Length & (sizeof(WCHAR) - 1)) return STATUS_OBJECT_NAME_INVALID;
+        len += attr->ObjectName->Length;
+    }
+    else if (attr->RootDirectory) return STATUS_OBJECT_NAME_INVALID;
+
+    len = (len + 3) & ~3;  /* DWORD-align the entire structure */
+
+    *ret = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, len );
+    if (!*ret) return STATUS_NO_MEMORY;
+
+    (*ret)->rootdir = wine_server_obj_handle( attr->RootDirectory );
+    (*ret)->attributes = attr->Attributes;
+
+    if (attr->SecurityDescriptor)
+    {
+        struct security_descriptor *descr = (struct security_descriptor *)(*ret + 1);
+        unsigned char *ptr = (unsigned char *)(descr + 1);
+
+        descr->control = ((SECURITY_DESCRIPTOR *)sd)->Control & ~SE_SELF_RELATIVE;
+        if (owner) descr->owner_len = RtlLengthSid( owner );
+        if (group) descr->group_len = RtlLengthSid( group );
+        if (sacl_present && sacl) descr->sacl_len = sacl->AclSize;
+        if (dacl_present && dacl) descr->dacl_len = dacl->AclSize;
+
+        memcpy( ptr, owner, descr->owner_len );
+        ptr += descr->owner_len;
+        memcpy( ptr, group, descr->group_len );
+        ptr += descr->group_len;
+        memcpy( ptr, sacl, descr->sacl_len );
+        ptr += descr->sacl_len;
+        memcpy( ptr, dacl, descr->dacl_len );
+        (*ret)->sd_len = (sizeof(*descr) + descr->owner_len + descr->group_len + descr->sacl_len +
+                          descr->dacl_len + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1);
+    }
+
+    if (attr->ObjectName)
+    {
+        unsigned char *ptr = (unsigned char *)(*ret + 1) + (*ret)->sd_len;
+        (*ret)->name_len = attr->ObjectName->Length;
+        memcpy( ptr, attr->ObjectName->Buffer, (*ret)->name_len );
+    }
+
+    *ret_len = len;
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS validate_open_object_attributes( const OBJECT_ATTRIBUTES *attr )
+{
+    if (!attr || attr->Length != sizeof(*attr)) return STATUS_INVALID_PARAMETER;
+
+    if (attr->ObjectName)
+    {
+        if (attr->ObjectName->Length & (sizeof(WCHAR) - 1)) return STATUS_OBJECT_NAME_INVALID;
+    }
+    else if (attr->RootDirectory) return STATUS_OBJECT_NAME_INVALID;
+
+    return STATUS_SUCCESS;
+}
+
+/*
+ *	Semaphores
+ */
+
+/******************************************************************************
+ *  NtCreateSemaphore (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateSemaphore( OUT PHANDLE SemaphoreHandle,
+                                   IN ACCESS_MASK access,
+                                   IN const OBJECT_ATTRIBUTES *attr OPTIONAL,
+                                   IN LONG InitialCount,
+                                   IN LONG MaximumCount )
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if (MaximumCount <= 0 || InitialCount < 0 || InitialCount > MaximumCount)
+        return STATUS_INVALID_PARAMETER;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ( create_semaphore )
+    {
+        req->access  = access;
+        req->initial = InitialCount;
+        req->max     = MaximumCount;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        *SemaphoreHandle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+/******************************************************************************
+ *  NtOpenSemaphore (NTDLL.@)
+ */
+NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    SERVER_START_REQ( open_semaphore )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtQuerySemaphore (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS class,
+                                  void *info, ULONG len, ULONG *ret_len )
+{
+    NTSTATUS ret;
+    SEMAPHORE_BASIC_INFORMATION *out = info;
+
+    TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
+
+    if (class != SemaphoreBasicInformation)
+    {
+        FIXME("(%p,%d,%u) Unknown class\n", handle, class, len);
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+
+    SERVER_START_REQ( query_semaphore )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            out->CurrentCount = reply->current;
+            out->MaximumCount = reply->max;
+            if (ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
+        }
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+/******************************************************************************
+ *  NtReleaseSemaphore (NTDLL.@)
+ */
+NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, PULONG previous )
+{
+    NTSTATUS ret;
+    SERVER_START_REQ( release_semaphore )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->count  = count;
+        if (!(ret = wine_server_call( req )))
+        {
+            if (previous) *previous = reply->prev_count;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/*
+ *	Events
+ */
+
+/**************************************************************************
+ * NtCreateEvent (NTDLL.@)
+ * ZwCreateEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateEvent( PHANDLE EventHandle, ACCESS_MASK DesiredAccess,
+                               const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN InitialState)
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ( create_event )
+    {
+        req->access = DesiredAccess;
+        req->manual_reset = (type == NotificationEvent);
+        req->initial_state = InitialState;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        *EventHandle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+/******************************************************************************
+ *  NtOpenEvent (NTDLL.@)
+ *  ZwOpenEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    SERVER_START_REQ( open_event )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/******************************************************************************
+ *  NtSetEvent (NTDLL.@)
+ *  ZwSetEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
+{
+    NTSTATUS ret;
+    SERVER_START_REQ( event_op )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->op     = SET_EVENT;
+        ret = wine_server_call( req );
+        if (!ret && prev_state) *prev_state = reply->state;
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtResetEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
+{
+    NTSTATUS ret;
+    SERVER_START_REQ( event_op )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->op     = RESET_EVENT;
+        ret = wine_server_call( req );
+        if (!ret && prev_state) *prev_state = reply->state;
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtClearEvent (NTDLL.@)
+ *
+ * FIXME
+ *   same as NtResetEvent ???
+ */
+NTSTATUS WINAPI NtClearEvent ( HANDLE handle )
+{
+    return NtResetEvent( handle, NULL );
+}
+
+/******************************************************************************
+ *  NtPulseEvent (NTDLL.@)
+ *
+ * FIXME
+ *   PulseCount
+ */
+NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( event_op )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->op     = PULSE_EVENT;
+        ret = wine_server_call( req );
+        if (!ret && prev_state) *prev_state = reply->state;
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *  NtQueryEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
+                              void *info, ULONG len, ULONG *ret_len )
+{
+    NTSTATUS ret;
+    EVENT_BASIC_INFORMATION *out = info;
+
+    TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
+
+    if (class != EventBasicInformation)
+    {
+        FIXME("(%p, %d, %d) Unknown class\n",
+              handle, class, len);
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+
+    SERVER_START_REQ( query_event )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            out->EventType  = reply->manual_reset ? NotificationEvent : SynchronizationEvent;
+            out->EventState = reply->state;
+            if (ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
+        }
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+/*
+ *	Mutants (known as Mutexes in Kernel32)
+ */
+
+/******************************************************************************
+ *              NtCreateMutant                          [NTDLL.@]
+ *              ZwCreateMutant                          [NTDLL.@]
+ */
+NTSTATUS WINAPI NtCreateMutant(OUT HANDLE* MutantHandle,
+                               IN ACCESS_MASK access,
+                               IN const OBJECT_ATTRIBUTES* attr OPTIONAL,
+                               IN BOOLEAN InitialOwner)
+{
+    NTSTATUS status;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
+
+    SERVER_START_REQ( create_mutex )
+    {
+        req->access  = access;
+        req->owned   = InitialOwner;
+        wine_server_add_data( req, objattr, len );
+        status = wine_server_call( req );
+        *MutantHandle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return status;
+}
+
+/**************************************************************************
+ *		NtOpenMutant				[NTDLL.@]
+ *		ZwOpenMutant				[NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS    status;
+
+    if ((status = validate_open_object_attributes( attr ))) return status;
+
+    SERVER_START_REQ( open_mutex )
+    {
+        req->access  = access;
+        req->attributes = attr->Attributes;
+        req->rootdir = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        status = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/**************************************************************************
+ *		NtReleaseMutant				[NTDLL.@]
+ *		ZwReleaseMutant				[NTDLL.@]
+ */
+NTSTATUS WINAPI NtReleaseMutant( IN HANDLE handle, OUT PLONG prev_count OPTIONAL)
+{
+    NTSTATUS    status;
+
+    SERVER_START_REQ( release_mutex )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        status = wine_server_call( req );
+        if (prev_count) *prev_count = 1 - reply->prev_count;
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************
+ *		NtQueryMutant                   [NTDLL.@]
+ *		ZwQueryMutant                   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
+                               void *info, ULONG len, ULONG *ret_len )
+{
+    NTSTATUS ret;
+    MUTANT_BASIC_INFORMATION *out = info;
+
+    TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
+
+    if (class != MutantBasicInformation)
+    {
+        FIXME("(%p, %d, %d) Unknown class\n",
+              handle, class, len);
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+
+    SERVER_START_REQ( query_mutex )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            out->CurrentCount   = 1 - reply->count;
+            out->OwnedByCaller  = reply->owned;
+            out->AbandonedState = reply->abandoned;
+            if (ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
+        }
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+/*
+ *	Jobs
+ */
+
+/******************************************************************************
+ *              NtCreateJobObject   [NTDLL.@]
+ *              ZwCreateJobObject   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtCreateJobObject( PHANDLE handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ( create_job )
+    {
+        req->access = access;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+/******************************************************************************
+ *              NtOpenJobObject   [NTDLL.@]
+ *              ZwOpenJobObject   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenJobObject( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    SERVER_START_REQ( open_job )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *              NtTerminateJobObject   [NTDLL.@]
+ *              ZwTerminateJobObject   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
+{
+    NTSTATUS ret;
+
+    TRACE( "(%p, %d)\n", handle, status );
+
+    SERVER_START_REQ( terminate_job )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->status = status;
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+/******************************************************************************
+ *              NtQueryInformationJobObject   [NTDLL.@]
+ *              ZwQueryInformationJobObject   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info,
+                                             ULONG len, PULONG ret_len )
+{
+    FIXME( "stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
+
+    if (class >= MaxJobObjectInfoClass)
+        return STATUS_INVALID_PARAMETER;
+
+    switch (class)
+    {
+    case JobObjectBasicAccountingInformation:
+        {
+            JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *accounting;
+            if (len < sizeof(*accounting))
+                return STATUS_INFO_LENGTH_MISMATCH;
+
+            accounting = (JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *)info;
+            memset(accounting, 0, sizeof(*accounting));
+            if (ret_len) *ret_len = sizeof(*accounting);
+            return STATUS_SUCCESS;
+        }
+
+    case JobObjectBasicProcessIdList:
+        {
+            JOBOBJECT_BASIC_PROCESS_ID_LIST *process;
+            if (len < sizeof(*process))
+                return STATUS_INFO_LENGTH_MISMATCH;
+
+            process = (JOBOBJECT_BASIC_PROCESS_ID_LIST *)info;
+            memset(process, 0, sizeof(*process));
+            if (ret_len) *ret_len = sizeof(*process);
+            return STATUS_SUCCESS;
+        }
+
+    case JobObjectExtendedLimitInformation:
+        {
+            JOBOBJECT_EXTENDED_LIMIT_INFORMATION *extended_limit;
+            if (len < sizeof(*extended_limit))
+                return STATUS_INFO_LENGTH_MISMATCH;
+
+            extended_limit = (JOBOBJECT_EXTENDED_LIMIT_INFORMATION *)info;
+            memset(extended_limit, 0, sizeof(*extended_limit));
+            if (ret_len) *ret_len = sizeof(*extended_limit);
+            return STATUS_SUCCESS;
+        }
+
+    case JobObjectBasicLimitInformation:
+        {
+            JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit;
+            if (len < sizeof(*basic_limit))
+                return STATUS_INFO_LENGTH_MISMATCH;
+
+            basic_limit = (JOBOBJECT_BASIC_LIMIT_INFORMATION *)info;
+            memset(basic_limit, 0, sizeof(*basic_limit));
+            if (ret_len) *ret_len = sizeof(*basic_limit);
+            return STATUS_SUCCESS;
+        }
+
+    default:
+        return STATUS_NOT_IMPLEMENTED;
+    }
+}
+
+/******************************************************************************
+ *              NtSetInformationJobObject   [NTDLL.@]
+ *              ZwSetInformationJobObject   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtSetInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info, ULONG len )
+{
+    NTSTATUS status = STATUS_NOT_IMPLEMENTED;
+    JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit;
+    ULONG info_size = sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION);
+    DWORD limit_flags = JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS;
+
+    TRACE( "(%p, %u, %p, %u)\n", handle, class, info, len );
+
+    if (class >= MaxJobObjectInfoClass)
+        return STATUS_INVALID_PARAMETER;
+
+    switch (class)
+    {
+
+    case JobObjectExtendedLimitInformation:
+        info_size = sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION);
+        limit_flags = JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS;
+        /* fallthrough */
+    case JobObjectBasicLimitInformation:
+        if (len != info_size)
+            return STATUS_INVALID_PARAMETER;
+
+        basic_limit = info;
+        if (basic_limit->LimitFlags & ~limit_flags)
+            return STATUS_INVALID_PARAMETER;
+
+        SERVER_START_REQ( set_job_limits )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->limit_flags = basic_limit->LimitFlags;
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        break;
+
+    case JobObjectAssociateCompletionPortInformation:
+        if (len != sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT))
+            return STATUS_INVALID_PARAMETER;
+
+        SERVER_START_REQ( set_job_completion_port )
+        {
+            JOBOBJECT_ASSOCIATE_COMPLETION_PORT *port_info = info;
+            req->job = wine_server_obj_handle( handle );
+            req->port = wine_server_obj_handle( port_info->CompletionPort );
+            req->key = wine_server_client_ptr( port_info->CompletionKey );
+            status = wine_server_call(req);
+        }
+        SERVER_END_REQ;
+        break;
+
+    case JobObjectBasicUIRestrictions:
+        status = STATUS_SUCCESS;
+        /* fallthrough */
+    default:
+        FIXME( "stub: %p %u %p %u\n", handle, class, info, len );
+    }
+
+    return status;
+}
+
+/******************************************************************************
+ *              NtIsProcessInJob   [NTDLL.@]
+ *              ZwIsProcessInJob   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtIsProcessInJob( HANDLE process, HANDLE job )
+{
+    NTSTATUS status;
+
+    TRACE( "(%p %p)\n", job, process );
+
+    SERVER_START_REQ( process_in_job )
+    {
+        req->job     = wine_server_obj_handle( job );
+        req->process = wine_server_obj_handle( process );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
+
+/******************************************************************************
+ *              NtAssignProcessToJobObject   [NTDLL.@]
+ *              ZwAssignProcessToJobObject   [NTDLL.@]
+ */
+NTSTATUS WINAPI NtAssignProcessToJobObject( HANDLE job, HANDLE process )
+{
+    NTSTATUS status;
+
+    TRACE( "(%p %p)\n", job, process );
+
+    SERVER_START_REQ( assign_job )
+    {
+        req->job     = wine_server_obj_handle( job );
+        req->process = wine_server_obj_handle( process );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
+
+/*
+ *	Timers
+ */
+
+/**************************************************************************
+ *		NtCreateTimer				[NTDLL.@]
+ *		ZwCreateTimer				[NTDLL.@]
+ */
+NTSTATUS WINAPI NtCreateTimer(OUT HANDLE *handle,
+                              IN ACCESS_MASK access,
+                              IN const OBJECT_ATTRIBUTES *attr OPTIONAL,
+                              IN TIMER_TYPE timer_type)
+{
+    NTSTATUS status;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if (timer_type != NotificationTimer && timer_type != SynchronizationTimer)
+        return STATUS_INVALID_PARAMETER;
+
+    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
+
+    SERVER_START_REQ( create_timer )
+    {
+        req->access  = access;
+        req->manual  = (timer_type == NotificationTimer);
+        wine_server_add_data( req, objattr, len );
+        status = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return status;
+
+}
+
+/**************************************************************************
+ *		NtOpenTimer				[NTDLL.@]
+ *		ZwOpenTimer				[NTDLL.@]
+ */
+NTSTATUS WINAPI NtOpenTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS status;
+
+    if ((status = validate_open_object_attributes( attr ))) return status;
+
+    SERVER_START_REQ( open_timer )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        status = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/**************************************************************************
+ *		NtSetTimer				[NTDLL.@]
+ *		ZwSetTimer				[NTDLL.@]
+ */
+NTSTATUS WINAPI NtSetTimer(IN HANDLE handle,
+                           IN const LARGE_INTEGER* when,
+                           IN PTIMER_APC_ROUTINE callback,
+                           IN PVOID callback_arg,
+                           IN BOOLEAN resume,
+                           IN ULONG period OPTIONAL,
+                           OUT PBOOLEAN state OPTIONAL)
+{
+    NTSTATUS    status = STATUS_SUCCESS;
+
+    TRACE("(%p,%p,%p,%p,%08x,0x%08x,%p)\n",
+          handle, when, callback, callback_arg, resume, period, state);
+
+    SERVER_START_REQ( set_timer )
+    {
+        req->handle   = wine_server_obj_handle( handle );
+        req->period   = period;
+        req->expire   = when->QuadPart;
+        req->callback = wine_server_client_ptr( callback );
+        req->arg      = wine_server_client_ptr( callback_arg );
+        status = wine_server_call( req );
+        if (state) *state = reply->signaled;
+    }
+    SERVER_END_REQ;
+
+    /* set error but can still succeed */
+    if (resume && status == STATUS_SUCCESS) return STATUS_TIMER_RESUME_IGNORED;
+    return status;
+}
+
+/**************************************************************************
+ *		NtCancelTimer				[NTDLL.@]
+ *		ZwCancelTimer				[NTDLL.@]
+ */
+NTSTATUS WINAPI NtCancelTimer(IN HANDLE handle, OUT BOOLEAN* state)
+{
+    NTSTATUS    status;
+
+    SERVER_START_REQ( cancel_timer )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        status = wine_server_call( req );
+        if (state) *state = reply->signaled;
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************************
+ *  NtQueryTimer (NTDLL.@)
+ *
+ * Retrieves information about a timer.
+ *
+ * PARAMS
+ *  TimerHandle           [I] The timer to retrieve information about.
+ *  TimerInformationClass [I] The type of information to retrieve.
+ *  TimerInformation      [O] Pointer to buffer to store information in.
+ *  Length                [I] The length of the buffer pointed to by TimerInformation.
+ *  ReturnLength          [O] Optional. The size of buffer actually used.
+ *
+ * RETURNS
+ *  Success: STATUS_SUCCESS
+ *  Failure: STATUS_INFO_LENGTH_MISMATCH, if Length doesn't match the required data
+ *           size for the class specified.
+ *           STATUS_INVALID_INFO_CLASS, if an invalid TimerInformationClass was specified.
+ *           STATUS_ACCESS_DENIED, if TimerHandle does not have TIMER_QUERY_STATE access
+ *           to the timer.
+ */
+NTSTATUS WINAPI NtQueryTimer(
+    HANDLE TimerHandle,
+    TIMER_INFORMATION_CLASS TimerInformationClass,
+    PVOID TimerInformation,
+    ULONG Length,
+    PULONG ReturnLength)
+{
+    TIMER_BASIC_INFORMATION * basic_info = TimerInformation;
+    NTSTATUS status;
+    LARGE_INTEGER now;
+
+    TRACE("(%p,%d,%p,0x%08x,%p)\n", TimerHandle, TimerInformationClass,
+       TimerInformation, Length, ReturnLength);
+
+    switch (TimerInformationClass)
+    {
+    case TimerBasicInformation:
+        if (Length < sizeof(TIMER_BASIC_INFORMATION))
+            return STATUS_INFO_LENGTH_MISMATCH;
+
+        SERVER_START_REQ(get_timer_info)
+        {
+            req->handle = wine_server_obj_handle( TimerHandle );
+            status = wine_server_call(req);
+
+            /* convert server time to absolute NTDLL time */
+            basic_info->RemainingTime.QuadPart = reply->when;
+            basic_info->TimerState = reply->signaled;
+        }
+        SERVER_END_REQ;
+
+        /* convert into relative time */
+        if (basic_info->RemainingTime.QuadPart > 0)
+            NtQuerySystemTime(&now);
+        else
+        {
+            RtlQueryPerformanceCounter(&now);
+            basic_info->RemainingTime.QuadPart = -basic_info->RemainingTime.QuadPart;
+        }
+
+        if (now.QuadPart > basic_info->RemainingTime.QuadPart)
+            basic_info->RemainingTime.QuadPart = 0;
+        else
+            basic_info->RemainingTime.QuadPart -= now.QuadPart;
+
+        if (ReturnLength) *ReturnLength = sizeof(TIMER_BASIC_INFORMATION);
+
+        return status;
+    }
+
+    FIXME("Unhandled class %d\n", TimerInformationClass);
+    return STATUS_INVALID_INFO_CLASS;
+}
+
+
+/******************************************************************************
+ * NtQueryTimerResolution [NTDLL.@]
+ */
+NTSTATUS WINAPI NtQueryTimerResolution(OUT ULONG* min_resolution,
+                                       OUT ULONG* max_resolution,
+                                       OUT ULONG* current_resolution)
+{
+    FIXME("(%p,%p,%p), stub!\n",
+          min_resolution, max_resolution, current_resolution);
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/******************************************************************************
+ * NtSetTimerResolution [NTDLL.@]
+ */
+NTSTATUS WINAPI NtSetTimerResolution(IN ULONG resolution,
+                                     IN BOOLEAN set_resolution,
+                                     OUT ULONG* current_resolution )
+{
+    FIXME("(%u,%u,%p), stub!\n",
+          resolution, set_resolution, current_resolution);
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+
+
+/* wait operations */
+
+static NTSTATUS wait_objects( DWORD count, const HANDLE *handles,
+                              BOOLEAN wait_any, BOOLEAN alertable,
+                              const LARGE_INTEGER *timeout )
+{
+    select_op_t select_op;
+    UINT i, flags = SELECT_INTERRUPTIBLE;
+
+    if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
+
+    if (alertable) flags |= SELECT_ALERTABLE;
+    select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
+    for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
+    return server_wait( &select_op, offsetof( select_op_t, wait.handles[count] ), flags, timeout );
+}
+
+
+/******************************************************************
+ *		NtWaitForMultipleObjects (NTDLL.@)
+ */
+NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles,
+                                          BOOLEAN wait_any, BOOLEAN alertable,
+                                          const LARGE_INTEGER *timeout )
+{
+    return wait_objects( count, handles, wait_any, alertable, timeout );
+}
+
+
+/******************************************************************
+ *		NtWaitForSingleObject (NTDLL.@)
+ */
+NTSTATUS WINAPI NtWaitForSingleObject(HANDLE handle, BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return wait_objects( 1, &handle, FALSE, alertable, timeout );
+}
+
+
+/******************************************************************
+ *		NtSignalAndWaitForSingleObject (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE hSignalObject, HANDLE hWaitObject,
+                                                BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    select_op_t select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (!hSignalObject) return STATUS_INVALID_HANDLE;
+
+    if (alertable) flags |= SELECT_ALERTABLE;
+    select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
+    select_op.signal_and_wait.wait = wine_server_obj_handle( hWaitObject );
+    select_op.signal_and_wait.signal = wine_server_obj_handle( hSignalObject );
+    return server_wait( &select_op, sizeof(select_op.signal_and_wait), flags, timeout );
+}
+
+
+/******************************************************************
+ *		NtYieldExecution (NTDLL.@)
+ */
+NTSTATUS WINAPI NtYieldExecution(void)
+{
+#ifdef HAVE_SCHED_YIELD
+    sched_yield();
+    return STATUS_SUCCESS;
+#else
+    return STATUS_NO_YIELD_PERFORMED;
+#endif
+}
+
+
+/******************************************************************
+ *		NtDelayExecution (NTDLL.@)
+ */
+NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    /* if alertable, we need to query the server */
+    if (alertable)
+        return server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, timeout );
+
+    if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)  /* sleep forever */
+    {
+        for (;;) select( 0, NULL, NULL, NULL, NULL );
+    }
+    else
+    {
+        LARGE_INTEGER now;
+        timeout_t when, diff;
+
+        if ((when = timeout->QuadPart) < 0)
+        {
+            NtQuerySystemTime( &now );
+            when = now.QuadPart - when;
+        }
+
+        /* Note that we yield after establishing the desired timeout */
+        NtYieldExecution();
+        if (!when) return STATUS_SUCCESS;
+
+        for (;;)
+        {
+            struct timeval tv;
+            NtQuerySystemTime( &now );
+            diff = (when - now.QuadPart + 9) / 10;
+            if (diff <= 0) break;
+            tv.tv_sec  = diff / 1000000;
+            tv.tv_usec = diff % 1000000;
+            if (select( 0, NULL, NULL, NULL, &tv ) != -1) break;
+        }
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/******************************************************************************
+ *              NtCreateKeyedEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateKeyedEvent( HANDLE *handle, ACCESS_MASK access,
+                                    const OBJECT_ATTRIBUTES *attr, ULONG flags )
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ( create_keyed_event )
+    {
+        req->access = access;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+/******************************************************************************
+ *              NtOpenKeyedEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtOpenKeyedEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    SERVER_START_REQ( open_keyed_event )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+/******************************************************************************
+ *              NtWaitForKeyedEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtWaitForKeyedEvent( HANDLE handle, const void *key,
+                                     BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    select_op_t select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (!handle) handle = keyed_event;
+    if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
+    if (alertable) flags |= SELECT_ALERTABLE;
+    select_op.keyed_event.op     = SELECT_KEYED_EVENT_WAIT;
+    select_op.keyed_event.handle = wine_server_obj_handle( handle );
+    select_op.keyed_event.key    = wine_server_client_ptr( key );
+    return server_wait( &select_op, sizeof(select_op.keyed_event), flags, timeout );
+}
+
+/******************************************************************************
+ *              NtReleaseKeyedEvent (NTDLL.@)
+ */
+NTSTATUS WINAPI NtReleaseKeyedEvent( HANDLE handle, const void *key,
+                                     BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    select_op_t select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (!handle) handle = keyed_event;
+    if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
+    if (alertable) flags |= SELECT_ALERTABLE;
+    select_op.keyed_event.op     = SELECT_KEYED_EVENT_RELEASE;
+    select_op.keyed_event.handle = wine_server_obj_handle( handle );
+    select_op.keyed_event.key    = wine_server_client_ptr( key );
+    return server_wait( &select_op, sizeof(select_op.keyed_event), flags, timeout );
+}
+
+/******************************************************************
+ *              NtCreateIoCompletion (NTDLL.@)
+ *              ZwCreateIoCompletion (NTDLL.@)
+ *
+ * Creates I/O completion object.
+ *
+ * PARAMS
+ *      CompletionPort            [O] created completion object handle will be placed there
+ *      DesiredAccess             [I] desired access to a handle (combination of IO_COMPLETION_*)
+ *      ObjectAttributes          [I] completion object attributes
+ *      NumberOfConcurrentThreads [I] desired number of concurrent active worker threads
+ *
+ */
+NTSTATUS WINAPI NtCreateIoCompletion( PHANDLE CompletionPort, ACCESS_MASK DesiredAccess,
+                                      POBJECT_ATTRIBUTES attr, ULONG NumberOfConcurrentThreads )
+{
+    NTSTATUS status;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    TRACE("(%p, %x, %p, %d)\n", CompletionPort, DesiredAccess, attr, NumberOfConcurrentThreads);
+
+    if (!CompletionPort)
+        return STATUS_INVALID_PARAMETER;
+
+    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
+
+    SERVER_START_REQ( create_completion )
+    {
+        req->access     = DesiredAccess;
+        req->concurrent = NumberOfConcurrentThreads;
+        wine_server_add_data( req, objattr, len );
+        if (!(status = wine_server_call( req )))
+            *CompletionPort = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return status;
+}
+
+/******************************************************************
+ *              NtSetIoCompletion (NTDLL.@)
+ *              ZwSetIoCompletion (NTDLL.@)
+ *
+ * Inserts completion message into queue
+ *
+ * PARAMS
+ *      CompletionPort           [I] HANDLE to completion object
+ *      CompletionKey            [I] completion key
+ *      CompletionValue          [I] completion value (usually pointer to OVERLAPPED)
+ *      Status                   [I] operation status
+ *      NumberOfBytesTransferred [I] number of bytes transferred
+ */
+NTSTATUS WINAPI NtSetIoCompletion( HANDLE CompletionPort, ULONG_PTR CompletionKey,
+                                   ULONG_PTR CompletionValue, NTSTATUS Status,
+                                   SIZE_T NumberOfBytesTransferred )
+{
+    NTSTATUS status;
+
+    TRACE("(%p, %lx, %lx, %x, %lx)\n", CompletionPort, CompletionKey,
+          CompletionValue, Status, NumberOfBytesTransferred);
+
+    SERVER_START_REQ( add_completion )
+    {
+        req->handle      = wine_server_obj_handle( CompletionPort );
+        req->ckey        = CompletionKey;
+        req->cvalue      = CompletionValue;
+        req->status      = Status;
+        req->information = NumberOfBytesTransferred;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************
+ *              NtRemoveIoCompletion (NTDLL.@)
+ *              ZwRemoveIoCompletion (NTDLL.@)
+ *
+ * (Wait for and) retrieve first completion message from completion object's queue
+ *
+ * PARAMS
+ *      CompletionPort  [I] HANDLE to I/O completion object
+ *      CompletionKey   [O] completion key
+ *      CompletionValue [O] Completion value given in NtSetIoCompletion or in async operation
+ *      iosb            [O] IO_STATUS_BLOCK of completed asynchronous operation
+ *      WaitTime        [I] optional wait time in NTDLL format
+ *
+ */
+NTSTATUS WINAPI NtRemoveIoCompletion( HANDLE CompletionPort, PULONG_PTR CompletionKey,
+                                      PULONG_PTR CompletionValue, PIO_STATUS_BLOCK iosb,
+                                      PLARGE_INTEGER WaitTime )
+{
+    NTSTATUS status;
+
+    TRACE("(%p, %p, %p, %p, %p)\n", CompletionPort, CompletionKey,
+          CompletionValue, iosb, WaitTime);
+
+    for(;;)
+    {
+        SERVER_START_REQ( remove_completion )
+        {
+            req->handle = wine_server_obj_handle( CompletionPort );
+            if (!(status = wine_server_call( req )))
+            {
+                *CompletionKey    = reply->ckey;
+                *CompletionValue  = reply->cvalue;
+                iosb->Information = reply->information;
+                iosb->u.Status    = reply->status;
+            }
+        }
+        SERVER_END_REQ;
+        if (status != STATUS_PENDING) break;
+
+        status = NtWaitForSingleObject( CompletionPort, FALSE, WaitTime );
+        if (status != WAIT_OBJECT_0) break;
+    }
+    return status;
+}
+
+/******************************************************************
+ *              NtRemoveIoCompletionEx (NTDLL.@)
+ *              ZwRemoveIoCompletionEx (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRemoveIoCompletionEx( HANDLE port, FILE_IO_COMPLETION_INFORMATION *info, ULONG count,
+                                        ULONG *written, LARGE_INTEGER *timeout, BOOLEAN alertable )
+{
+    NTSTATUS ret;
+    ULONG i = 0;
+
+    TRACE("%p %p %u %p %p %u\n", port, info, count, written, timeout, alertable);
+
+    for (;;)
+    {
+        while (i < count)
+        {
+            SERVER_START_REQ( remove_completion )
+            {
+                req->handle = wine_server_obj_handle( port );
+                if (!(ret = wine_server_call( req )))
+                {
+                    info[i].CompletionKey             = reply->ckey;
+                    info[i].CompletionValue           = reply->cvalue;
+                    info[i].IoStatusBlock.Information = reply->information;
+                    info[i].IoStatusBlock.u.Status    = reply->status;
+                }
+            }
+            SERVER_END_REQ;
+
+            if (ret != STATUS_SUCCESS) break;
+
+            ++i;
+        }
+
+        if (i || ret != STATUS_PENDING)
+        {
+            if (ret == STATUS_PENDING)
+                ret = STATUS_SUCCESS;
+            break;
+        }
+
+        ret = NtWaitForSingleObject( port, alertable, timeout );
+        if (ret != WAIT_OBJECT_0) break;
+    }
+
+    *written = i ? i : 1;
+    return ret;
+}
+
+/******************************************************************
+ *              NtOpenIoCompletion (NTDLL.@)
+ *              ZwOpenIoCompletion (NTDLL.@)
+ *
+ * Opens I/O completion object
+ *
+ * PARAMS
+ *      CompletionPort     [O] completion object handle will be placed there
+ *      DesiredAccess      [I] desired access to a handle (combination of IO_COMPLETION_*)
+ *      ObjectAttributes   [I] completion object name
+ *
+ */
+NTSTATUS WINAPI NtOpenIoCompletion( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS status;
+
+    if (!handle) return STATUS_INVALID_PARAMETER;
+    if ((status = validate_open_object_attributes( attr ))) return status;
+
+    SERVER_START_REQ( open_completion )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        status = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+/******************************************************************
+ *              NtQueryIoCompletion (NTDLL.@)
+ *              ZwQueryIoCompletion (NTDLL.@)
+ *
+ * Requests information about given I/O completion object
+ *
+ * PARAMS
+ *      CompletionPort        [I] HANDLE to completion port to request
+ *      InformationClass      [I] information class
+ *      CompletionInformation [O] user-provided buffer for data
+ *      BufferLength          [I] buffer length
+ *      RequiredLength        [O] required buffer length
+ *
+ */
+NTSTATUS WINAPI NtQueryIoCompletion( HANDLE CompletionPort, IO_COMPLETION_INFORMATION_CLASS InformationClass,
+                                     PVOID CompletionInformation, ULONG BufferLength, PULONG RequiredLength )
+{
+    NTSTATUS status;
+
+    TRACE("(%p, %d, %p, 0x%x, %p)\n", CompletionPort, InformationClass, CompletionInformation,
+          BufferLength, RequiredLength);
+
+    if (!CompletionInformation) return STATUS_INVALID_PARAMETER;
+    switch( InformationClass )
+    {
+        case IoCompletionBasicInformation:
+            {
+                ULONG *info = CompletionInformation;
+
+                if (RequiredLength) *RequiredLength = sizeof(*info);
+                if (BufferLength != sizeof(*info))
+                    status = STATUS_INFO_LENGTH_MISMATCH;
+                else
+                {
+                    SERVER_START_REQ( query_completion )
+                    {
+                        req->handle = wine_server_obj_handle( CompletionPort );
+                        if (!(status = wine_server_call( req )))
+                            *info = reply->depth;
+                    }
+                    SERVER_END_REQ;
+                }
+            }
+            break;
+        default:
+            status = STATUS_INVALID_PARAMETER;
+            break;
+    }
+    return status;
+}
+
+NTSTATUS NTDLL_AddCompletion( HANDLE hFile, ULONG_PTR CompletionValue,
+                              NTSTATUS CompletionStatus, ULONG Information, BOOL async )
+{
+    NTSTATUS status;
 
+    SERVER_START_REQ( add_fd_completion )
+    {
+        req->handle      = wine_server_obj_handle( hFile );
+        req->cvalue      = CompletionValue;
+        req->status      = CompletionStatus;
+        req->information = Information;
+        req->async       = async;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return status;
+}
 
 /******************************************************************
  *              RtlRunOnceInitialize (NTDLL.@)
@@ -153,6 +1672,291 @@ DWORD WINAPI RtlRunOnceExecuteOnce( RTL_RUN_ONCE *once, PRTL_RUN_ONCE_INIT_FN fu
     return RtlRunOnceComplete( once, 0, context ? *context : NULL );
 }
 
+#ifdef __linux__
+
+/* Futex-based SRW lock implementation:
+ *
+ * Since we can rely on the kernel to release all threads and don't need to
+ * worry about NtReleaseKeyedEvent(), we can simplify the layout a bit. The
+ * layout looks like this:
+ *
+ *    31 - Exclusive lock bit, set if the resource is owned exclusively.
+ * 30-16 - Number of exclusive waiters. Unlike the fallback implementation,
+ *         this does not include the thread owning the lock, or shared threads
+ *         waiting on the lock.
+ *    15 - Does this lock have any shared waiters? We use this as an
+ *         optimization to avoid unnecessary FUTEX_WAKE_BITSET calls when
+ *         releasing an exclusive lock.
+ *  14-0 - Number of shared owners. Unlike the fallback implementation, this
+ *         does not include the number of shared threads waiting on the lock.
+ *         Thus the state [1, x, >=1] will never occur.
+ */
+
+#define SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT        0x80000000
+#define SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK    0x7fff0000
+#define SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_INC     0x00010000
+#define SRWLOCK_FUTEX_SHARED_WAITERS_BIT        0x00008000
+#define SRWLOCK_FUTEX_SHARED_OWNERS_MASK        0x00007fff
+#define SRWLOCK_FUTEX_SHARED_OWNERS_INC         0x00000001
+
+/* Futex bitmasks; these are independent from the bits in the lock itself. */
+#define SRWLOCK_FUTEX_BITSET_EXCLUSIVE  1
+#define SRWLOCK_FUTEX_BITSET_SHARED     2
+
+static NTSTATUS fast_try_acquire_srw_exclusive( RTL_SRWLOCK *lock )
+{
+    int old, new, *futex;
+    NTSTATUS ret;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &lock->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    do
+    {
+        old = *futex;
+
+        if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
+                && !(old & SRWLOCK_FUTEX_SHARED_OWNERS_MASK))
+        {
+            /* Not locked exclusive or shared. We can try to grab it. */
+            new = old | SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT;
+            ret = STATUS_SUCCESS;
+        }
+        else
+        {
+            new = old;
+            ret = STATUS_TIMEOUT;
+        }
+    } while (InterlockedCompareExchange( futex, new, old ) != old);
+
+    return ret;
+}
+
+static NTSTATUS fast_acquire_srw_exclusive( RTL_SRWLOCK *lock )
+{
+    int old, new, *futex;
+    BOOLEAN wait;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &lock->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    /* Atomically increment the exclusive waiter count. */
+    do
+    {
+        old = *futex;
+        new = old + SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_INC;
+        assert(new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK);
+    } while (InterlockedCompareExchange( futex, new, old ) != old);
+
+    for (;;)
+    {
+        do
+        {
+            old = *futex;
+
+            if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
+                    && !(old & SRWLOCK_FUTEX_SHARED_OWNERS_MASK))
+            {
+                /* Not locked exclusive or shared. We can try to grab it. */
+                new = old | SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT;
+                assert(old & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK);
+                new -= SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_INC;
+                wait = FALSE;
+            }
+            else
+            {
+                new = old;
+                wait = TRUE;
+            }
+        } while (InterlockedCompareExchange( futex, new, old ) != old);
+
+        if (!wait)
+            return STATUS_SUCCESS;
+
+        futex_wait_bitset( futex, new, NULL, SRWLOCK_FUTEX_BITSET_EXCLUSIVE );
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS fast_try_acquire_srw_shared( RTL_SRWLOCK *lock )
+{
+    int new, old, *futex;
+    NTSTATUS ret;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &lock->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    do
+    {
+        old = *futex;
+
+        if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
+                && !(old & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
+        {
+            /* Not locked exclusive, and no exclusive waiters. We can try to
+             * grab it. */
+            new = old + SRWLOCK_FUTEX_SHARED_OWNERS_INC;
+            assert(new & SRWLOCK_FUTEX_SHARED_OWNERS_MASK);
+            ret = STATUS_SUCCESS;
+        }
+        else
+        {
+            new = old;
+            ret = STATUS_TIMEOUT;
+        }
+    } while (InterlockedCompareExchange( futex, new, old ) != old);
+
+    return ret;
+}
+
+static NTSTATUS fast_acquire_srw_shared( RTL_SRWLOCK *lock )
+{
+    int old, new, *futex;
+    BOOLEAN wait;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &lock->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    for (;;)
+    {
+        do
+        {
+            old = *futex;
+
+            if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
+                    && !(old & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
+            {
+                /* Not locked exclusive, and no exclusive waiters. We can try
+                 * to grab it. */
+                new = old + SRWLOCK_FUTEX_SHARED_OWNERS_INC;
+                assert(new & SRWLOCK_FUTEX_SHARED_OWNERS_MASK);
+                wait = FALSE;
+            }
+            else
+            {
+                new = old | SRWLOCK_FUTEX_SHARED_WAITERS_BIT;
+                wait = TRUE;
+            }
+        } while (InterlockedCompareExchange( futex, new, old ) != old);
+
+        if (!wait)
+            return STATUS_SUCCESS;
+
+        futex_wait_bitset( futex, new, NULL, SRWLOCK_FUTEX_BITSET_SHARED );
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS fast_release_srw_exclusive( RTL_SRWLOCK *lock )
+{
+    int old, new, *futex;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &lock->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    do
+    {
+        old = *futex;
+
+        if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT))
+        {
+            ERR("Lock %p is not owned exclusive! (%#x)\n", lock, *futex);
+            return STATUS_RESOURCE_NOT_OWNED;
+        }
+
+        new = old & ~SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT;
+
+        if (!(new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
+            new &= ~SRWLOCK_FUTEX_SHARED_WAITERS_BIT;
+    } while (InterlockedCompareExchange( futex, new, old ) != old);
+
+    if (new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK)
+        futex_wake_bitset( futex, 1, SRWLOCK_FUTEX_BITSET_EXCLUSIVE );
+    else if (old & SRWLOCK_FUTEX_SHARED_WAITERS_BIT)
+        futex_wake_bitset( futex, INT_MAX, SRWLOCK_FUTEX_BITSET_SHARED );
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS fast_release_srw_shared( RTL_SRWLOCK *lock )
+{
+    int old, new, *futex;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &lock->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    do
+    {
+        old = *futex;
+
+        if (old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
+        {
+            ERR("Lock %p is owned exclusive! (%#x)\n", lock, *futex);
+            return STATUS_RESOURCE_NOT_OWNED;
+        }
+        else if (!(old & SRWLOCK_FUTEX_SHARED_OWNERS_MASK))
+        {
+            ERR("Lock %p is not owned shared! (%#x)\n", lock, *futex);
+            return STATUS_RESOURCE_NOT_OWNED;
+        }
+
+        new = old - SRWLOCK_FUTEX_SHARED_OWNERS_INC;
+    } while (InterlockedCompareExchange( futex, new, old ) != old);
+
+    /* Optimization: only bother waking if there are actually exclusive waiters. */
+    if (!(new & SRWLOCK_FUTEX_SHARED_OWNERS_MASK) && (new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
+        futex_wake_bitset( futex, 1, SRWLOCK_FUTEX_BITSET_EXCLUSIVE );
+
+    return STATUS_SUCCESS;
+}
+
+#else
+
+static NTSTATUS fast_try_acquire_srw_exclusive( RTL_SRWLOCK *lock )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_acquire_srw_exclusive( RTL_SRWLOCK *lock )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_try_acquire_srw_shared( RTL_SRWLOCK *lock )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_acquire_srw_shared( RTL_SRWLOCK *lock )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_release_srw_exclusive( RTL_SRWLOCK *lock )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_release_srw_shared( RTL_SRWLOCK *lock )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif
 
 /* SRW locks implementation
  *
@@ -300,7 +2104,7 @@ void WINAPI RtlInitializeSRWLock( RTL_SRWLOCK *lock )
  */
 void WINAPI RtlAcquireSRWLockExclusive( RTL_SRWLOCK *lock )
 {
-    if (unix_funcs->fast_RtlAcquireSRWLockExclusive( lock ) != STATUS_NOT_IMPLEMENTED)
+    if (fast_acquire_srw_exclusive( lock ) != STATUS_NOT_IMPLEMENTED)
         return;
 
     if (srwlock_lock_exclusive( (unsigned int *)&lock->Ptr, SRWLOCK_RES_EXCLUSIVE ))
@@ -318,7 +2122,7 @@ void WINAPI RtlAcquireSRWLockShared( RTL_SRWLOCK *lock )
 {
     unsigned int val, tmp;
 
-    if (unix_funcs->fast_RtlAcquireSRWLockShared( lock ) != STATUS_NOT_IMPLEMENTED)
+    if (fast_acquire_srw_shared( lock ) != STATUS_NOT_IMPLEMENTED)
         return;
 
     /* Acquires a shared lock. If it's currently not possible to add elements to
@@ -351,7 +2155,7 @@ void WINAPI RtlAcquireSRWLockShared( RTL_SRWLOCK *lock )
  */
 void WINAPI RtlReleaseSRWLockExclusive( RTL_SRWLOCK *lock )
 {
-    if (unix_funcs->fast_RtlReleaseSRWLockExclusive( lock ) != STATUS_NOT_IMPLEMENTED)
+    if (fast_release_srw_exclusive( lock ) != STATUS_NOT_IMPLEMENTED)
         return;
 
     srwlock_leave_exclusive( lock, srwlock_unlock_exclusive( (unsigned int *)&lock->Ptr,
@@ -363,7 +2167,7 @@ void WINAPI RtlReleaseSRWLockExclusive( RTL_SRWLOCK *lock )
  */
 void WINAPI RtlReleaseSRWLockShared( RTL_SRWLOCK *lock )
 {
-    if (unix_funcs->fast_RtlReleaseSRWLockShared( lock ) != STATUS_NOT_IMPLEMENTED)
+    if (fast_release_srw_shared( lock ) != STATUS_NOT_IMPLEMENTED)
         return;
 
     srwlock_leave_shared( lock, srwlock_lock_exclusive( (unsigned int *)&lock->Ptr,
@@ -381,7 +2185,7 @@ BOOLEAN WINAPI RtlTryAcquireSRWLockExclusive( RTL_SRWLOCK *lock )
 {
     NTSTATUS ret;
 
-    if ((ret = unix_funcs->fast_RtlTryAcquireSRWLockExclusive( lock )) != STATUS_NOT_IMPLEMENTED)
+    if ((ret = fast_try_acquire_srw_exclusive( lock )) != STATUS_NOT_IMPLEMENTED)
         return (ret == STATUS_SUCCESS);
 
     return InterlockedCompareExchange( (int *)&lock->Ptr, SRWLOCK_MASK_IN_EXCLUSIVE |
@@ -396,7 +2200,7 @@ BOOLEAN WINAPI RtlTryAcquireSRWLockShared( RTL_SRWLOCK *lock )
     unsigned int val, tmp;
     NTSTATUS ret;
 
-    if ((ret = unix_funcs->fast_RtlTryAcquireSRWLockShared( lock )) != STATUS_NOT_IMPLEMENTED)
+    if ((ret = fast_try_acquire_srw_shared( lock )) != STATUS_NOT_IMPLEMENTED)
         return (ret == STATUS_SUCCESS);
 
     for (val = *(unsigned int *)&lock->Ptr;; val = tmp)
@@ -409,6 +2213,105 @@ BOOLEAN WINAPI RtlTryAcquireSRWLockShared( RTL_SRWLOCK *lock )
     return TRUE;
 }
 
+#ifdef __linux__
+static NTSTATUS fast_wait_cv( int *futex, int val, const LARGE_INTEGER *timeout )
+{
+    struct timespec timespec;
+    int ret;
+
+    if (timeout && timeout->QuadPart != TIMEOUT_INFINITE)
+    {
+        timespec_from_timeout( &timespec, timeout );
+        ret = futex_wait( futex, val, &timespec );
+    }
+    else
+        ret = futex_wait( futex, val, NULL );
+
+    if (ret == -1 && errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    return STATUS_WAIT_0;
+}
+
+static NTSTATUS fast_sleep_cs_cv( RTL_CONDITION_VARIABLE *variable,
+        RTL_CRITICAL_SECTION *cs, const LARGE_INTEGER *timeout )
+{
+    NTSTATUS status;
+    int val, *futex;
+
+    if (!use_futexes())
+        return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &variable->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    val = *futex;
+
+    RtlLeaveCriticalSection( cs );
+    status = fast_wait_cv( futex, val, timeout );
+    RtlEnterCriticalSection( cs );
+    return status;
+}
+
+static NTSTATUS fast_sleep_srw_cv( RTL_CONDITION_VARIABLE *variable,
+        RTL_SRWLOCK *lock, const LARGE_INTEGER *timeout, ULONG flags )
+{
+    NTSTATUS status;
+    int val, *futex;
+
+    if (!use_futexes())
+        return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &variable->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    val = *futex;
+
+    if (flags & RTL_CONDITION_VARIABLE_LOCKMODE_SHARED)
+        RtlReleaseSRWLockShared( lock );
+    else
+        RtlReleaseSRWLockExclusive( lock );
+
+    status = fast_wait_cv( futex, val, timeout );
+
+    if (flags & RTL_CONDITION_VARIABLE_LOCKMODE_SHARED)
+        RtlAcquireSRWLockShared( lock );
+    else
+        RtlAcquireSRWLockExclusive( lock );
+    return status;
+}
+
+static NTSTATUS fast_wake_cv( RTL_CONDITION_VARIABLE *variable, int count )
+{
+    int *futex;
+
+    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
+
+    if (!(futex = get_futex( &variable->Ptr )))
+        return STATUS_NOT_IMPLEMENTED;
+
+    InterlockedIncrement( futex );
+    futex_wake( futex, count );
+    return STATUS_SUCCESS;
+}
+#else
+static NTSTATUS fast_sleep_srw_cv( RTL_CONDITION_VARIABLE *variable,
+        RTL_SRWLOCK *lock, const LARGE_INTEGER *timeout, ULONG flags )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_sleep_cs_cv( RTL_CONDITION_VARIABLE *variable,
+        RTL_CRITICAL_SECTION *cs, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_wake_cv( RTL_CONDITION_VARIABLE *variable, int count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+#endif
+
 /***********************************************************************
  *           RtlInitializeConditionVariable   (NTDLL.@)
  *
@@ -442,7 +2345,7 @@ void WINAPI RtlInitializeConditionVariable( RTL_CONDITION_VARIABLE *variable )
  */
 void WINAPI RtlWakeConditionVariable( RTL_CONDITION_VARIABLE *variable )
 {
-    if (unix_funcs->fast_RtlWakeConditionVariable( variable, 1 ) == STATUS_NOT_IMPLEMENTED)
+    if (fast_wake_cv( variable, 1 ) == STATUS_NOT_IMPLEMENTED)
     {
         InterlockedIncrement( (int *)&variable->Ptr );
         RtlWakeAddressSingle( variable );
@@ -456,7 +2359,7 @@ void WINAPI RtlWakeConditionVariable( RTL_CONDITION_VARIABLE *variable )
  */
 void WINAPI RtlWakeAllConditionVariable( RTL_CONDITION_VARIABLE *variable )
 {
-    if (unix_funcs->fast_RtlWakeConditionVariable( variable, INT_MAX ) == STATUS_NOT_IMPLEMENTED)
+    if (fast_wake_cv( variable, INT_MAX ) == STATUS_NOT_IMPLEMENTED)
     {
         InterlockedIncrement( (int *)&variable->Ptr );
         RtlWakeAddressAll( variable );
@@ -484,8 +2387,7 @@ NTSTATUS WINAPI RtlSleepConditionVariableCS( RTL_CONDITION_VARIABLE *variable, R
     NTSTATUS status;
     int val;
 
-    if ((status = unix_funcs->fast_RtlSleepConditionVariableCS( variable, crit,
-                                                                timeout )) != STATUS_NOT_IMPLEMENTED)
+    if ((status = fast_sleep_cs_cv( variable, crit, timeout )) != STATUS_NOT_IMPLEMENTED)
         return status;
 
     val = *(int *)&variable->Ptr;
@@ -520,8 +2422,7 @@ NTSTATUS WINAPI RtlSleepConditionVariableSRW( RTL_CONDITION_VARIABLE *variable,
     NTSTATUS status;
     int val;
 
-    if ((status = unix_funcs->fast_RtlSleepConditionVariableSRW( variable, lock, timeout,
-                                                                 flags )) != STATUS_NOT_IMPLEMENTED)
+    if ((status = fast_sleep_srw_cv( variable, lock, timeout, flags )) != STATUS_NOT_IMPLEMENTED)
         return status;
 
     val = *(int *)&variable->Ptr;
@@ -540,13 +2441,145 @@ NTSTATUS WINAPI RtlSleepConditionVariableSRW( RTL_CONDITION_VARIABLE *variable,
     return status;
 }
 
+static RTL_CRITICAL_SECTION addr_section;
+static RTL_CRITICAL_SECTION_DEBUG addr_section_debug =
+{
+    0, 0, &addr_section,
+    { &addr_section_debug.ProcessLocksList, &addr_section_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": addr_section") }
+};
+static RTL_CRITICAL_SECTION addr_section = { &addr_section_debug, -1, 0, 0, 0, 0 };
+
+static BOOL compare_addr( const void *addr, const void *cmp, SIZE_T size )
+{
+    switch (size)
+    {
+        case 1:
+            return (*(const UCHAR *)addr == *(const UCHAR *)cmp);
+        case 2:
+            return (*(const USHORT *)addr == *(const USHORT *)cmp);
+        case 4:
+            return (*(const ULONG *)addr == *(const ULONG *)cmp);
+        case 8:
+            return (*(const ULONG64 *)addr == *(const ULONG64 *)cmp);
+    }
+
+    return FALSE;
+}
+
+#ifdef __linux__
+/* We can't map addresses to futex directly, because an application can wait on
+ * 8 bytes, and we can't pass all 8 as the compare value to futex(). Instead we
+ * map all addresses to a small fixed table of futexes. This may result in
+ * spurious wakes, but the application is already expected to handle those. */
+
+static int addr_futex_table[256];
+
+static inline int *hash_addr( const void *addr )
+{
+    ULONG_PTR val = (ULONG_PTR)addr;
+
+    return &addr_futex_table[(val >> 2) & 255];
+}
+
+static inline NTSTATUS fast_wait_addr( const void *addr, const void *cmp, SIZE_T size,
+                                       const LARGE_INTEGER *timeout )
+{
+    int *futex;
+    int val;
+    struct timespec timespec;
+    int ret;
+
+    if (!use_futexes())
+        return STATUS_NOT_IMPLEMENTED;
+
+    futex = hash_addr( addr );
+
+    /* We must read the previous value of the futex before checking the value
+     * of the address being waited on. That way, if we receive a wake between
+     * now and waiting on the futex, we know that val will have changed.
+     * Use an atomic load so that memory accesses are ordered between this read
+     * and the increment below. */
+    val = InterlockedCompareExchange( futex, 0, 0 );
+    if (!compare_addr( addr, cmp, size ))
+        return STATUS_SUCCESS;
+
+    if (timeout)
+    {
+        timespec_from_timeout( &timespec, timeout );
+        ret = futex_wait( futex, val, &timespec );
+    }
+    else
+        ret = futex_wait( futex, val, NULL );
+
+    if (ret == -1 && errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    return STATUS_SUCCESS;
+}
+
+static inline NTSTATUS fast_wake_addr( const void *addr )
+{
+    int *futex;
+
+    if (!use_futexes())
+        return STATUS_NOT_IMPLEMENTED;
+
+    futex = hash_addr( addr );
+
+    InterlockedIncrement( futex );
+
+    futex_wake( futex, INT_MAX );
+    return STATUS_SUCCESS;
+}
+#else
+static inline NTSTATUS fast_wait_addr( const void *addr, const void *cmp, SIZE_T size,
+                                       const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static inline NTSTATUS fast_wake_addr( const void *addr )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+#endif
+
 /***********************************************************************
  *           RtlWaitOnAddress   (NTDLL.@)
  */
 NTSTATUS WINAPI RtlWaitOnAddress( const void *addr, const void *cmp, SIZE_T size,
                                   const LARGE_INTEGER *timeout )
 {
-    return unix_funcs->RtlWaitOnAddress( addr, cmp, size, timeout );
+    select_op_t select_op;
+    NTSTATUS ret;
+    timeout_t abs_timeout = timeout ? timeout->QuadPart : TIMEOUT_INFINITE;
+
+    if (size != 1 && size != 2 && size != 4 && size != 8)
+        return STATUS_INVALID_PARAMETER;
+
+    if ((ret = fast_wait_addr( addr, cmp, size, timeout )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
+    RtlEnterCriticalSection( &addr_section );
+    if (!compare_addr( addr, cmp, size ))
+    {
+        RtlLeaveCriticalSection( &addr_section );
+        return STATUS_SUCCESS;
+    }
+
+    if (abs_timeout < 0)
+    {
+        LARGE_INTEGER now;
+
+        RtlQueryPerformanceCounter(&now);
+        abs_timeout -= now.QuadPart;
+    }
+
+    select_op.keyed_event.op     = SELECT_KEYED_EVENT_WAIT;
+    select_op.keyed_event.handle = wine_server_obj_handle( keyed_event );
+    select_op.keyed_event.key    = wine_server_client_ptr( addr );
+
+    return server_select( &select_op, sizeof(select_op.keyed_event), SELECT_INTERRUPTIBLE, abs_timeout, NULL, &addr_section, NULL );
 }
 
 /***********************************************************************
@@ -554,7 +2587,12 @@ NTSTATUS WINAPI RtlWaitOnAddress( const void *addr, const void *cmp, SIZE_T size
  */
 void WINAPI RtlWakeAddressAll( const void *addr )
 {
-    return unix_funcs->RtlWakeAddressAll( addr );
+    if (fast_wake_addr( addr ) != STATUS_NOT_IMPLEMENTED)
+        return;
+
+    RtlEnterCriticalSection( &addr_section );
+    while (NtReleaseKeyedEvent( 0, addr, 0, &zero_timeout ) == STATUS_SUCCESS) {}
+    RtlLeaveCriticalSection( &addr_section );
 }
 
 /***********************************************************************
@@ -562,5 +2600,10 @@ void WINAPI RtlWakeAddressAll( const void *addr )
  */
 void WINAPI RtlWakeAddressSingle( const void *addr )
 {
-    return unix_funcs->RtlWakeAddressSingle( addr );
+    if (fast_wake_addr( addr ) != STATUS_NOT_IMPLEMENTED)
+        return;
+
+    RtlEnterCriticalSection( &addr_section );
+    NtReleaseKeyedEvent( 0, addr, 0, &zero_timeout );
+    RtlLeaveCriticalSection( &addr_section );
 }
diff --git a/dlls/ntdll/unix/tape.c b/dlls/ntdll/tape.c
similarity index 94%
rename from dlls/ntdll/unix/tape.c
rename to dlls/ntdll/tape.c
index 6824d42a74..90505847b1 100644
--- a/dlls/ntdll/unix/tape.c
+++ b/dlls/ntdll/tape.c
@@ -18,16 +18,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 #include "wine/port.h"
 
 #include <stdarg.h>
 #include <stdio.h>
-#include <errno.h>
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
@@ -47,6 +42,7 @@
 #ifndef MT_ST_BLKSIZE_MASK
 #define MT_ST_BLKSIZE_MASK 0xffffff
 #endif
+
 /* Darwin 7.9.0 has MTSETBSIZ instead of MTSETBLK */
 #if !defined(MTSETBLK) && defined(MTSETBSIZ)
 #define MTSETBLK MTSETBSIZ
@@ -59,8 +55,8 @@
 #include "winternl.h"
 #include "winioctl.h"
 #include "ddk/ntddtape.h"
+#include "ntdll_misc.h"
 #include "wine/server.h"
-#include "unix_private.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(tape);
@@ -95,7 +91,7 @@ static const char *io2str( DWORD io )
 static inline NTSTATUS TAPE_GetStatus( int error )
 {
     if (!error) return STATUS_SUCCESS;
-    return errno_to_status( errno );
+    return FILE_GetNtStatus();
 }
 #endif
 
@@ -380,7 +376,7 @@ static NTSTATUS TAPE_SetDriveParams( int fd, const TAPE_SET_DRIVE_PARAMETERS *da
     return STATUS_NOT_SUPPORTED;
 #endif
 }
-
+        
 /******************************************************************
  *      TAPE_SetMediaParams
  */
@@ -390,7 +386,7 @@ static NTSTATUS TAPE_SetMediaParams( int fd, const TAPE_SET_MEDIA_PARAMETERS *da
     struct mtop cmd;
 
     TRACE( "fd: %d blocksize: 0x%08x\n", fd, data->BlockSize );
-
+    
     cmd.mt_op = MTSETBLK;
     cmd.mt_count = data->BlockSize;
 
@@ -400,7 +396,7 @@ static NTSTATUS TAPE_SetMediaParams( int fd, const TAPE_SET_MEDIA_PARAMETERS *da
     return STATUS_NOT_SUPPORTED;
 #endif
 }
-
+        
 /******************************************************************
  *      TAPE_SetPosition
  */
@@ -515,24 +511,29 @@ static NTSTATUS TAPE_WriteMarks( int fd, const TAPE_WRITE_MARKS *data )
 }
 
 /******************************************************************
- *		tape_DeviceIoControl
+ *		TAPE_DeviceIoControl
+ *
+ * SEE ALSO
+ *   NtDeviceIoControl.
  */
-NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                               IO_STATUS_BLOCK *io, ULONG code,
-                               void *in_buffer, ULONG in_size, void *out_buffer, ULONG out_size )
+NTSTATUS TAPE_DeviceIoControl( HANDLE device, HANDLE event,
+    PIO_APC_ROUTINE apc, PVOID apc_user, PIO_STATUS_BLOCK io_status,
+    ULONG io_control, LPVOID in_buffer, DWORD in_size,
+    LPVOID out_buffer, DWORD out_size )
 {
     DWORD sz = 0;
     NTSTATUS status = STATUS_INVALID_PARAMETER;
     int fd, needs_close;
 
-    TRACE( "%p %s %p %d %p %d %p\n", device, io2str(code),
-           in_buffer, in_size, out_buffer, out_size, io );
+    TRACE( "%p %s %p %d %p %d %p\n", device, io2str(io_control),
+           in_buffer, in_size, out_buffer, out_size, io_status );
 
-    io->Information = 0;
+    io_status->Information = 0;
 
-    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL ))) goto error;
+    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL )))
+        goto error;
 
-    switch (code)
+    switch (io_control)
     {
     case IOCTL_TAPE_CREATE_PARTITION:
         status = TAPE_CreatePartition( fd, in_buffer );
@@ -551,7 +552,7 @@ NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc,
                                    out_buffer );
         break;
     case IOCTL_TAPE_GET_STATUS:
-        status = errno_to_status( errno );
+        status = FILE_GetNtStatus();
         break;
     case IOCTL_TAPE_PREPARE:
         status = TAPE_Prepare( fd, in_buffer );
@@ -574,15 +575,16 @@ NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc,
         break;
     default:
         FIXME( "Unsupported IOCTL %x (type=%x access=%x func=%x meth=%x)\n",
-               code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3 );
+               io_control, io_control >> 16, (io_control >> 14) & 3,
+               (io_control >> 2) & 0xfff, io_control & 3 );
         break;
     }
 
     if (needs_close) close( fd );
 
 error:
-    io->u.Status = status;
-    io->Information = sz;
+    io_status->u.Status = status;
+    io_status->Information = sz;
     if (event) NtSetEvent( event, NULL );
     return status;
 }
diff --git a/dlls/ntdll/tests/directory.c b/dlls/ntdll/tests/directory.c
index d21a2e64f8..4618f4eaff 100644
--- a/dlls/ntdll/tests/directory.c
+++ b/dlls/ntdll/tests/directory.c
@@ -450,7 +450,7 @@ static void test_NtQueryDirectoryFile(void)
 {
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING ntdirname, mask;
-    char testdirA[MAX_PATH], buffer[MAX_PATH];
+    char testdirA[MAX_PATH];
     WCHAR testdirW[MAX_PATH];
     int i;
     IO_STATUS_BLOCK io;
@@ -462,7 +462,7 @@ static void test_NtQueryDirectoryFile(void)
     FILE_NAMES_INFORMATION *names;
     const WCHAR *filename = fbdi->FileName;
     NTSTATUS status;
-    HANDLE dirh, h;
+    HANDLE dirh;
 
     /* Clean up from prior aborted run, if any, then set up test files */
     ok(GetTempPathA(MAX_PATH, testdirA), "couldn't get temp dir\n");
@@ -728,18 +728,6 @@ static void test_NtQueryDirectoryFile(void)
     ok(status == STATUS_INVALID_HANDLE, "wrong status %x\n", status);
     ok(U(io).Status == 0xdeadbeef, "wrong status %x\n", U(io).Status);
 
-    GetModuleFileNameA( 0, buffer, sizeof(buffer) );
-    h = CreateFileA( buffer, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0 );
-    if (h != INVALID_HANDLE_VALUE)
-    {
-        U(io).Status = 0xdeadbeef;
-        status = pNtQueryDirectoryFile( h, 0, NULL, NULL, &io, data, data_size,
-                                        FileBothDirectoryInformation, TRUE, NULL, TRUE );
-        ok(status == STATUS_INVALID_PARAMETER, "wrong status %x\n", status);
-        ok(U(io).Status == 0xdeadbeef, "wrong status %x\n", U(io).Status);
-        CloseHandle ( h );
-    }
-
 done:
     test_directory_sort( testdirW );
     tear_down_attribute_test( testdirW );
@@ -845,7 +833,6 @@ static void test_redirection(void)
 {
     ULONG old, cur;
     NTSTATUS status;
-    ULONGLONG *tls64 = NULL;
 
     if (!pRtlWow64EnableFsRedirection || !pRtlWow64EnableFsRedirectionEx)
     {
@@ -860,39 +847,21 @@ static void test_redirection(void)
     }
     ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
 
-#ifndef _WIN64
-    if (NtCurrentTeb()->GdiBatchCount)
-        tls64 = ((TEB64 *)NtCurrentTeb()->GdiBatchCount)->TlsSlots + WOW64_TLS_FILESYSREDIR;
-#endif
-
     status = pRtlWow64EnableFsRedirectionEx( FALSE, &cur );
     ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
     ok( !cur, "RtlWow64EnableFsRedirectionEx got %u\n", cur );
-    if (tls64) ok( *tls64 == FALSE, "wrong tls %s\n", wine_dbgstr_longlong(*tls64) );
 
     status = pRtlWow64EnableFsRedirectionEx( TRUE, &cur );
     ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
     status = pRtlWow64EnableFsRedirectionEx( TRUE, &cur );
     ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
     ok( cur == 1, "RtlWow64EnableFsRedirectionEx got %u\n", cur );
-    if (tls64) ok( *tls64 == TRUE, "wrong tls %s\n", wine_dbgstr_longlong(*tls64) );
 
     status = pRtlWow64EnableFsRedirection( TRUE );
     ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
     status = pRtlWow64EnableFsRedirectionEx( TRUE, &cur );
     ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
     ok( !cur, "RtlWow64EnableFsRedirectionEx got %u\n", cur );
-    if (tls64) ok( *tls64 == TRUE, "wrong tls %s\n", wine_dbgstr_longlong(*tls64) );
-
-    status = pRtlWow64EnableFsRedirectionEx( 123, &cur );
-    ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
-    ok( cur == TRUE, "RtlWow64EnableFsRedirectionEx got %u\n", cur );
-    if (tls64) ok( *tls64 == 123, "wrong tls %s\n", wine_dbgstr_longlong(*tls64) );
-
-    status = pRtlWow64EnableFsRedirectionEx( 0xdeadbeef, &cur );
-    ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
-    ok( cur == 123, "RtlWow64EnableFsRedirectionEx got %u\n", cur );
-    if (tls64) ok( *tls64 == 0xdeadbeef, "wrong tls %s\n", wine_dbgstr_longlong(*tls64) );
 
     status = pRtlWow64EnableFsRedirectionEx( TRUE, NULL );
     ok( status == STATUS_ACCESS_VIOLATION, "RtlWow64EnableFsRedirectionEx failed with status %x\n", status );
@@ -906,7 +875,6 @@ static void test_redirection(void)
     status = pRtlWow64EnableFsRedirectionEx( FALSE, &cur );
     ok( !status, "RtlWow64EnableFsRedirectionEx failed status %x\n", status );
     ok( cur == 1, "RtlWow64EnableFsRedirectionEx got %u\n", cur );
-    if (tls64) ok( *tls64 == FALSE, "wrong tls %s\n", wine_dbgstr_longlong(*tls64) );
 
     pRtlWow64EnableFsRedirectionEx( old, &cur );
 }
diff --git a/dlls/ntdll/tests/env.c b/dlls/ntdll/tests/env.c
index 4865a0a8e5..9883739eba 100644
--- a/dlls/ntdll/tests/env.c
+++ b/dlls/ntdll/tests/env.c
@@ -386,7 +386,7 @@ static void test_process_params(void)
     else
     {
         size = HeapSize( GetProcessHeap(), 0, params );
-        ok( size != ~(SIZE_T)0, "not a heap block %p\n", params );
+        ok( size != ~0UL, "not a heap block %p\n", params );
         ok( params->AllocationSize == params->Size,
             "wrong AllocationSize %x/%x\n", params->AllocationSize, params->Size );
     }
@@ -456,7 +456,7 @@ static void test_process_params(void)
     else
     {
         size = HeapSize( GetProcessHeap(), 0, params );
-        ok( size != ~(SIZE_T)0, "not a heap block %p\n", params );
+        ok( size != ~0UL, "not a heap block %p\n", params );
         ok( params->AllocationSize == params->Size,
             "wrong AllocationSize %x/%x\n", params->AllocationSize, params->Size );
     }
@@ -509,7 +509,7 @@ static void test_process_params(void)
     else
     {
         size = HeapSize( GetProcessHeap(), 0, cur_params );
-        ok( size != ~(SIZE_T)0, "not a heap block %p\n", cur_params );
+        ok( size != ~0UL, "not a heap block %p\n", cur_params );
         ok( cur_params->AllocationSize == cur_params->Size,
             "wrong AllocationSize %x/%x\n", cur_params->AllocationSize, cur_params->Size );
         ok( cur_params->Size == size, "wrong Size %x/%lx\n", cur_params->Size, size );
@@ -548,7 +548,7 @@ static void test_process_params(void)
     else
     {
         size = HeapSize( GetProcessHeap(), 0, initial_env );
-        ok( size != ~(SIZE_T)0, "env is not a heap block %p / %p\n", cur_params, initial_env );
+        ok( size != ~0UL, "env is not a heap block %p / %p\n", cur_params, initial_env );
     }
 }
 
diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index 9e33417c7f..e85b0911b8 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -23,6 +23,7 @@
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
+#define NONAMELESSUNION
 #include "windef.h"
 #include "winbase.h"
 #include "winnt.h"
@@ -42,7 +43,6 @@ static PVOID     (WINAPI *pRtlAddVectoredExceptionHandler)(ULONG first, PVECTORE
 static ULONG     (WINAPI *pRtlRemoveVectoredExceptionHandler)(PVOID handler);
 static PVOID     (WINAPI *pRtlAddVectoredContinueHandler)(ULONG first, PVECTORED_EXCEPTION_HANDLER func);
 static ULONG     (WINAPI *pRtlRemoveVectoredContinueHandler)(PVOID handler);
-static void      (WINAPI *pRtlSetUnhandledExceptionFilter)(PRTL_EXCEPTION_FILTER filter);
 static NTSTATUS  (WINAPI *pNtReadVirtualMemory)(HANDLE, const void*, void*, SIZE_T, SIZE_T*);
 static NTSTATUS  (WINAPI *pNtTerminateProcess)(HANDLE handle, LONG exit_code);
 static NTSTATUS  (WINAPI *pNtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);
@@ -68,10 +68,6 @@ typedef struct _RTL_UNLOAD_EVENT_TRACE
 static RTL_UNLOAD_EVENT_TRACE *(WINAPI *pRtlGetUnloadEventTrace)(void);
 static void (WINAPI *pRtlGetUnloadEventTraceEx)(ULONG **element_size, ULONG **element_count, void **event_trace);
 
-#ifndef EH_NESTED_CALL
-#define EH_NESTED_CALL 0x10
-#endif
-
 #if defined(__x86_64__)
 typedef struct
 {
@@ -164,9 +160,6 @@ static int       (CDECL *p_setjmp)(_JUMP_BUFFER*);
 
 static int      my_argc;
 static char**   my_argv;
-static BOOL     is_wow64;
-static BOOL have_vectored_api;
-static int test_stage;
 
 #ifdef __i386__
 
@@ -178,6 +171,10 @@ static int test_stage;
 #define MEM_EXECUTE_OPTION_PERMANENT 0x08
 #endif
 
+static int      test_stage;
+
+static BOOL is_wow64;
+
 /* Test various instruction combinations that cause a protection fault on the i386,
  * and check what the resulting exception looks like.
  */
@@ -330,6 +327,7 @@ static const struct exception
 };
 
 static int got_exception;
+static BOOL have_vectored_api;
 
 static void run_exception_test(void *handler, const void* context,
                                const void *code, unsigned int code_size,
@@ -381,16 +379,14 @@ static LONG CALLBACK rtlraiseexception_vectored_handler(EXCEPTION_POINTERS *Exce
     if(rec->ExceptionCode == EXCEPTION_BREAKPOINT)
     {
         ok(context->Eip == (DWORD)code_mem + 0xa ||
-           broken(context->Eip == (DWORD)code_mem + 0xb) /* win2k3 */ ||
-           broken(context->Eip == (DWORD)code_mem + 0xd) /* w2008 */,
+           broken(context->Eip == (DWORD)code_mem + 0xb), /* win2k3 */
            "Eip at %x instead of %x or %x\n", context->Eip,
            (DWORD)code_mem + 0xa, (DWORD)code_mem + 0xb);
     }
     else
     {
-        ok(context->Eip == (DWORD)code_mem + 0xb ||
-           broken(context->Eip == (DWORD)code_mem + 0xd) /* w2008 */,
-           "Eip at %x instead of %x\n", context->Eip, (DWORD)code_mem + 0xb);
+        ok(context->Eip == (DWORD)code_mem + 0xb, "Eip at %x instead of %x\n",
+           context->Eip, (DWORD)code_mem + 0xb);
     }
 
     /* test if context change is preserved from vectored handler to stack handlers */
@@ -418,16 +414,14 @@ static DWORD rtlraiseexception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTR
     if(rec->ExceptionCode == EXCEPTION_BREAKPOINT)
     {
         ok(context->Eip == (DWORD)code_mem + 0xa ||
-           broken(context->Eip == (DWORD)code_mem + 0xb) /* win2k3 */ ||
-           broken(context->Eip == (DWORD)code_mem + 0xd) /* w2008 */,
+           broken(context->Eip == (DWORD)code_mem + 0xb), /* win2k3 */
            "Eip at %x instead of %x or %x\n", context->Eip,
            (DWORD)code_mem + 0xa, (DWORD)code_mem + 0xb);
     }
     else
     {
-        ok(context->Eip == (DWORD)code_mem + 0xb ||
-           broken(context->Eip == (DWORD)code_mem + 0xd) /* w2008 */,
-           "Eip at %x instead of %x\n", context->Eip, (DWORD)code_mem + 0xb);
+        ok(context->Eip == (DWORD)code_mem + 0xb, "Eip at %x instead of %x\n",
+           context->Eip, (DWORD)code_mem + 0xb);
     }
 
     if(have_vectored_api)
@@ -1053,10 +1047,11 @@ static void test_debugger(void)
                 {
                     ok((char *)ctx.Eip == (char *)code_mem_address + 0xb, "Eip at %x instead of %p\n",
                        ctx.Eip, (char *)code_mem_address + 0xb);
-                    /* setting the context from debugger does not affect the context that the
-                     * exception handler gets, except on w2008 */
-                    ctx.Eip = (UINT_PTR)code_mem_address + 0xd;
+                    /* setting the context from debugger does not affect the context, the exception handlers gets */
+                    /* uncomment once wine is fixed */
+                    /* ctx.Eip = 0x12345; */
                     ctx.Eax = 0xf00f00f1;
+
                     /* let the debuggee handle the exception */
                     continuestatus = DBG_EXCEPTION_NOT_HANDLED;
                 }
@@ -1066,11 +1061,16 @@ static void test_debugger(void)
                     {
                         /* debugger gets first chance exception with unmodified ctx.Eip */
                         ok((char *)ctx.Eip == (char *)code_mem_address + 0xb, "Eip at 0x%x instead of %p\n",
-                           ctx.Eip, (char *)code_mem_address + 0xb);
-                        ctx.Eip = (UINT_PTR)code_mem_address + 0xd;
+                            ctx.Eip, (char *)code_mem_address + 0xb);
+
+                        /* setting the context from debugger does not affect the context, the exception handlers gets */
+                        /* uncomment once wine is fixed */
+                        /* ctx.Eip = 0x12345; */
                         ctx.Eax = 0xf00f00f1;
+
                         /* pass exception to debuggee
-                         * exception will not be handled and a second chance exception will be raised */
+                         * exception will not be handled and
+                         * a second chance exception will be raised */
                         continuestatus = DBG_EXCEPTION_NOT_HANDLED;
                     }
                     else
@@ -1080,8 +1080,7 @@ static void test_debugger(void)
                         if (de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT)
                         {
                             ok((char *)ctx.Eip == (char *)code_mem_address + 0xa ||
-                               broken(is_wow64 && (char *)ctx.Eip == (char *)code_mem_address + 0xb) ||
-                               broken((char *)ctx.Eip == (char *)code_mem_address + 0xd) /* w2008 */,
+                               broken(is_wow64 && (char *)ctx.Eip == (char *)code_mem_address + 0xb),
                                "Eip at 0x%x instead of %p\n",
                                 ctx.Eip, (char *)code_mem_address + 0xa);
                             /* need to fixup Eip for debuggee */
@@ -1089,10 +1088,8 @@ static void test_debugger(void)
                                 ctx.Eip += 1;
                         }
                         else
-                            ok((char *)ctx.Eip == (char *)code_mem_address + 0xb ||
-                               broken((char *)ctx.Eip == (char *)code_mem_address + 0xd) /* w2008 */,
-                               "Eip at 0x%x instead of %p\n",
-                               ctx.Eip, (char *)code_mem_address + 0xb);
+                            ok((char *)ctx.Eip == (char *)code_mem_address + 0xb, "Eip at 0x%x instead of %p\n",
+                                ctx.Eip, (char *)code_mem_address + 0xb);
                         /* here we handle exception */
                     }
                 }
@@ -1663,246 +1660,10 @@ static void test_thread_context(void)
 #undef COMPARE
 }
 
-static BYTE saved_KiUserExceptionDispatcher_bytes[7];
-static void *pKiUserExceptionDispatcher;
-static BOOL hook_called;
-static void *hook_KiUserExceptionDispatcher_eip;
-static void *dbg_except_continue_handler_eip;
-static void *hook_exception_address;
-
-static struct
-{
-    DWORD old_eax;
-    DWORD old_edx;
-    DWORD old_esi;
-    DWORD old_edi;
-    DWORD old_ebp;
-    DWORD old_esp;
-    DWORD new_eax;
-    DWORD new_edx;
-    DWORD new_esi;
-    DWORD new_edi;
-    DWORD new_ebp;
-    DWORD new_esp;
-}
-test_kiuserexceptiondispatcher_regs;
-
-static DWORD dbg_except_continue_handler(EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
-        CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher)
-{
-    ok(hook_called, "Hook was not called.\n");
-
-    ok(rec->ExceptionCode == 0x80000003, "Got unexpected ExceptionCode %#x.\n", rec->ExceptionCode);
-
-    got_exception = 1;
-    dbg_except_continue_handler_eip = (void *)context->Eip;
-    ++context->Eip;
-
-    context->Eip = (DWORD)code_mem + 0x1c;
-    context->Eax = 0xdeadbeef;
-    context->Esi = 0xdeadbeef;
-    pRtlUnwind(NtCurrentTeb()->Tib.ExceptionList, (void *)context->Eip, rec, (void *)0xdeadbeef);
-    return ExceptionContinueExecution;
-}
-
-static LONG WINAPI dbg_except_continue_vectored_handler(struct _EXCEPTION_POINTERS *e)
-{
-    EXCEPTION_RECORD *rec = e->ExceptionRecord;
-    CONTEXT *context = e->ContextRecord;
-
-    trace("dbg_except_continue_vectored_handler, code %#x, eip %#x, ExceptionAddress %p.\n",
-            rec->ExceptionCode, context->Eip, rec->ExceptionAddress);
-
-    ok(rec->ExceptionCode == 0x80000003, "Got unexpected ExceptionCode %#x.\n", rec->ExceptionCode);
-
-    got_exception = 1;
-
-    if ((ULONG_PTR)rec->ExceptionAddress == context->Eip + 1)
-    {
-        /* XP and Vista+ have ExceptionAddress == Eip + 1, Eip is adjusted even
-         * for software raised breakpoint exception.
-         * Win2003 has Eip not adjusted and matching ExceptionAddress.
-         * Win2008 has Eip not adjuated and ExceptionAddress not filled for
-         * software raised exception. */
-        context->Eip = (ULONG_PTR)rec->ExceptionAddress;
-    }
-
-    return EXCEPTION_CONTINUE_EXECUTION;
-}
-
-/* Use CDECL to leave arguments on stack. */
-void CDECL hook_KiUserExceptionDispatcher(EXCEPTION_RECORD *rec, CONTEXT *context)
-{
-    trace("rec %p, context %p.\n", rec, context);
-    trace("context->Eip %#x, context->Esp %#x, ContextFlags %#x.\n",
-            context->Eip, context->Esp, context->ContextFlags);
-
-    hook_called = TRUE;
-    /* Broken on Win2008, probably rec offset in stack is different. */
-    ok(rec->ExceptionCode == 0x80000003 || broken(!rec->ExceptionCode),
-            "Got unexpected ExceptionCode %#x.\n", rec->ExceptionCode);
-
-    hook_KiUserExceptionDispatcher_eip = (void *)context->Eip;
-    hook_exception_address = rec->ExceptionAddress;
-    memcpy(pKiUserExceptionDispatcher, saved_KiUserExceptionDispatcher_bytes,
-            sizeof(saved_KiUserExceptionDispatcher_bytes));
-}
-
-static void test_kiuserexceptiondispatcher(void)
-{
-    PVOID vectored_handler;
-    HMODULE hntdll = GetModuleHandleA("ntdll.dll");
-    static BYTE except_code[] =
-    {
-        0xb9, /* mov imm32, %ecx */
-        /* offset: 0x1 */
-        0x00, 0x00, 0x00, 0x00,
-
-        0x89, 0x01,       /* mov %eax, (%ecx) */
-        0x89, 0x51, 0x04, /* mov %edx, 0x4(%ecx) */
-        0x89, 0x71, 0x08, /* mov %esi, 0x8(%ecx) */
-        0x89, 0x79, 0x0c, /* mov %edi, 0xc(%ecx) */
-        0x89, 0x69, 0x10, /* mov %ebp, 0x10(%ecx) */
-        0x89, 0x61, 0x14, /* mov %esp, 0x14(%ecx) */
-        0x83, 0xc1, 0x18, /* add $0x18, %ecx */
-
-        /* offset: 0x19 */
-        0xcc,  /* int3 */
-
-        0x0f, 0x0b, /* ud2, illegal instruction */
-
-        /* offset: 0x1c */
-        0xb9, /* mov imm32, %ecx */
-        /* offset: 0x1d */
-        0x00, 0x00, 0x00, 0x00,
-
-        0x89, 0x01,       /* mov %eax, (%ecx) */
-        0x89, 0x51, 0x04, /* mov %edx, 0x4(%ecx) */
-        0x89, 0x71, 0x08, /* mov %esi, 0x8(%ecx) */
-        0x89, 0x79, 0x0c, /* mov %edi, 0xc(%ecx) */
-        0x89, 0x69, 0x10, /* mov %ebp, 0x10(%ecx) */
-        0x89, 0x61, 0x14, /* mov %esp, 0x14(%ecx) */
-
-        0x67, 0x48, 0x8b, 0x71, 0xf0, /* mov -0x10(%ecx),%esi */
-
-        0xc3,  /* ret  */
-    };
-    static BYTE hook_trampoline[] =
-    {
-        0xff, 0x15,
-        /* offset: 2 bytes */
-        0x00, 0x00, 0x00, 0x00,     /* callq *addr */ /* call hook implementation. */
-
-        0xff, 0x25,
-        /* offset: 8 bytes */
-        0x00, 0x00, 0x00, 0x00,     /* jmpq *addr */ /* jump to original function. */
-    };
-    void *phook_KiUserExceptionDispatcher = hook_KiUserExceptionDispatcher;
-    BYTE patched_KiUserExceptionDispatcher_bytes[7];
-    void *phook_trampoline = hook_trampoline;
-    DWORD old_protect1, old_protect2;
-    EXCEPTION_RECORD record;
-    void *bpt_address;
-    BYTE *ptr;
-    BOOL ret;
-
-    pKiUserExceptionDispatcher = (void *)GetProcAddress(hntdll, "KiUserExceptionDispatcher");
-    if (!pKiUserExceptionDispatcher)
-    {
-        win_skip("KiUserExceptionDispatcher is not available.\n");
-        return;
-    }
-
-    if (!pRtlUnwind)
-    {
-        win_skip("RtlUnwind is not available.\n");
-        return;
-    }
-
-    *(DWORD *)(except_code + 1) = (DWORD)&test_kiuserexceptiondispatcher_regs;
-    *(DWORD *)(except_code + 0x1d) = (DWORD)&test_kiuserexceptiondispatcher_regs.new_eax;
-
-    *(unsigned int *)(hook_trampoline + 2) = (ULONG_PTR)&phook_KiUserExceptionDispatcher;
-    *(unsigned int *)(hook_trampoline + 8) = (ULONG_PTR)&pKiUserExceptionDispatcher;
-
-    ret = VirtualProtect(hook_trampoline, ARRAY_SIZE(hook_trampoline), PAGE_EXECUTE_READWRITE, &old_protect1);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-
-    ret = VirtualProtect(pKiUserExceptionDispatcher, sizeof(saved_KiUserExceptionDispatcher_bytes),
-            PAGE_EXECUTE_READWRITE, &old_protect2);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-
-    memcpy(saved_KiUserExceptionDispatcher_bytes, pKiUserExceptionDispatcher,
-            sizeof(saved_KiUserExceptionDispatcher_bytes));
-
-    ptr = patched_KiUserExceptionDispatcher_bytes;
-    /* mov hook_trampoline, %eax */
-    *ptr++ = 0xa1;
-    *(void **)ptr = &phook_trampoline;
-    ptr += sizeof(void *);
-    /* jmp *eax */
-    *ptr++ = 0xff;
-    *ptr++ = 0xe0;
-
-    memcpy(pKiUserExceptionDispatcher, patched_KiUserExceptionDispatcher_bytes,
-            sizeof(patched_KiUserExceptionDispatcher_bytes));
-    got_exception = 0;
-    run_exception_test(dbg_except_continue_handler, NULL, except_code, ARRAY_SIZE(except_code),
-            PAGE_EXECUTE_READ);
-
-    ok(got_exception, "Handler was not called.\n");
-    ok(hook_called, "Hook was not called.\n");
-
-    ok(test_kiuserexceptiondispatcher_regs.new_eax == 0xdeadbeef, "Got unexpected eax %#x.\n",
-            test_kiuserexceptiondispatcher_regs.new_eax);
-    ok(test_kiuserexceptiondispatcher_regs.new_esi == 0xdeadbeef, "Got unexpected esi %#x.\n",
-            test_kiuserexceptiondispatcher_regs.new_esi);
-    ok(test_kiuserexceptiondispatcher_regs.old_edi
-            == test_kiuserexceptiondispatcher_regs.new_edi, "edi does not match.\n");
-    ok(test_kiuserexceptiondispatcher_regs.old_ebp
-            == test_kiuserexceptiondispatcher_regs.new_ebp, "ebp does not match.\n");
-
-    bpt_address = (BYTE *)code_mem + 0x19;
-
-    ok(hook_exception_address == bpt_address || broken(!hook_exception_address) /* Win2008 */,
-            "Got unexpected exception address %p, expected %p.\n",
-            hook_exception_address, bpt_address);
-    ok(hook_KiUserExceptionDispatcher_eip == bpt_address, "Got unexpected exception address %p, expected %p.\n",
-            hook_KiUserExceptionDispatcher_eip, bpt_address);
-    ok(dbg_except_continue_handler_eip == bpt_address, "Got unexpected exception address %p, expected %p.\n",
-            dbg_except_continue_handler_eip, bpt_address);
-
-    record.ExceptionCode = 0x80000003;
-    record.ExceptionFlags = 0;
-    record.ExceptionRecord = NULL;
-    record.ExceptionAddress = NULL; /* does not matter, copied return address */
-    record.NumberParameters = 0;
-
-    vectored_handler = AddVectoredExceptionHandler(TRUE, dbg_except_continue_vectored_handler);
-
-    memcpy(pKiUserExceptionDispatcher, patched_KiUserExceptionDispatcher_bytes,
-            sizeof(patched_KiUserExceptionDispatcher_bytes));
-    got_exception = 0;
-    hook_called = FALSE;
-
-    pRtlRaiseException(&record);
-
-    ok(got_exception, "Handler was not called.\n");
-    ok(hook_called || broken(!hook_called) /* 2003 */, "Hook was not called.\n");
-
-    memcpy(pKiUserExceptionDispatcher, saved_KiUserExceptionDispatcher_bytes,
-            sizeof(saved_KiUserExceptionDispatcher_bytes));
-
-    RemoveVectoredExceptionHandler(vectored_handler);
-    ret = VirtualProtect(pKiUserExceptionDispatcher, sizeof(saved_KiUserExceptionDispatcher_bytes),
-            old_protect2, &old_protect2);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-    ret = VirtualProtect(hook_trampoline, ARRAY_SIZE(hook_trampoline), old_protect1, &old_protect1);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-}
-
 #elif defined(__x86_64__)
 
+#define is_wow64 0
+
 #define UNW_FLAG_NHANDLER  0
 #define UNW_FLAG_EHANDLER  1
 #define UNW_FLAG_UHANDLER  2
@@ -1935,7 +1696,6 @@ struct unwind_test
     const BYTE *unwind_info;
     const struct results *results;
     unsigned int nb_results;
-    const struct results *broken_results;
 };
 
 enum regs
@@ -1960,11 +1720,10 @@ static void call_virtual_unwind( int testnum, const struct unwind_test *test )
     CONTEXT context;
     RUNTIME_FUNCTION runtime_func;
     KNONVOLATILE_CONTEXT_POINTERS ctx_ptr;
-    UINT i, j, k, broken_k;
+    UINT i, j, k;
     ULONG64 fake_stack[256];
     ULONG64 frame, orig_rip, orig_rbp, unset_reg;
     UINT unwind_size = 4 + 2 * test->unwind_info[2] + 8;
-    void *expected_handler, *broken_handler;
 
     memcpy( (char *)code_mem + code_offset, test->function, test->function_size );
     memcpy( (char *)code_mem + unwind_offset, test->unwind_info, unwind_size );
@@ -1993,24 +1752,23 @@ static void call_virtual_unwind( int testnum, const struct unwind_test *test )
         data = (void *)0xdeadbeef;
         handler = RtlVirtualUnwind( UNW_FLAG_EHANDLER, (ULONG64)code_mem, orig_rip,
                                     &runtime_func, &context, &data, &frame, &ctx_ptr );
-
-        expected_handler = test->results[i].handler ? (char *)code_mem + 0x200 : NULL;
-        broken_handler = test->broken_results && test->broken_results[i].handler ? (char *)code_mem + 0x200 : NULL;
-
-        ok( handler == expected_handler || broken( test->broken_results && handler == broken_handler ),
-                "%u/%u: wrong handler %p/%p\n", testnum, i, handler, expected_handler );
-        if (handler)
-            ok( *(DWORD *)data == 0x08070605, "%u/%u: wrong handler data %p\n", testnum, i, data );
+        if (test->results[i].handler)
+        {
+            ok( (char *)handler == (char *)code_mem + 0x200,
+                "%u/%u: wrong handler %p/%p\n", testnum, i, handler, (char *)code_mem + 0x200 );
+            if (handler) ok( *(DWORD *)data == 0x08070605,
+                             "%u/%u: wrong handler data %p\n", testnum, i, data );
+        }
         else
+        {
+            ok( handler == NULL, "%u/%u: handler %p instead of NULL\n", testnum, i, handler );
             ok( data == (void *)0xdeadbeef, "%u/%u: handler data set to %p\n", testnum, i, data );
+        }
 
-        ok( context.Rip == test->results[i].rip
-                || broken( test->broken_results && context.Rip == test->broken_results[i].rip ),
-                "%u/%u: wrong rip %p/%x\n", testnum, i, (void *)context.Rip, test->results[i].rip );
-        ok( frame == (ULONG64)fake_stack + test->results[i].frame
-                || broken( test->broken_results && frame == (ULONG64)fake_stack + test->broken_results[i].frame ),
-                "%u/%u: wrong frame %p/%p\n",
-                testnum, i, (void *)frame, (char *)fake_stack + test->results[i].frame );
+        ok( context.Rip == test->results[i].rip, "%u/%u: wrong rip %p/%x\n",
+            testnum, i, (void *)context.Rip, test->results[i].rip );
+        ok( frame == (ULONG64)fake_stack + test->results[i].frame, "%u/%u: wrong frame %p/%p\n",
+            testnum, i, (void *)frame, (char *)fake_stack + test->results[i].frame );
 
         for (j = 0; j < 16; j++)
         {
@@ -2026,59 +1784,28 @@ static void call_virtual_unwind( int testnum, const struct unwind_test *test )
                 if (test->results[i].regs[k][0] == j) break;
             }
 
-            if (test->broken_results)
-            {
-                for (broken_k = 0; broken_k < nb_regs; broken_k++)
-                {
-                    if (test->broken_results[i].regs[broken_k][0] == -1)
-                    {
-                        broken_k = nb_regs;
-                        break;
-                    }
-                    if (test->broken_results[i].regs[broken_k][0] == j)
-                        break;
-                }
-            }
-            else
-            {
-                broken_k = k;
-            }
-
             if (j == rsp)  /* rsp is special */
             {
-                ULONG64 expected_rsp, broken_rsp;
-
-                ok( !ctx_ptr.IntegerContext[j],
+                ok( !ctx_ptr.u2.IntegerContext[j],
                     "%u/%u: rsp should not be set in ctx_ptr\n", testnum, i );
-                expected_rsp = test->results[i].regs[k][1] < 0
-                        ? -test->results[i].regs[k][1] : (ULONG64)fake_stack + test->results[i].regs[k][1];
-                if (test->broken_results)
-                    broken_rsp = test->broken_results[i].regs[k][1] < 0
-                            ? -test->broken_results[i].regs[k][1]
-                            : (ULONG64)fake_stack + test->broken_results[i].regs[k][1];
-                else
-                    broken_rsp = expected_rsp;
-
-                ok( context.Rsp == expected_rsp || broken( context.Rsp == broken_rsp ),
+                ok( context.Rsp == (ULONG64)fake_stack + test->results[i].regs[k][1],
                     "%u/%u: register rsp wrong %p/%p\n",
-                    testnum, i, (void *)context.Rsp, (void *)expected_rsp );
+                    testnum, i, (void *)context.Rsp, (char *)fake_stack + test->results[i].regs[k][1] );
                 continue;
             }
 
-            if (ctx_ptr.IntegerContext[j])
+            if (ctx_ptr.u2.IntegerContext[j])
             {
-                ok( k < nb_regs || broken( broken_k < nb_regs ), "%u/%u: register %s should not be set to %lx\n",
+                ok( k < nb_regs, "%u/%u: register %s should not be set to %lx\n",
                     testnum, i, reg_names[j], *(&context.Rax + j) );
-                ok( k == nb_regs || *(&context.Rax + j) == test->results[i].regs[k][1]
-                        || broken( broken_k == nb_regs || *(&context.Rax + j)
-                        == test->broken_results[i].regs[broken_k][1] ),
+                if (k < nb_regs)
+                    ok( *(&context.Rax + j) == test->results[i].regs[k][1],
                         "%u/%u: register %s wrong %p/%x\n",
                         testnum, i, reg_names[j], (void *)*(&context.Rax + j), test->results[i].regs[k][1] );
             }
             else
             {
-                ok( k == nb_regs || broken( broken_k == nb_regs ), "%u/%u: register %s should be set\n",
-                        testnum, i, reg_names[j] );
+                ok( k == nb_regs, "%u/%u: register %s should be set\n", testnum, i, reg_names[j] );
                 if (j == rbp)
                     ok( context.Rbp == orig_rbp, "%u/%u: register rbp wrong %p/unset\n",
                         testnum, i, (void *)context.Rbp );
@@ -2197,93 +1924,10 @@ static void test_virtual_unwind(void)
         { 0x16,  0x50,  FALSE, 0x000, 0x000, { {rsp,0x008}, {-1,-1} }},
     };
 
-    static const BYTE function_2[] =
-    {
-        0x55,                     /* 00: push %rbp */
-        0x90, 0x90,               /* 01: nop; nop */
-        0x5d,                     /* 03: pop %rbp */
-        0xc3                      /* 04: ret */
-     };
-
-    static const BYTE unwind_info_2[] =
-    {
-        1 | (UNW_FLAG_EHANDLER << 3),  /* version + flags */
-        0x0,                           /* prolog size */
-        2,                             /* opcode count */
-        0,                             /* frame reg */
-
-        0x01, UWOP(PUSH_NONVOL, rbp), /* 02: push %rbp */
-        0x00, UWOP(PUSH_MACHFRAME, 0), /* 00 */
-
-        0x00, 0x02, 0x00, 0x00,  /* handler */
-        0x05, 0x06, 0x07, 0x08,  /* data */
-    };
-
-    static const struct results results_2[] =
-    {
-      /* offset  rbp   handler  rip   frame   registers */
-        { 0x01,  0x50,  TRUE, 0x008, 0x000, { {rsp,-0x020}, {rbp,0x000}, {-1,-1} }},
-    };
-
-    static const BYTE unwind_info_3[] =
-    {
-        1 | (UNW_FLAG_EHANDLER << 3),  /* version + flags */
-        0x0,                           /* prolog size */
-        2,                             /* opcode count */
-        0,                             /* frame reg */
-
-        0x01, UWOP(PUSH_NONVOL, rbp), /* 02: push %rbp */
-        0x00, UWOP(PUSH_MACHFRAME, 1), /* 00 */
-
-        0x00, 0x02, 0x00, 0x00,  /* handler */
-        0x05, 0x06, 0x07, 0x08,  /* data */
-    };
-
-    static const struct results results_3[] =
-    {
-      /* offset  rbp   handler  rip   frame   registers */
-        { 0x01,  0x50,  TRUE, 0x010, 0x000, { {rsp,-0x028}, {rbp,0x000}, {-1,-1} }},
-    };
-
-    static const BYTE function_4[] =
-    {
-        0x55,                     /* 00: push %rbp */
-        0x5d,                     /* 01: pop %rbp */
-        0xc3                      /* 02: ret */
-     };
-
-    static const BYTE unwind_info_4[] =
-    {
-        1 | (UNW_FLAG_EHANDLER << 3),  /* version + flags */
-        0x0,                           /* prolog size */
-        0,                             /* opcode count */
-        0,                             /* frame reg */
-
-        0x00, 0x02, 0x00, 0x00,  /* handler */
-        0x05, 0x06, 0x07, 0x08,  /* data */
-    };
-
-    static const struct results results_4[] =
-    {
-      /* offset  rbp   handler  rip   frame   registers */
-        { 0x01,  0x50,  TRUE, 0x000, 0x000, { {rsp,0x008}, {-1,-1} }},
-    };
-
-    static const struct results broken_results_4[] =
-    {
-      /* offset  rbp   handler  rip   frame   registers */
-        { 0x01,  0x50,  FALSE, 0x008, 0x000, { {rsp,0x010}, {rbp,0x000}, {-1,-1} }},
-    };
-
     static const struct unwind_test tests[] =
     {
         { function_0, sizeof(function_0), unwind_info_0, results_0, ARRAY_SIZE(results_0) },
-        { function_1, sizeof(function_1), unwind_info_1, results_1, ARRAY_SIZE(results_1) },
-        { function_2, sizeof(function_2), unwind_info_2, results_2, ARRAY_SIZE(results_2) },
-        { function_2, sizeof(function_2), unwind_info_3, results_3, ARRAY_SIZE(results_3) },
-
-        /* Broken before Win10 1809. */
-        { function_4, sizeof(function_4), unwind_info_4, results_4, ARRAY_SIZE(results_4), broken_results_4 },
+        { function_1, sizeof(function_1), unwind_info_1, results_1, ARRAY_SIZE(results_1) }
     };
     unsigned int i;
 
@@ -2360,13 +2004,13 @@ static void test_restore_context(void)
         fltsave = &buf.Xmm6;
         for (i = 0; i < 10; i++)
         {
-            ok(fltsave[i].Part[0] == ctx.FltSave.XmmRegisters[i + 6].Low,
+            ok(fltsave[i].Part[0] == ctx.u.FltSave.XmmRegisters[i + 6].Low,
                 "longjmp failed for Xmm%d, expected %lx, got %lx\n", i + 6,
-                fltsave[i].Part[0], ctx.FltSave.XmmRegisters[i + 6].Low);
+                fltsave[i].Part[0], ctx.u.FltSave.XmmRegisters[i + 6].Low);
 
-            ok(fltsave[i].Part[1] == ctx.FltSave.XmmRegisters[i + 6].High,
+            ok(fltsave[i].Part[1] == ctx.u.FltSave.XmmRegisters[i + 6].High,
                 "longjmp failed for Xmm%d, expected %lx, got %lx\n", i + 6,
-                fltsave[i].Part[1], ctx.FltSave.XmmRegisters[i + 6].High);
+                fltsave[i].Part[1], ctx.u.FltSave.XmmRegisters[i + 6].High);
         }
     }
     else
@@ -2980,1626 +2624,155 @@ static void test_dpe_exceptions(void)
     pRtlRemoveVectoredExceptionHandler(handler);
 }
 
-static const BYTE call_one_arg_code[] = {
-    0x55, /* push %rbp */
-    0x48, 0x89, 0xe5, /* mov %rsp,%rbp */
-    0x48, 0x83, 0xec, 0x20, /* sub $0x20,%rsp */
-    0x48, 0x89, 0xc8, /* mov %rcx,%rax */
-    0x48, 0x89, 0xd1, /* mov %rdx,%rcx */
-    0xff, 0xd0, /* callq *%rax */
-    0x90, /* nop */
-    0x90, /* nop */
-    0x90, /* nop */
-    0x90, /* nop */
-    0x48, 0x83, 0xc4, 0x20, /* add $0x20,%rsp */
-    0x5d, /* pop %rbp */
-    0xc3, /* retq  */
-};
-
-static int rtlraiseexception_unhandled_handler_called;
-static int rtlraiseexception_handler_called;
-
-static void rtlraiseexception_handler_( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
-                                        CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher,
-                                        BOOL unhandled_handler )
+static void test_wow64_context(void)
 {
-    if (unhandled_handler) rtlraiseexception_unhandled_handler_called = 1;
-    else rtlraiseexception_handler_called = 1;
-
-    trace( "exception: %08x flags:%x addr:%p context: Rip:%p\n",
-           rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress, (void *)context->Rip );
-
-    ok( rec->ExceptionAddress == (char *)code_mem + 0x10
-        || broken( rec->ExceptionAddress == code_mem || !rec->ExceptionAddress ) /* 2008 */,
-        "ExceptionAddress at %p instead of %p\n", rec->ExceptionAddress, (char *)code_mem + 0x10 );
+    char cmdline[] = "C:\\windows\\syswow64\\notepad.exe";
+    PROCESS_INFORMATION pi;
+    STARTUPINFOA si = {0};
+    WOW64_CONTEXT ctx;
+    NTSTATUS ret;
 
-    ok( context->ContextFlags == CONTEXT_ALL || context->ContextFlags == (CONTEXT_ALL | CONTEXT_XSTATE)
-        || context->ContextFlags == (CONTEXT_FULL | CONTEXT_SEGMENTS)
-        || context->ContextFlags == (CONTEXT_FULL | CONTEXT_SEGMENTS | CONTEXT_XSTATE),
-        "wrong context flags %x\n", context->ContextFlags );
+    memset(&ctx, 0x55, sizeof(ctx));
+    ctx.ContextFlags = WOW64_CONTEXT_ALL;
+    ret = pRtlWow64GetThreadContext( GetCurrentThread(), &ctx );
+    ok(ret == STATUS_INVALID_PARAMETER || broken(ret == STATUS_PARTIAL_COPY), "got %#x\n", ret);
 
-    /* check that pc is fixed up only for EXCEPTION_BREAKPOINT
-     * even if raised by RtlRaiseException
-     */
-    if (rec->ExceptionCode == EXCEPTION_BREAKPOINT && test_stage)
-        ok( context->Rip == (UINT_PTR)code_mem + 0xf,
-            "%d: Rip at %Ix instead of %Ix\n", test_stage, context->Rip, (UINT_PTR)code_mem + 0xf );
-    else
-        ok( context->Rip == (UINT_PTR)code_mem + 0x10,
-            "%d: Rip at %Ix instead of %Ix\n", test_stage, context->Rip, (UINT_PTR)code_mem + 0x10 );
+    CreateProcessA(NULL, cmdline, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
 
-    if (have_vectored_api) ok( context->Rax == 0xf00f00f0, "context->Rax is %Ix, should have been set to 0xf00f00f0 in vectored handler\n", context->Rax );
+    ret = pRtlWow64GetThreadContext( pi.hThread, &ctx );
+    ok(ret == STATUS_SUCCESS, "got %#x\n", ret);
+    ok(ctx.ContextFlags == WOW64_CONTEXT_ALL, "got context flags %#x\n", ctx.ContextFlags);
+    ok(!ctx.Ebp, "got ebp %08x\n", ctx.Ebp);
+    ok(!ctx.Ecx, "got ecx %08x\n", ctx.Ecx);
+    ok(!ctx.Edx, "got edx %08x\n", ctx.Edx);
+    ok(!ctx.Esi, "got esi %08x\n", ctx.Esi);
+    ok(!ctx.Edi, "got edi %08x\n", ctx.Edi);
+    ok((ctx.EFlags & ~2) == 0x200, "got eflags %08x\n", ctx.EFlags);
+    ok((WORD) ctx.FloatSave.ControlWord == 0x27f, "got control word %08x\n",
+        ctx.FloatSave.ControlWord);
+    ok(*(WORD *)ctx.ExtendedRegisters == 0x27f, "got SSE control word %04x\n",
+       *(WORD *)ctx.ExtendedRegisters);
 
-    /* give the debugger a chance to examine the state a second time */
-    /* without the exception handler changing pc */
-    if (test_stage == 2)
-        return;
+    ret = pRtlWow64SetThreadContext( pi.hThread, &ctx );
+    ok(ret == STATUS_SUCCESS, "got %#x\n", ret);
 
-    /* pc in context is decreased by 1
-     * Increase it again, else execution will continue in the middle of an instruction */
-    if (rec->ExceptionCode == EXCEPTION_BREAKPOINT && (context->Rip == (UINT_PTR)code_mem + 0xf))
-        context->Rip++;
+    pNtTerminateProcess(pi.hProcess, 0);
 }
 
-static LONG CALLBACK rtlraiseexception_unhandled_handler(EXCEPTION_POINTERS *ExceptionInfo)
-{
-    PCONTEXT context = ExceptionInfo->ContextRecord;
-    PEXCEPTION_RECORD rec = ExceptionInfo->ExceptionRecord;
-    rtlraiseexception_handler_(rec, NULL, context, NULL, TRUE);
-    if (test_stage == 2) return EXCEPTION_CONTINUE_SEARCH;
-    return EXCEPTION_CONTINUE_EXECUTION;
-}
+static BYTE saved_KiUserExceptionDispatcher_bytes[12];
+static void *pKiUserExceptionDispatcher;
+static BOOL hook_called;
+static void *hook_KiUserExceptionDispatcher_rip;
+static void *dbg_except_continue_handler_rip;
+static void *hook_exception_address;
 
-static DWORD rtlraiseexception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
-                                        CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher )
+static DWORD dbg_except_continue_handler(EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
+        CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher)
 {
-    rtlraiseexception_handler_(rec, frame, context, dispatcher, FALSE);
-    if (test_stage == 2) return ExceptionContinueSearch;
+    ok(hook_called, "Hook was not called.\n");
+    got_exception = 1;
+    dbg_except_continue_handler_rip = (void *)context->Rip;
+    ++context->Rip;
     return ExceptionContinueExecution;
 }
 
-static LONG CALLBACK rtlraiseexception_vectored_handler(EXCEPTION_POINTERS *ExceptionInfo)
+void WINAPI hook_KiUserExceptionDispatcher(EXCEPTION_RECORD *rec, CONTEXT *context)
 {
-    PCONTEXT context = ExceptionInfo->ContextRecord;
-    PEXCEPTION_RECORD rec = ExceptionInfo->ExceptionRecord;
-
-    trace( "vect. handler %08x addr:%p Rip:%p\n", rec->ExceptionCode, rec->ExceptionAddress, (void *)context->Rip );
-
-    ok( rec->ExceptionAddress == (char *)code_mem + 0x10
-        || broken(rec->ExceptionAddress == code_mem || !rec->ExceptionAddress ) /* 2008 */,
-        "ExceptionAddress at %p instead of %p\n", rec->ExceptionAddress, (char *)code_mem + 0x10 );
-
-    /* check that Rip is fixed up only for EXCEPTION_BREAKPOINT
-     * even if raised by RtlRaiseException
-     */
-    if (rec->ExceptionCode == EXCEPTION_BREAKPOINT && test_stage)
-        ok( context->Rip == (UINT_PTR)code_mem + 0xf,
-            "%d: Rip at %Ix instead of %Ix\n", test_stage, context->Rip, (UINT_PTR)code_mem + 0xf );
-    else
-        ok( context->Rip == (UINT_PTR)code_mem + 0x10,
-            "%d: Rip at %Ix instead of %Ix\n", test_stage, context->Rip, (UINT_PTR)code_mem + 0x10 );
-
-    /* test if context change is preserved from vectored handler to stack handlers */
-    context->Rax = 0xf00f00f0;
-
-    return EXCEPTION_CONTINUE_SEARCH;
-}
-
-static void run_rtlraiseexception_test(DWORD exceptioncode)
-{
-    EXCEPTION_REGISTRATION_RECORD frame;
-    EXCEPTION_RECORD record;
-    PVOID vectored_handler = NULL;
-
-    void (CDECL *func)(void* function, EXCEPTION_RECORD* record) = code_mem;
-
-    record.ExceptionCode = exceptioncode;
-    record.ExceptionFlags = 0;
-    record.ExceptionRecord = NULL;
-    record.ExceptionAddress = NULL; /* does not matter, copied return address */
-    record.NumberParameters = 0;
-
-    frame.Handler = rtlraiseexception_handler;
-    frame.Prev = NtCurrentTeb()->Tib.ExceptionList;
-
-    memcpy(code_mem, call_one_arg_code, sizeof(call_one_arg_code));
-
-    NtCurrentTeb()->Tib.ExceptionList = &frame;
-    if (have_vectored_api)
-    {
-        vectored_handler = pRtlAddVectoredExceptionHandler(TRUE, &rtlraiseexception_vectored_handler);
-        ok(vectored_handler != 0, "RtlAddVectoredExceptionHandler failed\n");
-    }
-    if (pRtlSetUnhandledExceptionFilter) pRtlSetUnhandledExceptionFilter(&rtlraiseexception_unhandled_handler);
-
-    rtlraiseexception_handler_called = 0;
-    rtlraiseexception_unhandled_handler_called = 0;
-    func(pRtlRaiseException, &record);
-    ok( record.ExceptionAddress == (char *)code_mem + 0x10,
-        "address set to %p instead of %p\n", record.ExceptionAddress, (char *)code_mem + 0x10 );
-
-    todo_wine
-    ok( !rtlraiseexception_handler_called, "Frame handler called\n" );
-    todo_wine
-    ok( rtlraiseexception_unhandled_handler_called, "UnhandledExceptionFilter wasn't called\n" );
-
-    if (have_vectored_api)
-        pRtlRemoveVectoredExceptionHandler(vectored_handler);
-
-    if (pRtlSetUnhandledExceptionFilter) pRtlSetUnhandledExceptionFilter(NULL);
-    NtCurrentTeb()->Tib.ExceptionList = frame.Prev;
-}
-
-static void test_rtlraiseexception(void)
-{
-    if (!pRtlRaiseException)
-    {
-        skip("RtlRaiseException not found\n");
-        return;
-    }
-
-    /* test without debugger */
-    run_rtlraiseexception_test(0x12345);
-    run_rtlraiseexception_test(EXCEPTION_BREAKPOINT);
-    run_rtlraiseexception_test(EXCEPTION_INVALID_HANDLE);
-}
-
-static void test_debugger(void)
-{
-    char cmdline[MAX_PATH];
-    PROCESS_INFORMATION pi;
-    STARTUPINFOA si = { 0 };
-    DEBUG_EVENT de;
-    DWORD continuestatus;
-    PVOID code_mem_address = NULL;
-    NTSTATUS status;
-    SIZE_T size_read;
-    BOOL ret;
-    int counter = 0;
-    si.cb = sizeof(si);
-
-    if(!pNtGetContextThread || !pNtSetContextThread || !pNtReadVirtualMemory || !pNtTerminateProcess)
-    {
-        skip("NtGetContextThread, NtSetContextThread, NtReadVirtualMemory or NtTerminateProcess not found\n");
-        return;
-    }
-
-    sprintf(cmdline, "%s %s %s %p", my_argv[0], my_argv[1], "debuggee", &test_stage);
-    ret = CreateProcessA(NULL, cmdline, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &si, &pi);
-    ok(ret, "could not create child process error: %u\n", GetLastError());
-    if (!ret)
-        return;
-
-    do
-    {
-        continuestatus = DBG_CONTINUE;
-        ok(WaitForDebugEvent(&de, INFINITE), "reading debug event\n");
-
-        ret = ContinueDebugEvent(de.dwProcessId, de.dwThreadId, 0xdeadbeef);
-        ok(!ret, "ContinueDebugEvent unexpectedly succeeded\n");
-        ok(GetLastError() == ERROR_INVALID_PARAMETER, "Unexpected last error: %u\n", GetLastError());
-
-        if (de.dwThreadId != pi.dwThreadId)
-        {
-            trace("event %d not coming from main thread, ignoring\n", de.dwDebugEventCode);
-            ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);
-            continue;
-        }
-
-        if (de.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT)
-        {
-            if(de.u.CreateProcessInfo.lpBaseOfImage != NtCurrentTeb()->Peb->ImageBaseAddress)
-            {
-                skip("child process loaded at different address, terminating it\n");
-                pNtTerminateProcess(pi.hProcess, 0);
-            }
-        }
-        else if (de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
-        {
-            CONTEXT ctx;
-            int stage;
-
-            counter++;
-            status = pNtReadVirtualMemory(pi.hProcess, &code_mem, &code_mem_address,
-                                          sizeof(code_mem_address), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            ctx.ContextFlags = CONTEXT_FULL;
-            status = pNtGetContextThread(pi.hThread, &ctx);
-            ok(!status, "NtGetContextThread failed with 0x%x\n", status);
-
-            trace("exception 0x%x at %p firstchance=%d Rip=%p, Rax=%p\n",
-                  de.u.Exception.ExceptionRecord.ExceptionCode,
-                  de.u.Exception.ExceptionRecord.ExceptionAddress,
-                  de.u.Exception.dwFirstChance, (char *)ctx.Rip, (char *)ctx.Rax);
-
-            if (counter > 100)
-            {
-                ok(FALSE, "got way too many exceptions, probably caught in an infinite loop, terminating child\n");
-                pNtTerminateProcess(pi.hProcess, 1);
-            }
-            else if (counter >= 2) /* skip startup breakpoint */
-            {
-                if (stage == 1)
-                {
-                    ok((char *)ctx.Rip == (char *)code_mem_address + 0x10, "Rip at %p instead of %p\n",
-                       (char *)ctx.Rip, (char *)code_mem_address + 0x10);
-                    /* setting the context from debugger does not affect the context that the
-                     * exception handler gets, except on w2008 */
-                    ctx.Rip = (UINT_PTR)code_mem_address + 0x12;
-                    ctx.Rax = 0xf00f00f1;
-                    /* let the debuggee handle the exception */
-                    continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 2)
-                {
-                    if (de.u.Exception.dwFirstChance)
-                    {
-                        ok((char *)ctx.Rip == (char *)code_mem_address + 0x10, "Rip at %p instead of %p\n",
-                           (char *)ctx.Rip, (char *)code_mem_address + 0x10);
-                        /* setting the context from debugger does not affect the context that the
-                         * exception handler gets, except on w2008 */
-                        ctx.Rip = (UINT_PTR)code_mem_address + 0x12;
-                        ctx.Rax = 0xf00f00f1;
-                        /* pass exception to debuggee
-                         * exception will not be handled and a second chance exception will be raised */
-                        continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                    }
-                    else
-                    {
-                        /* debugger gets context after exception handler has played with it */
-                        if (de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT)
-                        {
-                            ok((char *)ctx.Rip == (char *)code_mem_address + 0xf, "Rip at %p instead of %p\n",
-                               (char *)ctx.Rip, (char *)code_mem_address + 0xf);
-                            ctx.Rip += 1;
-                        }
-                        else ok((char *)ctx.Rip == (char *)code_mem_address + 0x10, "Rip at 0x%x instead of %p\n",
-                                ctx.Rip, (char *)code_mem_address + 0x10);
-                        /* here we handle exception */
-                    }
-                }
-                else if (stage == 7 || stage == 8)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT,
-                       "expected EXCEPTION_BREAKPOINT, got %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode);
-                    ok((char *)ctx.Rip == (char *)code_mem_address + 0x30,
-                       "expected Rip = %p, got %p\n", (char *)code_mem_address + 0x30, (char *)ctx.Rip);
-                    if (stage == 8) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 9 || stage == 10)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT,
-                       "expected EXCEPTION_BREAKPOINT, got %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode);
-                    ok((char *)ctx.Rip == (char *)code_mem_address + 2,
-                       "expected Rip = %p, got %p\n", (char *)code_mem_address + 2, (char *)ctx.Rip);
-                    if (stage == 10) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 11 || stage == 12 || stage == 13)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_INVALID_HANDLE,
-                       "unexpected exception code %08x, expected %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode,
-                       EXCEPTION_INVALID_HANDLE);
-                    ok(de.u.Exception.ExceptionRecord.NumberParameters == 0,
-                       "unexpected number of parameters %d, expected 0\n", de.u.Exception.ExceptionRecord.NumberParameters);
-
-                    if (stage == 12|| stage == 13) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else
-                    ok(FALSE, "unexpected stage %x\n", stage);
-
-                status = pNtSetContextThread(pi.hThread, &ctx);
-                ok(!status, "NtSetContextThread failed with 0x%x\n", status);
-            }
-        }
-        else if (de.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
-        {
-            int stage;
-            char buffer[64];
-
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            ok(!de.u.DebugString.fUnicode, "unexpected unicode debug string event\n");
-            ok(de.u.DebugString.nDebugStringLength < sizeof(buffer) - 1, "buffer not large enough to hold %d bytes\n",
-               de.u.DebugString.nDebugStringLength);
-
-            memset(buffer, 0, sizeof(buffer));
-            status = pNtReadVirtualMemory(pi.hProcess, de.u.DebugString.lpDebugStringData, buffer,
-                                          de.u.DebugString.nDebugStringLength, &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            if (stage == 3 || stage == 4)
-                ok(!strcmp(buffer, "Hello World"), "got unexpected debug string '%s'\n", buffer);
-            else /* ignore unrelated debug strings like 'SHIMVIEW: ShimInfo(Complete)' */
-                ok(strstr(buffer, "SHIMVIEW") != NULL, "unexpected stage %x, got debug string event '%s'\n", stage, buffer);
-
-            if (stage == 4) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-        }
-        else if (de.dwDebugEventCode == RIP_EVENT)
-        {
-            int stage;
-
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            if (stage == 5 || stage == 6)
-            {
-                ok(de.u.RipInfo.dwError == 0x11223344, "got unexpected rip error code %08x, expected %08x\n",
-                   de.u.RipInfo.dwError, 0x11223344);
-                ok(de.u.RipInfo.dwType  == 0x55667788, "got unexpected rip type %08x, expected %08x\n",
-                   de.u.RipInfo.dwType, 0x55667788);
-            }
-            else
-                ok(FALSE, "unexpected stage %x\n", stage);
-
-            if (stage == 6) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-        }
-
-        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, continuestatus);
-
-    } while (de.dwDebugEventCode != EXIT_PROCESS_DEBUG_EVENT);
-
-    wait_child_process( pi.hProcess );
-    ret = CloseHandle(pi.hThread);
-    ok(ret, "error %u\n", GetLastError());
-    ret = CloseHandle(pi.hProcess);
-    ok(ret, "error %u\n", GetLastError());
-}
-
-static void test_thread_context(void)
-{
-    CONTEXT context;
-    NTSTATUS status;
-    int i;
-    struct expected
-    {
-        ULONG64 Rax, Rbx, Rcx, Rdx, Rsi, Rdi, R8, R9, R10, R11,
-            R12, R13, R14, R15, Rbp, Rsp, Rip, prev_frame, EFlags;
-        ULONG MxCsr;
-        XMM_SAVE_AREA32 FltSave;
-        WORD SegCs, SegDs, SegEs, SegFs, SegGs, SegSs;
-    } expect;
-    XMM_SAVE_AREA32 broken_fltsave;
-    NTSTATUS (*func_ptr)( void *arg1, void *arg2, struct expected *res, void *func ) = (void *)code_mem;
-
-    static const BYTE call_func[] =
-    {
-        0x55,                                                 /* push   %rbp */
-        0x48, 0x89, 0xe5,                                     /* mov    %rsp,%rbp */
-        0x48, 0x8d, 0x64, 0x24, 0xd0,                         /* lea    -0x30(%rsp),%rsp */
-        0x49, 0x89, 0x00,                                     /* mov    %rax,(%r8) */
-        0x49, 0x89, 0x58, 0x08,                               /* mov    %rbx,0x8(%r8) */
-        0x49, 0x89, 0x48, 0x10,                               /* mov    %rcx,0x10(%r8) */
-        0x49, 0x89, 0x50, 0x18,                               /* mov    %rdx,0x18(%r8) */
-        0x49, 0x89, 0x70, 0x20,                               /* mov    %rsi,0x20(%r8) */
-        0x49, 0x89, 0x78, 0x28,                               /* mov    %rdi,0x28(%r8) */
-        0x4d, 0x89, 0x40, 0x30,                               /* mov    %r8,0x30(%r8) */
-        0x4d, 0x89, 0x48, 0x38,                               /* mov    %r9,0x38(%r8) */
-        0x4d, 0x89, 0x50, 0x40,                               /* mov    %r10,0x40(%r8) */
-        0x4d, 0x89, 0x58, 0x48,                               /* mov    %r11,0x48(%r8) */
-        0x4d, 0x89, 0x60, 0x50,                               /* mov    %r12,0x50(%r8) */
-        0x4d, 0x89, 0x68, 0x58,                               /* mov    %r13,0x58(%r8) */
-        0x4d, 0x89, 0x70, 0x60,                               /* mov    %r14,0x60(%r8) */
-        0x4d, 0x89, 0x78, 0x68,                               /* mov    %r15,0x68(%r8) */
-        0x49, 0x89, 0x68, 0x70,                               /* mov    %rbp,0x70(%r8) */
-        0x49, 0x89, 0x60, 0x78,                               /* mov    %rsp,0x78(%r8) */
-        0xff, 0x75, 0x08,                                     /* pushq  0x8(%rbp) */
-        0x41, 0x8f, 0x80, 0x80, 0x00, 0x00, 0x00,             /* popq   0x80(%r8) */
-        0xff, 0x75, 0x00,                                     /* pushq  0x0(%rbp) */
-        0x41, 0x8f, 0x80, 0x88, 0x00, 0x00, 0x00,             /* popq   0x88(%r8) */
-        0x9c,                                                 /* pushfq */
-        0x41, 0x8f, 0x80, 0x90, 0x00, 0x00, 0x00,             /* popq   0x90(%r8) */
-        0x41, 0x0f, 0xae, 0x98, 0x98, 0x00, 0x00, 0x00,       /* stmxcsr 0x98(%r8) */
-        0x41, 0x0f, 0xae, 0x80, 0xa0, 0x00, 0x00, 0x00,       /* fxsave 0xa0(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0x80, 0x40, 0x01, 0x00, 0x00, /* movdqa %xmm0,0x140(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0x88, 0x50, 0x01, 0x00, 0x00, /* movdqa %xmm1,0x150(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0x90, 0x60, 0x01, 0x00, 0x00, /* movdqa %xmm2,0x160(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0x98, 0x70, 0x01, 0x00, 0x00, /* movdqa %xmm3,0x170(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0xa0, 0x80, 0x01, 0x00, 0x00, /* movdqa %xmm4,0x180(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0xa8, 0x90, 0x01, 0x00, 0x00, /* movdqa %xmm5,0x190(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0xb0, 0xa0, 0x01, 0x00, 0x00, /* movdqa %xmm6,0x1a0(%r8) */
-        0x66, 0x41, 0x0f, 0x7f, 0xb8, 0xb0, 0x01, 0x00, 0x00, /* movdqa %xmm7,0x1b0(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0x80, 0xc0, 0x01, 0x00, 0x00, /* movdqa %xmm8,0x1c0(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0x88, 0xd0, 0x01, 0x00, 0x00, /* movdqa %xmm9,0x1d0(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0x90, 0xe0, 0x01, 0x00, 0x00, /* movdqa %xmm10,0x1e0(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0x98, 0xf0, 0x01, 0x00, 0x00, /* movdqa %xmm11,0x1f0(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0xa0, 0x00, 0x02, 0x00, 0x00, /* movdqa %xmm12,0x200(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0xa8, 0x10, 0x02, 0x00, 0x00, /* movdqa %xmm13,0x210(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0xb0, 0x20, 0x02, 0x00, 0x00, /* movdqa %xmm14,0x220(%r8) */
-        0x66, 0x45, 0x0f, 0x7f, 0xb8, 0x30, 0x02, 0x00, 0x00, /* movdqa %xmm15,0x230(%r8) */
-        0x41, 0x8c, 0x88, 0xa0, 0x02, 0x00, 0x00,             /* mov    %cs,0x2a0(%r8) */
-        0x41, 0x8c, 0x98, 0xa2, 0x02, 0x00, 0x00,             /* mov    %ds,0x2a2(%r8) */
-        0x41, 0x8c, 0x80, 0xa4, 0x02, 0x00, 0x00,             /* mov    %es,0x2a4(%r8) */
-        0x41, 0x8c, 0xa0, 0xa6, 0x02, 0x00, 0x00,             /* mov    %fs,0x2a6(%r8) */
-        0x41, 0x8c, 0xa8, 0xa8, 0x02, 0x00, 0x00,             /* mov    %gs,0x2a8(%r8) */
-        0x41, 0x8c, 0x90, 0xaa, 0x02, 0x00, 0x00,             /* mov    %ss,0x2aa(%r8) */
-        0x41, 0xff, 0xd1,                                     /* callq  *%r9 */
-        0xc9,                                                 /* leaveq */
-        0xc3,                                                 /* retq */
-    };
-
-    memcpy( func_ptr, call_func, sizeof(call_func) );
-
-#define COMPARE(reg) \
-    ok( context.reg == expect.reg, "wrong " #reg " %p/%p\n", (void *)(ULONG64)context.reg, (void *)(ULONG64)expect.reg )
-
-    memset( &context, 0xcc, sizeof(context) );
-    memset( &expect, 0xcc, sizeof(expect) );
-    func_ptr( &context, 0, &expect, pRtlCaptureContext );
-    trace( "expect: rax=%p rbx=%p rcx=%p rdx=%p rsi=%p rdi=%p "
-           "r8=%p r9=%p r10=%p r11=%p r12=%p r13=%p r14=%p r15=%p "
-           "rbp=%p rsp=%p rip=%p cs=%04x ds=%04x es=%04x fs=%04x gs=%04x ss=%04x flags=%08x prev=%08x\n",
-           (void *)expect.Rax, (void *)expect.Rbx, (void *)expect.Rcx, (void *)expect.Rdx,
-           (void *)expect.Rsi, (void *)expect.Rdi, (void *)expect.R8, (void *)expect.R9,
-           (void *)expect.R10, (void *)expect.R11, (void *)expect.R12, (void *)expect.R13,
-           (void *)expect.R14, (void *)expect.R15, (void *)expect.Rbp, (void *)expect.Rsp,
-           (void *)expect.Rip, expect.SegCs, expect.SegDs, expect.SegEs,
-           expect.SegFs, expect.SegGs, expect.SegSs, expect.EFlags, expect.prev_frame );
-    trace( "actual: rax=%p rbx=%p rcx=%p rdx=%p rsi=%p rdi=%p "
-           "r8=%p r9=%p r10=%p r11=%p r12=%p r13=%p r14=%p r15=%p "
-           "rbp=%p rsp=%p rip=%p cs=%04x ds=%04x es=%04x fs=%04x gs=%04x ss=%04x flags=%08x prev=%08x\n",
-           (void *)context.Rax, (void *)context.Rbx, (void *)context.Rcx, (void *)context.Rdx,
-           (void *)context.Rsi, (void *)context.Rdi, (void *)context.R8, (void *)context.R9,
-           (void *)context.R10, (void *)context.R11, (void *)context.R12, (void *)context.R13,
-           (void *)context.R14, (void *)context.R15, (void *)context.Rbp, (void *)context.Rsp,
-           (void *)context.Rip, context.SegCs, context.SegDs, context.SegEs,
-           context.SegFs, context.SegGs, context.SegSs, context.EFlags );
-
-    ok( context.ContextFlags == (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT),
-        "wrong flags %08x\n", context.ContextFlags );
-    COMPARE( Rax );
-    COMPARE( Rbx );
-    COMPARE( Rcx );
-    COMPARE( Rdx );
-    COMPARE( Rsi );
-    COMPARE( Rdi );
-    COMPARE( R8 );
-    COMPARE( R9 );
-    COMPARE( R10 );
-    COMPARE( R11 );
-    COMPARE( R12 );
-    COMPARE( R13 );
-    COMPARE( R14 );
-    COMPARE( R15 );
-    COMPARE( Rbp );
-    COMPARE( Rsp );
-    COMPARE( EFlags );
-    COMPARE( MxCsr );
-    COMPARE( SegCs );
-    COMPARE( SegDs );
-    COMPARE( SegEs );
-    COMPARE( SegFs );
-    COMPARE( SegGs );
-    COMPARE( SegSs );
-    ok( !memcmp( &context.FltSave, &expect.FltSave, offsetof( XMM_SAVE_AREA32, XmmRegisters )),
-        "wrong FltSave\n" );
-    for (i = 0; i < 16; i++)
-        ok( !memcmp( &context.Xmm0 + i, &expect.FltSave.XmmRegisters[i], sizeof(context.Xmm0) ),
-            "wrong xmm%u\n", i );
-    /* Rip is return address from RtlCaptureContext */
-    ok( context.Rip == (ULONG64)func_ptr + sizeof(call_func) - 2,
-        "wrong Rip %p/%p\n", (void *)context.Rip, (char *)func_ptr + sizeof(call_func) - 2 );
-
-    memset( &context, 0xcc, sizeof(context) );
-    memset( &expect, 0xcc, sizeof(expect) );
-    context.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT;
-
-    status = func_ptr( GetCurrentThread(), &context, &expect, pNtGetContextThread );
-    ok( status == STATUS_SUCCESS, "NtGetContextThread failed %08x\n", status );
-    trace( "expect: rax=%p rbx=%p rcx=%p rdx=%p rsi=%p rdi=%p "
-           "r8=%p r9=%p r10=%p r11=%p r12=%p r13=%p r14=%p r15=%p "
-           "rbp=%p rsp=%p rip=%p cs=%04x ds=%04x es=%04x fs=%04x gs=%04x ss=%04x flags=%08x prev=%08x\n",
-           (void *)expect.Rax, (void *)expect.Rbx, (void *)expect.Rcx, (void *)expect.Rdx,
-           (void *)expect.Rsi, (void *)expect.Rdi, (void *)expect.R8, (void *)expect.R9,
-           (void *)expect.R10, (void *)expect.R11, (void *)expect.R12, (void *)expect.R13,
-           (void *)expect.R14, (void *)expect.R15, (void *)expect.Rbp, (void *)expect.Rsp,
-           (void *)expect.Rip, expect.SegCs, expect.SegDs, expect.SegEs,
-           expect.SegFs, expect.SegGs, expect.SegSs, expect.EFlags, expect.prev_frame );
-    trace( "actual: rax=%p rbx=%p rcx=%p rdx=%p rsi=%p rdi=%p "
-           "r8=%p r9=%p r10=%p r11=%p r12=%p r13=%p r14=%p r15=%p "
-           "rbp=%p rsp=%p rip=%p cs=%04x ds=%04x es=%04x fs=%04x gs=%04x ss=%04x flags=%08x prev=%08x\n",
-           (void *)context.Rax, (void *)context.Rbx, (void *)context.Rcx, (void *)context.Rdx,
-           (void *)context.Rsi, (void *)context.Rdi, (void *)context.R8, (void *)context.R9,
-           (void *)context.R10, (void *)context.R11, (void *)context.R12, (void *)context.R13,
-           (void *)context.R14, (void *)context.R15, (void *)context.Rbp, (void *)context.Rsp,
-           (void *)context.Rip, context.SegCs, context.SegDs, context.SegEs,
-           context.SegFs, context.SegGs, context.SegSs, context.EFlags );
-    /* other registers are not preserved */
-    COMPARE( Rbx );
-    COMPARE( Rsi );
-    COMPARE( Rdi );
-    COMPARE( R12 );
-    COMPARE( R13 );
-    COMPARE( R14 );
-    COMPARE( R15 );
-    COMPARE( Rbp );
-    COMPARE( MxCsr );
-    COMPARE( SegCs );
-    COMPARE( SegDs );
-    COMPARE( SegEs );
-    COMPARE( SegFs );
-    COMPARE( SegGs );
-    COMPARE( SegSs );
-
-    broken_fltsave = context.FltSave;
-    memset( &broken_fltsave.ErrorOpcode, 0xcc, 0x12 );
-
-    ok( !memcmp( &context.FltSave, &expect.FltSave, offsetof( XMM_SAVE_AREA32, XmmRegisters )) ||
-        broken( !memcmp( &broken_fltsave, &expect.FltSave, offsetof( XMM_SAVE_AREA32, XmmRegisters )) ) /* w2008, w8 */,
-        "wrong FltSave\n" );
-    for (i = 6; i < 16; i++)
-        ok( !memcmp( &context.Xmm0 + i, &expect.FltSave.XmmRegisters[i], sizeof(context.Xmm0) ),
-            "wrong xmm%u\n", i );
-    /* Rsp is the stack upon entry to NtGetContextThread */
-    ok( context.Rsp == expect.Rsp - 8,
-        "wrong Rsp %p/%p\n", (void *)context.Rsp, (void *)expect.Rsp );
-    /* Rip is somewhere close to the NtGetContextThread implementation */
-    ok( (char *)context.Rip >= (char *)pNtGetContextThread - 0x40000 &&
-        (char *)context.Rip <= (char *)pNtGetContextThread + 0x40000,
-        "wrong Rip %p/%p\n", (void *)context.Rip, (void *)pNtGetContextThread );
-#undef COMPARE
-}
-
-static void test_wow64_context(void)
-{
-    char cmdline[] = "C:\\windows\\syswow64\\notepad.exe";
-    PROCESS_INFORMATION pi;
-    STARTUPINFOA si = {0};
-    WOW64_CONTEXT ctx;
-    NTSTATUS ret;
-
-    memset(&ctx, 0x55, sizeof(ctx));
-    ctx.ContextFlags = WOW64_CONTEXT_ALL;
-    ret = pRtlWow64GetThreadContext( GetCurrentThread(), &ctx );
-    ok(ret == STATUS_INVALID_PARAMETER || broken(ret == STATUS_PARTIAL_COPY), "got %#x\n", ret);
-
-    CreateProcessA(NULL, cmdline, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
-
-    ret = pRtlWow64GetThreadContext( pi.hThread, &ctx );
-    ok(ret == STATUS_SUCCESS, "got %#x\n", ret);
-    ok(ctx.ContextFlags == WOW64_CONTEXT_ALL, "got context flags %#x\n", ctx.ContextFlags);
-    ok(!ctx.Ebp, "got ebp %08x\n", ctx.Ebp);
-    ok(!ctx.Ecx, "got ecx %08x\n", ctx.Ecx);
-    ok(!ctx.Edx, "got edx %08x\n", ctx.Edx);
-    ok(!ctx.Esi, "got esi %08x\n", ctx.Esi);
-    ok(!ctx.Edi, "got edi %08x\n", ctx.Edi);
-    ok((ctx.EFlags & ~2) == 0x200, "got eflags %08x\n", ctx.EFlags);
-    ok((WORD) ctx.FloatSave.ControlWord == 0x27f, "got control word %08x\n",
-        ctx.FloatSave.ControlWord);
-    ok(*(WORD *)ctx.ExtendedRegisters == 0x27f, "got SSE control word %04x\n",
-       *(WORD *)ctx.ExtendedRegisters);
-
-    ret = pRtlWow64SetThreadContext( pi.hThread, &ctx );
-    ok(ret == STATUS_SUCCESS, "got %#x\n", ret);
-
-    pNtTerminateProcess(pi.hProcess, 0);
-}
-
-static BYTE saved_KiUserExceptionDispatcher_bytes[12];
-static void *pKiUserExceptionDispatcher;
-static BOOL hook_called;
-static void *hook_KiUserExceptionDispatcher_rip;
-static void *dbg_except_continue_handler_rip;
-static void *hook_exception_address;
-static struct
-{
-    ULONG64 old_rax;
-    ULONG64 old_rdx;
-    ULONG64 old_rsi;
-    ULONG64 old_rdi;
-    ULONG64 old_rbp;
-    ULONG64 old_rsp;
-    ULONG64 new_rax;
-    ULONG64 new_rdx;
-    ULONG64 new_rsi;
-    ULONG64 new_rdi;
-    ULONG64 new_rbp;
-    ULONG64 new_rsp;
-}
-test_kiuserexceptiondispatcher_regs;
-
-static DWORD dbg_except_continue_handler(EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
-        CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher)
-{
-    trace("handler context->Rip %#lx, codemem %p.\n", context->Rip, code_mem);
-    got_exception = 1;
-    dbg_except_continue_handler_rip = (void *)context->Rip;
-    ++context->Rip;
-    memcpy(pKiUserExceptionDispatcher, saved_KiUserExceptionDispatcher_bytes,
-            sizeof(saved_KiUserExceptionDispatcher_bytes));
-
-    RtlUnwind((void *)test_kiuserexceptiondispatcher_regs.old_rsp,
-            (BYTE *)code_mem + 0x28, rec, (void *)0xdeadbeef);
-    return ExceptionContinueExecution;
-}
-
-static LONG WINAPI dbg_except_continue_vectored_handler(struct _EXCEPTION_POINTERS *e)
-{
-    EXCEPTION_RECORD *rec = e->ExceptionRecord;
-    CONTEXT *context = e->ContextRecord;
-
-    trace("dbg_except_continue_vectored_handler, code %#x, Rip %#lx.\n", rec->ExceptionCode, context->Rip);
-
-    ok(rec->ExceptionCode == 0x80000003, "Got unexpected exception code %#x.\n", rec->ExceptionCode);
-
-    got_exception = 1;
-    dbg_except_continue_handler_rip = (void *)context->Rip;
-    if (NtCurrentTeb()->Peb->BeingDebugged)
-        ++context->Rip;
-
-    if (context->Rip >= (ULONG64)code_mem && context->Rip < (ULONG64)code_mem + 0x100)
-        RtlUnwind((void *)test_kiuserexceptiondispatcher_regs.old_rsp,
-                (BYTE *)code_mem + 0x28, rec, (void *)0xdeadbeef);
-
-    return EXCEPTION_CONTINUE_EXECUTION;
-}
-
-void WINAPI hook_KiUserExceptionDispatcher(EXCEPTION_RECORD *rec, CONTEXT *context)
-{
-    trace("rec %p, context %p.\n", rec, context);
-    trace("context->Rip %#lx, context->Rsp %#lx, ContextFlags %#lx.\n",
-            context->Rip, context->Rsp, context->ContextFlags);
-
-    hook_called = TRUE;
-    /* Broken on Win2008, probably rec offset in stack is different. */
-    ok(rec->ExceptionCode == 0x80000003 || broken(!rec->ExceptionCode),
-            "Got unexpected ExceptionCode %#x.\n", rec->ExceptionCode);
-
-    hook_KiUserExceptionDispatcher_rip = (void *)context->Rip;
-    hook_exception_address = rec->ExceptionAddress;
-    memcpy(pKiUserExceptionDispatcher, saved_KiUserExceptionDispatcher_bytes,
-            sizeof(saved_KiUserExceptionDispatcher_bytes));
-}
-
-static void test_kiuserexceptiondispatcher(void)
-{
-    LPVOID vectored_handler;
-    HMODULE hntdll = GetModuleHandleA("ntdll.dll");
-    static BYTE except_code[] =
-    {
-        0x48, 0xb9, /* mov imm64, %rcx */
-        /* offset: 0x2 */
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-
-        0x48, 0x89, 0x01,       /* mov %rax, (%rcx) */
-        0x48, 0x89, 0x51, 0x08, /* mov %rdx, 0x8(%rcx) */
-        0x48, 0x89, 0x71, 0x10, /* mov %rsi, 0x10(%rcx) */
-        0x48, 0x89, 0x79, 0x18, /* mov %rdi, 0x18(%rcx) */
-        0x48, 0x89, 0x69, 0x20, /* mov %rbp, 0x20(%rcx) */
-        0x48, 0x89, 0x61, 0x28, /* mov %rsp, 0x28(%rcx) */
-        0x48, 0x83, 0xc1, 0x30, /* add $0x30, %rcx */
-
-        /* offset: 0x25 */
-        0xcc,  /* int3 */
-
-        0x0f, 0x0b, /* ud2, illegal instruction */
-
-        /* offset: 0x28 */
-        0x48, 0xb9, /* mov imm64, %rcx */
-        /* offset: 0x2a */
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-
-        0x48, 0x89, 0x01,       /* mov %rax, (%rcx) */
-        0x48, 0x89, 0x51, 0x08, /* mov %rdx, 0x8(%rcx) */
-        0x48, 0x89, 0x71, 0x10, /* mov %rsi, 0x10(%rcx) */
-        0x48, 0x89, 0x79, 0x18, /* mov %rdi, 0x18(%rcx) */
-        0x48, 0x89, 0x69, 0x20, /* mov %rbp, 0x20(%rcx) */
-        0x48, 0x89, 0x61, 0x28, /* mov %rsp, 0x28(%rcx) */
-        0xc3,  /* ret  */
-    };
-    static BYTE hook_trampoline[] =
-    {
-        0x48, 0x89, 0xe2,           /* mov %rsp,%rdx */
-        0x48, 0x8d, 0x8c, 0x24, 0xf0, 0x04, 0x00, 0x00,
-                                    /* lea 0x4f0(%rsp),%rcx */
-
-        0xff, 0x14, 0x25,
-        /* offset: 14 bytes */
-        0x00, 0x00, 0x00, 0x00,     /* callq *addr */ /* call hook implementation. */
-        0x48, 0x31, 0xc9,           /* xor %rcx, %rcx */
-        0x48, 0x31, 0xd2,           /* xor %rdx, %rdx */
-
-        0xff, 0x24, 0x25,
-        /* offset: 27 bytes */
-        0x00, 0x00, 0x00, 0x00,     /* jmpq *addr */ /* jump to original function. */
-    };
-
-    void *phook_KiUserExceptionDispatcher = hook_KiUserExceptionDispatcher;
-    BYTE patched_KiUserExceptionDispatcher_bytes[12];
-    DWORD old_protect1, old_protect2;
-    EXCEPTION_RECORD record;
-    void *bpt_address;
-    BYTE *ptr;
-    BOOL ret;
-
-    pKiUserExceptionDispatcher = (void *)GetProcAddress(hntdll, "KiUserExceptionDispatcher");
-    if (!pKiUserExceptionDispatcher)
-    {
-        win_skip("KiUserExceptionDispatcher is not available.\n");
-        return;
-    }
-
-    *(ULONG64 *)(except_code + 2) = (ULONG64)&test_kiuserexceptiondispatcher_regs;
-    *(ULONG64 *)(except_code + 0x2a) = (ULONG64)&test_kiuserexceptiondispatcher_regs.new_rax;
-
-    ok(((ULONG64)&phook_KiUserExceptionDispatcher & 0xffffffff) == ((ULONG64)&phook_KiUserExceptionDispatcher),
-            "Address is too long.\n");
-    ok(((ULONG64)&pKiUserExceptionDispatcher & 0xffffffff) == ((ULONG64)&pKiUserExceptionDispatcher),
-            "Address is too long.\n");
-
-    *(unsigned int *)(hook_trampoline + 14) = (unsigned int)(ULONG_PTR)&phook_KiUserExceptionDispatcher;
-    *(unsigned int *)(hook_trampoline + 27) = (unsigned int)(ULONG_PTR)&pKiUserExceptionDispatcher;
-
-    ret = VirtualProtect(hook_trampoline, ARRAY_SIZE(hook_trampoline), PAGE_EXECUTE_READWRITE, &old_protect1);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-
-    ret = VirtualProtect(pKiUserExceptionDispatcher, sizeof(saved_KiUserExceptionDispatcher_bytes),
-            PAGE_EXECUTE_READWRITE, &old_protect2);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-
-    memcpy(saved_KiUserExceptionDispatcher_bytes, pKiUserExceptionDispatcher,
-            sizeof(saved_KiUserExceptionDispatcher_bytes));
-    ptr = (BYTE *)patched_KiUserExceptionDispatcher_bytes;
-    /* mov hook_trampoline, %rax */
-    *ptr++ = 0x48;
-    *ptr++ = 0xb8;
-    *(void **)ptr = hook_trampoline;
-    ptr += sizeof(ULONG64);
-    /* jmp *rax */
-    *ptr++ = 0xff;
-    *ptr++ = 0xe0;
-
-    memcpy(pKiUserExceptionDispatcher, patched_KiUserExceptionDispatcher_bytes,
-            sizeof(patched_KiUserExceptionDispatcher_bytes));
-    got_exception = 0;
-    run_exception_test(dbg_except_continue_handler, NULL, except_code, ARRAY_SIZE(except_code), PAGE_EXECUTE_READ);
-    ok(got_exception, "Handler was not called.\n");
-    ok(hook_called, "Hook was not called.\n");
-
-    ok(test_kiuserexceptiondispatcher_regs.new_rax == 0xdeadbeef, "Got unexpected rax %#lx.\n",
-            test_kiuserexceptiondispatcher_regs.new_rax);
-    ok(test_kiuserexceptiondispatcher_regs.old_rsi
-            == test_kiuserexceptiondispatcher_regs.new_rsi, "rsi does not match.\n");
-    ok(test_kiuserexceptiondispatcher_regs.old_rdi
-            == test_kiuserexceptiondispatcher_regs.new_rdi, "rdi does not match.\n");
-    ok(test_kiuserexceptiondispatcher_regs.old_rbp
-            == test_kiuserexceptiondispatcher_regs.new_rbp, "rbp does not match.\n");
-
-    bpt_address = (BYTE *)code_mem + 0x25;
-
-    ok(hook_exception_address == bpt_address || broken(!hook_exception_address) /* Win2008 */,
-            "Got unexpected exception address %p, expected %p.\n",
-            hook_exception_address, bpt_address);
-    ok(hook_KiUserExceptionDispatcher_rip == bpt_address, "Got unexpected exception address %p, expected %p.\n",
-            hook_KiUserExceptionDispatcher_rip, bpt_address);
-    ok(dbg_except_continue_handler_rip == bpt_address, "Got unexpected exception address %p, expected %p.\n",
-            dbg_except_continue_handler_rip, bpt_address);
-
-    memset(&record, 0, sizeof(record));
-    record.ExceptionCode = 0x80000003;
-    record.ExceptionFlags = 0;
-    record.ExceptionRecord = NULL;
-    record.ExceptionAddress = NULL;
-    record.NumberParameters = 0;
-
-    vectored_handler = AddVectoredExceptionHandler(TRUE, dbg_except_continue_vectored_handler);
-
-    memcpy(pKiUserExceptionDispatcher, patched_KiUserExceptionDispatcher_bytes,
-            sizeof(patched_KiUserExceptionDispatcher_bytes));
-    got_exception = 0;
-    hook_called = FALSE;
-
-    pRtlRaiseException(&record);
-
-    ok(got_exception, "Handler was not called.\n");
-    ok(!hook_called, "Hook was called.\n");
-
-    memcpy(pKiUserExceptionDispatcher, patched_KiUserExceptionDispatcher_bytes,
-            sizeof(patched_KiUserExceptionDispatcher_bytes));
-    got_exception = 0;
-    hook_called = FALSE;
-    NtCurrentTeb()->Peb->BeingDebugged = 1;
-
-    pRtlRaiseException(&record);
-
-    ok(got_exception, "Handler was not called.\n");
-    ok(hook_called, "Hook was not called.\n");
-
-    ok(hook_exception_address == (BYTE *)hook_KiUserExceptionDispatcher_rip + 1
-            || broken(!hook_exception_address) /* 2008 */, "Got unexpected addresses %p, %p.\n",
-            hook_KiUserExceptionDispatcher_rip, hook_exception_address);
-
-    RemoveVectoredExceptionHandler(vectored_handler);
-
-    memcpy(pKiUserExceptionDispatcher, patched_KiUserExceptionDispatcher_bytes,
-            sizeof(patched_KiUserExceptionDispatcher_bytes));
-    got_exception = 0;
-    hook_called = FALSE;
-
-    run_exception_test(dbg_except_continue_handler, NULL, except_code, ARRAY_SIZE(except_code), PAGE_EXECUTE_READ);
-
-    ok(got_exception, "Handler was not called.\n");
-    ok(hook_called, "Hook was not called.\n");
-    ok(hook_KiUserExceptionDispatcher_rip == bpt_address, "Got unexpected exception address %p, expected %p.\n",
-            hook_KiUserExceptionDispatcher_rip, bpt_address);
-    ok(dbg_except_continue_handler_rip == bpt_address, "Got unexpected exception address %p, expected %p.\n",
-            dbg_except_continue_handler_rip, bpt_address);
-
-    ok(test_kiuserexceptiondispatcher_regs.new_rax == 0xdeadbeef, "Got unexpected rax %#lx.\n",
-            test_kiuserexceptiondispatcher_regs.new_rax);
-    ok(test_kiuserexceptiondispatcher_regs.old_rsi
-            == test_kiuserexceptiondispatcher_regs.new_rsi, "rsi does not match.\n");
-    ok(test_kiuserexceptiondispatcher_regs.old_rdi
-            == test_kiuserexceptiondispatcher_regs.new_rdi, "rdi does not match.\n");
-    ok(test_kiuserexceptiondispatcher_regs.old_rbp
-            == test_kiuserexceptiondispatcher_regs.new_rbp, "rbp does not match.\n");
-
-    NtCurrentTeb()->Peb->BeingDebugged = 0;
-
-    ret = VirtualProtect(pKiUserExceptionDispatcher, sizeof(saved_KiUserExceptionDispatcher_bytes),
-            old_protect2, &old_protect2);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-    ret = VirtualProtect(hook_trampoline, ARRAY_SIZE(hook_trampoline), old_protect1, &old_protect1);
-    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
-}
-
-static BOOL got_nested_exception, got_prev_frame_exception;
-static void *nested_exception_initial_frame;
-
-static DWORD nested_exception_handler(EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
-        CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher)
-{
-    trace("nested_exception_handler Rip %p, Rsp %p, code %#x, flags %#x, ExceptionAddress %p.\n",
-            (void *)context->Rip, (void *)context->Rsp, rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress);
-
-    if (rec->ExceptionCode == 0x80000003
-            && !(rec->ExceptionFlags & EH_NESTED_CALL))
-    {
-        ok(rec->NumberParameters == 1, "Got unexpected rec->NumberParameters %u.\n", rec->NumberParameters);
-        ok((void *)context->Rsp == frame, "Got unexpected frame %p.\n", frame);
-        ok(*(void **)frame == (char *)code_mem + 5, "Got unexpected *frame %p.\n", *(void **)frame);
-        ok(context->Rip == (ULONG_PTR)((char *)code_mem + 7), "Got unexpected Rip %#lx.\n", context->Rip);
-
-        nested_exception_initial_frame = frame;
-        RaiseException(0xdeadbeef, 0, 0, 0);
-        ++context->Rip;
-        return ExceptionContinueExecution;
-    }
-
-    if (rec->ExceptionCode == 0xdeadbeef && rec->ExceptionFlags == EH_NESTED_CALL)
-    {
-        ok(!rec->NumberParameters, "Got unexpected rec->NumberParameters %u.\n", rec->NumberParameters);
-        got_nested_exception = TRUE;
-        ok(frame == nested_exception_initial_frame, "Got unexpected frame %p.\n", frame);
-        return ExceptionContinueSearch;
-    }
-
-    ok(rec->ExceptionCode == 0xdeadbeef && !rec->ExceptionFlags,
-            "Got unexpected exception code %#x, flags %#x.\n", rec->ExceptionCode, rec->ExceptionFlags);
-    ok(!rec->NumberParameters, "Got unexpected rec->NumberParameters %u.\n", rec->NumberParameters);
-    ok(frame == (void *)((BYTE *)nested_exception_initial_frame + 8),
-            "Got unexpected frame %p.\n", frame);
-    got_prev_frame_exception = TRUE;
-    return ExceptionContinueExecution;
-}
-
-static void test_nested_exception(void)
-{
-    static const BYTE except_code[] =
-    {
-        0xe8, 0x02, 0x00, 0x00, 0x00, /* call nest */
-        0x90,                         /* nop */
-        0xc3,                         /* ret */
-        /* nest: */
-        0xcc,                         /* int3 */
-        0x90,                         /* nop */
-        0xc3,                         /* ret  */
-    };
-
-    got_nested_exception = got_prev_frame_exception = FALSE;
-    run_exception_test(nested_exception_handler, NULL, except_code, ARRAY_SIZE(except_code), PAGE_EXECUTE_READ);
-    ok(got_nested_exception, "Did not get nested exception.\n");
-    ok(got_prev_frame_exception, "Did not get nested exception in the previous frame.\n");
-}
-
-#elif defined(__arm__)
-
-static void test_thread_context(void)
-{
-    CONTEXT context;
-    NTSTATUS status;
-    struct expected
-    {
-        DWORD R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, Sp, Lr, Pc, Cpsr;
-    } expect;
-    NTSTATUS (*func_ptr)( void *arg1, void *arg2, struct expected *res, void *func ) = (void *)code_mem;
-
-    static const DWORD call_func[] =
-    {
-        0xe92d4002,  /* push    {r1, lr} */
-        0xe8821fff,  /* stm     r2, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip} */
-        0xe582d034,  /* str     sp, [r2, #52] */
-        0xe582e038,  /* str     lr, [r2, #56] */
-        0xe10f1000,  /* mrs     r1, CPSR */
-        0xe5821040,  /* str     r1, [r2, #64] */
-        0xe59d1000,  /* ldr     r1, [sp] */
-        0xe582f03c,  /* str     pc, [r2, #60] */
-        0xe12fff33,  /* blx     r3 */
-        0xe8bd8002,  /* pop     {r1, pc} */
-    };
-
-    memcpy( func_ptr, call_func, sizeof(call_func) );
-
-#define COMPARE(reg) \
-    ok( context.reg == expect.reg, "wrong " #reg " %08x/%08x\n", context.reg, expect.reg )
-
-    memset( &context, 0xcc, sizeof(context) );
-    memset( &expect, 0xcc, sizeof(expect) );
-    func_ptr( &context, 0, &expect, pRtlCaptureContext );
-    trace( "expect: r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x r6=%08x r7=%08x r8=%08x r9=%08x "
-           "r10=%08x r11=%08x r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
-           expect.R0, expect.R1, expect.R2, expect.R3, expect.R4, expect.R5, expect.R6, expect.R7,
-           expect.R8, expect.R9, expect.R10, expect.R11, expect.R12, expect.Sp, expect.Lr, expect.Pc, expect.Cpsr );
-    trace( "actual: r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x r6=%08x r7=%08x r8=%08x r9=%08x "
-           "r10=%08x r11=%08x r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
-           context.R0, context.R1, context.R2, context.R3, context.R4, context.R5, context.R6, context.R7,
-           context.R8, context.R9, context.R10, context.R11, context.R12, context.Sp, context.Lr, context.Pc, context.Cpsr );
-
-    ok( context.ContextFlags == CONTEXT_FULL,
-        "wrong flags %08x\n", context.ContextFlags );
-    COMPARE( R0 );
-    COMPARE( R1 );
-    COMPARE( R2 );
-    COMPARE( R3 );
-    COMPARE( R4 );
-    COMPARE( R5 );
-    COMPARE( R6 );
-    COMPARE( R7 );
-    COMPARE( R8 );
-    COMPARE( R9 );
-    COMPARE( R10 );
-    COMPARE( R11 );
-    COMPARE( R12 );
-    COMPARE( Sp );
-    COMPARE( Pc );
-    COMPARE( Cpsr );
-    ok( context.Lr == expect.Pc, "wrong Lr %08x/%08x\n", context.Lr, expect.Pc );
-
-    memset( &context, 0xcc, sizeof(context) );
-    memset( &expect, 0xcc, sizeof(expect) );
-    context.ContextFlags = CONTEXT_FULL;
-
-    status = func_ptr( GetCurrentThread(), &context, &expect, pNtGetContextThread );
-    ok( status == STATUS_SUCCESS, "NtGetContextThread failed %08x\n", status );
-    trace( "expect: r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x r6=%08x r7=%08x r8=%08x r9=%08x "
-           "r10=%08x r11=%08x r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
-           expect.R0, expect.R1, expect.R2, expect.R3, expect.R4, expect.R5, expect.R6, expect.R7,
-           expect.R8, expect.R9, expect.R10, expect.R11, expect.R12, expect.Sp, expect.Lr, expect.Pc, expect.Cpsr );
-    trace( "actual: r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x r6=%08x r7=%08x r8=%08x r9=%08x "
-           "r10=%08x r11=%08x r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
-           context.R0, context.R1, context.R2, context.R3, context.R4, context.R5, context.R6, context.R7,
-           context.R8, context.R9, context.R10, context.R11, context.R12, context.Sp, context.Lr, context.Pc, context.Cpsr );
-    /* other registers are not preserved */
-    COMPARE( R4 );
-    COMPARE( R5 );
-    COMPARE( R6 );
-    COMPARE( R7 );
-    COMPARE( R8 );
-    COMPARE( R9 );
-    COMPARE( R10 );
-    COMPARE( R11 );
-    COMPARE( Cpsr );
-    ok( context.Sp == expect.Sp - 8,
-        "wrong Sp %08x/%08x\n", context.Sp, expect.Sp - 8 );
-    /* Pc is somewhere close to the NtGetContextThread implementation */
-    ok( (char *)context.Pc >= (char *)pNtGetContextThread - 0x40000 &&
-        (char *)context.Pc <= (char *)pNtGetContextThread + 0x40000,
-        "wrong Pc %08x/%08x\n", context.Pc, (DWORD)pNtGetContextThread );
-#undef COMPARE
-}
-
-static void test_debugger(void)
-{
-    char cmdline[MAX_PATH];
-    PROCESS_INFORMATION pi;
-    STARTUPINFOA si = { 0 };
-    DEBUG_EVENT de;
-    DWORD continuestatus;
-    PVOID code_mem_address = NULL;
-    NTSTATUS status;
-    SIZE_T size_read;
-    BOOL ret;
-    int counter = 0;
-    si.cb = sizeof(si);
-
-    if(!pNtGetContextThread || !pNtSetContextThread || !pNtReadVirtualMemory || !pNtTerminateProcess)
-    {
-        skip("NtGetContextThread, NtSetContextThread, NtReadVirtualMemory or NtTerminateProcess not found\n");
-        return;
-    }
-
-    sprintf(cmdline, "%s %s %s %p", my_argv[0], my_argv[1], "debuggee", &test_stage);
-    ret = CreateProcessA(NULL, cmdline, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &si, &pi);
-    ok(ret, "could not create child process error: %u\n", GetLastError());
-    if (!ret)
-        return;
-
-    do
-    {
-        continuestatus = DBG_CONTINUE;
-        ok(WaitForDebugEvent(&de, INFINITE), "reading debug event\n");
-
-        ret = ContinueDebugEvent(de.dwProcessId, de.dwThreadId, 0xdeadbeef);
-        ok(!ret, "ContinueDebugEvent unexpectedly succeeded\n");
-        ok(GetLastError() == ERROR_INVALID_PARAMETER, "Unexpected last error: %u\n", GetLastError());
-
-        if (de.dwThreadId != pi.dwThreadId)
-        {
-            trace("event %d not coming from main thread, ignoring\n", de.dwDebugEventCode);
-            ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);
-            continue;
-        }
-
-        if (de.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT)
-        {
-            if(de.u.CreateProcessInfo.lpBaseOfImage != NtCurrentTeb()->Peb->ImageBaseAddress)
-            {
-                skip("child process loaded at different address, terminating it\n");
-                pNtTerminateProcess(pi.hProcess, 0);
-            }
-        }
-        else if (de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
-        {
-            CONTEXT ctx;
-            int stage;
-
-            counter++;
-            status = pNtReadVirtualMemory(pi.hProcess, &code_mem, &code_mem_address,
-                                          sizeof(code_mem_address), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            ctx.ContextFlags = CONTEXT_FULL;
-            status = pNtGetContextThread(pi.hThread, &ctx);
-            ok(!status, "NtGetContextThread failed with 0x%x\n", status);
-
-            trace("exception 0x%x at %p firstchance=%d pc=%08x, r0=%08x\n",
-                  de.u.Exception.ExceptionRecord.ExceptionCode,
-                  de.u.Exception.ExceptionRecord.ExceptionAddress,
-                  de.u.Exception.dwFirstChance, ctx.Pc, ctx.R0);
-
-            if (counter > 100)
-            {
-                ok(FALSE, "got way too many exceptions, probably caught in an infinite loop, terminating child\n");
-                pNtTerminateProcess(pi.hProcess, 1);
-            }
-            else if (counter >= 2) /* skip startup breakpoint */
-            {
-#if 0  /* RtlRaiseException test disabled for now */
-                if (stage == 1)
-                {
-                    ok((char *)ctx.Pc == (char *)code_mem_address + 0xb, "Pc at %x instead of %p\n",
-                       ctx.Pc, (char *)code_mem_address + 0xb);
-                    /* setting the context from debugger does not affect the context that the
-                     * exception handler gets, except on w2008 */
-                    ctx.Pc = (UINT_PTR)code_mem_address + 0xd;
-                    ctx.R0 = 0xf00f00f1;
-                    /* let the debuggee handle the exception */
-                    continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 2)
-                {
-                    if (de.u.Exception.dwFirstChance)
-                    {
-                        /* debugger gets first chance exception with unmodified ctx.Pc */
-                        ok((char *)ctx.Pc == (char *)code_mem_address + 0xb, "Pc at 0x%x instead of %p\n",
-                           ctx.Pc, (char *)code_mem_address + 0xb);
-                        ctx.Pc = (UINT_PTR)code_mem_address + 0xd;
-                        ctx.R0 = 0xf00f00f1;
-                        /* pass exception to debuggee
-                         * exception will not be handled and a second chance exception will be raised */
-                        continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                    }
-                    else
-                    {
-                        /* debugger gets context after exception handler has played with it */
-                        /* ctx.Pc is the same value the exception handler got */
-                        if (de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT)
-                        {
-                            ok((char *)ctx.Pc == (char *)code_mem_address + 0xa,
-                               "Pc at 0x%x instead of %p\n", ctx.Pc, (char *)code_mem_address + 0xa);
-                            /* need to fixup Pc for debuggee */
-                            /*ctx.Pc += 2; */
-                        }
-                        else ok((char *)ctx.Pc == (char *)code_mem_address + 0xb,
-                                "Pc at 0x%x instead of %p\n", ctx.Pc, (char *)code_mem_address + 0xb);
-                        /* here we handle exception */
-                    }
-                }
-                else
-#endif
-                if (stage == 7 || stage == 8)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT,
-                       "expected EXCEPTION_BREAKPOINT, got %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode);
-                    ok((char *)ctx.Pc == (char *)code_mem_address + 0x1d,
-                       "expected Pc = %p, got 0x%x\n", (char *)code_mem_address + 0x1d, ctx.Pc);
-                    if (stage == 8) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 9 || stage == 10)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT,
-                       "expected EXCEPTION_BREAKPOINT, got %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode);
-                    ok((char *)ctx.Pc == (char *)code_mem_address + 4,
-                       "expected Pc = %p, got 0x%x\n", (char *)code_mem_address + 4, ctx.Pc);
-                    if (stage == 10) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 11 || stage == 12 || stage == 13)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_INVALID_HANDLE,
-                       "unexpected exception code %08x, expected %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode,
-                       EXCEPTION_INVALID_HANDLE);
-                    ok(de.u.Exception.ExceptionRecord.NumberParameters == 0,
-                       "unexpected number of parameters %d, expected 0\n", de.u.Exception.ExceptionRecord.NumberParameters);
-
-                    if (stage == 12|| stage == 13) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else
-                    ok(FALSE, "unexpected stage %x\n", stage);
-
-                status = pNtSetContextThread(pi.hThread, &ctx);
-                ok(!status, "NtSetContextThread failed with 0x%x\n", status);
-            }
-        }
-        else if (de.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
-        {
-            int stage;
-            char buffer[64];
-
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            ok(!de.u.DebugString.fUnicode, "unexpected unicode debug string event\n");
-            ok(de.u.DebugString.nDebugStringLength < sizeof(buffer) - 1, "buffer not large enough to hold %d bytes\n",
-               de.u.DebugString.nDebugStringLength);
-
-            memset(buffer, 0, sizeof(buffer));
-            status = pNtReadVirtualMemory(pi.hProcess, de.u.DebugString.lpDebugStringData, buffer,
-                                          de.u.DebugString.nDebugStringLength, &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            if (stage == 3 || stage == 4)
-                ok(!strcmp(buffer, "Hello World"), "got unexpected debug string '%s'\n", buffer);
-            else /* ignore unrelated debug strings like 'SHIMVIEW: ShimInfo(Complete)' */
-                ok(strstr(buffer, "SHIMVIEW") != NULL, "unexpected stage %x, got debug string event '%s'\n", stage, buffer);
-
-            if (stage == 4) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-        }
-        else if (de.dwDebugEventCode == RIP_EVENT)
-        {
-            int stage;
-
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            if (stage == 5 || stage == 6)
-            {
-                ok(de.u.RipInfo.dwError == 0x11223344, "got unexpected rip error code %08x, expected %08x\n",
-                   de.u.RipInfo.dwError, 0x11223344);
-                ok(de.u.RipInfo.dwType  == 0x55667788, "got unexpected rip type %08x, expected %08x\n",
-                   de.u.RipInfo.dwType, 0x55667788);
-            }
-            else
-                ok(FALSE, "unexpected stage %x\n", stage);
-
-            if (stage == 6) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-        }
-
-        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, continuestatus);
-
-    } while (de.dwDebugEventCode != EXIT_PROCESS_DEBUG_EVENT);
+    trace("rec %p, context %p.\n", rec, context);
+    trace("context->Rip %#lx, context->Rsp %#lx, ContextFlags %#lx.\n", sizeof(*context),
+            context->Rip, context->Rsp, context->ContextFlags);
 
-    wait_child_process( pi.hProcess );
-    ret = CloseHandle(pi.hThread);
-    ok(ret, "error %u\n", GetLastError());
-    ret = CloseHandle(pi.hProcess);
-    ok(ret, "error %u\n", GetLastError());
-}
+    hook_called = TRUE;
+    /* Broken on Win2008, probably rec offset in stack is different. */
+    ok(rec->ExceptionCode == 0x80000003 || broken(!rec->ExceptionCode),
+            "Got unexpected ExceptionCode %#x.\n", rec->ExceptionCode);
 
-static void test_debug_service(DWORD numexc)
-{
-    /* not supported */
+    hook_KiUserExceptionDispatcher_rip = (void *)context->Rip;
+    hook_exception_address = rec->ExceptionAddress;
+    memcpy(pKiUserExceptionDispatcher, saved_KiUserExceptionDispatcher_bytes, sizeof(saved_KiUserExceptionDispatcher_bytes));
 }
 
-#elif defined(__aarch64__)
-
-static void test_thread_context(void)
+static void test_kiuserexceptiondispatcher(void)
 {
-    CONTEXT context;
-    NTSTATUS status;
-    struct expected
+    HMODULE hntdll = GetModuleHandleA("ntdll.dll");
+    static const BYTE except_code[] =
     {
-        ULONG64 X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15, X16,
-            X17, X18, X19, X20, X21, X22, X23, X24, X25, X26, X27, X28, Fp, Lr, Sp, Pc;
-        ULONG Cpsr;
-    } expect;
-    NTSTATUS (*func_ptr)( void *arg1, void *arg2, struct expected *res, void *func ) = (void *)code_mem;
-
-    static const DWORD call_func[] =
+        0xcc,  /* int3 */
+        0xc3,  /* ret  */
+    };
+    static BYTE hook_trampoline[] =
     {
-        0xa9bf7bfd,  /* stp     x29, x30, [sp, #-16]! */
-        0xa9000440,  /* stp     x0, x1, [x2] */
-        0xa9010c42,  /* stp     x2, x3, [x2, #16] */
-        0xa9021444,  /* stp     x4, x5, [x2, #32] */
-        0xa9031c46,  /* stp     x6, x7, [x2, #48] */
-        0xa9042448,  /* stp     x8, x9, [x2, #64] */
-        0xa9052c4a,  /* stp     x10, x11, [x2, #80] */
-        0xa906344c,  /* stp     x12, x13, [x2, #96] */
-        0xa9073c4e,  /* stp     x14, x15, [x2, #112] */
-        0xa9084450,  /* stp     x16, x17, [x2, #128] */
-        0xa9094c52,  /* stp     x18, x19, [x2, #144] */
-        0xa90a5454,  /* stp     x20, x21, [x2, #160] */
-        0xa90b5c56,  /* stp     x22, x23, [x2, #176] */
-        0xa90c6458,  /* stp     x24, x25, [x2, #192] */
-        0xa90d6c5a,  /* stp     x26, x27, [x2, #208] */
-        0xa90e745c,  /* stp     x28, x29, [x2, #224] */
-        0xf900785e,  /* str     x30, [x2, #240] */
-        0x910003e1,  /* mov     x1, sp */
-        0xf9007c41,  /* str     x1, [x2, #248] */
-        0x90000001,  /* adrp    x1, 1f */
-        0x9101a021,  /* add     x1, x1, #:lo12:1f */
-        0xf9008041,  /* str     x1, [x2, #256] */
-        0xd53b4201,  /* mrs     x1, nzcv */
-        0xb9010841,  /* str     w1, [x2, #264] */
-        0xf9400441,  /* ldr     x1, [x2, #8] */
-        0xd63f0060,  /* blr     x3 */
-        0xa8c17bfd,  /* 1: ldp     x29, x30, [sp], #16 */
-        0xd65f03c0,  /* ret */
-     };
-
-    memcpy( func_ptr, call_func, sizeof(call_func) );
-
-#define COMPARE(reg) \
-    ok( context.reg == expect.reg, "wrong " #reg " %p/%p\n", (void *)(ULONG64)context.reg, (void *)(ULONG64)expect.reg )
-
-    memset( &context, 0xcc, sizeof(context) );
-    memset( &expect, 0xcc, sizeof(expect) );
-    func_ptr( &context, 0, &expect, pRtlCaptureContext );
-    trace( "expect: x0=%p x1=%p x2=%p x3=%p x4=%p x5=%p x6=%p x7=%p x8=%p x9=%p x10=%p x11=%p x12=%p x13=%p x14=%p x15=%p x16=%p x17=%p x18=%p x19=%p x20=%p x21=%p x22=%p x23=%p x24=%p x25=%p x26=%p x27=%p x28=%p fp=%p lr=%p sp=%p pc=%p cpsr=%08x\n",
-           (void *)expect.X0, (void *)expect.X1, (void *)expect.X2, (void *)expect.X3,
-           (void *)expect.X4, (void *)expect.X5, (void *)expect.X6, (void *)expect.X7,
-           (void *)expect.X8, (void *)expect.X9, (void *)expect.X10, (void *)expect.X11,
-           (void *)expect.X12, (void *)expect.X13, (void *)expect.X14, (void *)expect.X15,
-           (void *)expect.X16, (void *)expect.X17, (void *)expect.X18, (void *)expect.X19,
-           (void *)expect.X20, (void *)expect.X21, (void *)expect.X22, (void *)expect.X23,
-           (void *)expect.X24, (void *)expect.X25, (void *)expect.X26, (void *)expect.X27,
-           (void *)expect.X28, (void *)expect.Fp, (void *)expect.Lr, (void *)expect.Sp,
-           (void *)expect.Pc, expect.Cpsr );
-    trace( "actual: x0=%p x1=%p x2=%p x3=%p x4=%p x5=%p x6=%p x7=%p x8=%p x9=%p x10=%p x11=%p x12=%p x13=%p x14=%p x15=%p x16=%p x17=%p x18=%p x19=%p x20=%p x21=%p x22=%p x23=%p x24=%p x25=%p x26=%p x27=%p x28=%p fp=%p lr=%p sp=%p pc=%p cpsr=%08x\n",
-           (void *)context.X0, (void *)context.X1, (void *)context.X2, (void *)context.X3,
-           (void *)context.X4, (void *)context.X5, (void *)context.X6, (void *)context.X7,
-           (void *)context.X8, (void *)context.X9, (void *)context.X10, (void *)context.X11,
-           (void *)context.X12, (void *)context.X13, (void *)context.X14, (void *)context.X15,
-           (void *)context.X16, (void *)context.X17, (void *)context.X18, (void *)context.X19,
-           (void *)context.X20, (void *)context.X21, (void *)context.X22, (void *)context.X23,
-           (void *)context.X24, (void *)context.X25, (void *)context.X26, (void *)context.X27,
-           (void *)context.X28, (void *)context.Fp, (void *)context.Lr, (void *)context.Sp,
-           (void *)context.Pc, context.Cpsr );
-
-    ok( context.ContextFlags == CONTEXT_FULL,
-        "wrong flags %08x\n", context.ContextFlags );
-    COMPARE( X0 );
-    COMPARE( X1 );
-    COMPARE( X2 );
-    COMPARE( X3 );
-    COMPARE( X4 );
-    COMPARE( X5 );
-    COMPARE( X6 );
-    COMPARE( X7 );
-    COMPARE( X8 );
-    COMPARE( X9 );
-    COMPARE( X10 );
-    COMPARE( X11 );
-    COMPARE( X12 );
-    COMPARE( X13 );
-    COMPARE( X14 );
-    COMPARE( X15 );
-    COMPARE( X16 );
-    COMPARE( X17 );
-    COMPARE( X18 );
-    COMPARE( X19 );
-    COMPARE( X20 );
-    COMPARE( X21 );
-    COMPARE( X22 );
-    COMPARE( X23 );
-    COMPARE( X24 );
-    COMPARE( X25 );
-    COMPARE( X26 );
-    COMPARE( X27 );
-    COMPARE( X28 );
-    COMPARE( Fp );
-    COMPARE( Sp );
-    COMPARE( Pc );
-    COMPARE( Cpsr );
-    ok( context.Lr == expect.Pc, "wrong Lr %p/%p\n", (void *)context.Lr, (void *)expect.Pc );
-
-    memset( &context, 0xcc, sizeof(context) );
-    memset( &expect, 0xcc, sizeof(expect) );
-    context.ContextFlags = CONTEXT_FULL;
+        0x48, 0x89, 0xe2,           /* mov %rsp,%rdx */
+        0x48, 0x8d, 0x8c, 0x24, 0xf0, 0x04, 0x00, 0x00,
+                                    /* lea 0x4f0(%rsp),%rcx */
 
-    status = func_ptr( GetCurrentThread(), &context, &expect, pNtGetContextThread );
-    ok( status == STATUS_SUCCESS, "NtGetContextThread failed %08x\n", status );
-    trace( "expect: x0=%p x1=%p x2=%p x3=%p x4=%p x5=%p x6=%p x7=%p x8=%p x9=%p x10=%p x11=%p x12=%p x13=%p x14=%p x15=%p x16=%p x17=%p x18=%p x19=%p x20=%p x21=%p x22=%p x23=%p x24=%p x25=%p x26=%p x27=%p x28=%p fp=%p lr=%p sp=%p pc=%p cpsr=%08x\n",
-           (void *)expect.X0, (void *)expect.X1, (void *)expect.X2, (void *)expect.X3,
-           (void *)expect.X4, (void *)expect.X5, (void *)expect.X6, (void *)expect.X7,
-           (void *)expect.X8, (void *)expect.X9, (void *)expect.X10, (void *)expect.X11,
-           (void *)expect.X12, (void *)expect.X13, (void *)expect.X14, (void *)expect.X15,
-           (void *)expect.X16, (void *)expect.X17, (void *)expect.X18, (void *)expect.X19,
-           (void *)expect.X20, (void *)expect.X21, (void *)expect.X22, (void *)expect.X23,
-           (void *)expect.X24, (void *)expect.X25, (void *)expect.X26, (void *)expect.X27,
-           (void *)expect.X28, (void *)expect.Fp, (void *)expect.Lr, (void *)expect.Sp,
-           (void *)expect.Pc, expect.Cpsr );
-    trace( "actual: x0=%p x1=%p x2=%p x3=%p x4=%p x5=%p x6=%p x7=%p x8=%p x9=%p x10=%p x11=%p x12=%p x13=%p x14=%p x15=%p x16=%p x17=%p x18=%p x19=%p x20=%p x21=%p x22=%p x23=%p x24=%p x25=%p x26=%p x27=%p x28=%p fp=%p lr=%p sp=%p pc=%p cpsr=%08x\n",
-           (void *)context.X0, (void *)context.X1, (void *)context.X2, (void *)context.X3,
-           (void *)context.X4, (void *)context.X5, (void *)context.X6, (void *)context.X7,
-           (void *)context.X8, (void *)context.X9, (void *)context.X10, (void *)context.X11,
-           (void *)context.X12, (void *)context.X13, (void *)context.X14, (void *)context.X15,
-           (void *)context.X16, (void *)context.X17, (void *)context.X18, (void *)context.X19,
-           (void *)context.X20, (void *)context.X21, (void *)context.X22, (void *)context.X23,
-           (void *)context.X24, (void *)context.X25, (void *)context.X26, (void *)context.X27,
-           (void *)context.X28, (void *)context.Fp, (void *)context.Lr, (void *)context.Sp,
-           (void *)context.Pc, context.Cpsr );
-    /* other registers are not preserved */
-    todo_wine COMPARE( X18 );
-    COMPARE( X19 );
-    COMPARE( X20 );
-    COMPARE( X21 );
-    COMPARE( X22 );
-    COMPARE( X23 );
-    COMPARE( X24 );
-    COMPARE( X25 );
-    COMPARE( X26 );
-    COMPARE( X27 );
-    COMPARE( X28 );
-    COMPARE( Fp );
-    ok( context.Lr == expect.Pc, "wrong Lr %p/%p\n", (void *)context.Lr, (void *)expect.Pc );
-    ok( context.Sp == expect.Sp - 16,
-        "wrong Sp %p/%p\n", (void *)context.Sp, (void *)(expect.Sp - 16) );
-    /* Pc is somewhere close to the NtGetContextThread implementation */
-    ok( (char *)context.Pc >= (char *)pNtGetContextThread - 0x40000 &&
-        (char *)context.Pc <= (char *)pNtGetContextThread + 0x40000,
-        "wrong Pc %08x/%08x\n", context.Pc, (DWORD)pNtGetContextThread );
-#undef COMPARE
-}
+        0xff, 0x14, 0x25,
+        /* offset: 14 bytes */
+        0x00, 0x00, 0x00, 0x00,     /* callq *addr */ /* call hook implementation. */
+        0x48, 0x31, 0xc9,           /* xor %rcx, %rcx */
+        0x48, 0x31, 0xd2,           /* xor %rdx, %rdx */
 
-static void test_debugger(void)
-{
-    char cmdline[MAX_PATH];
-    PROCESS_INFORMATION pi;
-    STARTUPINFOA si = { 0 };
-    DEBUG_EVENT de;
-    DWORD continuestatus;
-    PVOID code_mem_address = NULL;
-    NTSTATUS status;
-    SIZE_T size_read;
+        0xff, 0x24, 0x25,
+        /* offset: 27 bytes */
+        0x00, 0x00, 0x00, 0x00,     /* jmpq *addr */ /* jump to original function. */
+    };
+    void *phook_KiUserExceptionDispatcher = hook_KiUserExceptionDispatcher;
+    DWORD old_protect1, old_protect2;
+    BYTE *ptr;
     BOOL ret;
-    int counter = 0;
-    si.cb = sizeof(si);
 
-    if(!pNtGetContextThread || !pNtSetContextThread || !pNtReadVirtualMemory || !pNtTerminateProcess)
+    pKiUserExceptionDispatcher = (void *)GetProcAddress(hntdll, "KiUserExceptionDispatcher");
+    if (!pKiUserExceptionDispatcher)
     {
-        skip("NtGetContextThread, NtSetContextThread, NtReadVirtualMemory or NtTerminateProcess not found\n");
+        win_skip("KiUserExceptionDispatcher is not available.\n");
         return;
     }
 
-    sprintf(cmdline, "%s %s %s %p", my_argv[0], my_argv[1], "debuggee", &test_stage);
-    ret = CreateProcessA(NULL, cmdline, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &si, &pi);
-    ok(ret, "could not create child process error: %u\n", GetLastError());
-    if (!ret)
-        return;
-
-    do
-    {
-        continuestatus = DBG_CONTINUE;
-        ok(WaitForDebugEvent(&de, INFINITE), "reading debug event\n");
-
-        ret = ContinueDebugEvent(de.dwProcessId, de.dwThreadId, 0xdeadbeef);
-        ok(!ret, "ContinueDebugEvent unexpectedly succeeded\n");
-        ok(GetLastError() == ERROR_INVALID_PARAMETER, "Unexpected last error: %u\n", GetLastError());
-
-        if (de.dwThreadId != pi.dwThreadId)
-        {
-            trace("event %d not coming from main thread, ignoring\n", de.dwDebugEventCode);
-            ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);
-            continue;
-        }
-
-        if (de.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT)
-        {
-            if(de.u.CreateProcessInfo.lpBaseOfImage != NtCurrentTeb()->Peb->ImageBaseAddress)
-            {
-                skip("child process loaded at different address, terminating it\n");
-                pNtTerminateProcess(pi.hProcess, 0);
-            }
-        }
-        else if (de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
-        {
-            CONTEXT ctx;
-            int stage;
-
-            counter++;
-            status = pNtReadVirtualMemory(pi.hProcess, &code_mem, &code_mem_address,
-                                          sizeof(code_mem_address), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            ctx.ContextFlags = CONTEXT_FULL;
-            status = pNtGetContextThread(pi.hThread, &ctx);
-            ok(!status, "NtGetContextThread failed with 0x%x\n", status);
-
-            trace("exception 0x%x at %p firstchance=%d pc=%p, x0=%p\n",
-                  de.u.Exception.ExceptionRecord.ExceptionCode,
-                  de.u.Exception.ExceptionRecord.ExceptionAddress,
-                  de.u.Exception.dwFirstChance, (char *)ctx.Pc, (char *)ctx.X0);
-
-            if (counter > 100)
-            {
-                ok(FALSE, "got way too many exceptions, probably caught in an infinite loop, terminating child\n");
-                pNtTerminateProcess(pi.hProcess, 1);
-            }
-            else if (counter >= 2) /* skip startup breakpoint */
-            {
-#if 0  /* RtlRaiseException test disabled for now */
-                if (stage == 1)
-                {
-                    ok((char *)ctx.Pc == (char *)code_mem_address + 0xb, "Pc at %p instead of %p\n",
-                       (char *)ctx.Pc, (char *)code_mem_address + 0xb);
-                    /* setting the context from debugger does not affect the context that the
-                     * exception handler gets, except on w2008 */
-                    ctx.Pc = (UINT_PTR)code_mem_address + 0xd;
-                    ctx.X0 = 0xf00f00f1;
-                    /* let the debuggee handle the exception */
-                    continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 2)
-                {
-                    if (de.u.Exception.dwFirstChance)
-                    {
-                        /* debugger gets first chance exception with unmodified ctx.Pc */
-                        ok((char *)ctx.Pc == (char *)code_mem_address + 0xb, "Pc at %p instead of %p\n",
-                           (char *)ctx.Pc, (char *)code_mem_address + 0xb);
-                        ctx.Pc = (UINT_PTR)code_mem_address + 0xd;
-                        ctx.X0 = 0xf00f00f1;
-                        /* pass exception to debuggee
-                         * exception will not be handled and a second chance exception will be raised */
-                        continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                    }
-                    else
-                    {
-                        /* debugger gets context after exception handler has played with it */
-                        /* ctx.Pc is the same value the exception handler got */
-                        if (de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT)
-                        {
-                            ok((char *)ctx.Pc == (char *)code_mem_address + 0xa,
-                               "Pc at %p instead of %p\n", (char *)ctx.Pc, (char *)code_mem_address + 0xa);
-                            /* need to fixup Pc for debuggee */
-                            ctx.Pc += 4;
-                        }
-                        else ok((char *)ctx.Pc == (char *)code_mem_address + 0xb,
-                                "Pc at 0x%x instead of %p\n", ctx.Pc, (char *)code_mem_address + 0xb);
-                        /* here we handle exception */
-                    }
-                }
-                else
-#endif
-                if (stage == 7 || stage == 8)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT,
-                       "expected EXCEPTION_BREAKPOINT, got %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode);
-                    ok((char *)ctx.Pc == (char *)code_mem_address + 0x1d,
-                       "expected Pc = %p, got %p\n", (char *)code_mem_address + 0x1d, (char *)ctx.Pc);
-                    if (stage == 8) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 9 || stage == 10)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT,
-                       "expected EXCEPTION_BREAKPOINT, got %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode);
-                    ok((char *)ctx.Pc == (char *)code_mem_address + 4,
-                       "expected Pc = %p, got %p\n", (char *)code_mem_address + 4, (char *)ctx.Pc);
-                    if (stage == 10) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else if (stage == 11 || stage == 12 || stage == 13)
-                {
-                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_INVALID_HANDLE,
-                       "unexpected exception code %08x, expected %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode,
-                       EXCEPTION_INVALID_HANDLE);
-                    ok(de.u.Exception.ExceptionRecord.NumberParameters == 0,
-                       "unexpected number of parameters %d, expected 0\n", de.u.Exception.ExceptionRecord.NumberParameters);
-
-                    if (stage == 12|| stage == 13) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-                }
-                else
-                    ok(FALSE, "unexpected stage %x\n", stage);
-
-                status = pNtSetContextThread(pi.hThread, &ctx);
-                ok(!status, "NtSetContextThread failed with 0x%x\n", status);
-            }
-        }
-        else if (de.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
-        {
-            int stage;
-            char buffer[64];
-
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            ok(!de.u.DebugString.fUnicode, "unexpected unicode debug string event\n");
-            ok(de.u.DebugString.nDebugStringLength < sizeof(buffer) - 1, "buffer not large enough to hold %d bytes\n",
-               de.u.DebugString.nDebugStringLength);
-
-            memset(buffer, 0, sizeof(buffer));
-            status = pNtReadVirtualMemory(pi.hProcess, de.u.DebugString.lpDebugStringData, buffer,
-                                          de.u.DebugString.nDebugStringLength, &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
-
-            if (stage == 3 || stage == 4)
-                ok(!strcmp(buffer, "Hello World"), "got unexpected debug string '%s'\n", buffer);
-            else /* ignore unrelated debug strings like 'SHIMVIEW: ShimInfo(Complete)' */
-                ok(strstr(buffer, "SHIMVIEW") != NULL, "unexpected stage %x, got debug string event '%s'\n", stage, buffer);
-
-            if (stage == 4) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-        }
-        else if (de.dwDebugEventCode == RIP_EVENT)
-        {
-            int stage;
+    ok(((ULONG64)&phook_KiUserExceptionDispatcher & 0xffffffff) == ((ULONG64)&phook_KiUserExceptionDispatcher),
+            "Address is too long.\n");
+    ok(((ULONG64)&pKiUserExceptionDispatcher & 0xffffffff) == ((ULONG64)&pKiUserExceptionDispatcher),
+            "Address is too long.\n");
 
-            status = pNtReadVirtualMemory(pi.hProcess, &test_stage, &stage,
-                                          sizeof(stage), &size_read);
-            ok(!status,"NtReadVirtualMemory failed with 0x%x\n", status);
+    *(unsigned int *)(hook_trampoline + 14) = (unsigned int)(ULONG_PTR)&phook_KiUserExceptionDispatcher;
+    *(unsigned int *)(hook_trampoline + 27) = (unsigned int)(ULONG_PTR)&pKiUserExceptionDispatcher;
 
-            if (stage == 5 || stage == 6)
-            {
-                ok(de.u.RipInfo.dwError == 0x11223344, "got unexpected rip error code %08x, expected %08x\n",
-                   de.u.RipInfo.dwError, 0x11223344);
-                ok(de.u.RipInfo.dwType  == 0x55667788, "got unexpected rip type %08x, expected %08x\n",
-                   de.u.RipInfo.dwType, 0x55667788);
-            }
-            else
-                ok(FALSE, "unexpected stage %x\n", stage);
+    ret = VirtualProtect(hook_trampoline, ARRAY_SIZE(hook_trampoline), PAGE_EXECUTE_READWRITE, &old_protect1);
+    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
 
-            if (stage == 6) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
-        }
+    ret = VirtualProtect(pKiUserExceptionDispatcher, 5, PAGE_EXECUTE_READWRITE, &old_protect2);
+    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
 
-        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, continuestatus);
+    memcpy(saved_KiUserExceptionDispatcher_bytes, pKiUserExceptionDispatcher, sizeof(saved_KiUserExceptionDispatcher_bytes));
+    ptr = (BYTE *)pKiUserExceptionDispatcher;
+    /* mov hook_trampoline, %rax */
+    *ptr++ = 0x48;
+    *ptr++ = 0xb8;
+    *(void **)ptr = hook_trampoline;
+    ptr += sizeof(ULONG64);
+    /* jmp *rax */
+    *ptr++ = 0xff;
+    *ptr++ = 0xe0;
 
-    } while (de.dwDebugEventCode != EXIT_PROCESS_DEBUG_EVENT);
+    got_exception = 0;
+    run_exception_test(dbg_except_continue_handler, NULL, except_code, ARRAY_SIZE(except_code), PAGE_EXECUTE_READ);
+    ok(got_exception, "Handler was not called.\n");
+    ok(hook_called, "Hook was not called.\n");
 
-    wait_child_process( pi.hProcess );
-    ret = CloseHandle(pi.hThread);
-    ok(ret, "error %u\n", GetLastError());
-    ret = CloseHandle(pi.hProcess);
-    ok(ret, "error %u\n", GetLastError());
-}
+    ok(hook_exception_address == code_mem || broken(!hook_exception_address) /* Win2008 */,
+            "Got unexpected exception address %p, expected %p.\n",
+            hook_exception_address, code_mem);
+    todo_wine ok(hook_KiUserExceptionDispatcher_rip == code_mem, "Got unexpected exception address %p, expected %p.\n",
+            hook_KiUserExceptionDispatcher_rip, code_mem);
+    ok(dbg_except_continue_handler_rip == code_mem, "Got unexpected exception address %p, expected %p.\n",
+            dbg_except_continue_handler_rip, code_mem);
 
-static void test_debug_service(DWORD numexc)
-{
-    /* not supported */
+    ret = VirtualProtect(pKiUserExceptionDispatcher, 5, old_protect2, &old_protect2);
+    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
+    ret = VirtualProtect(hook_trampoline, ARRAY_SIZE(hook_trampoline), old_protect1, &old_protect1);
+    ok(ret, "Got unexpected ret %#x, GetLastError() %u.\n", ret, GetLastError());
 }
 
-#endif  /* __aarch64__ */
+#endif  /* __x86_64__ */
 
 #if defined(__i386__) || defined(__x86_64__)
 
@@ -4695,6 +2868,96 @@ static void test_debug_registers(void)
     CloseHandle(thread);
 }
 
+static DWORD outputdebugstring_exceptions;
+
+static LONG CALLBACK outputdebugstring_vectored_handler(EXCEPTION_POINTERS *ExceptionInfo)
+{
+    PEXCEPTION_RECORD rec = ExceptionInfo->ExceptionRecord;
+    trace("vect. handler %08x addr:%p\n", rec->ExceptionCode, rec->ExceptionAddress);
+
+    ok(rec->ExceptionCode == DBG_PRINTEXCEPTION_C, "ExceptionCode is %08x instead of %08x\n",
+        rec->ExceptionCode, DBG_PRINTEXCEPTION_C);
+    ok(rec->NumberParameters == 2, "ExceptionParameters is %d instead of 2\n", rec->NumberParameters);
+    ok(rec->ExceptionInformation[0] == 12, "ExceptionInformation[0] = %d instead of 12\n", (DWORD)rec->ExceptionInformation[0]);
+    ok(!strcmp((char *)rec->ExceptionInformation[1], "Hello World"),
+        "ExceptionInformation[1] = '%s' instead of 'Hello World'\n", (char *)rec->ExceptionInformation[1]);
+
+    outputdebugstring_exceptions++;
+    return EXCEPTION_CONTINUE_SEARCH;
+}
+
+static void test_outputdebugstring(DWORD numexc, BOOL todo)
+{
+    PVOID vectored_handler;
+
+    if (!pRtlAddVectoredExceptionHandler || !pRtlRemoveVectoredExceptionHandler)
+    {
+        skip("RtlAddVectoredExceptionHandler or RtlRemoveVectoredExceptionHandler not found\n");
+        return;
+    }
+
+    vectored_handler = pRtlAddVectoredExceptionHandler(TRUE, &outputdebugstring_vectored_handler);
+    ok(vectored_handler != 0, "RtlAddVectoredExceptionHandler failed\n");
+
+    outputdebugstring_exceptions = 0;
+    OutputDebugStringA("Hello World");
+
+    todo_wine_if(todo)
+    ok(outputdebugstring_exceptions == numexc, "OutputDebugStringA generated %d exceptions, expected %d\n",
+       outputdebugstring_exceptions, numexc);
+
+    pRtlRemoveVectoredExceptionHandler(vectored_handler);
+}
+
+static DWORD ripevent_exceptions;
+
+static LONG CALLBACK ripevent_vectored_handler(EXCEPTION_POINTERS *ExceptionInfo)
+{
+    PEXCEPTION_RECORD rec = ExceptionInfo->ExceptionRecord;
+    trace("vect. handler %08x addr:%p\n", rec->ExceptionCode, rec->ExceptionAddress);
+
+    ok(rec->ExceptionCode == DBG_RIPEXCEPTION, "ExceptionCode is %08x instead of %08x\n",
+       rec->ExceptionCode, DBG_RIPEXCEPTION);
+    ok(rec->NumberParameters == 2, "ExceptionParameters is %d instead of 2\n", rec->NumberParameters);
+    ok(rec->ExceptionInformation[0] == 0x11223344, "ExceptionInformation[0] = %08x instead of %08x\n",
+       (NTSTATUS)rec->ExceptionInformation[0], 0x11223344);
+    ok(rec->ExceptionInformation[1] == 0x55667788, "ExceptionInformation[1] = %08x instead of %08x\n",
+       (NTSTATUS)rec->ExceptionInformation[1], 0x55667788);
+
+    ripevent_exceptions++;
+    return (rec->ExceptionCode == DBG_RIPEXCEPTION) ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_CONTINUE_SEARCH;
+}
+
+static void test_ripevent(DWORD numexc)
+{
+    EXCEPTION_RECORD record;
+    PVOID vectored_handler;
+
+    if (!pRtlAddVectoredExceptionHandler || !pRtlRemoveVectoredExceptionHandler || !pRtlRaiseException)
+    {
+        skip("RtlAddVectoredExceptionHandler or RtlRemoveVectoredExceptionHandler or RtlRaiseException not found\n");
+        return;
+    }
+
+    vectored_handler = pRtlAddVectoredExceptionHandler(TRUE, &ripevent_vectored_handler);
+    ok(vectored_handler != 0, "RtlAddVectoredExceptionHandler failed\n");
+
+    record.ExceptionCode = DBG_RIPEXCEPTION;
+    record.ExceptionFlags = 0;
+    record.ExceptionRecord = NULL;
+    record.ExceptionAddress = NULL;
+    record.NumberParameters = 2;
+    record.ExceptionInformation[0] = 0x11223344;
+    record.ExceptionInformation[1] = 0x55667788;
+
+    ripevent_exceptions = 0;
+    pRtlRaiseException(&record);
+    ok(ripevent_exceptions == numexc, "RtlRaiseException generated %d exceptions, expected %d\n",
+       ripevent_exceptions, numexc);
+
+    pRtlRemoveVectoredExceptionHandler(vectored_handler);
+}
+
 static DWORD debug_service_exceptions;
 
 static LONG CALLBACK debug_service_handler(EXCEPTION_POINTERS *ExceptionInfo)
@@ -4869,97 +3132,6 @@ static void test_debug_service(DWORD numexc)
 
     pRtlRemoveVectoredExceptionHandler(vectored_handler);
 }
-#endif /* defined(__i386__) || defined(__x86_64__) */
-
-static DWORD outputdebugstring_exceptions;
-
-static LONG CALLBACK outputdebugstring_vectored_handler(EXCEPTION_POINTERS *ExceptionInfo)
-{
-    PEXCEPTION_RECORD rec = ExceptionInfo->ExceptionRecord;
-    trace("vect. handler %08x addr:%p\n", rec->ExceptionCode, rec->ExceptionAddress);
-
-    ok(rec->ExceptionCode == DBG_PRINTEXCEPTION_C, "ExceptionCode is %08x instead of %08x\n",
-        rec->ExceptionCode, DBG_PRINTEXCEPTION_C);
-    ok(rec->NumberParameters == 2, "ExceptionParameters is %d instead of 2\n", rec->NumberParameters);
-    ok(rec->ExceptionInformation[0] == 12, "ExceptionInformation[0] = %d instead of 12\n", (DWORD)rec->ExceptionInformation[0]);
-    ok(!strcmp((char *)rec->ExceptionInformation[1], "Hello World"),
-        "ExceptionInformation[1] = '%s' instead of 'Hello World'\n", (char *)rec->ExceptionInformation[1]);
-
-    outputdebugstring_exceptions++;
-    return EXCEPTION_CONTINUE_SEARCH;
-}
-
-static void test_outputdebugstring(DWORD numexc, BOOL todo)
-{
-    PVOID vectored_handler;
-
-    if (!pRtlAddVectoredExceptionHandler || !pRtlRemoveVectoredExceptionHandler)
-    {
-        skip("RtlAddVectoredExceptionHandler or RtlRemoveVectoredExceptionHandler not found\n");
-        return;
-    }
-
-    vectored_handler = pRtlAddVectoredExceptionHandler(TRUE, &outputdebugstring_vectored_handler);
-    ok(vectored_handler != 0, "RtlAddVectoredExceptionHandler failed\n");
-
-    outputdebugstring_exceptions = 0;
-    OutputDebugStringA("Hello World");
-
-    todo_wine_if(todo)
-    ok(outputdebugstring_exceptions == numexc, "OutputDebugStringA generated %d exceptions, expected %d\n",
-       outputdebugstring_exceptions, numexc);
-
-    pRtlRemoveVectoredExceptionHandler(vectored_handler);
-}
-
-static DWORD ripevent_exceptions;
-
-static LONG CALLBACK ripevent_vectored_handler(EXCEPTION_POINTERS *ExceptionInfo)
-{
-    PEXCEPTION_RECORD rec = ExceptionInfo->ExceptionRecord;
-    trace("vect. handler %08x addr:%p\n", rec->ExceptionCode, rec->ExceptionAddress);
-
-    ok(rec->ExceptionCode == DBG_RIPEXCEPTION, "ExceptionCode is %08x instead of %08x\n",
-       rec->ExceptionCode, DBG_RIPEXCEPTION);
-    ok(rec->NumberParameters == 2, "ExceptionParameters is %d instead of 2\n", rec->NumberParameters);
-    ok(rec->ExceptionInformation[0] == 0x11223344, "ExceptionInformation[0] = %08x instead of %08x\n",
-       (NTSTATUS)rec->ExceptionInformation[0], 0x11223344);
-    ok(rec->ExceptionInformation[1] == 0x55667788, "ExceptionInformation[1] = %08x instead of %08x\n",
-       (NTSTATUS)rec->ExceptionInformation[1], 0x55667788);
-
-    ripevent_exceptions++;
-    return (rec->ExceptionCode == DBG_RIPEXCEPTION) ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_CONTINUE_SEARCH;
-}
-
-static void test_ripevent(DWORD numexc)
-{
-    EXCEPTION_RECORD record;
-    PVOID vectored_handler;
-
-    if (!pRtlAddVectoredExceptionHandler || !pRtlRemoveVectoredExceptionHandler || !pRtlRaiseException)
-    {
-        skip("RtlAddVectoredExceptionHandler or RtlRemoveVectoredExceptionHandler or RtlRaiseException not found\n");
-        return;
-    }
-
-    vectored_handler = pRtlAddVectoredExceptionHandler(TRUE, &ripevent_vectored_handler);
-    ok(vectored_handler != 0, "RtlAddVectoredExceptionHandler failed\n");
-
-    record.ExceptionCode = DBG_RIPEXCEPTION;
-    record.ExceptionFlags = 0;
-    record.ExceptionRecord = NULL;
-    record.ExceptionAddress = NULL;
-    record.NumberParameters = 2;
-    record.ExceptionInformation[0] = 0x11223344;
-    record.ExceptionInformation[1] = 0x55667788;
-
-    ripevent_exceptions = 0;
-    pRtlRaiseException(&record);
-    ok(ripevent_exceptions == numexc, "RtlRaiseException generated %d exceptions, expected %d\n",
-       ripevent_exceptions, numexc);
-
-    pRtlRemoveVectoredExceptionHandler(vectored_handler);
-}
 
 static DWORD breakpoint_exceptions;
 
@@ -4979,7 +3151,7 @@ static LONG CALLBACK breakpoint_handler(EXCEPTION_POINTERS *ExceptionInfo)
     ok(rec->ExceptionInformation[0] == 0,
        "got ExceptionInformation[0] = %lx\n", rec->ExceptionInformation[0]);
     ExceptionInfo->ContextRecord->Eip = (DWORD)code_mem + 2;
-#elif defined(__x86_64__)
+#else
     ok(ExceptionInfo->ContextRecord->Rip == (DWORD_PTR)code_mem + 1,
        "expected Rip = %lx, got %lx\n", (DWORD_PTR)code_mem + 1, ExceptionInfo->ContextRecord->Rip);
     ok(rec->NumberParameters == 1,
@@ -4987,33 +3159,16 @@ static LONG CALLBACK breakpoint_handler(EXCEPTION_POINTERS *ExceptionInfo)
     ok(rec->ExceptionInformation[0] == 0,
        "got ExceptionInformation[0] = %lx\n", rec->ExceptionInformation[0]);
     ExceptionInfo->ContextRecord->Rip = (DWORD_PTR)code_mem + 2;
-#elif defined(__arm__)
-    ok(ExceptionInfo->ContextRecord->Pc == (DWORD)code_mem + 4,
-       "expected pc = %lx, got %lx\n", (DWORD)code_mem + 4, ExceptionInfo->ContextRecord->Pc);
-    ok(rec->NumberParameters == 1,
-       "ExceptionParameters is %d instead of 1\n", rec->NumberParameters);
-    ok(rec->ExceptionInformation[0] == 0,
-       "got ExceptionInformation[0] = %lx\n", rec->ExceptionInformation[0]);
-#elif defined(__aarch64__)
-    ok(ExceptionInfo->ContextRecord->Pc == (DWORD_PTR)code_mem + 4,
-       "expected pc = %lx, got %lx\n", (DWORD_PTR)code_mem + 4, ExceptionInfo->ContextRecord->Pc);
-    ok(rec->NumberParameters == 1,
-       "ExceptionParameters is %d instead of 1\n", rec->NumberParameters);
-    ok(rec->ExceptionInformation[0] == 0,
-       "got ExceptionInformation[0] = %lx\n", rec->ExceptionInformation[0]);
 #endif
 
     breakpoint_exceptions++;
     return (rec->ExceptionCode == EXCEPTION_BREAKPOINT) ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_CONTINUE_SEARCH;
 }
 
-#if defined(__i386__) || defined(__x86_64__)
-static const BYTE breakpoint_code[] = { 0xcd, 0x03, 0xc3 };   /* int $0x3; ret */
-#elif defined(__arm__)
-static const DWORD breakpoint_code[] = { 0xe1200070, 0xe12fff1e };  /* bkpt #0; bx lr */
-#elif defined(__aarch64__)
-static const DWORD breakpoint_code[] = { 0xd4200000, 0xd65f03c0 };  /* brk #0; ret */
-#endif
+static const BYTE breakpoint_code[] = {
+    0xcd, 0x03,                   /* int $0x3 */
+    0xc3,                         /* ret */
+};
 
 static void test_breakpoint(DWORD numexc)
 {
@@ -5117,6 +3272,7 @@ static void test_vectored_continue_handler(void)
     ret = pRtlRemoveVectoredContinueHandler((void *)0x11223344);
     ok(!ret, "RtlRemoveVectoredContinueHandler succeeded\n");
 }
+#endif /* defined(__i386__) || defined(__x86_64__) */
 
 static DWORD WINAPI suspend_thread_test( void *arg )
 {
@@ -5454,7 +3610,6 @@ START_TEST(exception)
     X(RtlRemoveVectoredExceptionHandler);
     X(RtlAddVectoredContinueHandler);
     X(RtlRemoveVectoredContinueHandler);
-    X(RtlSetUnhandledExceptionFilter);
     X(NtQueryInformationProcess);
     X(NtQueryInformationThread);
     X(NtSetInformationProcess);
@@ -5465,6 +3620,8 @@ START_TEST(exception)
 #undef X
 
     pIsWow64Process = (void *)GetProcAddress(GetModuleHandleA("kernel32.dll"), "IsWow64Process");
+
+#ifdef __i386__
     if (!pIsWow64Process || !pIsWow64Process( GetCurrentProcess(), &is_wow64 )) is_wow64 = FALSE;
 
     if (pRtlAddVectoredExceptionHandler && pRtlRemoveVectoredExceptionHandler)
@@ -5491,7 +3648,6 @@ START_TEST(exception)
             return;
         }
 
-#if defined(__i386__) || defined(__x86_64__)
         if (pRtlRaiseException)
         {
             test_stage = 1;
@@ -5502,48 +3658,55 @@ START_TEST(exception)
             run_rtlraiseexception_test(0x12345);
             run_rtlraiseexception_test(EXCEPTION_BREAKPOINT);
             run_rtlraiseexception_test(EXCEPTION_INVALID_HANDLE);
+            test_stage = 3;
+            test_outputdebugstring(0, FALSE);
+            test_stage = 4;
+            test_outputdebugstring(2, TRUE); /* is this a Windows bug? */
+            test_stage = 5;
+            test_ripevent(0);
+            test_stage = 6;
+            test_ripevent(1);
+            test_stage = 7;
+            test_debug_service(0);
+            test_stage = 8;
+            test_debug_service(1);
+            test_stage = 9;
+            test_breakpoint(0);
+            test_stage = 10;
+            test_breakpoint(1);
+            test_stage = 11;
+            test_closehandle(0, (HANDLE)0xdeadbeef);
+            test_stage = 12;
+            test_closehandle(1, (HANDLE)0xdeadbeef);
+            test_stage = 13;
+            test_closehandle(0, 0); /* Special case. */
         }
-        else skip( "RtlRaiseException not found\n" );
-#endif
-        test_stage = 3;
-        test_outputdebugstring(0, FALSE);
-        test_stage = 4;
-        test_outputdebugstring(2, TRUE); /* is this a Windows bug? */
-        test_stage = 5;
-        test_ripevent(0);
-        test_stage = 6;
-        test_ripevent(1);
-        test_stage = 7;
-        test_debug_service(0);
-        test_stage = 8;
-        test_debug_service(1);
-        test_stage = 9;
-        test_breakpoint(0);
-        test_stage = 10;
-        test_breakpoint(1);
-        test_stage = 11;
-        test_closehandle(0, (HANDLE)0xdeadbeef);
-        test_stage = 12;
-        test_closehandle(1, (HANDLE)0xdeadbeef);
-        test_stage = 13;
-        test_closehandle(0, 0); /* Special case. */
+        else
+            skip( "RtlRaiseException not found\n" );
 
         /* rest of tests only run in parent */
         return;
     }
 
-#ifdef __i386__
-
     test_unwind();
     test_exceptions();
     test_rtlraiseexception();
     test_debug_registers();
+    test_outputdebugstring(1, FALSE);
+    test_ripevent(1);
     test_debug_service(1);
+    test_breakpoint(1);
+    test_closehandle(0, (HANDLE)0xdeadbeef);
+    test_vectored_continue_handler();
+    test_debugger();
     test_simd_exceptions();
     test_fpu_exceptions();
     test_dpe_exceptions();
     test_prot_fault();
-    test_kiuserexceptiondispatcher();
+    test_thread_context();
+    test_suspend_thread();
+    test_suspend_process();
+    test_unload_trace();
 
 #elif defined(__x86_64__)
 
@@ -5566,39 +3729,30 @@ START_TEST(exception)
     p_setjmp                           = (void *)GetProcAddress( hmsvcrt,
                                                                  "_setjmp" );
 
-    test_rtlraiseexception();
     test_debug_registers();
+    test_outputdebugstring(1, FALSE);
+    test_ripevent(1);
     test_debug_service(1);
+    test_breakpoint(1);
+    test_closehandle(0, (HANDLE)0xdeadbeef);
+    test_vectored_continue_handler();
     test_virtual_unwind();
     test___C_specific_handler();
     test_restore_context();
     test_prot_fault();
     test_dpe_exceptions();
     test_wow64_context();
+    test_suspend_thread();
+    test_suspend_process();
+    test_unload_trace();
     test_kiuserexceptiondispatcher();
-    test_nested_exception();
 
     if (pRtlAddFunctionTable && pRtlDeleteFunctionTable && pRtlInstallFunctionTableCallback && pRtlLookupFunctionEntry)
       test_dynamic_unwind();
     else
       skip( "Dynamic unwind functions not found\n" );
-#endif
 
-    test_debugger();
-    test_thread_context();
-    test_outputdebugstring(1, FALSE);
-    test_ripevent(1);
-    test_breakpoint(1);
-    test_closehandle(0, (HANDLE)0xdeadbeef);
-    /* Call of Duty WWII writes to BeingDebugged then closes an invalid handle,
-     * crashing the game if an exception is raised. */
-    NtCurrentTeb()->Peb->BeingDebugged = 0x98;
-    test_closehandle(0, (HANDLE)0xdeadbeef);
-    NtCurrentTeb()->Peb->BeingDebugged = 0;
+#endif
 
-    test_vectored_continue_handler();
-    test_suspend_thread();
-    test_suspend_process();
-    test_unload_trace();
     VirtualFree(code_mem, 0, MEM_RELEASE);
 }
diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
index 8b9ec4f624..184b7cdad5 100644
--- a/dlls/ntdll/tests/file.c
+++ b/dlls/ntdll/tests/file.c
@@ -349,7 +349,7 @@ static void open_file_test(void)
     attr.Length = sizeof(attr);
     attr.RootDirectory = 0;
     attr.ObjectName = &nameW;
-    attr.Attributes = 0;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
     status = pNtOpenFile( &dir, SYNCHRONIZE|FILE_LIST_DIRECTORY, &attr, &io,
@@ -401,31 +401,6 @@ static void open_file_test(void)
     CloseHandle( handle );
     CloseHandle( dir );
 
-    attr.RootDirectory = 0;
-    wcscat( path, L"\\cmd.exe" );
-    pRtlDosPathNameToNtPathName_U( path, &nameW, NULL, NULL );
-    status = pNtOpenFile( &handle, GENERIC_READ, &attr, &io,
-                          FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_DIRECTORY_FILE );
-    ok( status == STATUS_NOT_A_DIRECTORY, "open %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
-    CloseHandle( handle );
-    status = pNtOpenFile( &handle, GENERIC_READ, &attr, &io,
-                          FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE );
-    ok( !status, "open %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
-    CloseHandle( handle );
-    pRtlFreeUnicodeString( &nameW );
-
-    wcscat( path, L"\\cmd.exe" );
-    pRtlDosPathNameToNtPathName_U( path, &nameW, NULL, NULL );
-    status = pNtOpenFile( &handle, GENERIC_READ, &attr, &io,
-                          FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_DIRECTORY_FILE );
-    todo_wine
-    ok( status == STATUS_OBJECT_PATH_NOT_FOUND, "open %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
-    status = pNtOpenFile( &handle, GENERIC_READ, &attr, &io,
-                          FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE );
-    todo_wine
-    ok( status == STATUS_OBJECT_PATH_NOT_FOUND, "open %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
-    pRtlFreeUnicodeString( &nameW );
-
     GetTempPathW( MAX_PATH, path );
     lstrcatW( path, testdirW );
     CreateDirectoryW( path, NULL );
@@ -3107,17 +3082,16 @@ todo_wine
     fileDeleted = RemoveDirectoryA( buffer );
     ok( fileDeleted, "Directory should have been deleted\n" );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+todo_wine
     ok( !fileDeleted, "Directory shouldn't have been deleted\n" );
     res = nt_get_file_attrs( buffer, &fdi2 );
 todo_wine
     ok( res == STATUS_DELETE_PENDING, "got %#x\n", res );
     /* can't open the deleted directory */
     handle2 = CreateFileA(buffer, DELETE, FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
-todo_wine
     ok( handle2 == INVALID_HANDLE_VALUE, "CreateFile should fail\n" );
 todo_wine
     ok(GetLastError() == ERROR_ACCESS_DENIED, "got %u\n", GetLastError());
-    if (handle2 != INVALID_HANDLE_VALUE) CloseHandle( handle2 );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
     ok( fileDeleted, "Directory should have been deleted\n" );
@@ -3813,6 +3787,7 @@ static void test_file_mode(void)
         UNICODE_STRING *file_name;
         ULONG options;
         ULONG mode;
+        BOOL todo;
     } option_tests[] = {
         { &file_name, 0, 0 },
         { &file_name, FILE_NON_DIRECTORY_FILE, 0 },
@@ -3826,7 +3801,7 @@ static void test_file_mode(void)
         { &pipe_dev_name, 0, 0 },
         { &pipe_dev_name, FILE_SYNCHRONOUS_IO_ALERT, FILE_SYNCHRONOUS_IO_ALERT },
         { &mailslot_dev_name, 0, 0 },
-        { &mailslot_dev_name, FILE_SYNCHRONOUS_IO_ALERT, FILE_SYNCHRONOUS_IO_ALERT },
+        { &mailslot_dev_name, FILE_SYNCHRONOUS_IO_ALERT, FILE_SYNCHRONOUS_IO_ALERT, TRUE },
         { &mountmgr_dev_name, 0, 0 },
         { &mountmgr_dev_name, FILE_SYNCHRONOUS_IO_ALERT, FILE_SYNCHRONOUS_IO_ALERT }
     };
@@ -3878,6 +3853,7 @@ static void test_file_mode(void)
         memset(&mode, 0xcc, sizeof(mode));
         status = pNtQueryInformationFile(file, &io, &mode, sizeof(mode), FileModeInformation);
         ok(status == STATUS_SUCCESS, "[%u] can't get FileModeInformation: %x\n", i, status);
+        todo_wine_if(option_tests[i].todo)
         ok(mode.Mode == option_tests[i].mode, "[%u] Mode = %x, expected %x\n",
            i, mode.Mode, option_tests[i].mode);
 
@@ -4995,71 +4971,6 @@ static void test_file_readonly_access(void)
     DeleteFileW(path);
 }
 
-static void test_mailslot_name(void)
-{
-    char buffer[1024] = {0};
-    const FILE_NAME_INFORMATION *name = (const FILE_NAME_INFORMATION *)buffer;
-    HANDLE server, client, device;
-    IO_STATUS_BLOCK io;
-    NTSTATUS ret;
-
-    server = CreateMailslotA( "\\\\.\\mailslot\\winetest", 100, 1000, NULL );
-    ok(server != INVALID_HANDLE_VALUE, "got error %u\n", GetLastError());
-
-    ret = NtQueryInformationFile( server, &io, buffer, 0, FileNameInformation );
-    ok(ret == STATUS_INFO_LENGTH_MISMATCH, "got %#x\n", ret);
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = NtQueryInformationFile( server, &io, buffer,
-            offsetof(FILE_NAME_INFORMATION, FileName[5]), FileNameInformation );
-    todo_wine ok(ret == STATUS_BUFFER_OVERFLOW, "got %#x\n", ret);
-    if (ret == STATUS_BUFFER_OVERFLOW)
-    {
-        ok(name->FileNameLength == 18, "got length %u\n", name->FileNameLength);
-        ok(!memcmp(name->FileName, L"\\wine", 10), "got %s\n",
-                debugstr_wn(name->FileName, name->FileNameLength / sizeof(WCHAR)));
-    }
-
-    memset(buffer, 0xcc, sizeof(buffer));
-    ret = NtQueryInformationFile( server, &io, buffer, sizeof(buffer), FileNameInformation );
-    todo_wine ok(!ret, "got %#x\n", ret);
-    if (!ret)
-    {
-        ok(name->FileNameLength == 18, "got length %u\n", name->FileNameLength);
-        ok(!memcmp(name->FileName, L"\\winetest", 18), "got %s\n",
-                debugstr_wn(name->FileName, name->FileNameLength / sizeof(WCHAR)));
-    }
-
-    client = CreateFileA( "\\\\.\\mailslot\\winetest", 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
-    ok(client != INVALID_HANDLE_VALUE, "got error %u\n", GetLastError());
-
-    ret = NtQueryInformationFile( client, &io, buffer, 0, FileNameInformation );
-    ok(ret == STATUS_INFO_LENGTH_MISMATCH, "got %#x\n", ret);
-
-    ret = NtQueryInformationFile( client, &io, buffer, sizeof(buffer), FileNameInformation );
-    todo_wine ok(ret == STATUS_INVALID_PARAMETER || !ret /* win8+ */, "got %#x\n", ret);
-    if (!ret)
-    {
-        ok(name->FileNameLength == 18, "got length %u\n", name->FileNameLength);
-        ok(!memcmp(name->FileName, L"\\winetest", 18), "got %s\n",
-                debugstr_wn(name->FileName, name->FileNameLength / sizeof(WCHAR)));
-    }
-
-    CloseHandle( server );
-    CloseHandle( client );
-
-    device = CreateFileA("\\\\.\\mailslot", 0, 0, NULL, OPEN_EXISTING, 0, NULL);
-    ok(device != INVALID_HANDLE_VALUE, "got error %u\n", GetLastError());
-
-    ret = NtQueryInformationFile( device, &io, buffer, 0, FileNameInformation );
-    ok(ret == STATUS_INFO_LENGTH_MISMATCH, "got %#x\n", ret);
-
-    ret = NtQueryInformationFile( device, &io, buffer, sizeof(buffer), FileNameInformation );
-    todo_wine ok(ret == STATUS_INVALID_PARAMETER, "got %#x\n", ret);
-
-    CloseHandle( device );
-}
-
 START_TEST(file)
 {
     HMODULE hkernel32 = GetModuleHandleA("kernel32.dll");
@@ -5130,5 +5041,4 @@ START_TEST(file)
     test_query_attribute_information_file();
     test_ioctl();
     test_flush_buffers_file();
-    test_mailslot_name();
 }
diff --git a/dlls/ntdll/tests/info.c b/dlls/ntdll/tests/info.c
index 057b855914..cf3f7b9f6f 100644
--- a/dlls/ntdll/tests/info.c
+++ b/dlls/ntdll/tests/info.c
@@ -51,12 +51,6 @@ static BOOL is_wow64;
 */
 static DWORD one_before_last_pid = 0;
 
-static inline DWORD_PTR get_affinity_mask(DWORD num_cpus)
-{
-    if (num_cpus >= sizeof(DWORD_PTR) * 8) return ~(DWORD_PTR)0;
-    return ((DWORD_PTR)1 << num_cpus) - 1;
-}
-
 #define NTDLL_GET_PROC(func) do {                     \
     p ## func = (void*)GetProcAddress(hntdll, #func); \
     if(!p ## func) { \
@@ -76,6 +70,12 @@ static BOOL InitFunctionPtrs(void)
     HMODULE hntdll = GetModuleHandleA("ntdll");
     HMODULE hkernel32 = GetModuleHandleA("kernel32");
 
+    if (!hntdll)
+    {
+        win_skip("Not running on NT\n");
+        return FALSE;
+    }
+
     NTDLL_GET_PROC(NtQuerySystemInformation);
     NTDLL_GET_PROC(NtSetSystemInformation);
     NTDLL_GET_PROC(RtlGetNativeSystemInformation);
@@ -122,34 +122,40 @@ static void test_query_basic(void)
     */
 
     /* Use a nonexistent info class */
+    trace("Check nonexistent info class\n");
     status = pNtQuerySystemInformation(-1, NULL, 0, NULL);
     ok( status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED /* vista */,
         "Expected STATUS_INVALID_INFO_CLASS or STATUS_NOT_IMPLEMENTED, got %08x\n", status);
 
     /* Use an existing class but with a zero-length buffer */
+    trace("Check zero-length buffer\n");
     status = pNtQuerySystemInformation(SystemBasicInformation, NULL, 0, NULL);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
 
     /* Use an existing class, correct length but no SystemInformation buffer */
+    trace("Check no SystemInformation buffer\n");
     status = pNtQuerySystemInformation(SystemBasicInformation, NULL, sizeof(sbi), NULL);
     ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_PARAMETER /* vista */,
         "Expected STATUS_ACCESS_VIOLATION or STATUS_INVALID_PARAMETER, got %08x\n", status);
 
     /* Use an existing class, correct length, a pointer to a buffer but no ReturnLength pointer */
+    trace("Check no ReturnLength pointer\n");
     status = pNtQuerySystemInformation(SystemBasicInformation, &sbi, sizeof(sbi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
 
     /* Check a too large buffer size */
+    trace("Check a too large buffer size\n");
     status = pNtQuerySystemInformation(SystemBasicInformation, &sbi, sizeof(sbi) * 2, &ReturnLength);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
 
     /* Finally some correct calls */
+    trace("Check with correct parameters\n");
     status = pNtQuerySystemInformation(SystemBasicInformation, &sbi, sizeof(sbi), &ReturnLength);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok( sizeof(sbi) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
 
     /* Check if we have some return values */
-    if (winetest_debug > 1) trace("Number of Processors : %d\n", sbi.NumberOfProcessors);
+    trace("Number of Processors : %d\n", sbi.NumberOfProcessors);
     ok( sbi.NumberOfProcessors > 0, "Expected more than 0 processors, got %d\n", sbi.NumberOfProcessors);
 
     memset(&sbi2, 0, sizeof(sbi2));
@@ -196,7 +202,7 @@ static void test_query_cpu(void)
     ok( sizeof(sci) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
 
     /* Check if we have some return values */
-    if (winetest_debug > 1) trace("Processor FeatureSet : %08x\n", sci.FeatureSet);
+    trace("Processor FeatureSet : %08x\n", sci.FeatureSet);
     ok( sci.FeatureSet != 0, "Expected some features for this processor, got %08x\n", sci.FeatureSet);
 }
 
@@ -222,7 +228,7 @@ static void test_query_performance(void)
 
     status = pNtQuerySystemInformation(SystemPerformanceInformation, buffer, size + 2, &ReturnLength);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( ReturnLength == size || ReturnLength == size + 2 /* win8+ */,
+    ok( ReturnLength == size || ReturnLength == size + 2,
         "Inconsistent length %d\n", ReturnLength);
 
     /* Not return values yet, as struct members are unknown */
@@ -244,33 +250,67 @@ static void test_query_timeofday(void)
 
     SYSTEM_TIMEOFDAY_INFORMATION_PRIVATE sti;
   
-    status = pNtQuerySystemInformation( SystemTimeOfDayInformation, &sti, 0, &ReturnLength );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( 0 == ReturnLength, "ReturnLength should be 0, it is (%d)\n", ReturnLength);
-
-    sti.uCurrentTimeZoneId = 0xdeadbeef;
-    status = pNtQuerySystemInformation( SystemTimeOfDayInformation, &sti, 24, &ReturnLength );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( 24 == ReturnLength, "ReturnLength should be 24, it is (%d)\n", ReturnLength);
-    ok( 0xdeadbeef == sti.uCurrentTimeZoneId, "This part of the buffer should not have been filled\n");
+    /*  The struct size for NT (32 bytes) and Win2K/XP (48 bytes) differ.
+     *
+     *  Windows 2000 and XP return STATUS_INFO_LENGTH_MISMATCH if the given buffer size is greater
+     *  then 48 and 0 otherwise
+     *  Windows NT returns STATUS_INFO_LENGTH_MISMATCH when the given buffer size is not correct
+     *  and 0 otherwise
+     *
+     *  Windows 2000 and XP copy the given buffer size into the provided buffer, if the return code is STATUS_SUCCESS
+     *  NT only fills the buffer if the return code is STATUS_SUCCESS
+     *
+    */
 
-    sti.uCurrentTimeZoneId = 0xdeadbeef;
-    status = pNtQuerySystemInformation( SystemTimeOfDayInformation, &sti, 32, &ReturnLength );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( 32 == ReturnLength, "ReturnLength should be 32, it is (%d)\n", ReturnLength);
-    ok( 0xdeadbeef != sti.uCurrentTimeZoneId, "Buffer should have been partially filled\n");
+    status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, sizeof(sti), &ReturnLength);
 
-    status = pNtQuerySystemInformation( SystemTimeOfDayInformation, &sti, 49, &ReturnLength );
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
-    ok( ReturnLength == 0 || ReturnLength == sizeof(sti) /* vista */,
-        "ReturnLength should be 0, it is (%d)\n", ReturnLength);
+    if (status == STATUS_INFO_LENGTH_MISMATCH)
+    {
+        trace("Windows version is NT, we have to cater for differences with W2K/WinXP\n");
+ 
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, 0, &ReturnLength);
+        ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
+        ok( 0 == ReturnLength, "ReturnLength should be 0, it is (%d)\n", ReturnLength);
+
+        sti.uCurrentTimeZoneId = 0xdeadbeef;
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, 28, &ReturnLength);
+        ok(status == STATUS_SUCCESS || broken(status == STATUS_INFO_LENGTH_MISMATCH /* NT4 */), "Expected STATUS_SUCCESS, got %08x\n", status);
+        ok( 0xdeadbeef == sti.uCurrentTimeZoneId, "This part of the buffer should not have been filled\n");
+
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, 32, &ReturnLength);
+        ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
+        ok( 32 == ReturnLength, "ReturnLength should be 0, it is (%d)\n", ReturnLength);
+    }
+    else
+    {
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, 0, &ReturnLength);
+        ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
+        ok( 0 == ReturnLength, "ReturnLength should be 0, it is (%d)\n", ReturnLength);
 
-    status = pNtQuerySystemInformation( SystemTimeOfDayInformation, &sti, sizeof(sti), &ReturnLength );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( sizeof(sti) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
+        sti.uCurrentTimeZoneId = 0xdeadbeef;
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, 24, &ReturnLength);
+        ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
+        ok( 24 == ReturnLength, "ReturnLength should be 24, it is (%d)\n", ReturnLength);
+        ok( 0xdeadbeef == sti.uCurrentTimeZoneId, "This part of the buffer should not have been filled\n");
+    
+        sti.uCurrentTimeZoneId = 0xdeadbeef;
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, 32, &ReturnLength);
+        ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
+        ok( 32 == ReturnLength, "ReturnLength should be 32, it is (%d)\n", ReturnLength);
+        ok( 0xdeadbeef != sti.uCurrentTimeZoneId, "Buffer should have been partially filled\n");
+    
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, 49, &ReturnLength);
+        ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
+        ok( ReturnLength == 0 || ReturnLength == sizeof(sti) /* vista */,
+            "ReturnLength should be 0, it is (%d)\n", ReturnLength);
+    
+        status = pNtQuerySystemInformation(SystemTimeOfDayInformation, &sti, sizeof(sti), &ReturnLength);
+        ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
+        ok( sizeof(sti) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
+    }
 
     /* Check if we have some return values */
-    if (winetest_debug > 1) trace("uCurrentTimeZoneId : (%d)\n", sti.uCurrentTimeZoneId);
+    trace("uCurrentTimeZoneId : (%d)\n", sti.uCurrentTimeZoneId);
 }
 
 static void test_query_process(void)
@@ -279,6 +319,7 @@ static void test_query_process(void)
     DWORD last_pid;
     ULONG ReturnLength;
     int i = 0, k = 0;
+    BOOL is_nt = FALSE;
     SYSTEM_BASIC_INFORMATION sbi;
     PROCESS_BASIC_INFORMATION pbi;
     THREAD_BASIC_INFORMATION tbi;
@@ -301,7 +342,7 @@ static void test_query_process(void)
         ULONG HandleCount;
         DWORD dwUnknown3;
         DWORD dwUnknown4;
-        VM_COUNTERS_EX vmCounters;
+        VM_COUNTERS vmCounters;
         IO_COUNTERS ioCounters;
         SYSTEM_THREAD_INFORMATION ti[1];
     } SYSTEM_PROCESS_INFORMATION_PRIVATE;
@@ -313,7 +354,8 @@ static void test_query_process(void)
     ReturnLength = 0;
     status = pNtQuerySystemInformation(SystemProcessInformation, NULL, 0, &ReturnLength);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH got %08x\n", status);
-    ok( ReturnLength > 0, "got 0 length\n");
+    ok( ReturnLength > 0 || broken(ReturnLength == 0) /* NT4, Win2K */,
+        "Expected a ReturnLength to show the needed length\n");
 
     /* W2K3 and later returns the needed length, the rest returns 0, so we have to loop */
     for (;;)
@@ -327,26 +369,59 @@ static void test_query_process(void)
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     spi = spi_buf;
 
+    /* Get the first NextEntryOffset, from this we can deduce the OS version we're running
+     *
+     * W2K/WinXP/W2K3:
+     *   NextEntryOffset for a process is 184 + (no. of threads) * sizeof(SYSTEM_THREAD_INFORMATION)
+     * NT:
+     *   NextEntryOffset for a process is 136 + (no. of threads) * sizeof(SYSTEM_THREAD_INFORMATION)
+     * Wine (with every windows version):
+     *   NextEntryOffset for a process is 0 if just this test is running
+     *   NextEntryOffset for a process is 184 + (no. of threads) * sizeof(SYSTEM_THREAD_INFORMATION) +
+     *                             ProcessName.MaximumLength
+     *     if more wine processes are running
+     *
+     * Note : On windows the first process is in fact the Idle 'process' with a thread for every processor
+    */
+
     pNtQuerySystemInformation(SystemBasicInformation, &sbi, sizeof(sbi), &ReturnLength);
 
+    is_nt = ( spi->NextEntryOffset - (sbi.NumberOfProcessors * sizeof(SYSTEM_THREAD_INFORMATION)) == 136);
+
+    if (is_nt) win_skip("Windows version is NT, we will skip thread tests\n");
+
+    /* Check if we have some return values
+     * 
+     * On windows there will be several processes running (Including the always present Idle and System)
+     * On wine we only have one (if this test is the only wine process running)
+    */
+    
+    /* Loop through the processes */
+
     for (;;)
     {
-        DWORD_PTR tid;
-        DWORD j;
-
         i++;
 
         last_pid = (DWORD_PTR)spi->UniqueProcessId;
-        ok(!(last_pid & 3), "Unexpected PID low bits: %p\n", spi->UniqueProcessId);
-        for (j = 0; j < spi->dwThreadCount; j++)
+
+        /* Loop through the threads, skip NT4 for now */
+        
+        if (!is_nt)
         {
-            k++;
-            ok ( spi->ti[j].ClientId.UniqueProcess == spi->UniqueProcessId,
-                 "The owning pid of the thread (%p) doesn't equal the pid (%p) of the process\n",
-                 spi->ti[j].ClientId.UniqueProcess, spi->UniqueProcessId);
+            DWORD_PTR tid;
+            DWORD j;
+
+            ok(!(last_pid & 3), "Unexpected PID low bits: %p\n", spi->UniqueProcessId);
+            for ( j = 0; j < spi->dwThreadCount; j++) 
+            {
+                k++;
+                ok ( spi->ti[j].ClientId.UniqueProcess == spi->UniqueProcessId,
+                     "The owning pid of the thread (%p) doesn't equal the pid (%p) of the process\n",
+                     spi->ti[j].ClientId.UniqueProcess, spi->UniqueProcessId);
 
-            tid = (DWORD_PTR)spi->ti[j].ClientId.UniqueThread;
-            ok(!(tid & 3), "Unexpected TID low bits: %p\n", spi->ti[j].ClientId.UniqueThread);
+                tid = (DWORD_PTR)spi->ti[j].ClientId.UniqueThread;
+                ok(!(tid & 3), "Unexpected TID low bits: %p\n", spi->ti[j].ClientId.UniqueThread);
+            }
         }
 
         if (!spi->NextEntryOffset) break;
@@ -355,12 +430,19 @@ static void test_query_process(void)
 
         spi = (SYSTEM_PROCESS_INFORMATION_PRIVATE*)((char*)spi + spi->NextEntryOffset);
     }
-    if (winetest_debug > 1) trace("%u processes, %u threads\n", i, k);
+    trace("Total number of running processes : %d\n", i);
+    if (!is_nt) trace("Total number of running threads   : %d\n", k);
 
     if (one_before_last_pid == 0) one_before_last_pid = last_pid;
 
     HeapFree( GetProcessHeap(), 0, spi_buf);
 
+    if (is_nt)
+    {
+        win_skip("skipping ptids low bits tests\n");
+        return;
+    }
+
     for (i = 1; i < 4; ++i)
     {
         InitializeObjectAttributes( &attr, NULL, 0, NULL, NULL );
@@ -553,6 +635,10 @@ static void test_query_handle(void)
                 ((HANDLE)(ULONG_PTR)shi->Handle[i].HandleValue == EventHandle);
     ok( found, "Expected to find event handle %p (pid %x) in handle list\n", EventHandle, GetCurrentProcessId() );
 
+    if (!found)
+        for (i = 0; i < shi->Count; i++)
+            trace( "%d: handle %x pid %x\n", i, shi->Handle[i].HandleValue, shi->Handle[i].OwnerPid );
+
     CloseHandle(EventHandle);
 
     ReturnLength = 0xdeadbeef;
@@ -736,11 +822,16 @@ static void test_query_logicalproc(void)
     GetSystemInfo(&si);
 
     status = pNtQuerySystemInformation(SystemLogicalProcessorInformation, NULL, 0, &len);
-    if (status == STATUS_INVALID_INFO_CLASS) /* wow64 win8+ */
+    if(status == STATUS_INVALID_INFO_CLASS)
     {
         win_skip("SystemLogicalProcessorInformation is not supported\n");
         return;
     }
+    if(status == STATUS_NOT_IMPLEMENTED)
+    {
+        todo_wine ok(0, "SystemLogicalProcessorInformation is not implemented\n");
+        return;
+    }
     ok(status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
     ok(len%sizeof(*slpi) == 0, "Incorrect length %d\n", len);
 
@@ -773,7 +864,6 @@ static void test_query_logicalprocex(void)
     SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *infoex, *infoex_public, *infoex_core, *infoex_numa,
                                             *infoex_cache, *infoex_package, *infoex_group, *ex;
     DWORD relationship, len, len_public, len_core, len_numa, len_cache, len_package, len_group, len_union;
-    unsigned int i, j;
     NTSTATUS status;
     BOOL ret;
 
@@ -821,156 +911,180 @@ static void test_query_logicalprocex(void)
     ok(!ret && GetLastError() == ERROR_INSUFFICIENT_BUFFER, "got %d, error %d\n", ret, GetLastError());
     ok(len == len_public, "got %u, expected %u\n", len_public, len);
 
-    infoex = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len);
-    infoex_public = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_public);
-    infoex_core = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_core);
-    infoex_numa = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_numa);
-    infoex_cache = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_cache);
-    infoex_package = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_package);
-    infoex_group = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_group);
+    if (len && len == len_public) {
+        int j, i;
 
-    relationship = RelationAll;
-    status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex, len, &len);
-    ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
+        infoex = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len);
+        infoex_public = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_public);
+        infoex_core = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_core);
+        infoex_numa = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_numa);
+        infoex_cache = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_cache);
+        infoex_package = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_package);
+        infoex_group = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len_group);
 
-    ret = pGetLogicalProcessorInformationEx(RelationAll, infoex_public, &len_public);
-    ok(ret, "got %d, error %d\n", ret, GetLastError());
-    ok(!memcmp(infoex, infoex_public, len), "returned info data mismatch\n");
+        relationship = RelationAll;
+        status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex, len, &len);
+        ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
 
-    /* Test for RelationAll. */
-    for (i = 0; status == STATUS_SUCCESS && i < len; )
-    {
-        ex = (void *)(((char *)infoex) + i);
-        ok(ex->Size, "%u: got size 0\n", i);
+        ret = pGetLogicalProcessorInformationEx(RelationAll, infoex_public, &len_public);
+        ok(ret, "got %d, error %d\n", ret, GetLastError());
+        ok(!memcmp(infoex, infoex_public, len), "returned info data mismatch\n");
 
-        if (winetest_debug <= 1)
-        {
-            i += ex->Size;
-            continue;
-        }
+        /* Test for RelationAll. */
+        for(i = 0; status == STATUS_SUCCESS && i < len; ){
+            ex = (void*)(((char *)infoex) + i);
 
-        trace("infoex[%u].Size: %u\n", i, ex->Size);
-        switch (ex->Relationship)
-        {
-        case RelationProcessorCore:
-        case RelationProcessorPackage:
-            trace("infoex[%u].Relationship: 0x%x (%s)\n", i, ex->Relationship, ex->Relationship == RelationProcessorCore ? "Core" : "Package");
-            trace("infoex[%u].Processor.Flags: 0x%x\n", i, ex->Processor.Flags);
-            trace("infoex[%u].Processor.EfficiencyClass: 0x%x\n", i, ex->Processor.EfficiencyClass);
-            trace("infoex[%u].Processor.GroupCount: 0x%x\n", i, ex->Processor.GroupCount);
-            for (j = 0; j < ex->Processor.GroupCount; ++j)
+            if (!ex->Size)
             {
-                trace("infoex[%u].Processor.GroupMask[%u].Mask: 0x%lx\n", i, j, ex->Processor.GroupMask[j].Mask);
-                trace("infoex[%u].Processor.GroupMask[%u].Group: 0x%x\n", i, j, ex->Processor.GroupMask[j].Group);
+                ok(0, "got infoex[%u].Size=0\n", i);
+                break;
             }
-            break;
-        case RelationNumaNode:
-            trace("infoex[%u].Relationship: 0x%x (NumaNode)\n", i, ex->Relationship);
-            trace("infoex[%u].NumaNode.NodeNumber: 0x%x\n", i, ex->NumaNode.NodeNumber);
-            trace("infoex[%u].NumaNode.GroupMask.Mask: 0x%lx\n", i, ex->NumaNode.GroupMask.Mask);
-            trace("infoex[%u].NumaNode.GroupMask.Group: 0x%x\n", i, ex->NumaNode.GroupMask.Group);
-            break;
-        case RelationCache:
-            trace("infoex[%u].Relationship: 0x%x (Cache)\n", i, ex->Relationship);
-            trace("infoex[%u].Cache.Level: 0x%x\n", i, ex->Cache.Level);
-            trace("infoex[%u].Cache.Associativity: 0x%x\n", i, ex->Cache.Associativity);
-            trace("infoex[%u].Cache.LineSize: 0x%x\n", i, ex->Cache.LineSize);
-            trace("infoex[%u].Cache.CacheSize: 0x%x\n", i, ex->Cache.CacheSize);
-            trace("infoex[%u].Cache.Type: 0x%x\n", i, ex->Cache.Type);
-            trace("infoex[%u].Cache.GroupMask.Mask: 0x%lx\n", i, ex->Cache.GroupMask.Mask);
-            trace("infoex[%u].Cache.GroupMask.Group: 0x%x\n", i, ex->Cache.GroupMask.Group);
-            break;
-        case RelationGroup:
-            trace("infoex[%u].Relationship: 0x%x (Group)\n", i, ex->Relationship);
-            trace("infoex[%u].Group.MaximumGroupCount: 0x%x\n", i, ex->Group.MaximumGroupCount);
-            trace("infoex[%u].Group.ActiveGroupCount: 0x%x\n", i, ex->Group.ActiveGroupCount);
-            for (j = 0; j < ex->Group.ActiveGroupCount; ++j)
-            {
-                trace("infoex[%u].Group.GroupInfo[%u].MaximumProcessorCount: 0x%x\n", i, j, ex->Group.GroupInfo[j].MaximumProcessorCount);
-                trace("infoex[%u].Group.GroupInfo[%u].ActiveProcessorCount: 0x%x\n", i, j, ex->Group.GroupInfo[j].ActiveProcessorCount);
-                trace("infoex[%u].Group.GroupInfo[%u].ActiveProcessorMask: 0x%lx\n", i, j, ex->Group.GroupInfo[j].ActiveProcessorMask);
+
+            trace("infoex[%u].Size: %u\n", i, ex->Size);
+            switch(ex->Relationship){
+            case RelationProcessorCore:
+            case RelationProcessorPackage:
+                trace("infoex[%u].Relationship: 0x%x (%s)\n", i, ex->Relationship, ex->Relationship == RelationProcessorCore ? "Core" : "Package");
+                trace("infoex[%u].Processor.Flags: 0x%x\n", i, ex->Processor.Flags);
+                trace("infoex[%u].Processor.EfficiencyClass: 0x%x\n", i, ex->Processor.EfficiencyClass);
+                trace("infoex[%u].Processor.GroupCount: 0x%x\n", i, ex->Processor.GroupCount);
+                for(j = 0; j < ex->Processor.GroupCount; ++j){
+                    trace("infoex[%u].Processor.GroupMask[%u].Mask: 0x%lx\n", i, j, ex->Processor.GroupMask[j].Mask);
+                    trace("infoex[%u].Processor.GroupMask[%u].Group: 0x%x\n", i, j, ex->Processor.GroupMask[j].Group);
+                }
+                break;
+            case RelationNumaNode:
+                trace("infoex[%u].Relationship: 0x%x (NumaNode)\n", i, ex->Relationship);
+                trace("infoex[%u].NumaNode.NodeNumber: 0x%x\n", i, ex->NumaNode.NodeNumber);
+                trace("infoex[%u].NumaNode.GroupMask.Mask: 0x%lx\n", i, ex->NumaNode.GroupMask.Mask);
+                trace("infoex[%u].NumaNode.GroupMask.Group: 0x%x\n", i, ex->NumaNode.GroupMask.Group);
+                break;
+            case RelationCache:
+                trace("infoex[%u].Relationship: 0x%x (Cache)\n", i, ex->Relationship);
+                trace("infoex[%u].Cache.Level: 0x%x\n", i, ex->Cache.Level);
+                trace("infoex[%u].Cache.Associativity: 0x%x\n", i, ex->Cache.Associativity);
+                trace("infoex[%u].Cache.LineSize: 0x%x\n", i, ex->Cache.LineSize);
+                trace("infoex[%u].Cache.CacheSize: 0x%x\n", i, ex->Cache.CacheSize);
+                trace("infoex[%u].Cache.Type: 0x%x\n", i, ex->Cache.Type);
+                trace("infoex[%u].Cache.GroupMask.Mask: 0x%lx\n", i, ex->Cache.GroupMask.Mask);
+                trace("infoex[%u].Cache.GroupMask.Group: 0x%x\n", i, ex->Cache.GroupMask.Group);
+                break;
+            case RelationGroup:
+                trace("infoex[%u].Relationship: 0x%x (Group)\n", i, ex->Relationship);
+                trace("infoex[%u].Group.MaximumGroupCount: 0x%x\n", i, ex->Group.MaximumGroupCount);
+                trace("infoex[%u].Group.ActiveGroupCount: 0x%x\n", i, ex->Group.ActiveGroupCount);
+                for(j = 0; j < ex->Group.ActiveGroupCount; ++j){
+                    trace("infoex[%u].Group.GroupInfo[%u].MaximumProcessorCount: 0x%x\n", i, j, ex->Group.GroupInfo[j].MaximumProcessorCount);
+                    trace("infoex[%u].Group.GroupInfo[%u].ActiveProcessorCount: 0x%x\n", i, j, ex->Group.GroupInfo[j].ActiveProcessorCount);
+                    trace("infoex[%u].Group.GroupInfo[%u].ActiveProcessorMask: 0x%lx\n", i, j, ex->Group.GroupInfo[j].ActiveProcessorMask);
+                }
+                break;
+            default:
+                ok(0, "Got invalid relationship value: 0x%x\n", ex->Relationship);
+                break;
             }
-            break;
-        default:
-            ok(0, "Got invalid relationship value: 0x%x\n", ex->Relationship);
-            break;
+
+            i += ex->Size;
         }
 
-        i += ex->Size;
-    }
+        /* Test Relationship filtering. */
 
-    /* Test Relationship filtering. */
+        relationship = RelationProcessorCore;
+        status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_core, len_core, &len_core);
+        ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
 
-    relationship = RelationProcessorCore;
-    status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_core, len_core, &len_core);
-    ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
-
-    for (i = 0; status == STATUS_SUCCESS && i < len_core;)
-    {
-        ex = (void *)(((char*)infoex_core) + i);
-        ok(ex->Size, "%u: got size 0\n", i);
-        ok(ex->Relationship == RelationProcessorCore, "%u: got relationship %#x\n", i, ex->Relationship);
-        i += ex->Size;
-    }
+        for(i = 0; status == STATUS_SUCCESS && i < len_core;) {
+            ex = (void*)(((char*)infoex_core) + i);
+            if (ex->Size == 0) {
+                ok(0, "Got infoex_core[%u].Size=0\n", i);
+                break;
+            }
+            if (ex->Relationship != RelationProcessorCore) {
+                ok(0, "Expected 0x%x, got 0x%x\n", RelationProcessorCore, ex->Relationship);
+                break;
+            }
+            i += ex->Size;
+        }
 
-    relationship = RelationNumaNode;
-    status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_numa, len_numa, &len_numa);
-    ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
+        relationship = RelationNumaNode;
+        status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_numa, len_numa, &len_numa);
+        ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
 
-    for (i = 0; status == STATUS_SUCCESS && i < len_numa;)
-    {
-        ex = (void *)(((char*)infoex_numa) + i);
-        ok(ex->Size, "%u: got size 0\n", i);
-        ok(ex->Relationship == RelationNumaNode, "%u: got relationship %#x\n", i, ex->Relationship);
-        i += ex->Size;
-    }
+        for(i = 0; status == STATUS_SUCCESS && i < len_numa;) {
+            ex = (void*)(((char*)infoex_numa) + i);
+            if (ex->Size == 0) {
+                ok(0, "Got infoex_numa[%u].Size=0\n", i);
+                break;
+            }
+            if (ex->Relationship != RelationNumaNode) {
+                ok(0, "Expected 0x%x, got 0x%x\n", RelationNumaNode, ex->Relationship);
+                break;
+            }
+            i += ex->Size;
+        }
 
-    relationship = RelationCache;
-    status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_cache, len_cache, &len_cache);
-    ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
+        relationship = RelationCache;
+        status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_cache, len_cache, &len_cache);
+        ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
 
-    for (i = 0; status == STATUS_SUCCESS && i < len_cache;)
-    {
-        ex = (void *)(((char*)infoex_cache) + i);
-        ok(ex->Size, "%u: got size 0\n", i);
-        ok(ex->Relationship == RelationCache, "%u: got relationship %#x\n", i, ex->Relationship);
-        i += ex->Size;
-    }
+        for(i = 0; status == STATUS_SUCCESS && i < len_cache;) {
+            ex = (void*)(((char*)infoex_cache) + i);
+            if (ex->Size == 0) {
+                ok(0, "Got infoex_cache[%u].Size=0\n", i);
+                break;
+            }
+            if (ex->Relationship != RelationCache) {
+                ok(0, "Expected 0x%x, got 0x%x\n", RelationCache, ex->Relationship);
+                break;
+            }
+            i += ex->Size;
+        }
 
-    relationship = RelationProcessorPackage;
-    status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_package, len_package, &len_package);
-    ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
+        relationship = RelationProcessorPackage;
+        status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_package, len_package, &len_package);
+        ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
 
-    for (i = 0; status == STATUS_SUCCESS && i < len_package;)
-    {
-        ex = (void *)(((char*)infoex_package) + i);
-        ok(ex->Size, "%u: got size 0\n", i);
-        ok(ex->Relationship == RelationProcessorPackage, "%u: got relationship %#x\n", i, ex->Relationship);
-        i += ex->Size;
-    }
+        for(i = 0; status == STATUS_SUCCESS && i < len_package;) {
+            ex = (void*)(((char*)infoex_package) + i);
+            if (ex->Size == 0) {
+                ok(0, "Got infoex_package[%u].Size=0\n", i);
+                break;
+            }
+            if (ex->Relationship != RelationProcessorPackage) {
+                ok(0, "Expected 0x%x, got 0x%x\n", RelationProcessorPackage, ex->Relationship);
+                break;
+            }
+            i += ex->Size;
+        }
 
-    relationship = RelationGroup;
-    status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_group, len_group, &len_group);
-    ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
+        relationship = RelationGroup;
+        status = pNtQuerySystemInformationEx(SystemLogicalProcessorInformationEx, &relationship, sizeof(relationship), infoex_group, len_group, &len_group);
+        ok(status == STATUS_SUCCESS, "got 0x%08x\n", status);
 
-    for (i = 0; status == STATUS_SUCCESS && i < len_group;)
-    {
-        ex = (void *)(((char *)infoex_group) + i);
-        ok(ex->Size, "%u: got size 0\n", i);
-        ok(ex->Relationship == RelationGroup, "%u: got relationship %#x\n", i, ex->Relationship);
-        i += ex->Size;
-    }
+        for(i = 0; status == STATUS_SUCCESS && i < len_group;) {
+            ex = (void*)(((char *)infoex_group) + i);
+            if (ex->Size == 0) {
+                ok(0, "Got infoex_group[%u].Size=0\n", i);
+                break;
+            }
+            if (ex->Relationship != RelationGroup) {
+                ok(0, "Expected 0x%x, got 0x%x\n", RelationGroup, ex->Relationship);
+                break;
+            }
+            i += ex->Size;
+        }
 
-    len_union = len_core + len_numa + len_cache + len_package + len_group;
-    ok(len == len_union, "Expected 0x%x, got 0x%0x\n", len, len_union);
+        len_union = len_core + len_numa + len_cache + len_package + len_group;
+        ok(len == len_union, "Expected 0x%x, got 0x%0x\n", len, len_union);
 
-    HeapFree(GetProcessHeap(), 0, infoex);
-    HeapFree(GetProcessHeap(), 0, infoex_public);
-    HeapFree(GetProcessHeap(), 0, infoex_core);
-    HeapFree(GetProcessHeap(), 0, infoex_numa);
-    HeapFree(GetProcessHeap(), 0, infoex_cache);
-    HeapFree(GetProcessHeap(), 0, infoex_package);
-    HeapFree(GetProcessHeap(), 0, infoex_group);
+        HeapFree(GetProcessHeap(), 0, infoex);
+        HeapFree(GetProcessHeap(), 0, infoex_public);
+        HeapFree(GetProcessHeap(), 0, infoex_core);
+        HeapFree(GetProcessHeap(), 0, infoex_numa);
+        HeapFree(GetProcessHeap(), 0, infoex_cache);
+        HeapFree(GetProcessHeap(), 0, infoex_package);
+        HeapFree(GetProcessHeap(), 0, infoex_group);
+    }
 }
 
 static void test_query_firmware(void)
@@ -1038,21 +1152,18 @@ static void test_query_battery(void)
     }
     ok(status == STATUS_SUCCESS, "expected success\n");
 
-    if (winetest_debug > 1)
-    {
-        trace("Battery state:\n");
-        trace("AcOnLine          : %u\n", bs.AcOnLine);
-        trace("BatteryPresent    : %u\n", bs.BatteryPresent);
-        trace("Charging          : %u\n", bs.Charging);
-        trace("Discharging       : %u\n", bs.Discharging);
-        trace("Tag               : %u\n", bs.Tag);
-        trace("MaxCapacity       : %u\n", bs.MaxCapacity);
-        trace("RemainingCapacity : %u\n", bs.RemainingCapacity);
-        trace("Rate              : %d\n", (LONG)bs.Rate);
-        trace("EstimatedTime     : %u\n", bs.EstimatedTime);
-        trace("DefaultAlert1     : %u\n", bs.DefaultAlert1);
-        trace("DefaultAlert2     : %u\n", bs.DefaultAlert2);
-    }
+    trace("Battery state:\n");
+    trace("AcOnLine          : %u\n", bs.AcOnLine);
+    trace("BatteryPresent    : %u\n", bs.BatteryPresent);
+    trace("Charging          : %u\n", bs.Charging);
+    trace("Discharging       : %u\n", bs.Discharging);
+    trace("Tag               : %u\n", bs.Tag);
+    trace("MaxCapacity       : %u\n", bs.MaxCapacity);
+    trace("RemainingCapacity : %u\n", bs.RemainingCapacity);
+    trace("Rate              : %d\n", (LONG)bs.Rate);
+    trace("EstimatedTime     : %u\n", bs.EstimatedTime);
+    trace("DefaultAlert1     : %u\n", bs.DefaultAlert1);
+    trace("DefaultAlert2     : %u\n", bs.DefaultAlert2);
 
     ok(bs.MaxCapacity >= bs.RemainingCapacity,
        "expected MaxCapacity %u to be greater than or equal to RemainingCapacity %u\n",
@@ -1180,6 +1291,7 @@ static void test_query_process_wow64(void)
     pbi[0] = pbi[1] = dummy;
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information, pbi, sizeof(ULONG_PTR), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
+    trace( "Platform is_wow64 %d, ProcessInformation of ProcessWow64Information %lx\n", is_wow64, pbi[0]);
     ok( is_wow64 == (pbi[0] != 0), "is_wow64 %x, pbi[0] %lx\n", is_wow64, pbi[0]);
     ok( pbi[0] != dummy, "pbi[0] %lx\n", pbi[0]);
     ok( pbi[1] == dummy, "pbi[1] changed to %lx\n", pbi[1]);
@@ -1238,39 +1350,56 @@ static void test_query_process_basic(void)
      * every information class
     */
 
+    /* Use a nonexistent info class */
+    trace("Check nonexistent info class\n");
     status = pNtQueryInformationProcess(NULL, -1, NULL, 0, NULL);
     ok( status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED /* vista */,
         "Expected STATUS_INVALID_INFO_CLASS or STATUS_NOT_IMPLEMENTED, got %08x\n", status);
 
+    /* Do not give a handle and buffer */
+    trace("Check NULL handle and buffer and zero-length buffersize\n");
     status = pNtQueryInformationProcess(NULL, ProcessBasicInformation, NULL, 0, NULL);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
 
+    /* Use a correct info class and buffer size, but still no handle and buffer */
+    trace("Check NULL handle and buffer\n");
     status = pNtQueryInformationProcess(NULL, ProcessBasicInformation, NULL, sizeof(pbi), NULL);
     ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_HANDLE,
         "Expected STATUS_ACCESS_VIOLATION or STATUS_INVALID_HANDLE(W2K3), got %08x\n", status);
 
+    /* Use a correct info class and buffer size, but still no handle */
+    trace("Check NULL handle\n");
     status = pNtQueryInformationProcess(NULL, ProcessBasicInformation, &pbi, sizeof(pbi), NULL);
     ok( status == STATUS_INVALID_HANDLE, "Expected STATUS_INVALID_HANDLE, got %08x\n", status);
 
+    /* Use a greater buffer size */
+    trace("Check NULL handle and too large buffersize\n");
     status = pNtQueryInformationProcess(NULL, ProcessBasicInformation, &pbi, sizeof(pbi) * 2, NULL);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
 
+    /* Use no ReturnLength */
+    trace("Check NULL ReturnLength\n");
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &pbi, sizeof(pbi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
 
+    /* Finally some correct calls */
+    trace("Check with correct parameters\n");
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &pbi, sizeof(pbi), &ReturnLength);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok( sizeof(pbi) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
 
+    /* Everything is correct except a too large buffersize */
+    trace("Too large buffersize\n");
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &pbi, sizeof(pbi) * 2, &ReturnLength);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
     ok( sizeof(pbi) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
-
-    if (winetest_debug > 1) trace("ProcessID : %lx\n", pbi.UniqueProcessId);
+                                                                                                                                               
+    /* Check if we have some return values */
+    trace("ProcessID : %lx\n", pbi.UniqueProcessId);
     ok( pbi.UniqueProcessId > 0, "Expected a ProcessID > 0, got 0\n");
 }
 
-static void dump_vm_counters(const char *header, const VM_COUNTERS_EX *pvi)
+static void dump_vm_counters(const char *header, const VM_COUNTERS *pvi)
 {
     trace("%s:\n", header);
     trace("PeakVirtualSize           : %lu\n", pvi->PeakVirtualSize);
@@ -1290,7 +1419,8 @@ static void test_query_process_vm(void)
 {
     NTSTATUS status;
     ULONG ReturnLength;
-    VM_COUNTERS_EX pvi;
+    VM_COUNTERS pvi;
+    ULONG old_size = FIELD_OFFSET(VM_COUNTERS,PrivatePageCount);
     HANDLE process;
     SIZE_T prev_size;
     const SIZE_T alloc_size = 16 * 1024 * 1024;
@@ -1300,23 +1430,27 @@ static void test_query_process_vm(void)
     ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_HANDLE,
         "Expected STATUS_ACCESS_VIOLATION or STATUS_INVALID_HANDLE(W2K3), got %08x\n", status);
 
-    status = pNtQueryInformationProcess(NULL, ProcessVmCounters, &pvi, sizeof(VM_COUNTERS), NULL);
+    status = pNtQueryInformationProcess(NULL, ProcessVmCounters, &pvi, old_size, NULL);
     ok( status == STATUS_INVALID_HANDLE, "Expected STATUS_INVALID_HANDLE, got %08x\n", status);
 
+    /* Windows XP and W2K3 will report success for a size of 44 AND 48 !
+       Windows W2K will only report success for 44.
+       For now we only care for 44, which is FIELD_OFFSET(VM_COUNTERS,PrivatePageCount))
+    */
+
     status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessVmCounters, &pvi, 24, &ReturnLength);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
 
-    status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessVmCounters, &pvi, sizeof(VM_COUNTERS), &ReturnLength);
+    status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessVmCounters, &pvi, old_size, &ReturnLength);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( ReturnLength == sizeof(VM_COUNTERS), "Inconsistent length %d\n", ReturnLength);
+    ok( old_size == ReturnLength, "Inconsistent length %d\n", ReturnLength);
 
     status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessVmCounters, &pvi, 46, &ReturnLength);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
-    todo_wine ok( ReturnLength == sizeof(VM_COUNTERS), "wrong size %d\n", ReturnLength);
+    ok( ReturnLength == old_size || ReturnLength == sizeof(pvi), "Inconsistent length %d\n", ReturnLength);
 
     /* Check if we have some return values */
-    if (winetest_debug > 1)
-        dump_vm_counters("VM counters for GetCurrentProcess", &pvi);
+    dump_vm_counters("VM counters for GetCurrentProcess", &pvi);
     ok( pvi.WorkingSetSize > 0, "Expected a WorkingSetSize > 0\n");
     ok( pvi.PagefileUsage > 0, "Expected a PagefileUsage > 0\n");
 
@@ -1334,11 +1468,9 @@ static void test_query_process_vm(void)
     process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
     status = pNtQueryInformationProcess(process, ProcessVmCounters, &pvi, sizeof(pvi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( pvi.PrivateUsage == pvi.PagefileUsage, "wrong value %lu/%lu\n", pvi.PrivateUsage, pvi.PagefileUsage );
 
     /* Check if we have some return values */
-    if (winetest_debug > 1)
-        dump_vm_counters("VM counters for GetCurrentProcessId", &pvi);
+    dump_vm_counters("VM counters for GetCurrentProcessId", &pvi);
     ok( pvi.WorkingSetSize > 0, "Expected a WorkingSetSize > 0\n");
     ok( pvi.PagefileUsage > 0, "Expected a PagefileUsage > 0\n");
 
@@ -1347,7 +1479,6 @@ static void test_query_process_vm(void)
     /* Check if we have real counters */
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessVmCounters, &pvi, sizeof(pvi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( pvi.PrivateUsage == pvi.PagefileUsage, "wrong value %lu/%lu\n", pvi.PrivateUsage, pvi.PagefileUsage );
     prev_size = pvi.VirtualSize;
     if (winetest_debug > 1)
         dump_vm_counters("VM counters before VirtualAlloc", &pvi);
@@ -1355,7 +1486,6 @@ static void test_query_process_vm(void)
     ok( ptr != NULL, "VirtualAlloc failed, err %u\n", GetLastError());
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessVmCounters, &pvi, sizeof(pvi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( pvi.PrivateUsage == pvi.PagefileUsage, "wrong value %lu/%lu\n", pvi.PrivateUsage, pvi.PagefileUsage );
     if (winetest_debug > 1)
         dump_vm_counters("VM counters after VirtualAlloc", &pvi);
     todo_wine ok( pvi.VirtualSize >= prev_size + alloc_size,
@@ -1364,7 +1494,6 @@ static void test_query_process_vm(void)
 
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessVmCounters, &pvi, sizeof(pvi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( pvi.PrivateUsage == pvi.PagefileUsage, "wrong value %lu/%lu\n", pvi.PrivateUsage, pvi.PagefileUsage );
     prev_size = pvi.VirtualSize;
     if (winetest_debug > 1)
         dump_vm_counters("VM counters before VirtualAlloc", &pvi);
@@ -1372,7 +1501,6 @@ static void test_query_process_vm(void)
     ok( ptr != NULL, "VirtualAlloc failed, err %u\n", GetLastError());
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessVmCounters, &pvi, sizeof(pvi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( pvi.PrivateUsage == pvi.PagefileUsage, "wrong value %lu/%lu\n", pvi.PrivateUsage, pvi.PagefileUsage );
     if (winetest_debug > 1)
         dump_vm_counters("VM counters after VirtualAlloc(MEM_RESERVE)", &pvi);
     todo_wine ok( pvi.VirtualSize >= prev_size + alloc_size,
@@ -1383,7 +1511,6 @@ static void test_query_process_vm(void)
     ok( ptr != NULL, "VirtualAlloc failed, err %u\n", GetLastError());
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessVmCounters, &pvi, sizeof(pvi), NULL);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( pvi.PrivateUsage == pvi.PagefileUsage, "wrong value %lu/%lu\n", pvi.PrivateUsage, pvi.PagefileUsage );
     if (winetest_debug > 1)
         dump_vm_counters("VM counters after VirtualAlloc(MEM_COMMIT)", &pvi);
     ok( pvi.VirtualSize == prev_size,
@@ -1397,6 +1524,14 @@ static void test_query_process_io(void)
     ULONG ReturnLength;
     IO_COUNTERS pii;
 
+    /* NT4 doesn't support this information class, so check for it */
+    status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessIoCounters, &pii, sizeof(pii), &ReturnLength);
+    if (status == STATUS_NOT_SUPPORTED)
+    {
+        win_skip("ProcessIoCounters information class is not supported\n");
+        return;
+    }
+ 
     status = pNtQueryInformationProcess(NULL, ProcessIoCounters, NULL, sizeof(pii), NULL);
     ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_HANDLE,
         "Expected STATUS_ACCESS_VIOLATION or STATUS_INVALID_HANDLE(W2K3), got %08x\n", status);
@@ -1416,7 +1551,7 @@ static void test_query_process_io(void)
     ok( sizeof(pii) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
 
     /* Check if we have some return values */
-    if (winetest_debug > 1) trace("OtherOperationCount : 0x%s\n", wine_dbgstr_longlong(pii.OtherOperationCount));
+    trace("OtherOperationCount : 0x%s\n", wine_dbgstr_longlong(pii.OtherOperationCount));
     todo_wine
     {
         ok( pii.OtherOperationCount > 0, "Expected an OtherOperationCount > 0\n");
@@ -1444,8 +1579,9 @@ static void test_query_process_times(void)
     process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, one_before_last_pid);
     if (!process)
     {
-        if (winetest_debug > 1) trace("Could not open process with ID : %d, error : %u. Going to use current one.\n", one_before_last_pid, GetLastError());
+        trace("Could not open process with ID : %d, error : %u. Going to use current one.\n", one_before_last_pid, GetLastError());
         process = GetCurrentProcess();
+        trace("ProcessTimes for current process\n");
     }
     else
         trace("ProcessTimes for process with ID : %d\n", one_before_last_pid);
@@ -1457,19 +1593,19 @@ static void test_query_process_times(void)
 
     FileTimeToSystemTime((const FILETIME *)&spti.CreateTime, &UTC);
     SystemTimeToTzSpecificLocalTime(NULL, &UTC, &Local);
-    if (winetest_debug > 1) trace("CreateTime : %02d/%02d/%04d %02d:%02d:%02d\n", Local.wMonth, Local.wDay, Local.wYear,
+    trace("CreateTime : %02d/%02d/%04d %02d:%02d:%02d\n", Local.wMonth, Local.wDay, Local.wYear,
            Local.wHour, Local.wMinute, Local.wSecond);
 
     FileTimeToSystemTime((const FILETIME *)&spti.ExitTime, &UTC);
     SystemTimeToTzSpecificLocalTime(NULL, &UTC, &Local);
-    if (winetest_debug > 1) trace("ExitTime   : %02d/%02d/%04d %02d:%02d:%02d\n", Local.wMonth, Local.wDay, Local.wYear,
+    trace("ExitTime   : %02d/%02d/%04d %02d:%02d:%02d\n", Local.wMonth, Local.wDay, Local.wYear,
            Local.wHour, Local.wMinute, Local.wSecond);
 
     FileTimeToSystemTime((const FILETIME *)&spti.KernelTime, &Local);
-    if (winetest_debug > 1) trace("KernelTime : %02d:%02d:%02d.%03d\n", Local.wHour, Local.wMinute, Local.wSecond, Local.wMilliseconds);
+    trace("KernelTime : %02d:%02d:%02d.%03d\n", Local.wHour, Local.wMinute, Local.wSecond, Local.wMilliseconds);
 
     FileTimeToSystemTime((const FILETIME *)&spti.UserTime, &Local);
-    if (winetest_debug > 1) trace("UserTime   : %02d:%02d:%02d.%03d\n", Local.wHour, Local.wMinute, Local.wSecond, Local.wMilliseconds);
+    trace("UserTime   : %02d:%02d:%02d.%03d\n", Local.wHour, Local.wMinute, Local.wSecond, Local.wMilliseconds);
 
     status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessTimes, &spti, sizeof(spti) * 2, &ReturnLength);
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
@@ -1501,7 +1637,8 @@ static void test_query_process_debug_port(int argc, char **argv)
 
     status = pNtQueryInformationProcess(NULL, ProcessDebugPort,
             NULL, sizeof(debug_port), NULL);
-    ok(status == STATUS_INVALID_HANDLE || status == STATUS_ACCESS_VIOLATION /* XP */, "got %#x\n", status);
+    ok(status == STATUS_INVALID_HANDLE || status == STATUS_ACCESS_VIOLATION,
+            "Expected STATUS_INVALID_HANDLE, got %#x.\n", status);
 
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort,
             NULL, sizeof(debug_port), NULL);
@@ -1607,9 +1744,10 @@ static void test_query_process_handlecount(void)
     {
         trace("Could not open process with ID : %d, error : %u. Going to use current one.\n", one_before_last_pid, GetLastError());
         process = GetCurrentProcess();
+        trace("ProcessHandleCount for current process\n");
     }
     else
-        if (winetest_debug > 1) trace("ProcessHandleCount for process with ID : %d\n", one_before_last_pid);
+        trace("ProcessHandleCount for process with ID : %d\n", one_before_last_pid);
 
     status = pNtQueryInformationProcess( process, ProcessHandleCount, &handlecount, sizeof(handlecount), &ReturnLength);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
@@ -1622,7 +1760,7 @@ static void test_query_process_handlecount(void)
     ok( sizeof(handlecount) == ReturnLength, "Inconsistent length %d\n", ReturnLength);
 
     /* Check if we have some return values */
-    if (winetest_debug > 1) trace("HandleCount : %d\n", handlecount);
+    trace("HandleCount : %d\n", handlecount);
     todo_wine
     {
         ok( handlecount > 0, "Expected some handles, got 0\n");
@@ -1638,6 +1776,11 @@ static void test_query_process_image_file_name(void)
     UNICODE_STRING *buffer = NULL;
 
     status = pNtQueryInformationProcess(NULL, ProcessImageFileName, &image_file_name, sizeof(image_file_name), NULL);
+    if (status == STATUS_INVALID_INFO_CLASS)
+    {
+        win_skip("ProcessImageFileName is not supported\n");
+        return;
+    }
     ok( status == STATUS_INVALID_HANDLE, "Expected STATUS_INVALID_HANDLE, got %08x\n", status);
 
     status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessImageFileName, &image_file_name, 2, &ReturnLength);
@@ -1725,6 +1868,11 @@ static void test_query_process_debug_object_handle(int argc, char **argv)
 
     status = pNtQueryInformationProcess(NULL, ProcessDebugObjectHandle, NULL,
             0, NULL);
+    if (status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED)
+    {
+        win_skip("ProcessDebugObjectHandle is not supported\n");
+        return;
+    }
     ok(status == STATUS_INFO_LENGTH_MISMATCH,
        "Expected NtQueryInformationProcess to return STATUS_INFO_LENGTH_MISMATCH, got 0x%08x\n",
        status);
@@ -1974,7 +2122,7 @@ static void test_readvirtualmemory(void)
     /* illegal remote address */
     todo_wine{
     status = pNtReadVirtualMemory(process, (void *) 0x1234, buffer, 12, &readcount);
-    ok( status == STATUS_PARTIAL_COPY, "Expected STATUS_PARTIAL_COPY, got %08x\n", status);
+    ok( status == STATUS_PARTIAL_COPY || broken(status == STATUS_ACCESS_VIOLATION), "Expected STATUS_PARTIAL_COPY, got %08x\n", status);
     if (status == STATUS_PARTIAL_COPY)
         ok( readcount == 0, "Expected to read 0 bytes, got %ld\n",readcount);
     }
@@ -2021,7 +2169,7 @@ static void test_mapprotection(void)
         return;
     }
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status );
-    if (winetest_debug > 1) trace("Process execute flags %08x\n", oldflags);
+    trace("Process execute flags %08x\n", oldflags);
 
     if (!(oldflags & MEM_EXECUTE_OPTION_ENABLE))
     {
@@ -2070,9 +2218,9 @@ static void test_mapprotection(void)
 #else
     ok(0, "Add a return opcode for your architecture or expect a crash in this test\n");
 #endif
-    if (winetest_debug > 1) trace("trying to execute code in the readwrite only mapped anon file...\n");
+    trace("trying to execute code in the readwrite only mapped anon file...\n");
     f = addr;f();
-    if (winetest_debug > 1) trace("...done.\n");
+    trace("...done.\n");
 
     status = pNtQueryVirtualMemory( GetCurrentProcess(), addr, MemoryBasicInformation, &info, sizeof(info), &retlen );
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
@@ -2087,69 +2235,6 @@ static void test_mapprotection(void)
         pNtSetInformationProcess( GetCurrentProcess(), ProcessExecuteFlags, &oldflags, sizeof(oldflags) );
 }
 
-static void test_threadstack(void)
-{
-    PROCESS_STACK_ALLOCATION_INFORMATION info = { 0x100000, 0, (void *)0xdeadbeef };
-    PROCESS_STACK_ALLOCATION_INFORMATION_EX info_ex = { 0 };
-    MEMORY_BASIC_INFORMATION meminfo;
-    SIZE_T retlen;
-    NTSTATUS status;
-
-    info.ReserveSize = 0x100000;
-    info.StackBase = (void *)0xdeadbeef;
-    status = pNtSetInformationProcess( GetCurrentProcess(), ProcessThreadStackAllocation, &info, sizeof(info) );
-    ok( !status, "NtSetInformationProcess failed %08x\n", status );
-    ok( info.StackBase != (void *)0xdeadbeef, "stackbase not set\n" );
-
-    status = pNtQueryVirtualMemory( GetCurrentProcess(), info.StackBase, MemoryBasicInformation,
-                                    &meminfo, sizeof(meminfo), &retlen );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( retlen == sizeof(meminfo), "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( meminfo.AllocationBase == info.StackBase, "wrong base %p/%p\n",
-        meminfo.AllocationBase, info.StackBase );
-    ok( meminfo.RegionSize == info.ReserveSize, "wrong size %lx/%lx\n",
-        meminfo.RegionSize, info.ReserveSize );
-    ok( meminfo.State == MEM_RESERVE, "wrong state %x\n", meminfo.State );
-    ok( meminfo.Protect == 0, "wrong protect %x\n", meminfo.Protect );
-    ok( meminfo.Type == MEM_PRIVATE, "wrong type %x\n", meminfo.Type );
-
-    info_ex.AllocInfo = info;
-    status = pNtSetInformationProcess( GetCurrentProcess(), ProcessThreadStackAllocation,
-                                       &info_ex, sizeof(info_ex) );
-    if (status != STATUS_INVALID_PARAMETER)
-    {
-        ok( !status, "NtSetInformationProcess failed %08x\n", status );
-        ok( info_ex.AllocInfo.StackBase != info.StackBase, "stackbase not set\n" );
-        status = pNtQueryVirtualMemory( GetCurrentProcess(), info_ex.AllocInfo.StackBase,
-                                        MemoryBasicInformation, &meminfo, sizeof(meminfo), &retlen );
-        ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-        ok( retlen == sizeof(meminfo), "Expected STATUS_SUCCESS, got %08x\n", status);
-        ok( meminfo.AllocationBase == info_ex.AllocInfo.StackBase, "wrong base %p/%p\n",
-            meminfo.AllocationBase, info_ex.AllocInfo.StackBase );
-        ok( meminfo.RegionSize == info_ex.AllocInfo.ReserveSize, "wrong size %lx/%lx\n",
-            meminfo.RegionSize, info_ex.AllocInfo.ReserveSize );
-        ok( meminfo.State == MEM_RESERVE, "wrong state %x\n", meminfo.State );
-        ok( meminfo.Protect == 0, "wrong protect %x\n", meminfo.Protect );
-        ok( meminfo.Type == MEM_PRIVATE, "wrong type %x\n", meminfo.Type );
-        VirtualFree( info_ex.AllocInfo.StackBase, 0, MEM_FREE );
-        status = pNtSetInformationProcess( GetCurrentProcess(), ProcessThreadStackAllocation,
-                                           &info, sizeof(info) - 1 );
-        ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtSetInformationProcess failed %08x\n", status );
-        status = pNtSetInformationProcess( GetCurrentProcess(), ProcessThreadStackAllocation,
-                                           &info, sizeof(info) + 1 );
-        ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtSetInformationProcess failed %08x\n", status );
-        status = pNtSetInformationProcess( GetCurrentProcess(), ProcessThreadStackAllocation,
-                                           &info_ex, sizeof(info_ex) - 1 );
-        ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtSetInformationProcess failed %08x\n", status );
-        status = pNtSetInformationProcess( GetCurrentProcess(), ProcessThreadStackAllocation,
-                                           &info_ex, sizeof(info_ex) + 1 );
-        ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtSetInformationProcess failed %08x\n", status );
-    }
-    else win_skip( "ProcessThreadStackAllocation ex not supported\n" );
-
-    VirtualFree( info.StackBase, 0, MEM_FREE );
-}
-
 static void test_queryvirtualmemory(void)
 {
     NTSTATUS status;
@@ -2163,6 +2248,7 @@ static void test_queryvirtualmemory(void)
     void *user_shared_data = (void *)0x7ffe0000;
 
     module = GetModuleHandleA( "ntdll.dll" );
+    trace("Check flags of the PE header of NTDLL.DLL at %p\n", module);
     status = pNtQueryVirtualMemory(NtCurrentProcess(), module, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok( readcount == sizeof(MEMORY_BASIC_INFORMATION), "Expected to read %d bytes, got %ld\n",(int)sizeof(MEMORY_BASIC_INFORMATION),readcount);
@@ -2172,6 +2258,7 @@ static void test_queryvirtualmemory(void)
     ok (mbi.Protect == PAGE_READONLY, "mbi.Protect is 0x%x, expected 0x%x\n", mbi.Protect, PAGE_READONLY);
     ok (mbi.Type == MEM_IMAGE, "mbi.Type is 0x%x, expected 0x%x\n", mbi.Type, MEM_IMAGE);
 
+    trace("Check flags of a function entry in NTDLL.DLL at %p\n", pNtQueryVirtualMemory);
     module = GetModuleHandleA( "ntdll.dll" );
     status = pNtQueryVirtualMemory(NtCurrentProcess(), pNtQueryVirtualMemory, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
@@ -2181,6 +2268,7 @@ static void test_queryvirtualmemory(void)
     ok (mbi.State == MEM_COMMIT, "mbi.State is 0x%x, expected 0x%x\n", mbi.State, MEM_COMMIT);
     ok (mbi.Protect == PAGE_EXECUTE_READ, "mbi.Protect is 0x%x, expected 0x%x\n", mbi.Protect, PAGE_EXECUTE_READ);
 
+    trace("Check flags of heap at %p\n", GetProcessHeap());
     status = pNtQueryVirtualMemory(NtCurrentProcess(), GetProcessHeap(), MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok( readcount == sizeof(MEMORY_BASIC_INFORMATION), "Expected to read %d bytes, got %ld\n",(int)sizeof(MEMORY_BASIC_INFORMATION),readcount);
@@ -2190,6 +2278,7 @@ static void test_queryvirtualmemory(void)
     ok (mbi.Protect == PAGE_READWRITE || mbi.Protect == PAGE_EXECUTE_READWRITE,
         "mbi.Protect is 0x%x\n", mbi.Protect);
 
+    trace("Check flags of stack at %p\n", stackbuf);
     status = pNtQueryVirtualMemory(NtCurrentProcess(), stackbuf, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok( readcount == sizeof(MEMORY_BASIC_INFORMATION), "Expected to read %d bytes, got %ld\n",(int)sizeof(MEMORY_BASIC_INFORMATION),readcount);
@@ -2197,6 +2286,7 @@ static void test_queryvirtualmemory(void)
     ok (mbi.State == MEM_COMMIT, "mbi.State is 0x%x, expected 0x%x\n", mbi.State, MEM_COMMIT);
     ok (mbi.Protect == PAGE_READWRITE, "mbi.Protect is 0x%x, expected 0x%x\n", mbi.Protect, PAGE_READWRITE);
 
+    trace("Check flags of read-only data at %p\n", teststring);
     module = GetModuleHandleA( NULL );
     status = pNtQueryVirtualMemory(NtCurrentProcess(), teststring, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
@@ -2204,8 +2294,10 @@ static void test_queryvirtualmemory(void)
     ok (mbi.AllocationBase == module, "mbi.AllocationBase is 0x%p, expected 0x%p\n", mbi.AllocationBase, module);
     ok (mbi.AllocationProtect == PAGE_EXECUTE_WRITECOPY, "mbi.AllocationProtect is 0x%x, expected 0x%x\n", mbi.AllocationProtect, PAGE_EXECUTE_WRITECOPY);
     ok (mbi.State == MEM_COMMIT, "mbi.State is 0x%x, expected 0x%X\n", mbi.State, MEM_COMMIT);
-    ok (mbi.Protect == PAGE_READONLY, "mbi.Protect is 0x%x, expected 0x%X\n", mbi.Protect, PAGE_READONLY);
+    if (mbi.Protect != PAGE_READONLY)
+        todo_wine ok( mbi.Protect == PAGE_READONLY, "mbi.Protect is 0x%x, expected 0x%X\n", mbi.Protect, PAGE_READONLY);
 
+    trace("Check flags of read-write data at %p\n", datatestbuf);
     status = pNtQueryVirtualMemory(NtCurrentProcess(), datatestbuf, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok( readcount == sizeof(MEMORY_BASIC_INFORMATION), "Expected to read %d bytes, got %ld\n",(int)sizeof(MEMORY_BASIC_INFORMATION),readcount);
@@ -2215,6 +2307,7 @@ static void test_queryvirtualmemory(void)
     ok (mbi.Protect == PAGE_READWRITE || mbi.Protect == PAGE_WRITECOPY,
         "mbi.Protect is 0x%x\n", mbi.Protect);
 
+    trace("Check flags of read-write uninitialized data (.bss) at %p\n", rwtestbuf);
     status = pNtQueryVirtualMemory(NtCurrentProcess(), rwtestbuf, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok( readcount == sizeof(MEMORY_BASIC_INFORMATION), "Expected to read %d bytes, got %ld\n",(int)sizeof(MEMORY_BASIC_INFORMATION),readcount);
@@ -2227,6 +2320,7 @@ static void test_queryvirtualmemory(void)
     }
     else skip( "bss is outside of module\n" );  /* this can happen on Mac OS */
 
+    trace("Check flags of user shared data at %p\n", user_shared_data);
     status = pNtQueryVirtualMemory(NtCurrentProcess(), user_shared_data, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
     ok(status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     ok(readcount == sizeof(MEMORY_BASIC_INFORMATION), "Expected to read %d bytes, got %ld\n",(int)sizeof(MEMORY_BASIC_INFORMATION),readcount);
@@ -2257,8 +2351,8 @@ static void test_affinity(void)
     status = pNtQueryInformationProcess( GetCurrentProcess(), ProcessBasicInformation, &pbi, sizeof(pbi), NULL );
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     proc_affinity = pbi.AffinityMask;
-    ok( proc_affinity == get_affinity_mask( si.dwNumberOfProcessors ), "Unexpected process affinity\n" );
-    proc_affinity = (DWORD_PTR)1 << si.dwNumberOfProcessors;
+    ok( proc_affinity == (1 << si.dwNumberOfProcessors) - 1, "Unexpected process affinity\n" );
+    proc_affinity = 1 << si.dwNumberOfProcessors;
     status = pNtSetInformationProcess( GetCurrentProcess(), ProcessAffinityMask, &proc_affinity, sizeof(proc_affinity) );
     ok( status == STATUS_INVALID_PARAMETER,
         "Expected STATUS_INVALID_PARAMETER, got %08x\n", status);
@@ -2270,8 +2364,8 @@ static void test_affinity(void)
 
     status = pNtQueryInformationThread( GetCurrentThread(), ThreadBasicInformation, &tbi, sizeof(tbi), NULL );
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( tbi.AffinityMask == get_affinity_mask( si.dwNumberOfProcessors ), "Unexpected thread affinity\n" );
-    thread_affinity = (DWORD_PTR)1 << si.dwNumberOfProcessors;
+    ok( tbi.AffinityMask == (1 << si.dwNumberOfProcessors) - 1, "Unexpected thread affinity\n" );
+    thread_affinity = 1 << si.dwNumberOfProcessors;
     status = pNtSetInformationThread( GetCurrentThread(), ThreadAffinityMask, &thread_affinity, sizeof(thread_affinity) );
     ok( status == STATUS_INVALID_PARAMETER,
         "Expected STATUS_INVALID_PARAMETER, got %08x\n", status);
@@ -2325,7 +2419,8 @@ static void test_affinity(void)
     {
         status = pNtQueryInformationThread( GetCurrentThread(), ThreadBasicInformation, &tbi, sizeof(tbi), NULL );
         ok(status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-        ok( tbi.AffinityMask == get_affinity_mask( si.dwNumberOfProcessors ), "unexpected affinity %#lx\n", tbi.AffinityMask );
+        ok( broken(tbi.AffinityMask == 1) || tbi.AffinityMask == (1 << si.dwNumberOfProcessors) - 1,
+            "Unexpected thread affinity\n" );
     }
     else
         skip("Cannot test thread affinity mask for 'all processors' flag\n");
@@ -2347,80 +2442,16 @@ static void test_affinity(void)
     ok( status == STATUS_INVALID_PARAMETER,
         "Expected STATUS_INVALID_PARAMETER, got %08x\n", status);
 
-    proc_affinity = get_affinity_mask( si.dwNumberOfProcessors );
+    proc_affinity = (1 << si.dwNumberOfProcessors) - 1;
     status = pNtSetInformationProcess( GetCurrentProcess(), ProcessAffinityMask, &proc_affinity, sizeof(proc_affinity) );
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
     /* Resetting the process affinity also resets the thread affinity */
     status = pNtQueryInformationThread( GetCurrentThread(), ThreadBasicInformation, &tbi, sizeof(tbi), NULL );
     ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
-    ok( tbi.AffinityMask == get_affinity_mask( si.dwNumberOfProcessors ),
+    ok( tbi.AffinityMask == (1 << si.dwNumberOfProcessors) - 1,
         "Unexpected thread affinity\n" );
 }
 
-static DWORD WINAPI hide_from_debugger_thread(void *arg)
-{
-    HANDLE stop_event = arg;
-    WaitForSingleObject( stop_event, INFINITE );
-    return 0;
-}
-
-static void test_HideFromDebugger(void)
-{
-    NTSTATUS status;
-    HANDLE thread, stop_event;
-    ULONG dummy;
-
-    dummy = 0;
-    status = pNtSetInformationThread( GetCurrentThread(), ThreadHideFromDebugger, &dummy, sizeof(ULONG) );
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status );
-    dummy = 0;
-    status = pNtSetInformationThread( GetCurrentThread(), ThreadHideFromDebugger, &dummy, 1 );
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status );
-    status = pNtSetInformationThread( (HANDLE)0xdeadbeef, ThreadHideFromDebugger, NULL, 0 );
-    ok( status == STATUS_INVALID_HANDLE, "Expected STATUS_INVALID_HANDLE, got %08x\n", status );
-    status = pNtSetInformationThread( GetCurrentThread(), ThreadHideFromDebugger, NULL, 0 );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status );
-    dummy = 0;
-    status = NtQueryInformationThread( GetCurrentThread(), ThreadHideFromDebugger, &dummy, sizeof(ULONG), NULL );
-    if (status == STATUS_INVALID_INFO_CLASS)
-    {
-        win_skip("ThreadHideFromDebugger not available\n");
-        return;
-    }
-
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status );
-    dummy = 0;
-    status = NtQueryInformationThread( (HANDLE)0xdeadbeef, ThreadHideFromDebugger, &dummy, sizeof(ULONG), NULL );
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status );
-    dummy = 0;
-    status = NtQueryInformationThread( GetCurrentThread(), ThreadHideFromDebugger, &dummy, 1, NULL );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status );
-    ok( dummy == 1, "Expected dummy == 1, got %08x\n", dummy );
-
-    stop_event = CreateEventA( NULL, FALSE, FALSE, NULL );
-    ok( stop_event != NULL, "CreateEvent failed\n" );
-    thread = CreateThread( NULL, 0, hide_from_debugger_thread, stop_event, 0, NULL );
-    ok( thread != INVALID_HANDLE_VALUE, "CreateThread failed with %d\n", GetLastError() );
-
-    dummy = 0;
-    status = NtQueryInformationThread( thread, ThreadHideFromDebugger, &dummy, 1, NULL );
-    ok( status == STATUS_SUCCESS, "got %#x\n", status );
-    ok( dummy == 0, "Expected dummy == 0, got %08x\n", dummy );
-
-    status = pNtSetInformationThread( thread, ThreadHideFromDebugger, NULL, 0 );
-    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status );
-
-    dummy = 0;
-    status = NtQueryInformationThread( thread, ThreadHideFromDebugger, &dummy, 1, NULL );
-    ok( status == STATUS_SUCCESS, "got %#x\n", status );
-    ok( dummy == 1, "Expected dummy == 1, got %08x\n", dummy );
-
-    SetEvent( stop_event );
-    WaitForSingleObject( thread, INFINITE );
-    CloseHandle( thread );
-    CloseHandle( stop_event );
-}
-
 static void test_NtGetCurrentProcessorNumber(void)
 {
     NTSTATUS status;
@@ -2440,7 +2471,7 @@ static void test_NtGetCurrentProcessorNumber(void)
 
     GetSystemInfo(&si);
     current_cpu = pNtGetCurrentProcessorNumber();
-    if (winetest_debug > 1) trace("dwNumberOfProcessors: %d, current processor: %d\n", si.dwNumberOfProcessors, current_cpu);
+    trace("dwNumberOfProcessors: %d, current processor: %d\n", si.dwNumberOfProcessors, current_cpu);
 
     status = pNtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &pbi, sizeof(pbi), NULL);
     old_process_mask = pbi.AffinityMask;
@@ -2451,13 +2482,13 @@ static void test_NtGetCurrentProcessorNumber(void)
     ok(status == STATUS_SUCCESS, "got 0x%x (expected STATUS_SUCCESS)\n", status);
 
     /* allow the test to run on all processors */
-    new_mask = get_affinity_mask( si.dwNumberOfProcessors );
+    new_mask = (1 << si.dwNumberOfProcessors) - 1;
     status = pNtSetInformationProcess(GetCurrentProcess(), ProcessAffinityMask, &new_mask, sizeof(new_mask));
     ok(status == STATUS_SUCCESS, "got 0x%x (expected STATUS_SUCCESS)\n", status);
 
     for (i = 0; i < si.dwNumberOfProcessors; i++)
     {
-        new_mask = (DWORD_PTR)1 << i;
+        new_mask = 1 << i;
         status = pNtSetInformationThread(GetCurrentThread(), ThreadAffinityMask, &new_mask, sizeof(new_mask));
         ok(status == STATUS_SUCCESS, "%d: got 0x%x (expected STATUS_SUCCESS)\n", i, status);
 
@@ -2612,77 +2643,6 @@ static void test_thread_lookup(void)
        "NtOpenThread returned %#x\n", status);
 }
 
-static void test_thread_info(void)
-{
-    NTSTATUS status;
-    ULONG len, data;
-
-    len = 0xdeadbeef;
-    data = 0xcccccccc;
-    status = pNtQueryInformationThread( GetCurrentThread(), ThreadAmILastThread,
-                                        &data, sizeof(data), &len );
-    ok( !status, "failed %x\n", status );
-    ok( data == 0 || data == 1, "wrong data %x\n", data );
-    ok( len == sizeof(data), "wrong len %u\n", len );
-
-    len = 0xdeadbeef;
-    data = 0xcccccccc;
-    status = pNtQueryInformationThread( GetCurrentThread(), ThreadAmILastThread,
-                                        &data, sizeof(data) - 1, &len );
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "failed %x\n", status );
-    ok( data == 0xcccccccc, "wrong data %x\n", data );
-    ok( len == 0xdeadbeef, "wrong len %u\n", len );
-
-    len = 0xdeadbeef;
-    data = 0xcccccccc;
-    status = pNtQueryInformationThread( GetCurrentThread(), ThreadAmILastThread,
-                                        &data, sizeof(data) + 1, &len );
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "failed %x\n", status );
-    ok( data == 0xcccccccc, "wrong data %x\n", data );
-    ok( len == 0xdeadbeef, "wrong len %u\n", len );
-}
-
-static void test_wow64(void)
-{
-#ifndef _WIN64
-    if (is_wow64)
-    {
-        PEB64 *peb64;
-        TEB64 *teb64 = (TEB64 *)NtCurrentTeb()->GdiBatchCount;
-
-        ok( !!teb64, "GdiBatchCount not set\n" );
-        ok( (char *)NtCurrentTeb() + NtCurrentTeb()->WowTebOffset == (char *)teb64 ||
-            broken(!NtCurrentTeb()->WowTebOffset),  /* pre-win10 */
-            "wrong WowTebOffset %x (%p/%p)\n", NtCurrentTeb()->WowTebOffset, teb64, NtCurrentTeb() );
-        ok( (char *)teb64 + 0x2000 == (char *)NtCurrentTeb(), "unexpected diff %p / %p\n",
-            teb64, NtCurrentTeb() );
-        ok( teb64->Tib.ExceptionList == PtrToUlong( NtCurrentTeb() ), "wrong Tib.ExceptionList %s / %p\n",
-            wine_dbgstr_longlong(teb64->Tib.ExceptionList), NtCurrentTeb() );
-        ok( teb64->Tib.Self == PtrToUlong( teb64 ), "wrong Tib.Self %s / %p\n",
-            wine_dbgstr_longlong(teb64->Tib.Self), teb64 );
-        ok( teb64->StaticUnicodeString.Buffer == PtrToUlong( teb64->StaticUnicodeBuffer ),
-            "wrong StaticUnicodeString %s / %p\n",
-            wine_dbgstr_longlong(teb64->StaticUnicodeString.Buffer), teb64->StaticUnicodeBuffer );
-        ok( teb64->ClientId.UniqueProcess == GetCurrentProcessId(), "wrong pid %s / %x\n",
-            wine_dbgstr_longlong(teb64->ClientId.UniqueProcess), GetCurrentProcessId() );
-        ok( teb64->ClientId.UniqueThread == GetCurrentThreadId(), "wrong tid %s / %x\n",
-            wine_dbgstr_longlong(teb64->ClientId.UniqueThread), GetCurrentThreadId() );
-        peb64 = ULongToPtr( teb64->Peb );
-        ok( peb64->ImageBaseAddress == PtrToUlong( NtCurrentTeb()->Peb->ImageBaseAddress ),
-            "wrong ImageBaseAddress %s / %p\n",
-            wine_dbgstr_longlong(peb64->ImageBaseAddress), NtCurrentTeb()->Peb->ImageBaseAddress);
-        ok( peb64->OSBuildNumber == NtCurrentTeb()->Peb->OSBuildNumber, "wrong OSBuildNumber %x / %x\n",
-            peb64->OSBuildNumber, NtCurrentTeb()->Peb->OSBuildNumber );
-        ok( peb64->OSPlatformId == NtCurrentTeb()->Peb->OSPlatformId, "wrong OSPlatformId %x / %x\n",
-            peb64->OSPlatformId, NtCurrentTeb()->Peb->OSPlatformId );
-        return;
-    }
-#endif
-    ok( !NtCurrentTeb()->GdiBatchCount, "GdiBatchCount set to %x\n", NtCurrentTeb()->GdiBatchCount );
-    ok( !NtCurrentTeb()->WowTebOffset, "WowTebOffset set to %x\n", NtCurrentTeb()->WowTebOffset );
-}
-
-
 START_TEST(info)
 {
     char **argv;
@@ -2695,55 +2655,149 @@ START_TEST(info)
     if (argc >= 3) return; /* Child */
 
     /* NtQuerySystemInformation */
+
+    /* 0x0 SystemBasicInformation */
+    trace("Starting test_query_basic()\n");
     test_query_basic();
+
+    /* 0x1 SystemCpuInformation */
+    trace("Starting test_query_cpu()\n");
     test_query_cpu();
+
+    /* 0x2 SystemPerformanceInformation */
+    trace("Starting test_query_performance()\n");
     test_query_performance();
+
+    /* 0x3 SystemTimeOfDayInformation */
+    trace("Starting test_query_timeofday()\n");
     test_query_timeofday();
+
+    /* 0x5 SystemProcessInformation */
+    trace("Starting test_query_process()\n");
     test_query_process();
+
+    /* 0x8 SystemProcessorPerformanceInformation */
+    trace("Starting test_query_procperf()\n");
     test_query_procperf();
+
+    /* 0xb SystemModuleInformation */
+    trace("Starting test_query_module()\n");
     test_query_module();
+
+    /* 0x10 SystemHandleInformation */
+    trace("Starting test_query_handle()\n");
     test_query_handle();
+
+    /* 0x15 SystemCacheInformation */
+    trace("Starting test_query_cache()\n");
     test_query_cache();
+
+    /* 0x17 SystemInterruptInformation */
+    trace("Starting test_query_interrupt()\n");
     test_query_interrupt();
+
+    /* 0x1c SystemTimeAdjustmentInformation */
+    trace("Starting test_time_adjustment()\n");
     test_time_adjustment();
+
+    /* 0x23 SystemKernelDebuggerInformation */
+    trace("Starting test_query_kerndebug()\n");
     test_query_kerndebug();
+
+    /* 0x25 SystemRegistryQuotaInformation */
+    trace("Starting test_query_regquota()\n");
     test_query_regquota();
+
+    /* 0x49 SystemLogicalProcessorInformation */
+    trace("Starting test_query_logicalproc()\n");
     test_query_logicalproc();
     test_query_logicalprocex();
-    test_query_firmware();
-    test_query_data_alignment();
 
     /* NtPowerInformation */
+
+    /* 0x5 SystemBatteryState */
+    trace("Starting test_query_battery()\n");
     test_query_battery();
+
+    /* 0xb ProcessorInformation */
+    trace("Starting test_query_processor_power_info()\n");
     test_query_processor_power_info();
 
     /* NtQueryInformationProcess */
+
+    /* 0x0 ProcessBasicInformation */
+    trace("Starting test_query_process_basic()\n");
     test_query_process_basic();
+
+    /* 0x2 ProcessIoCounters */
+    trace("Starting test_query_process_io()\n");
     test_query_process_io();
+
+    /* 0x3 ProcessVmCounters */
+    trace("Starting test_query_process_vm()\n");
     test_query_process_vm();
+
+    /* 0x4 ProcessTimes */
+    trace("Starting test_query_process_times()\n");
     test_query_process_times();
+
+    /* 0x7 ProcessDebugPort */
+    trace("Starting test_process_debug_port()\n");
     test_query_process_debug_port(argc, argv);
+
+    /* 0x12 ProcessPriorityClass */
+    trace("Starting test_query_process_priority()\n");
     test_query_process_priority();
+
+    /* 0x14 ProcessHandleCount */
+    trace("Starting test_query_process_handlecount()\n");
     test_query_process_handlecount();
+
+    /* 0x1A ProcessWow64Information */
+    trace("Starting test_query_process_wow64()\n");
     test_query_process_wow64();
+
+    /* 0x1B ProcessImageFileName */
+    trace("Starting test_query_process_image_file_name()\n");
     test_query_process_image_file_name();
+
+    /* 0x1E ProcessDebugObjectHandle */
+    trace("Starting test_query_process_debug_object_handle()\n");
     test_query_process_debug_object_handle(argc, argv);
+
+    /* 0x1F ProcessDebugFlags */
+    trace("Starting test_process_debug_flags()\n");
     test_query_process_debug_flags(argc, argv);
-    test_query_process_image_info();
-    test_mapprotection();
-    test_threadstack();
 
-    /* NtQueryInformationThread */
-    test_thread_info();
-    test_HideFromDebugger();
-    test_thread_start_address();
-    test_thread_lookup();
+    /* 0x25 ProcessImageInformation */
+    trace("Starting test_process_image_info()\n");
+    test_query_process_image_info();
 
-    test_affinity();
-    test_wow64();
+    /* 0x4C SystemFirmwareTableInformation */
+    trace("Starting test_query_firmware()\n");
+    test_query_firmware();
 
     /* belongs to its own file */
+    trace("Starting test_readvirtualmemory()\n");
     test_readvirtualmemory();
+
+    trace("Starting test_queryvirtualmemory()\n");
     test_queryvirtualmemory();
+
+    trace("Starting test_mapprotection()\n");
+    test_mapprotection();
+
+    trace("Starting test_affinity()\n");
+    test_affinity();
+
+    trace("Starting test_NtGetCurrentProcessorNumber()\n");
     test_NtGetCurrentProcessorNumber();
+
+    trace("Starting test_thread_start_address()\n");
+    test_thread_start_address();
+
+    trace("Starting test_query_data_alignment()\n");
+    test_query_data_alignment();
+
+    test_thread_lookup();
 }
diff --git a/dlls/ntdll/tests/om.c b/dlls/ntdll/tests/om.c
index 29c777e91e..c17b6ffa8d 100644
--- a/dlls/ntdll/tests/om.c
+++ b/dlls/ntdll/tests/om.c
@@ -25,7 +25,10 @@
 #include "winnt.h"
 #include "stdlib.h"
 
+static HANDLE   (WINAPI *pCreateWaitableTimerA)(SECURITY_ATTRIBUTES*, BOOL, LPCSTR);
+static BOOLEAN  (WINAPI *pRtlCreateUnicodeStringFromAsciiz)(PUNICODE_STRING, LPCSTR);
 static VOID     (WINAPI *pRtlInitUnicodeString)( PUNICODE_STRING, LPCWSTR );
+static VOID     (WINAPI *pRtlFreeUnicodeString)(PUNICODE_STRING);
 static NTSTATUS (WINAPI *pNtCreateEvent) ( PHANDLE, ACCESS_MASK, const POBJECT_ATTRIBUTES, BOOLEAN, BOOLEAN);
 static NTSTATUS (WINAPI *pNtOpenEvent)   ( PHANDLE, ACCESS_MASK, const POBJECT_ATTRIBUTES);
 static NTSTATUS (WINAPI *pNtPulseEvent)  ( HANDLE, PLONG );
@@ -80,25 +83,30 @@ static void     (WINAPI *pRtlWakeAddressSingle)( const void * );
 
 static void test_case_sensitive (void)
 {
+    static const WCHAR buffer1[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s','\\','t','e','s','t',0};
+    static const WCHAR buffer2[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s','\\','T','e','s','t',0};
+    static const WCHAR buffer3[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s','\\','T','E','s','t',0};
+    static const WCHAR buffer4[] = {'\\','B','A','S','E','N','a','m','e','d','O','b','j','e','c','t','s','\\','t','e','s','t',0};
     NTSTATUS status;
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING str;
     HANDLE Event, Mutant, h;
 
-    pRtlInitUnicodeString(&str, L"\\BaseNamedObjects\\test");
+    pRtlInitUnicodeString(&str, buffer1);
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtCreateMutant(&Mutant, GENERIC_ALL, &attr, FALSE);
     ok(status == STATUS_SUCCESS, "Failed to create Mutant(%08x)\n", status);
 
     status = pNtCreateEvent(&Event, GENERIC_ALL, &attr, FALSE, FALSE);
-    ok(status == STATUS_OBJECT_NAME_COLLISION || status == STATUS_OBJECT_TYPE_MISMATCH /* Vista+ */, "got %#x\n", status);
+    ok(status == STATUS_OBJECT_NAME_COLLISION || status == STATUS_OBJECT_TYPE_MISMATCH,
+        "NtCreateEvent should have failed with STATUS_OBJECT_NAME_COLLISION or STATUS_OBJECT_TYPE_MISMATCH got (%08x)\n", status);
 
-    pRtlInitUnicodeString(&str, L"\\BaseNamedObjects\\Test");
+    pRtlInitUnicodeString(&str, buffer2);
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtCreateEvent(&Event, GENERIC_ALL, &attr, FALSE, FALSE);
     ok(status == STATUS_SUCCESS, "Failed to create Event(%08x)\n", status);
 
-    pRtlInitUnicodeString(&str, L"\\BaseNamedObjects\\TEst");
+    pRtlInitUnicodeString(&str, buffer3);
     InitializeObjectAttributes(&attr, &str, OBJ_CASE_INSENSITIVE, 0, NULL);
     status = pNtOpenMutant(&h, GENERIC_ALL, &attr);
     ok(status == STATUS_OBJECT_TYPE_MISMATCH,
@@ -106,10 +114,11 @@ static void test_case_sensitive (void)
 
     pNtClose(Mutant);
 
-    pRtlInitUnicodeString(&str, L"\\BASENamedObjects\\test");
+    pRtlInitUnicodeString(&str, buffer4);
     InitializeObjectAttributes(&attr, &str, OBJ_CASE_INSENSITIVE, 0, NULL);
     status = pNtCreateMutant(&Mutant, GENERIC_ALL, &attr, FALSE);
-    ok(status == STATUS_OBJECT_NAME_COLLISION || status == STATUS_OBJECT_TYPE_MISMATCH /* Vista+ */, "got %#x\n", status);
+    ok(status == STATUS_OBJECT_NAME_COLLISION || status == STATUS_OBJECT_TYPE_MISMATCH,
+        "NtCreateMutant should have failed with STATUS_OBJECT_NAME_COLLISION or STATUS_OBJECT_TYPE_MISMATCH got (%08x)\n", status);
 
     status = pNtCreateEvent(&h, GENERIC_ALL, &attr, FALSE, FALSE);
     ok(status == STATUS_OBJECT_NAME_COLLISION,
@@ -125,6 +134,10 @@ static void test_case_sensitive (void)
 
 static void test_namespace_pipe(void)
 {
+    static const WCHAR buffer1[] = {'\\','?','?','\\','P','I','P','E','\\','t','e','s','t','\\','p','i','p','e',0};
+    static const WCHAR buffer2[] = {'\\','?','?','\\','P','I','P','E','\\','T','E','S','T','\\','P','I','P','E',0};
+    static const WCHAR buffer3[] = {'\\','?','?','\\','p','i','p','e','\\','t','e','s','t','\\','p','i','p','e',0};
+    static const WCHAR buffer4[] = {'\\','?','?','\\','p','i','p','e','\\','t','e','s','t',0};
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING str;
     IO_STATUS_BLOCK iosb;
@@ -134,7 +147,7 @@ static void test_namespace_pipe(void)
 
     timeout.QuadPart = -10000;
 
-    pRtlInitUnicodeString(&str, L"\\??\\PIPE\\test\\pipe");
+    pRtlInitUnicodeString(&str, buffer1);
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtCreateNamedPipeFile(&pipe, GENERIC_READ|GENERIC_WRITE, &attr, &iosb, FILE_SHARE_READ|FILE_SHARE_WRITE,
                                     FILE_CREATE, FILE_PIPE_FULL_DUPLEX, FALSE, FALSE, FALSE, 1, 256, 256, &timeout);
@@ -145,7 +158,7 @@ static void test_namespace_pipe(void)
     ok(status == STATUS_INSTANCE_NOT_AVAILABLE,
         "NtCreateNamedPipeFile should have failed with STATUS_INSTANCE_NOT_AVAILABLE got(%08x)\n", status);
 
-    pRtlInitUnicodeString(&str, L"\\??\\PIPE\\TEST\\PIPE");
+    pRtlInitUnicodeString(&str, buffer2);
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtCreateNamedPipeFile(&pipe, GENERIC_READ|GENERIC_WRITE, &attr, &iosb, FILE_SHARE_READ|FILE_SHARE_WRITE,
                                     FILE_CREATE, FILE_PIPE_FULL_DUPLEX, FALSE, FALSE, FALSE, 1, 256, 256, &timeout);
@@ -157,7 +170,7 @@ static void test_namespace_pipe(void)
     ok(h != INVALID_HANDLE_VALUE, "Failed to open NamedPipe (%u)\n", GetLastError());
     pNtClose(h);
 
-    pRtlInitUnicodeString(&str, L"\\??\\pipe\\test\\pipe");
+    pRtlInitUnicodeString(&str, buffer3);
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtOpenFile(&h, GENERIC_READ, &attr, &iosb, FILE_SHARE_READ|FILE_SHARE_WRITE, 0);
     ok(status == STATUS_OBJECT_PATH_NOT_FOUND ||
@@ -166,7 +179,7 @@ static void test_namespace_pipe(void)
        status == STATUS_OBJECT_NAME_NOT_FOUND, /* win8 */
         "NtOpenFile should have failed with STATUS_OBJECT_PATH_NOT_FOUND got(%08x)\n", status);
 
-    pRtlInitUnicodeString(&str, L"\\??\\pipe\\test");
+    pRtlInitUnicodeString(&str, buffer4);
     InitializeObjectAttributes(&attr, &str, OBJ_CASE_INSENSITIVE, 0, NULL);
     status = pNtOpenFile(&h, GENERIC_READ, &attr, &iosb, FILE_SHARE_READ|FILE_SHARE_WRITE, 0);
     ok(status == STATUS_OBJECT_NAME_NOT_FOUND ||
@@ -189,35 +202,30 @@ static void test_namespace_pipe(void)
 #define DIRECTORY_QUERY (0x0001)
 #define SYMBOLIC_LINK_QUERY 0x0001
 
-#define check_create_open_dir(parent, name, status) check_create_open_dir_(__LINE__, parent, name, status)
-static void check_create_open_dir_( int line, HANDLE parent, const WCHAR *name, NTSTATUS expect )
-{
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING str;
-    NTSTATUS status;
-    HANDLE h;
-
-    RtlInitUnicodeString( &str, name );
-    InitializeObjectAttributes( &attr, &str, 0, parent, NULL );
-    status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
-    ok_(__FILE__, line)( status == expect, "NtCreateDirectoryObject(%s) got %08x\n", debugstr_w(name), status );
-    if (!status) pNtClose( h );
-
-    status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr );
-    ok_(__FILE__, line)( status == expect, "NtOpenDirectoryObject(%s) got %08x\n", debugstr_w(name), status );
-    if (!status) pNtClose( h );
-}
-
-static BOOL is_correct_dir( HANDLE dir, const WCHAR *name )
+#define DIR_TEST_CREATE_OPEN(n,e) \
+    do { \
+        HANDLE h; \
+        pRtlCreateUnicodeStringFromAsciiz(&str, n); \
+        status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr ); \
+        ok( status == e, "NtCreateDirectoryObject(%s) got %08x\n", n, status ); \
+        if (!status) pNtClose( h ); \
+        status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr ); \
+        ok( status == e, "NtOpenDirectoryObject(%s) got %08x\n", n, status ); \
+        if (!status) pNtClose( h ); \
+        pRtlFreeUnicodeString(&str); \
+    } while(0)
+
+static BOOL is_correct_dir( HANDLE dir, const char *name )
 {
     NTSTATUS status;
     UNICODE_STRING str;
     OBJECT_ATTRIBUTES attr;
     HANDLE h = 0;
 
-    RtlInitUnicodeString( &str, name );
+    pRtlCreateUnicodeStringFromAsciiz(&str, name);
     InitializeObjectAttributes(&attr, &str, OBJ_OPENIF, dir, NULL);
     status = pNtCreateMutant(&h, GENERIC_ALL, &attr, FALSE);
+    pRtlFreeUnicodeString(&str);
     if (h) pNtClose( h );
     return (status == STATUS_OBJECT_NAME_EXISTS);
 }
@@ -225,23 +233,33 @@ static BOOL is_correct_dir( HANDLE dir, const WCHAR *name )
 /* return a handle to the BaseNamedObjects dir where kernel32 objects get created */
 static HANDLE get_base_dir(void)
 {
-    static const WCHAR objname[] = L"om.c_get_base_dir_obj";
+    static const char objname[] = "om.c_get_base_dir_obj";
     NTSTATUS status;
     UNICODE_STRING str;
     OBJECT_ATTRIBUTES attr;
     HANDLE dir, h;
-    WCHAR name[40];
+    char name[40];
 
-    h = CreateMutexW( NULL, FALSE, objname );
+    h = CreateMutexA(NULL, FALSE, objname);
     ok(h != 0, "CreateMutexA failed got ret=%p (%d)\n", h, GetLastError());
     InitializeObjectAttributes(&attr, &str, OBJ_OPENIF, 0, NULL);
 
-    swprintf( name, ARRAY_SIZE(name), L"\\BaseNamedObjects\\Session\\%u", NtCurrentTeb()->Peb->SessionId );
-    RtlInitUnicodeString( &str, name );
+    sprintf( name, "\\BaseNamedObjects\\Session\\%u", NtCurrentTeb()->Peb->SessionId );
+    pRtlCreateUnicodeStringFromAsciiz(&str, name );
+    status = pNtOpenDirectoryObject(&dir, DIRECTORY_QUERY, &attr);
+    pRtlFreeUnicodeString(&str);
+    if (!status && is_correct_dir( dir, objname )) goto done;
+    if (!status) pNtClose( dir );
+
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects");
     status = pNtOpenDirectoryObject(&dir, DIRECTORY_QUERY, &attr);
-    ok(!status, "got %#x\n", status);
-    ok(is_correct_dir( dir, objname ), "wrong dir\n");
+    pRtlFreeUnicodeString(&str);
+    if (!status && is_correct_dir( dir, objname )) goto done;
+    if (!status) pNtClose( dir );
+
+    dir = 0;
 
+done:
     pNtClose( h );
     return dir;
 }
@@ -256,7 +274,7 @@ static void test_name_collisions(void)
     LARGE_INTEGER size;
 
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
-    RtlInitUnicodeString(&str, L"\\");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\");
     status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_OBJECT_NAME_COLLISION, "NtCreateDirectoryObject got %08x\n", status );
     InitializeObjectAttributes(&attr, &str, OBJ_OPENIF, 0, NULL);
@@ -267,13 +285,20 @@ static void test_name_collisions(void)
     status = pNtCreateMutant(&h, GENERIC_ALL, &attr, FALSE);
     ok(status == STATUS_OBJECT_TYPE_MISMATCH,
         "NtCreateMutant should have failed with STATUS_OBJECT_TYPE_MISMATCH got(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
 
-    RtlInitUnicodeString(&str, L"\\??\\PIPE\\om.c-mutant");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\??\\PIPE\\om.c-mutant");
     status = pNtCreateMutant(&h, GENERIC_ALL, &attr, FALSE);
-    todo_wine ok(status == STATUS_OBJECT_PATH_NOT_FOUND, "got %#x\n", status);
+    ok(status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_OBJECT_PATH_NOT_FOUND,
+        "NtCreateMutant should have failed with STATUS_OBJECT_TYPE_MISMATCH got(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
 
-    dir = get_base_dir();
-    RtlInitUnicodeString(&str, L"om.c-test");
+    if (!(dir = get_base_dir()))
+    {
+        win_skip( "couldn't find the BaseNamedObjects dir\n" );
+        return;
+    }
+    pRtlCreateUnicodeStringFromAsciiz(&str, "om.c-test");
     InitializeObjectAttributes(&attr, &str, OBJ_OPENIF, dir, NULL);
     h = CreateMutexA(NULL, FALSE, "om.c-test");
     ok(h != 0, "CreateMutexA failed got ret=%p (%d)\n", h, GetLastError());
@@ -314,12 +339,12 @@ static void test_name_collisions(void)
     pNtClose(h1);
     pNtClose(h2);
     
-    h = CreateWaitableTimerA(NULL, TRUE, "om.c-test");
+    h = pCreateWaitableTimerA(NULL, TRUE, "om.c-test");
     ok(h != 0, "CreateWaitableTimerA failed got ret=%p (%d)\n", h, GetLastError());
     status = pNtCreateTimer(&h1, GENERIC_ALL, &attr, NotificationTimer);
     ok(status == STATUS_OBJECT_NAME_EXISTS && h1 != NULL,
         "NtCreateTimer should have succeeded with STATUS_OBJECT_NAME_EXISTS got(%08x)\n", status);
-    h2 = CreateWaitableTimerA(NULL, TRUE, "om.c-test");
+    h2 = pCreateWaitableTimerA(NULL, TRUE, "om.c-test");
     winerr = GetLastError();
     ok(h2 != 0 && winerr == ERROR_ALREADY_EXISTS,
         "CreateWaitableTimerA should have succeeded with ERROR_ALREADY_EXISTS got ret=%p (%d)\n", h2, winerr);
@@ -342,6 +367,7 @@ static void test_name_collisions(void)
     pNtClose(h1);
     pNtClose(h2);
 
+    pRtlFreeUnicodeString(&str);
     pNtClose(dir);
 }
 
@@ -353,7 +379,7 @@ static void test_all_kernel_objects( UINT line, OBJECT_ATTRIBUTES *attr,
     NTSTATUS status, status2;
     HANDLE ret, ret2;
 
-    RtlInitUnicodeString( &target, L"\\DosDevices" );
+    pRtlCreateUnicodeStringFromAsciiz( &target, "\\DosDevices" );
     size.QuadPart = 4096;
 
     status = pNtCreateMutant( &ret, GENERIC_ALL, attr, FALSE );
@@ -416,13 +442,15 @@ static void test_all_kernel_objects( UINT line, OBJECT_ATTRIBUTES *attr,
     ok( status2 == open_expect, "%u: NtOpenSection failed %x\n", line, status2 );
     if (!status) pNtClose( ret );
     if (!status2) pNtClose( ret2 );
+    pRtlFreeUnicodeString( &target );
 }
 
 static void test_name_limits(void)
 {
-    static const WCHAR pipeW[]     = L"\\Device\\NamedPipe\\";
-    static const WCHAR mailslotW[] = L"\\Device\\MailSlot\\";
-    static const WCHAR registryW[] = L"\\REGISTRY\\Machine\\SOFTWARE\\Microsoft\\";
+    static const WCHAR localW[]    = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s','\\','L','o','c','a','l',0};
+    static const WCHAR pipeW[]     = {'\\','D','e','v','i','c','e','\\','N','a','m','e','d','P','i','p','e','\\'};
+    static const WCHAR mailslotW[] = {'\\','D','e','v','i','c','e','\\','M','a','i','l','S','l','o','t','\\'};
+    static const WCHAR registryW[] = {'\\','R','E','G','I','S','T','R','Y','\\','M','a','c','h','i','n','e','\\','S','O','F','T','W','A','R','E','\\','M','i','c','r','o','s','o','f','t','\\'};
     OBJECT_ATTRIBUTES attr, attr2, attr3;
     IO_STATUS_BLOCK iosb;
     LARGE_INTEGER size, timeout;
@@ -438,9 +466,14 @@ static void test_name_limits(void)
     str.MaximumLength = 65534;
     for (i = 0; i < 65536 / sizeof(WCHAR); i++) str.Buffer[i] = 'a';
     size.QuadPart = 4096;
-    RtlInitUnicodeString( &target, L"\\DosDevices" );
+    pRtlCreateUnicodeStringFromAsciiz( &target, "\\DosDevices" );
+
+    if (!(attr.RootDirectory = get_base_dir()))
+    {
+        win_skip( "couldn't find the BaseNamedObjects dir\n" );
+        return;
+    }
 
-    attr.RootDirectory = get_base_dir();
     str.Length = 0;
     status = pNtCreateMutant( &ret, GENERIC_ALL, &attr2, FALSE );
     ok( status == STATUS_SUCCESS, "%u: NtCreateMutant failed %x\n", str.Length, status );
@@ -448,7 +481,7 @@ static void test_name_limits(void)
     status = pNtOpenMutant( &ret2, GENERIC_ALL, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenMutant failed %x\n", str.Length, status );
     status = pNtOpenMutant( &ret2, GENERIC_ALL, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenMutant failed %x\n", str.Length, status );
     pNtClose( ret );
     status = pNtCreateSemaphore( &ret, GENERIC_ALL, &attr2, 1, 2 );
@@ -457,7 +490,7 @@ static void test_name_limits(void)
     status = pNtOpenSemaphore( &ret2, GENERIC_ALL, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenSemaphore failed %x\n", str.Length, status );
     status = pNtOpenSemaphore( &ret2, GENERIC_ALL, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenSemaphore failed %x\n", str.Length, status );
     pNtClose( ret );
     status = pNtCreateEvent( &ret, GENERIC_ALL, &attr2, 1, 0 );
@@ -466,7 +499,7 @@ static void test_name_limits(void)
     status = pNtOpenEvent( &ret2, GENERIC_ALL, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenEvent failed %x\n", str.Length, status );
     status = pNtOpenEvent( &ret2, GENERIC_ALL, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenEvent failed %x\n", str.Length, status );
     pNtClose( ret );
     status = pNtCreateKeyedEvent( &ret, GENERIC_ALL, &attr2, 0 );
@@ -475,7 +508,7 @@ static void test_name_limits(void)
     status = pNtOpenKeyedEvent( &ret2, GENERIC_ALL, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenKeyedEvent failed %x\n", str.Length, status );
     status = pNtOpenKeyedEvent( &ret2, GENERIC_ALL, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenKeyedEvent failed %x\n", str.Length, status );
     pNtClose( ret );
     status = pNtCreateTimer( &ret, GENERIC_ALL, &attr2, NotificationTimer );
@@ -484,7 +517,7 @@ static void test_name_limits(void)
     status = pNtOpenTimer( &ret2, GENERIC_ALL, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenTimer failed %x\n", str.Length, status );
     status = pNtOpenTimer( &ret2, GENERIC_ALL, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenTimer failed %x\n", str.Length, status );
     pNtClose( ret );
     status = pNtCreateIoCompletion( &ret, GENERIC_ALL, &attr2, 0 );
@@ -493,7 +526,7 @@ static void test_name_limits(void)
     status = pNtOpenIoCompletion( &ret2, GENERIC_ALL, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenCompletion failed %x\n", str.Length, status );
     status = pNtOpenIoCompletion( &ret2, GENERIC_ALL, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenCompletion failed %x\n", str.Length, status );
     pNtClose( ret );
     status = pNtCreateJobObject( &ret, GENERIC_ALL, &attr2 );
@@ -502,7 +535,7 @@ static void test_name_limits(void)
     status = pNtOpenJobObject( &ret2, GENERIC_ALL, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenJobObject failed %x\n", str.Length, status );
     status = pNtOpenJobObject( &ret2, GENERIC_ALL, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenJobObject failed %x\n", str.Length, status );
     pNtClose( ret );
     status = pNtCreateDirectoryObject( &ret, GENERIC_ALL, &attr2 );
@@ -531,7 +564,7 @@ static void test_name_limits(void)
     status = pNtOpenSection( &ret2, SECTION_MAP_WRITE, &attr );
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "%u: NtOpenSection failed %x\n", str.Length, status );
     status = pNtOpenSection( &ret2, SECTION_MAP_WRITE, &attr3 );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE /* < 7 */,
+    ok( status == STATUS_OBJECT_TYPE_MISMATCH || status == STATUS_INVALID_HANDLE,
         "%u: NtOpenSection failed %x\n", str.Length, status );
     pNtClose( ret );
 
@@ -561,7 +594,7 @@ static void test_name_limits(void)
     test_all_kernel_objects( __LINE__, &attr3, STATUS_SUCCESS, STATUS_OBJECT_PATH_SYNTAX_BAD );
 
     attr3.ObjectName = &str2;
-    pRtlInitUnicodeString( &str2, L"\\BaseNamedObjects\\Local" );
+    pRtlInitUnicodeString( &str2, localW );
     status = pNtOpenSymbolicLinkObject( &ret, SYMBOLIC_LINK_QUERY, &attr3 );
     ok( status == STATUS_SUCCESS, "can't open BaseNamedObjects\\Local %x\n", status );
     attr3.ObjectName = &str;
@@ -623,8 +656,8 @@ static void test_name_limits(void)
     attr2.ObjectName = attr3.ObjectName = &str;
 
     /* named pipes */
-    wcscpy( str.Buffer, pipeW );
-    for (i = 0; i < 65536 / sizeof(WCHAR); i++) str.Buffer[i + wcslen( pipeW )] = 'a';
+    memcpy( str.Buffer, pipeW, sizeof(pipeW) );
+    for (i = 0; i < 65536 / sizeof(WCHAR); i++) str.Buffer[i + ARRAY_SIZE(pipeW)] = 'a';
     str.Length = 0;
     attr.RootDirectory = 0;
     attr.Attributes = OBJ_CASE_INSENSITIVE;
@@ -676,8 +709,8 @@ static void test_name_limits(void)
     attr2.ObjectName = attr3.ObjectName = &str;
 
     /* mailslots */
-    wcscpy( str.Buffer, mailslotW );
-    for (i = 0; i < 65536 / sizeof(WCHAR); i++) str.Buffer[i + wcslen( mailslotW )] = 'a';
+    memcpy( str.Buffer, mailslotW, sizeof(mailslotW) );
+    for (i = 0; i < 65536 / sizeof(WCHAR); i++) str.Buffer[i + ARRAY_SIZE(mailslotW)] = 'a';
     str.Length = 0;
     status = pNtCreateMailslotFile( &ret, GENERIC_ALL, &attr, &iosb, 0, 0, 0, NULL );
     ok( status == STATUS_OBJECT_PATH_SYNTAX_BAD, "%u: NtCreateMailslotFile failed %x\n", str.Length, status );
@@ -717,8 +750,8 @@ static void test_name_limits(void)
     attr2.ObjectName = attr3.ObjectName = &str;
 
     /* registry keys */
-    wcscpy( str.Buffer, registryW );
-    for (i = 0; i < 65536 / sizeof(WCHAR); i++) str.Buffer[i + wcslen(registryW)] = 'a';
+    memcpy( str.Buffer, registryW, sizeof(registryW) );
+    for (i = 0; i < 65536 / sizeof(WCHAR); i++) str.Buffer[i + ARRAY_SIZE(registryW)] = 'a';
     str.Length = 0;
     status = pNtCreateKey( &ret, GENERIC_ALL, &attr, 0, NULL, 0, NULL );
     todo_wine
@@ -727,7 +760,7 @@ static void test_name_limits(void)
     ok( status == STATUS_INVALID_HANDLE, "%u: NtCreateKey failed %x\n", str.Length, status );
     status = pNtOpenKey( &ret, GENERIC_ALL, &attr2 );
     ok( status == STATUS_INVALID_HANDLE, "%u: NtOpenKey failed %x\n", str.Length, status );
-    str.Length = (wcslen( registryW ) + 250) * sizeof(WCHAR) + 1;
+    str.Length = sizeof(registryW) + 250 * sizeof(WCHAR) + 1;
     status = pNtCreateKey( &ret, GENERIC_ALL, &attr, 0, NULL, 0, NULL );
     ok( status == STATUS_OBJECT_NAME_INVALID ||
         status == STATUS_INVALID_PARAMETER ||
@@ -738,7 +771,7 @@ static void test_name_limits(void)
         pNtDeleteKey( ret );
         pNtClose( ret );
     }
-    str.Length = (wcslen( registryW ) + 256) * sizeof(WCHAR);
+    str.Length = sizeof(registryW) + 256 * sizeof(WCHAR);
     status = pNtCreateKey( &ret, GENERIC_ALL, &attr, 0, NULL, 0, NULL );
     ok( status == STATUS_SUCCESS || status == STATUS_ACCESS_DENIED,
         "%u: NtCreateKey failed %x\n", str.Length, status );
@@ -755,7 +788,7 @@ static void test_name_limits(void)
         pNtDeleteKey( ret );
         pNtClose( ret );
 
-        str.Length = (wcslen( registryW ) + 256) * sizeof(WCHAR);
+        str.Length = sizeof(registryW) + 256 * sizeof(WCHAR);
         for (attr.Length = 0; attr.Length <= 2 * sizeof(attr); attr.Length++)
         {
             if (attr.Length == sizeof(attr))
@@ -778,7 +811,7 @@ static void test_name_limits(void)
         }
         attr.Length = sizeof(attr);
     }
-    str.Length = (wcslen( registryW ) + 256) * sizeof(WCHAR) + 1;
+    str.Length = sizeof(registryW) + 256 * sizeof(WCHAR) + 1;
     status = pNtCreateKey( &ret, GENERIC_ALL, &attr, 0, NULL, 0, NULL );
     ok( status == STATUS_OBJECT_NAME_INVALID ||
         status == STATUS_INVALID_PARAMETER ||
@@ -835,7 +868,7 @@ static void test_name_limits(void)
     attr2.ObjectName = attr3.ObjectName = NULL;
     status = pNtCreateKey( &ret, GENERIC_ALL, &attr2, 0, NULL, 0, NULL );
     todo_wine
-    ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_HANDLE /* vista wow64 */,
+    ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_HANDLE,
         "NULL: NtCreateKey failed %x\n", status );
     status = pNtCreateKey( &ret, GENERIC_ALL, &attr3, 0, NULL, 0, NULL );
     todo_wine
@@ -843,7 +876,7 @@ static void test_name_limits(void)
     status = pNtCreateKey( &ret, GENERIC_ALL, NULL, 0, NULL, 0, NULL );
     ok( status == STATUS_ACCESS_VIOLATION, "NULL: NtCreateKey failed %x\n", status );
     status = pNtOpenKey( &ret, GENERIC_ALL, &attr2 );
-    ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_HANDLE /* vista wow64 */,
+    ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_HANDLE,
         "NULL: NtOpenKey failed %x\n", status );
     status = pNtOpenKey( &ret, GENERIC_ALL, &attr3 );
     ok( status == STATUS_ACCESS_VIOLATION, "NULL: NtOpenKey failed %x\n", status );
@@ -851,7 +884,8 @@ static void test_name_limits(void)
     ok( status == STATUS_ACCESS_VIOLATION, "NULL: NtOpenKey failed %x\n", status );
     attr2.ObjectName = attr3.ObjectName = &str;
 
-    HeapFree( GetProcessHeap(), 0, str.Buffer );
+    pRtlFreeUnicodeString( &str );
+    pRtlFreeUnicodeString( &target );
 }
 
 static void test_directory(void)
@@ -860,14 +894,15 @@ static void test_directory(void)
     UNICODE_STRING str;
     OBJECT_ATTRIBUTES attr;
     HANDLE dir, dir1, h, h2;
-    WCHAR buffer[256];
-    ULONG len, full_len;
+    BOOL is_nt4;
 
     /* No name and/or no attributes */
     status = pNtCreateDirectoryObject(NULL, DIRECTORY_QUERY, &attr);
-    ok(status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_PARAMETER /* wow64 */, "got %#x\n", status);
+    ok(status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_PARAMETER,
+        "NtCreateDirectoryObject should have failed with STATUS_ACCESS_VIOLATION got(%08x)\n", status);
     status = pNtOpenDirectoryObject(NULL, DIRECTORY_QUERY, &attr);
-    ok(status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_PARAMETER /* wow64 */, "got %#x\n", status);
+    ok(status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_PARAMETER,
+        "NtOpenDirectoryObject should have failed with STATUS_ACCESS_VIOLATION got(%08x)\n", status);
 
     status = pNtCreateDirectoryObject(&h, DIRECTORY_QUERY, NULL);
     ok(status == STATUS_SUCCESS, "Failed to create Directory without attributes(%08x)\n", status);
@@ -885,25 +920,27 @@ static void test_directory(void)
     /* Bad name */
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
 
-    RtlInitUnicodeString(&str, L"");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "");
     status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
     pNtClose(h);
     status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_OBJECT_PATH_SYNTAX_BAD, "NtOpenDirectoryObject got %08x\n", status );
+    pRtlFreeUnicodeString(&str);
     pNtClose(dir);
 
-    check_create_open_dir( NULL, L"BaseNamedObjects", STATUS_OBJECT_PATH_SYNTAX_BAD );
-    check_create_open_dir( NULL, L"\\BaseNamedObjects\\", STATUS_OBJECT_NAME_INVALID );
-    check_create_open_dir( NULL, L"\\\\BaseNamedObjects", STATUS_OBJECT_NAME_INVALID );
-    check_create_open_dir( NULL, L"\\BaseNamedObjects\\\\om.c-test", STATUS_OBJECT_NAME_INVALID );
-    check_create_open_dir( NULL, L"\\BaseNamedObjects\\om.c-test\\", STATUS_OBJECT_PATH_NOT_FOUND );
+    DIR_TEST_CREATE_OPEN( "BaseNamedObjects", STATUS_OBJECT_PATH_SYNTAX_BAD );
+    DIR_TEST_CREATE_OPEN( "\\BaseNamedObjects\\", STATUS_OBJECT_NAME_INVALID );
+    DIR_TEST_CREATE_OPEN( "\\\\BaseNamedObjects", STATUS_OBJECT_NAME_INVALID );
+    DIR_TEST_CREATE_OPEN( "\\BaseNamedObjects\\\\om.c-test", STATUS_OBJECT_NAME_INVALID );
+    DIR_TEST_CREATE_OPEN( "\\BaseNamedObjects\\om.c-test\\", STATUS_OBJECT_PATH_NOT_FOUND );
 
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects\\om.c-test");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects\\om.c-test");
     status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
     status = pNtOpenDirectoryObject( &dir1, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to open directory %08x\n", status );
+    pRtlFreeUnicodeString(&str);
     pNtClose(h);
     pNtClose(dir1);
 
@@ -911,166 +948,201 @@ static void test_directory(void)
     /* Use of root directory */
 
     /* Can't use symlinks as a directory */
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects\\Local");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects\\Local");
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtOpenSymbolicLinkObject(&dir, SYMBOLIC_LINK_QUERY, &attr);
+    is_nt4 = (status == STATUS_OBJECT_NAME_NOT_FOUND);  /* nt4 doesn't have Local\\ symlink */
+    if (!is_nt4)
+    {
+        WCHAR buffer[256];
+        ULONG len, full_len;
+
+        ok(status == STATUS_SUCCESS, "Failed to open SymbolicLink(%08x)\n", status);
+        pRtlFreeUnicodeString(&str);
+        InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
+        pRtlCreateUnicodeStringFromAsciiz(&str, "one more level");
+        status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
+        ok( status == STATUS_OBJECT_TYPE_MISMATCH, "NtCreateDirectoryObject got %08x\n", status );
+        pRtlFreeUnicodeString(&str);
+
+        pRtlCreateUnicodeStringFromAsciiz( &str, "\\BaseNamedObjects\\Local\\om.c-test" );
+        InitializeObjectAttributes( &attr, &str, 0, 0, NULL );
+        status = pNtCreateDirectoryObject( &dir1, DIRECTORY_QUERY, &attr );
+        ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
+        pRtlFreeUnicodeString( &str );
+        pRtlCreateUnicodeStringFromAsciiz( &str, "om.c-test" );
+        InitializeObjectAttributes( &attr, &str, 0, dir, NULL );
+        status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr );
+        ok( status == STATUS_OBJECT_TYPE_MISMATCH, "Failed to open directory %08x\n", status );
+        if (!status) pNtClose(h);
+        pRtlFreeUnicodeString( &str );
+
+        pRtlCreateUnicodeStringFromAsciiz( &str, "om.c-event" );
+        InitializeObjectAttributes( &attr, &str, 0, dir1, NULL );
+        status = pNtCreateEvent( &h, GENERIC_ALL, &attr, 1, 0 );
+        ok( status == STATUS_SUCCESS, "NtCreateEvent failed %x\n", status );
+        status = pNtOpenEvent( &h2, GENERIC_ALL, &attr );
+        ok( status == STATUS_SUCCESS, "NtOpenEvent failed %x\n", status );
+        pNtClose( h2 );
+        pRtlFreeUnicodeString( &str );
+        pRtlCreateUnicodeStringFromAsciiz( &str, "om.c-test\\om.c-event" );
+        InitializeObjectAttributes( &attr, &str, 0, dir, NULL );
+        status = pNtOpenEvent( &h2, GENERIC_ALL, &attr );
+        ok( status == STATUS_OBJECT_TYPE_MISMATCH, "NtOpenEvent failed %x\n", status );
+        pRtlFreeUnicodeString( &str );
+        pRtlCreateUnicodeStringFromAsciiz( &str, "\\BasedNamedObjects\\Local\\om.c-test\\om.c-event" );
+        InitializeObjectAttributes( &attr, &str, 0, 0, NULL );
+        status = pNtOpenEvent( &h2, GENERIC_ALL, &attr );
+        ok( status == STATUS_OBJECT_PATH_NOT_FOUND, "NtOpenEvent failed %x\n", status );
+        pRtlFreeUnicodeString( &str );
+        pNtClose( h );
+        pNtClose( dir1 );
+
+        str.Buffer = buffer;
+        str.MaximumLength = sizeof(buffer);
+        len = 0xdeadbeef;
+        memset( buffer, 0xaa, sizeof(buffer) );
+        status = pNtQuerySymbolicLinkObject( dir, &str, &len );
+        ok( status == STATUS_SUCCESS, "NtQuerySymbolicLinkObject failed %08x\n", status );
+        if (status != STATUS_SUCCESS)
+            goto error;
+        full_len = str.Length + sizeof(WCHAR);
+        ok( len == full_len, "bad length %u/%u\n", len, full_len );
+        if (len == full_len)
+            ok( buffer[len / sizeof(WCHAR) - 1] == 0, "no terminating null\n" );
+
+        str.MaximumLength = str.Length;
+        len = 0xdeadbeef;
+        status = pNtQuerySymbolicLinkObject( dir, &str, &len );
+        ok( status == STATUS_BUFFER_TOO_SMALL, "NtQuerySymbolicLinkObject failed %08x\n", status );
+        ok( len == full_len, "bad length %u/%u\n", len, full_len );
+
+        str.MaximumLength = 0;
+        len = 0xdeadbeef;
+        status = pNtQuerySymbolicLinkObject( dir, &str, &len );
+        ok( status == STATUS_BUFFER_TOO_SMALL, "NtQuerySymbolicLinkObject failed %08x\n", status );
+        ok( len == full_len, "bad length %u/%u\n", len, full_len );
+
+        str.MaximumLength = str.Length + sizeof(WCHAR);
+        len = 0xdeadbeef;
+        status = pNtQuerySymbolicLinkObject( dir, &str, &len );
+        ok( status == STATUS_SUCCESS, "NtQuerySymbolicLinkObject failed %08x\n", status );
+        ok( len == full_len, "bad length %u/%u\n", len, full_len );
+
+error:
+        pNtClose(dir);
+    }
 
-    ok(status == STATUS_SUCCESS, "Failed to open SymbolicLink(%08x)\n", status);
-    InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
-    RtlInitUnicodeString(&str, L"one more level");
-    status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH, "NtCreateDirectoryObject got %08x\n", status );
-
-    RtlInitUnicodeString( &str, L"\\BaseNamedObjects\\Local\\om.c-test" );
-    InitializeObjectAttributes( &attr, &str, 0, 0, NULL );
-    status = pNtCreateDirectoryObject( &dir1, DIRECTORY_QUERY, &attr );
-    ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
-    RtlInitUnicodeString( &str, L"om.c-test" );
-    InitializeObjectAttributes( &attr, &str, 0, dir, NULL );
-    status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH, "Failed to open directory %08x\n", status );
-
-    RtlInitUnicodeString( &str, L"om.c-event" );
-    InitializeObjectAttributes( &attr, &str, 0, dir1, NULL );
-    status = pNtCreateEvent( &h, GENERIC_ALL, &attr, 1, 0 );
-    ok( status == STATUS_SUCCESS, "NtCreateEvent failed %x\n", status );
-    status = pNtOpenEvent( &h2, GENERIC_ALL, &attr );
-    ok( status == STATUS_SUCCESS, "NtOpenEvent failed %x\n", status );
-    pNtClose( h2 );
-    RtlInitUnicodeString( &str, L"om.c-test\\om.c-event" );
-    InitializeObjectAttributes( &attr, &str, 0, dir, NULL );
-    status = pNtOpenEvent( &h2, GENERIC_ALL, &attr );
-    ok( status == STATUS_OBJECT_TYPE_MISMATCH, "NtOpenEvent failed %x\n", status );
-    RtlInitUnicodeString( &str, L"\\BasedNamedObjects\\Local\\om.c-test\\om.c-event" );
-    InitializeObjectAttributes( &attr, &str, 0, 0, NULL );
-    status = pNtOpenEvent( &h2, GENERIC_ALL, &attr );
-    ok( status == STATUS_OBJECT_PATH_NOT_FOUND, "NtOpenEvent failed %x\n", status );
-    pNtClose( h );
-    pNtClose( dir1 );
-
-    str.Buffer = buffer;
-    str.MaximumLength = sizeof(buffer);
-    len = 0xdeadbeef;
-    memset( buffer, 0xaa, sizeof(buffer) );
-    status = pNtQuerySymbolicLinkObject( dir, &str, &len );
-    ok( status == STATUS_SUCCESS, "NtQuerySymbolicLinkObject failed %08x\n", status );
-    full_len = str.Length + sizeof(WCHAR);
-    ok( len == full_len, "bad length %u/%u\n", len, full_len );
-    ok( buffer[len / sizeof(WCHAR) - 1] == 0, "no terminating null\n" );
-
-    str.MaximumLength = str.Length;
-    len = 0xdeadbeef;
-    status = pNtQuerySymbolicLinkObject( dir, &str, &len );
-    ok( status == STATUS_BUFFER_TOO_SMALL, "NtQuerySymbolicLinkObject failed %08x\n", status );
-    ok( len == full_len, "bad length %u/%u\n", len, full_len );
-
-    str.MaximumLength = 0;
-    len = 0xdeadbeef;
-    status = pNtQuerySymbolicLinkObject( dir, &str, &len );
-    ok( status == STATUS_BUFFER_TOO_SMALL, "NtQuerySymbolicLinkObject failed %08x\n", status );
-    ok( len == full_len, "bad length %u/%u\n", len, full_len );
-
-    str.MaximumLength = str.Length + sizeof(WCHAR);
-    len = 0xdeadbeef;
-    status = pNtQuerySymbolicLinkObject( dir, &str, &len );
-    ok( status == STATUS_SUCCESS, "NtQuerySymbolicLinkObject failed %08x\n", status );
-    ok( len == full_len, "bad length %u/%u\n", len, full_len );
-
-    pNtClose(dir);
-
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects");
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtOpenDirectoryObject( &dir, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to open directory %08x\n", status );
+    pRtlFreeUnicodeString(&str);
 
     InitializeObjectAttributes(&attr, NULL, 0, dir, NULL);
     status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_OBJECT_NAME_INVALID, "NtOpenDirectoryObject got %08x\n", status );
 
-    check_create_open_dir( dir, L"", STATUS_SUCCESS );
-    check_create_open_dir( dir, L"\\", STATUS_OBJECT_PATH_SYNTAX_BAD );
-    check_create_open_dir( dir, L"\\om.c-test", STATUS_OBJECT_PATH_SYNTAX_BAD );
-    check_create_open_dir( dir, L"\\om.c-test\\", STATUS_OBJECT_PATH_SYNTAX_BAD );
-    check_create_open_dir( dir, L"om.c-test\\", STATUS_OBJECT_PATH_NOT_FOUND );
-
     InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
-    RtlInitUnicodeString(&str, L"om.c-test");
+    DIR_TEST_CREATE_OPEN( "", STATUS_SUCCESS );
+    DIR_TEST_CREATE_OPEN( "\\", STATUS_OBJECT_PATH_SYNTAX_BAD );
+    DIR_TEST_CREATE_OPEN( "\\om.c-test", STATUS_OBJECT_PATH_SYNTAX_BAD );
+    DIR_TEST_CREATE_OPEN( "\\om.c-test\\", STATUS_OBJECT_PATH_SYNTAX_BAD );
+    DIR_TEST_CREATE_OPEN( "om.c-test\\", STATUS_OBJECT_PATH_NOT_FOUND );
+
+    pRtlCreateUnicodeStringFromAsciiz(&str, "om.c-test");
     status = pNtCreateDirectoryObject( &dir1, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
     status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to open directory %08x\n", status );
+    pRtlFreeUnicodeString(&str);
 
     pNtClose(h);
     pNtClose(dir1);
     pNtClose(dir);
 
     /* Nested directories */
-    RtlInitUnicodeString(&str, L"\\");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\");
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtOpenDirectoryObject( &dir, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to open directory %08x\n", status );
     InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
     status = pNtOpenDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_OBJECT_PATH_SYNTAX_BAD, "NtOpenDirectoryObject got %08x\n", status );
+    pRtlFreeUnicodeString(&str);
     pNtClose(dir);
 
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects\\om.c-test");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects\\om.c-test");
     status = pNtCreateDirectoryObject( &dir, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects\\om.c-test\\one more level");
+    pRtlFreeUnicodeString(&str);
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects\\om.c-test\\one more level");
     status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
+    pRtlFreeUnicodeString(&str);
     pNtClose(h);
     InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
-    RtlInitUnicodeString(&str, L"one more level");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "one more level");
     status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
+    pRtlFreeUnicodeString(&str);
     pNtClose(h);
 
     pNtClose(dir);
 
-    InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects\\Global\\om.c-test");
-    status = pNtCreateDirectoryObject( &dir, DIRECTORY_QUERY, &attr );
-    ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects\\Local\\om.c-test\\one more level");
-    status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
-    ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
-    pNtClose(h);
-    InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
-    RtlInitUnicodeString(&str, L"one more level");
-    status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
-    ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
-    pNtClose(h);
-    pNtClose(dir);
+    if (!is_nt4)
+    {
+        InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
+        pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects\\Global\\om.c-test");
+        status = pNtCreateDirectoryObject( &dir, DIRECTORY_QUERY, &attr );
+        ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
+        pRtlFreeUnicodeString(&str);
+        pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects\\Local\\om.c-test\\one more level");
+        status = pNtCreateDirectoryObject( &h, DIRECTORY_QUERY, &attr );
+        ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
+        pRtlFreeUnicodeString(&str);
+        pNtClose(h);
+        InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
+        pRtlCreateUnicodeStringFromAsciiz(&str, "one more level");
+        status = pNtCreateDirectoryObject( &dir, DIRECTORY_QUERY, &attr );
+        ok( status == STATUS_SUCCESS, "Failed to create directory %08x\n", status );
+        pRtlFreeUnicodeString(&str);
+        pNtClose(h);
+        pNtClose(dir);
+    }
 
     /* Create other objects using RootDirectory */
 
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\BaseNamedObjects");
     status = pNtOpenDirectoryObject( &dir, DIRECTORY_QUERY, &attr );
     ok( status == STATUS_SUCCESS, "Failed to open directory %08x\n", status );
+    pRtlFreeUnicodeString(&str);
     InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
 
     /* Test invalid paths */
-    RtlInitUnicodeString(&str, L"\\om.c-mutant");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\om.c-mutant");
     status = pNtCreateMutant(&h, GENERIC_ALL, &attr, FALSE);
     ok(status == STATUS_OBJECT_PATH_SYNTAX_BAD,
         "NtCreateMutant should have failed with STATUS_OBJECT_PATH_SYNTAX_BAD got(%08x)\n", status);
-    RtlInitUnicodeString(&str, L"\\om.c-mutant\\");
+    pRtlFreeUnicodeString(&str);
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\om.c-mutant\\");
     status = pNtCreateMutant(&h, GENERIC_ALL, &attr, FALSE);
     ok(status == STATUS_OBJECT_PATH_SYNTAX_BAD,
         "NtCreateMutant should have failed with STATUS_OBJECT_PATH_SYNTAX_BAD got(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
 
-    RtlInitUnicodeString(&str, L"om.c\\-mutant");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "om.c\\-mutant");
     status = pNtCreateMutant(&h, GENERIC_ALL, &attr, FALSE);
     ok(status == STATUS_OBJECT_PATH_NOT_FOUND,
         "NtCreateMutant should have failed with STATUS_OBJECT_PATH_NOT_FOUND got(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
 
-    RtlInitUnicodeString(&str, L"om.c-mutant");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "om.c-mutant");
     status = pNtCreateMutant(&h, GENERIC_ALL, &attr, FALSE);
     ok(status == STATUS_SUCCESS, "Failed to create Mutant(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
     pNtClose(h);
 
     pNtClose(dir);
@@ -1086,11 +1158,13 @@ static void test_symboliclink(void)
 
     /* No name and/or no attributes */
     InitializeObjectAttributes(&attr, NULL, 0, 0, NULL);
-    RtlInitUnicodeString(&target, L"\\DosDevices");
+    pRtlCreateUnicodeStringFromAsciiz(&target, "\\DosDevices");
     status = pNtCreateSymbolicLinkObject( NULL, SYMBOLIC_LINK_QUERY, &attr, &target );
-    ok(status == STATUS_ACCESS_VIOLATION, "got %#x\n", status);
+    ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_PARAMETER,
+       "NtCreateSymbolicLinkObject got %08x\n", status );
     status = pNtOpenSymbolicLinkObject( NULL, SYMBOLIC_LINK_QUERY, &attr );
-    ok(status == STATUS_ACCESS_VIOLATION, "got %#x\n", status);
+    ok( status == STATUS_ACCESS_VIOLATION || status == STATUS_INVALID_PARAMETER,
+       "NtOpenSymbolicLinkObject got %08x\n", status );
 
     status = pNtCreateSymbolicLinkObject(&h, SYMBOLIC_LINK_QUERY, NULL, NULL);
     ok(status == STATUS_ACCESS_VIOLATION,
@@ -1103,77 +1177,100 @@ static void test_symboliclink(void)
     status = pNtCreateSymbolicLinkObject(&h, SYMBOLIC_LINK_QUERY, NULL, &target);
     ok(status == STATUS_SUCCESS || status == STATUS_ACCESS_VIOLATION, /* nt4 */
        "NtCreateSymbolicLinkObject failed(%08x)\n", status);
+    pRtlFreeUnicodeString(&target);
+    if (!status) pNtClose(h);
 
     InitializeObjectAttributes(&attr, NULL, 0, 0, NULL);
-    memset(&target, 0, sizeof(target));
     status = pNtCreateSymbolicLinkObject(&link, SYMBOLIC_LINK_QUERY, &attr, &target);
-    ok(status == STATUS_INVALID_PARAMETER, "got %#x\n", status);
+    ok(status == STATUS_INVALID_PARAMETER ||
+       broken(status == STATUS_SUCCESS),  /* nt4 */
+       "NtCreateSymbolicLinkObject should have failed with STATUS_INVALID_PARAMETER got(%08x)\n", status);
+    if (!status) pNtClose(h);
     status = pNtOpenSymbolicLinkObject(&h, SYMBOLIC_LINK_QUERY, &attr);
     ok(status == STATUS_OBJECT_PATH_SYNTAX_BAD,
        "NtOpenSymbolicLinkObject should have failed with STATUS_OBJECT_PATH_SYNTAX_BAD got(%08x)\n", status);
 
     /* Bad name */
-    RtlInitUnicodeString(&target, L"anywhere");
+    pRtlCreateUnicodeStringFromAsciiz(&target, "anywhere");
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
 
-    RtlInitUnicodeString(&str, L"");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "");
     status = pNtCreateSymbolicLinkObject(&link, SYMBOLIC_LINK_QUERY, &attr, &target);
     ok(status == STATUS_SUCCESS, "Failed to create SymbolicLink(%08x)\n", status);
     status = pNtOpenSymbolicLinkObject(&h, SYMBOLIC_LINK_QUERY, &attr);
     ok(status == STATUS_OBJECT_PATH_SYNTAX_BAD,
        "NtOpenSymbolicLinkObject should have failed with STATUS_OBJECT_PATH_SYNTAX_BAD got(%08x)\n", status);
     pNtClose(link);
+    pRtlFreeUnicodeString(&str);
 
-    RtlInitUnicodeString(&str, L"\\");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\");
     status = pNtCreateSymbolicLinkObject(&h, SYMBOLIC_LINK_QUERY, &attr, &target);
     todo_wine ok(status == STATUS_OBJECT_TYPE_MISMATCH,
                  "NtCreateSymbolicLinkObject should have failed with STATUS_OBJECT_TYPE_MISMATCH got(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
+    pRtlFreeUnicodeString(&target);
 
-    RtlInitUnicodeString( &target, L"->Somewhere");
+    pRtlCreateUnicodeStringFromAsciiz( &target, "->Somewhere");
 
-    RtlInitUnicodeString( &str, L"BaseNamedObjects" );
+    pRtlCreateUnicodeStringFromAsciiz( &str, "BaseNamedObjects" );
     status = pNtCreateSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr, &target );
     ok( status == STATUS_OBJECT_PATH_SYNTAX_BAD, "NtCreateSymbolicLinkObject got %08x\n", status );
     status = pNtOpenSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr );
     ok( status == STATUS_OBJECT_PATH_SYNTAX_BAD, "NtOpenSymbolicLinkObject got %08x\n", status );
+    pRtlFreeUnicodeString( &str );
 
-    RtlInitUnicodeString( &str, L"\\BaseNamedObjects\\" );
+    pRtlCreateUnicodeStringFromAsciiz( &str, "\\BaseNamedObjects\\" );
     status = pNtCreateSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr, &target );
     ok( status == STATUS_OBJECT_NAME_INVALID, "NtCreateSymbolicLinkObject got %08x\n", status );
     status = pNtOpenSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr );
     ok( status == STATUS_OBJECT_NAME_INVALID, "NtOpenSymbolicLinkObject got %08x\n", status );
+    pRtlFreeUnicodeString( &str );
 
-    RtlInitUnicodeString( &str, L"\\\\BaseNamedObjects" );
+    pRtlCreateUnicodeStringFromAsciiz( &str, "\\\\BaseNamedObjects" );
     status = pNtCreateSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr, &target );
     ok( status == STATUS_OBJECT_NAME_INVALID, "NtCreateSymbolicLinkObject got %08x\n", status );
     status = pNtOpenSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr );
     ok( status == STATUS_OBJECT_NAME_INVALID, "NtOpenSymbolicLinkObject got %08x\n", status );
+    pRtlFreeUnicodeString( &str );
 
-    RtlInitUnicodeString( &str, L"\\BaseNamedObjects\\\\om.c-test" );
+    pRtlCreateUnicodeStringFromAsciiz( &str, "\\BaseNamedObjects\\\\om.c-test" );
     status = pNtCreateSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr, &target );
     ok( status == STATUS_OBJECT_NAME_INVALID, "NtCreateSymbolicLinkObject got %08x\n", status );
     status = pNtOpenSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr );
     ok( status == STATUS_OBJECT_NAME_INVALID, "NtOpenSymbolicLinkObject got %08x\n", status );
+    pRtlFreeUnicodeString( &str );
 
-    RtlInitUnicodeString( &str, L"\\BaseNamedObjects\\om.c-test\\" );
+    pRtlCreateUnicodeStringFromAsciiz( &str, "\\BaseNamedObjects\\om.c-test\\" );
     status = pNtCreateSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr, &target );
-    ok( status == STATUS_OBJECT_PATH_NOT_FOUND, "got %#x\n", status );
+    ok( status == STATUS_OBJECT_NAME_INVALID || status == STATUS_OBJECT_PATH_NOT_FOUND,
+        "NtCreateSymbolicLinkObject got %08x\n", status );
     status = pNtOpenSymbolicLinkObject( &h, SYMBOLIC_LINK_QUERY, &attr );
-    ok( status == STATUS_OBJECT_PATH_NOT_FOUND, "got %#x\n", status );
+    ok( status == STATUS_OBJECT_NAME_INVALID || status == STATUS_OBJECT_PATH_NOT_FOUND,
+        "NtOpenSymbolicLinkObject got %08x\n", status );
+    pRtlFreeUnicodeString( &str );
+    pRtlFreeUnicodeString(&target);
 
     /* Compound test */
-    dir = get_base_dir();
+    if (!(dir = get_base_dir()))
+    {
+        win_skip( "couldn't find the BaseNamedObjects dir\n" );
+        return;
+    }
+
     InitializeObjectAttributes(&attr, &str, 0, dir, NULL);
-    RtlInitUnicodeString(&str, L"test-link");
-    RtlInitUnicodeString(&target, L"\\DosDevices");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "test-link");
+    pRtlCreateUnicodeStringFromAsciiz(&target, "\\DosDevices");
     status = pNtCreateSymbolicLinkObject(&link, SYMBOLIC_LINK_QUERY, &attr, &target);
     ok(status == STATUS_SUCCESS, "Failed to create SymbolicLink(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
+    pRtlFreeUnicodeString(&target);
 
-    RtlInitUnicodeString(&str, L"test-link\\NUL");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "test-link\\NUL");
     status = pNtOpenFile(&h, GENERIC_READ, &attr, &iosb, FILE_SHARE_READ|FILE_SHARE_WRITE, 0);
     ok(status == STATUS_SUCCESS, "Failed to open NUL device(%08x)\n", status);
     status = pNtOpenFile(&h, GENERIC_READ, &attr, &iosb, FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_DIRECTORY_FILE);
     ok(status == STATUS_SUCCESS, "Failed to open NUL device(%08x)\n", status);
+    pRtlFreeUnicodeString(&str);
 
     pNtClose(h);
     pNtClose(link);
@@ -1188,7 +1285,7 @@ static void _test_file_info(unsigned line, HANDLE handle)
     NTSTATUS status;
 
     status = pNtQueryInformationFile(handle, &io, buf, sizeof(buf), 0xdeadbeef);
-    ok_(__FILE__,line)(status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED /* Vista+ */,
+    ok_(__FILE__,line)(status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED,
                        "expected STATUS_NOT_IMPLEMENTED, got %x\n", status);
 
     status = pNtQueryInformationFile(handle, &io, buf, sizeof(buf), FileAccessInformation);
@@ -1196,7 +1293,7 @@ static void _test_file_info(unsigned line, HANDLE handle)
 
     status = pNtQueryInformationFile(handle, &io, buf, sizeof(buf),
                                     FileIoCompletionNotificationInformation);
-    ok_(__FILE__,line)(status == STATUS_SUCCESS || broken(status == STATUS_INVALID_INFO_CLASS) /* XP */,
+    ok_(__FILE__,line)(status == STATUS_SUCCESS || broken(status == STATUS_INVALID_INFO_CLASS),
                        "FileIoCompletionNotificationInformation returned %x\n", status);
 }
 
@@ -1208,7 +1305,7 @@ static void _test_no_file_info(unsigned line, HANDLE handle)
     NTSTATUS status;
 
     status = pNtQueryInformationFile(handle, &io, buf, sizeof(buf), 0xdeadbeef);
-    ok_(__FILE__,line)(status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED /* Vista+ */,
+    ok_(__FILE__,line)(status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED,
                        "expected STATUS_NOT_IMPLEMENTED, got %x\n", status);
 
     status = pNtQueryInformationFile(handle, &io, buf, sizeof(buf), FileAccessInformation);
@@ -1217,68 +1314,48 @@ static void _test_no_file_info(unsigned line, HANDLE handle)
 
     status = pNtQueryInformationFile(handle, &io, buf, sizeof(buf),
                                     FileIoCompletionNotificationInformation);
-    ok_(__FILE__,line)(status == STATUS_OBJECT_TYPE_MISMATCH || broken(status == STATUS_INVALID_INFO_CLASS) /* XP */,
+    ok_(__FILE__,line)(status == STATUS_OBJECT_TYPE_MISMATCH || broken(status == STATUS_INVALID_INFO_CLASS),
                        "FileIoCompletionNotificationInformation returned %x\n", status);
 }
 
-static BOOL compare_unicode_string( const UNICODE_STRING *string, const WCHAR *expect )
-{
-    return string->Length == wcslen( expect ) * sizeof(WCHAR)
-            && !wcsnicmp( string->Buffer, expect, string->Length / sizeof(WCHAR) );
-}
-
-#define test_object_type(a,b) _test_object_type(__LINE__,a,b,FALSE)
-#define test_object_type_todo(a,b) _test_object_type(__LINE__,a,b,TRUE)
-static void _test_object_type( unsigned line, HANDLE handle, const WCHAR *expected_name, BOOL todo )
+#define test_object_type(a,b) _test_object_type(__LINE__,a,b)
+static void _test_object_type(unsigned line, HANDLE handle, const char *expected_name)
 {
     char buffer[1024];
     UNICODE_STRING *str = (UNICODE_STRING *)buffer, expect;
     ULONG len = 0;
     NTSTATUS status;
 
-    RtlInitUnicodeString( &expect, expected_name );
+    pRtlCreateUnicodeStringFromAsciiz( &expect, expected_name );
 
     memset( buffer, 0, sizeof(buffer) );
     status = pNtQueryObject( handle, ObjectTypeInformation, buffer, sizeof(buffer), &len );
     ok_(__FILE__,line)( status == STATUS_SUCCESS, "NtQueryObject failed %x\n", status );
     ok_(__FILE__,line)( len > sizeof(UNICODE_STRING), "unexpected len %u\n", len );
-    ok_(__FILE__,line)( len >= sizeof(OBJECT_TYPE_INFORMATION) + str->Length, "unexpected len %u\n", len );
-    todo_wine_if (todo)
-        ok_(__FILE__,line)(compare_unicode_string( str, expected_name ), "wrong name %s\n", debugstr_w( str->Buffer ));
-}
-
-#define test_object_name(a,b,c) _test_object_name(__LINE__,a,b,c)
-static void _test_object_name( unsigned line, HANDLE handle, const WCHAR *expected_name, BOOL todo )
-{
-    char buffer[1024];
-    UNICODE_STRING *str = (UNICODE_STRING *)buffer, expect;
-    ULONG len = 0;
-    NTSTATUS status;
-
-    RtlInitUnicodeString( &expect, expected_name );
+    ok_(__FILE__,line)( len >= sizeof(OBJECT_TYPE_INFORMATION) + str->Length + sizeof(WCHAR), "unexpected len %u\n", len );
+    ok_(__FILE__,line)( str->Length == expect.Length && !memcmp( str->Buffer, expect.Buffer, expect.Length ),
+                        "wrong/bad type name %s (%p)\n", wine_dbgstr_w(str->Buffer), str->Buffer );
 
-    memset( buffer, 0, sizeof(buffer) );
-    status = pNtQueryObject( handle, ObjectNameInformation, buffer, sizeof(buffer), &len );
-    ok_(__FILE__,line)( status == STATUS_SUCCESS, "NtQueryObject failed %x\n", status );
-    ok_(__FILE__,line)( len >= sizeof(OBJECT_NAME_INFORMATION) + str->Length, "unexpected len %u\n", len );
-    todo_wine_if (todo)
-        ok_(__FILE__,line)(compare_unicode_string( str, expected_name ), "wrong name %s\n", debugstr_w( str->Buffer ));
+    pRtlFreeUnicodeString( &expect );
 }
 
 static void test_query_object(void)
 {
-    static const WCHAR name[] = L"\\BaseNamedObjects\\test_event";
+    static const WCHAR name[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s',
+                                 '\\','t','e','s','t','_','e','v','e','n','t'};
+    static const WCHAR type_event[] = {'E','v','e','n','t'};
     HANDLE handle, client;
     char buffer[1024];
     NTSTATUS status;
     ULONG len, expected_len;
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING path, *str;
+    UNICODE_STRING path, session, *str;
     char dir[MAX_PATH], tmp_path[MAX_PATH], file1[MAX_PATH + 16];
-    WCHAR expect[100];
     LARGE_INTEGER size;
     BOOL ret;
 
+    sprintf( tmp_path, "\\Sessions\\%u", NtCurrentTeb()->Peb->SessionId );
+    pRtlCreateUnicodeStringFromAsciiz( &session, tmp_path );
     InitializeObjectAttributes( &attr, &path, 0, 0, 0 );
 
     handle = CreateEventA( NULL, FALSE, FALSE, "test_event" );
@@ -1286,22 +1363,22 @@ static void test_query_object(void)
     len = 0;
     status = pNtQueryObject( handle, ObjectNameInformation, buffer, 0, &len );
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtQueryObject failed %x\n", status );
-    ok( len >= sizeof(UNICODE_STRING) + sizeof(name), "unexpected len %u\n", len );
+    ok( len >= sizeof(UNICODE_STRING) + sizeof(name) + sizeof(WCHAR), "unexpected len %u\n", len );
 
     len = 0;
     status = pNtQueryObject( handle, ObjectTypeInformation, buffer, 0, &len );
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtQueryObject failed %x\n", status );
-    ok( len >= sizeof(OBJECT_TYPE_INFORMATION) + sizeof(L"Event"), "unexpected len %u\n", len );
+    ok( len >= sizeof(OBJECT_TYPE_INFORMATION) + sizeof(type_event) + sizeof(WCHAR), "unexpected len %u\n", len );
 
     len = 0;
     status = pNtQueryObject( handle, ObjectNameInformation, buffer, sizeof(UNICODE_STRING), &len );
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtQueryObject failed %x\n", status );
-    ok( len >= sizeof(UNICODE_STRING) + sizeof(name), "unexpected len %u\n", len );
+    ok( len >= sizeof(UNICODE_STRING) + sizeof(name) + sizeof(WCHAR), "unexpected len %u\n", len );
 
     len = 0;
     status = pNtQueryObject( handle, ObjectTypeInformation, buffer, sizeof(OBJECT_TYPE_INFORMATION), &len );
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtQueryObject failed %x\n", status );
-    ok( len >= sizeof(OBJECT_TYPE_INFORMATION) + sizeof(L"Event"), "unexpected len %u\n", len );
+    ok( len >= sizeof(OBJECT_TYPE_INFORMATION) + sizeof(type_event) + sizeof(WCHAR), "unexpected len %u\n", len );
 
     len = 0;
     status = pNtQueryObject( handle, ObjectNameInformation, buffer, sizeof(buffer), &len );
@@ -1309,27 +1386,28 @@ static void test_query_object(void)
     ok( len > sizeof(UNICODE_STRING), "unexpected len %u\n", len );
     str = (UNICODE_STRING *)buffer;
     ok( sizeof(UNICODE_STRING) + str->Length + sizeof(WCHAR) == len, "unexpected len %u\n", len );
-    ok( str->Length >= sizeof(name) - sizeof(WCHAR), "unexpected len %u\n", str->Length );
+    ok( str->Length >= sizeof(name), "unexpected len %u\n", str->Length );
     ok( len > sizeof(UNICODE_STRING) + sizeof("\\test_event") * sizeof(WCHAR),
         "name too short %s\n", wine_dbgstr_w(str->Buffer) );
     /* check for \\Sessions prefix in the name */
-    swprintf( expect, ARRAY_SIZE(expect), L"\\Sessions\\%u%s", NtCurrentTeb()->Peb->SessionId, name );
-    ok( (str->Length == wcslen( expect ) * sizeof(WCHAR) && !wcscmp( str->Buffer, expect )) ||
-        broken( !wcscmp( str->Buffer, name )), /* winxp */
+    ok( (str->Length > session.Length &&
+         !memcmp( str->Buffer, session.Buffer, session.Length ) &&
+         !memcmp( str->Buffer + session.Length / sizeof(WCHAR), name, sizeof(name) )) ||
+        broken( !memcmp( str->Buffer, name, sizeof(name) )), /* winxp */
         "wrong name %s\n", wine_dbgstr_w(str->Buffer) );
     trace( "got %s len %u\n", wine_dbgstr_w(str->Buffer), len );
 
     len -= sizeof(WCHAR);
     status = pNtQueryObject( handle, ObjectNameInformation, buffer, len, &len );
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtQueryObject failed %x\n", status );
-    ok( len >= sizeof(UNICODE_STRING) + sizeof(name), "unexpected len %u\n", len );
+    ok( len >= sizeof(UNICODE_STRING) + sizeof(name) + sizeof(WCHAR), "unexpected len %u\n", len );
 
-    test_object_type( handle, L"Event" );
+    test_object_type( handle, "Event" );
 
     len -= sizeof(WCHAR);
     status = pNtQueryObject( handle, ObjectTypeInformation, buffer, len, &len );
     ok( status == STATUS_INFO_LENGTH_MISMATCH, "NtQueryObject failed %x\n", status );
-    ok( len >= sizeof(OBJECT_TYPE_INFORMATION) + sizeof(L"Event"), "unexpected len %u\n", len );
+    ok( len >= sizeof(OBJECT_TYPE_INFORMATION) + sizeof(type_event) + sizeof(WCHAR), "unexpected len %u\n", len );
 
     test_no_file_info( handle );
     pNtClose( handle );
@@ -1354,28 +1432,33 @@ static void test_query_object(void)
     ok( len > sizeof(UNICODE_STRING), "unexpected len %u\n", len );
     str = (UNICODE_STRING *)buffer;
     expected_len = sizeof(UNICODE_STRING) + str->Length + sizeof(WCHAR);
-    ok( len == expected_len, "unexpected len %u\n", len );
+    ok( len == expected_len || broken(len == expected_len - sizeof(WCHAR)), /* NT4 */
+        "unexpected len %u\n", len );
     trace( "got %s len %u\n", wine_dbgstr_w(str->Buffer), len );
 
     len = 0;
     status = pNtQueryObject( handle, ObjectNameInformation, buffer, 0, &len );
-    ok( status == STATUS_INFO_LENGTH_MISMATCH, "got %#x\n", status );
-    ok( len == expected_len || broken(!len /* XP */ || len == sizeof(UNICODE_STRING) /* 2003 */),
+    ok( status == STATUS_INFO_LENGTH_MISMATCH || broken(status == STATUS_INSUFFICIENT_RESOURCES),
+        "NtQueryObject failed %x\n", status );
+    ok( len == expected_len || broken(!len || len == sizeof(UNICODE_STRING)),
         "unexpected len %u\n", len );
 
     len = 0;
     status = pNtQueryObject( handle, ObjectNameInformation, buffer, sizeof(UNICODE_STRING), &len );
-    ok( status == STATUS_BUFFER_OVERFLOW, "got %#x\n", status);
-    ok( len == expected_len, "unexpected len %u\n", len );
+    ok( status == STATUS_BUFFER_OVERFLOW || broken(status == STATUS_INSUFFICIENT_RESOURCES
+            || status == STATUS_INFO_LENGTH_MISMATCH),
+        "NtQueryObject failed %x\n", status );
+    ok( len == expected_len || broken(!len),
+        "unexpected len %u\n", len );
 
-    test_object_type( handle, L"File" );
+    test_object_type( handle, "File" );
 
     pNtClose( handle );
 
     GetTempPathA(MAX_PATH, tmp_path);
     GetTempFileNameA(tmp_path, "foo", 0, file1);
     handle = CreateFileA(file1, GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, 0, 0);
-    test_object_type(handle, L"File");
+    test_object_type(handle, "File");
     DeleteFileA( file1 );
     test_file_info( handle );
     pNtClose( handle );
@@ -1383,7 +1466,7 @@ static void test_query_object(void)
     status = pNtCreateIoCompletion( &handle, IO_COMPLETION_ALL_ACCESS, NULL, 0 );
     ok( status == STATUS_SUCCESS, "NtCreateIoCompletion failed %x\n", status);
 
-    test_object_type( handle, L"IoCompletion" );
+    test_object_type( handle, "IoCompletion" );
     test_no_file_info( handle );
 
     pNtClose( handle );
@@ -1391,7 +1474,7 @@ static void test_query_object(void)
     status = pNtCreateDirectoryObject( &handle, DIRECTORY_QUERY, NULL );
     ok(status == STATUS_SUCCESS, "Failed to create Directory %08x\n", status);
 
-    test_object_type( handle, L"Directory" );
+    test_object_type( handle, "Directory" );
     test_no_file_info( handle );
 
     pNtClose( handle );
@@ -1401,42 +1484,27 @@ static void test_query_object(void)
     status = pNtCreateSection( &handle, SECTION_MAP_WRITE, NULL, &size, PAGE_READWRITE, SEC_COMMIT, 0 );
     ok( status == STATUS_SUCCESS , "NtCreateSection returned %x\n", status );
 
-    test_object_type( handle, L"Section" );
+    test_object_type( handle, "Section" );
     test_no_file_info( handle );
 
     pNtClose( handle );
 
     handle = CreateMailslotA( "\\\\.\\mailslot\\test_mailslot", 100, 1000, NULL );
     ok( handle != INVALID_HANDLE_VALUE, "CreateMailslot failed err %u\n", GetLastError() );
-
-    test_object_name( handle, L"\\Device\\Mailslot\\test_mailslot", FALSE );
-    test_object_type( handle, L"File" );
-    test_file_info( handle );
-
-    client = CreateFileA( "\\\\.\\mailslot\\test_mailslot", 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0 );
-    ok( client != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError() );
-
     len = 0;
-    status = pNtQueryObject( client, ObjectNameInformation, buffer, sizeof(buffer), &len );
-    ok( status == STATUS_SUCCESS, "NtQueryObject failed %x\n", status );
+    status = pNtQueryObject( handle, ObjectNameInformation, buffer, sizeof(buffer), &len );
+    ok( status == STATUS_SUCCESS , "NtQueryObject returned %x\n", status );
     str = (UNICODE_STRING *)buffer;
-    ok( len == sizeof(UNICODE_STRING) + str->MaximumLength, "unexpected len %u\n", len );
-    todo_wine
-        ok( compare_unicode_string( str, L"\\Device\\Mailslot" ) ||
-            compare_unicode_string( str, L"\\Device\\Mailslot\\test_mailslot" ) /* win8+ */,
-            "wrong name %s\n", debugstr_w( str->Buffer ));
-
-    test_object_type( client, L"File" );
-    test_file_info( client );
-
-    pNtClose( client );
-    pNtClose( handle );
-
-    handle = CreateFileA( "\\\\.\\mailslot", 0, 0, NULL, OPEN_EXISTING, 0, 0 );
-    ok( handle != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError() );
+    ok( len > sizeof(UNICODE_STRING), "unexpected len %u\n", len );
+    str = (UNICODE_STRING *)buffer;
+    expected_len = sizeof(UNICODE_STRING) + str->Length + sizeof(WCHAR);
+    ok( len == expected_len || broken(len == expected_len - sizeof(WCHAR)), /* NT4 */
+        "unexpected len %u\n", len );
+    ok( len > sizeof(UNICODE_STRING) + sizeof("\\test_mailslot") * sizeof(WCHAR),
+        "name too short %s\n", wine_dbgstr_w(str->Buffer) );
+    trace( "got %s len %u\n", wine_dbgstr_w(str->Buffer), len );
 
-    test_object_name( handle, L"\\Device\\Mailslot", TRUE );
-    test_object_type( handle, L"File" );
+    test_object_type( handle, "File" );
     test_file_info( handle );
 
     pNtClose( handle );
@@ -1444,55 +1512,75 @@ static void test_query_object(void)
     handle = CreateNamedPipeA( "\\\\.\\pipe\\test_pipe", PIPE_ACCESS_DUPLEX, PIPE_READMODE_BYTE,
                                1, 1000, 1000, 1000, NULL );
     ok( handle != INVALID_HANDLE_VALUE, "CreateNamedPipe failed err %u\n", GetLastError() );
+    len = 0;
+    status = pNtQueryObject( handle, ObjectNameInformation, buffer, sizeof(buffer), &len );
+    ok( status == STATUS_SUCCESS , "NtQueryObject returned %x\n", status );
+    str = (UNICODE_STRING *)buffer;
+    todo_wine
+    ok( len > sizeof(UNICODE_STRING), "unexpected len %u\n", len );
+    str = (UNICODE_STRING *)buffer;
+    expected_len = sizeof(UNICODE_STRING) + str->Length + sizeof(WCHAR);
+    todo_wine
+    ok( len == expected_len || broken(len == expected_len - sizeof(WCHAR)), /* NT4 */
+        "unexpected len %u\n", len );
+    todo_wine
+    ok( len > sizeof(UNICODE_STRING) + sizeof("\\test_pipe") * sizeof(WCHAR),
+        "name too short %s\n", wine_dbgstr_w(str->Buffer) );
+    trace( "got %s len %u\n", wine_dbgstr_w(str->Buffer), len );
 
-    test_object_name( handle, L"\\Device\\NamedPipe\\test_pipe", TRUE );
-    test_object_type( handle, L"File" );
+    test_object_type( handle, "File" );
     test_file_info( handle );
 
     client = CreateFileA( "\\\\.\\pipe\\test_pipe", GENERIC_READ | GENERIC_WRITE,
                           0, NULL, OPEN_EXISTING, 0, 0 );
     ok( client != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError() );
 
-    test_object_type( client, L"File" );
+    test_object_type( client, "File" );
     test_file_info( client );
 
     pNtClose( client );
     pNtClose( handle );
 
-    handle = CreateFileA( "\\\\.\\pipe", 0, 0, NULL, OPEN_EXISTING, 0, 0 );
-    ok( handle != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError() );
-
-    test_object_name( handle, L"\\Device\\NamedPipe", TRUE );
-    test_object_type_todo( handle, L"File" );
-    test_file_info( handle );
-
-    pNtClose( handle );
-
-    RtlInitUnicodeString( &path, L"\\REGISTRY\\Machine" );
-    status = pNtCreateKey( &handle, KEY_READ, &attr, 0, 0, 0, 0 );
-    ok( status == STATUS_SUCCESS, "NtCreateKey failed status %x\n", status );
-
-    test_object_name( handle, L"\\REGISTRY\\MACHINE", TRUE );
-    test_object_type( handle, L"Key" );
-
-    pNtClose( handle );
+    pRtlCreateUnicodeStringFromAsciiz( &path, "\\REGISTRY\\Machine\\Software\\Classes" );
+    status = pNtCreateKey( &handle, KEY_ALL_ACCESS, &attr, 0, 0, 0, 0 );
+    ok( status == STATUS_SUCCESS || status == STATUS_ACCESS_DENIED,
+        "NtCreateKey failed status %x\n", status );
+    pRtlFreeUnicodeString( &path );
+    if (status == STATUS_SUCCESS)
+    {
+        len = 0;
+        status = pNtQueryObject( handle, ObjectNameInformation, buffer, sizeof(buffer), &len );
+        ok( status == STATUS_SUCCESS , "NtQueryObject returned %x\n", status );
+        str = (UNICODE_STRING *)buffer;
+        todo_wine
+        ok( len > sizeof(UNICODE_STRING), "unexpected len %u\n", len );
+        str = (UNICODE_STRING *)buffer;
+        expected_len = sizeof(UNICODE_STRING) + str->Length + sizeof(WCHAR);
+        todo_wine
+        ok( len == expected_len || broken(len == expected_len - sizeof(WCHAR)), /* NT4 */
+            "unexpected len %u\n", len );
+        todo_wine
+        ok( len > sizeof(UNICODE_STRING) + sizeof("\\Classes") * sizeof(WCHAR),
+            "name too short %s\n", wine_dbgstr_w(str->Buffer) );
+        trace( "got %s len %u\n", wine_dbgstr_w(str->Buffer), len );
+        pNtClose( handle );
+    }
+    pRtlFreeUnicodeString( &session );
 
-    test_object_name( GetCurrentProcess(), L"", FALSE );
-    test_object_type( GetCurrentProcess(), L"Process" );
+    test_object_type( GetCurrentProcess(), "Process" );
     test_no_file_info( GetCurrentProcess() );
 
-    test_object_name( GetCurrentThread(), L"", FALSE );
-    test_object_type( GetCurrentThread(), L"Thread" );
+    test_object_type( GetCurrentThread(), "Thread" );
     test_no_file_info( GetCurrentThread() );
 
     ret = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &handle);
     ok(ret, "OpenProcessToken failed: %u\n", GetLastError());
 
-    test_object_name( handle, L"", FALSE );
-    test_object_type( handle, L"Token" );
+    test_object_type( handle, "Token" );
     test_no_file_info( handle );
 
     pNtClose(handle);
+
 }
 
 static void test_type_mismatch(void)
@@ -1526,8 +1614,9 @@ static void test_event(void)
     UNICODE_STRING str;
     OBJECT_ATTRIBUTES attr;
     EVENT_BASIC_INFORMATION info;
+    static const WCHAR eventName[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s','\\','t','e','s','t','E','v','e','n','t',0};
 
-    pRtlInitUnicodeString( &str, L"\\BaseNamedObjects\\testEvent" );
+    pRtlInitUnicodeString(&str, eventName);
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
 
     status = pNtCreateEvent(&Event, GENERIC_ALL, &attr, 1, 0);
@@ -1584,7 +1673,8 @@ static void test_event(void)
     pNtClose(Event);
 }
 
-static const WCHAR keyed_nameW[] = L"\\BaseNamedObjects\\WineTestEvent";
+static const WCHAR keyed_nameW[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s',
+                                    '\\','W','i','n','e','T','e','s','t','E','v','e','n','t',0};
 
 static DWORD WINAPI keyed_event_thread( void *arg )
 {
@@ -1763,7 +1853,7 @@ static void test_keyed_events(void)
     ok( status == STATUS_OBJECT_TYPE_MISMATCH, "NtPulseEvent %x\n", status );
 
     status = pNtCreateEvent( &event, GENERIC_ALL, &attr, FALSE, FALSE );
-    ok( status == STATUS_OBJECT_NAME_COLLISION || status == STATUS_OBJECT_TYPE_MISMATCH /* 7+ */,
+    ok( status == STATUS_OBJECT_NAME_COLLISION || status == STATUS_OBJECT_TYPE_MISMATCH,
         "CreateEvent %x\n", status );
 
     NtClose( handle );
@@ -1793,7 +1883,7 @@ static void test_null_device(void)
     memset(&ov, 0, sizeof(ov));
     ov.hEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
 
-    RtlInitUnicodeString(&str, L"\\Device\\Null");
+    pRtlCreateUnicodeStringFromAsciiz(&str, "\\Device\\Null");
     InitializeObjectAttributes(&attr, &str, OBJ_CASE_INSENSITIVE, 0, NULL);
     status = pNtOpenSymbolicLinkObject(&null, SYMBOLIC_LINK_QUERY, &attr);
     ok(status == STATUS_OBJECT_TYPE_MISMATCH,
@@ -1804,7 +1894,7 @@ static void test_null_device(void)
     ok(status == STATUS_SUCCESS,
        "expected STATUS_SUCCESS, got %08x\n", status);
 
-    test_object_type(null, L"File");
+    test_object_type(null, "File");
 
     SetLastError(0xdeadbeef);
     ret = WriteFile(null, buf, sizeof(buf), &num_bytes, NULL);
@@ -1821,15 +1911,34 @@ static void test_null_device(void)
     num_bytes = 0xdeadbeef;
     SetLastError(0xdeadbeef);
     ret = WriteFile(null, buf, sizeof(buf), &num_bytes, &ov);
-    ok(ret, "got error %u\n", GetLastError());
+    if (ret || GetLastError() != ERROR_IO_PENDING)
+    {
+        ok(ret, "WriteFile failed with error %u\n", GetLastError());
+    }
+    else
+    {
+        num_bytes = 0xdeadbeef;
+        ret = GetOverlappedResult(null, &ov, &num_bytes, TRUE);
+        ok(ret, "GetOverlappedResult failed with error %u\n", GetLastError());
+    }
     ok(num_bytes == sizeof(buf), "expected num_bytes = %u, got %u\n",
        (DWORD)sizeof(buf), num_bytes);
 
     num_bytes = 0xdeadbeef;
     SetLastError(0xdeadbeef);
     ret = ReadFile(null, buf, sizeof(buf), &num_bytes, &ov);
-    ok(!ret, "expected failure\n");
-    ok(GetLastError() == ERROR_HANDLE_EOF, "got error %u\n", GetLastError());
+    if (ret || GetLastError() != ERROR_IO_PENDING)
+    {
+        ok(!ret, "ReadFile unexpectedly succeeded\n");
+    }
+    else
+    {
+        num_bytes = 0xdeadbeef;
+        ret = GetOverlappedResult(null, &ov, &num_bytes, TRUE);
+        ok(!ret, "GetOverlappedResult unexpectedly succeeded\n");
+    }
+    ok(GetLastError() == ERROR_HANDLE_EOF,
+       "expected ERROR_HANDLE_EOF, got %u\n", GetLastError());
 
     pNtClose(null);
 
@@ -1847,6 +1956,7 @@ static void test_null_device(void)
     ok(GetLastError() == ERROR_PATH_NOT_FOUND,
        "expected ERROR_PATH_NOT_FOUND, got %u\n", GetLastError());
 
+    pRtlFreeUnicodeString(&str);
     CloseHandle(ov.hEvent);
 }
 
@@ -1874,6 +1984,8 @@ static DWORD WINAPI mutant_thread( void *arg )
 
 static void test_mutant(void)
 {
+    static const WCHAR name[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s',
+                                 '\\','t','e','s','t','_','m','u','t','a','n','t',0};
     MUTANT_BASIC_INFORMATION info;
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING str;
@@ -1884,7 +1996,7 @@ static void test_mutant(void)
     ULONG len;
     LONG prev;
 
-    pRtlInitUnicodeString(&str, L"\\BaseNamedObjects\\test_mutant");
+    pRtlInitUnicodeString(&str, name);
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     status = pNtCreateMutant(&mutant, GENERIC_ALL, &attr, TRUE);
     ok( status == STATUS_SUCCESS, "Failed to create Mutant(%08x)\n", status );
@@ -2039,7 +2151,18 @@ static void test_wait_on_address(void)
 START_TEST(om)
 {
     HMODULE hntdll = GetModuleHandleA("ntdll.dll");
+    HMODULE hkernel32 = GetModuleHandleA("kernel32.dll");
+
+    if (!hntdll)
+    {
+        skip("not running on NT, skipping test\n");
+        return;
+    }
+
+    pCreateWaitableTimerA = (void *)GetProcAddress(hkernel32, "CreateWaitableTimerA");
 
+    pRtlCreateUnicodeStringFromAsciiz = (void *)GetProcAddress(hntdll, "RtlCreateUnicodeStringFromAsciiz");
+    pRtlFreeUnicodeString   = (void *)GetProcAddress(hntdll, "RtlFreeUnicodeString");
     pNtCreateEvent          = (void *)GetProcAddress(hntdll, "NtCreateEvent");
     pNtCreateJobObject      = (void *)GetProcAddress(hntdll, "NtCreateJobObject");
     pNtOpenJobObject        = (void *)GetProcAddress(hntdll, "NtOpenJobObject");
diff --git a/dlls/ntdll/tests/pipe.c b/dlls/ntdll/tests/pipe.c
index 4eb957b1c2..a70f19b056 100644
--- a/dlls/ntdll/tests/pipe.c
+++ b/dlls/ntdll/tests/pipe.c
@@ -1679,20 +1679,16 @@ static void test_volume_info(void)
     CloseHandle( write );
 }
 
-#define test_file_name_fail(a,b,c) _test_file_name_fail(__LINE__,a,b,c)
-static void _test_file_name_fail(unsigned line, HANDLE pipe, NTSTATUS expected_status, BOOL todo)
+#define test_file_name_fail(a,b) _test_file_name_fail(__LINE__,a,b)
+static void _test_file_name_fail(unsigned line, HANDLE pipe, NTSTATUS expected_status)
 {
     char buffer[512];
     IO_STATUS_BLOCK iosb;
     NTSTATUS status;
 
-    status = NtQueryInformationFile( pipe, &iosb, buffer, 0, FileNameInformation );
-    ok_(__FILE__,line)( status == STATUS_INFO_LENGTH_MISMATCH,
-            "expected STATUS_INFO_LENGTH_MISMATCH, got %#x\n", status );
-
     status = NtQueryInformationFile( pipe, &iosb, buffer, sizeof(buffer), FileNameInformation );
-    todo_wine_if (todo)
-        ok_(__FILE__,line)( status == expected_status, "expected %#x, got %#x\n", expected_status, status );
+    ok_(__FILE__,line)( status == expected_status, "NtQueryInformationFile failed: %x, expected %x\n",
+                        status, expected_status );
 }
 
 #define test_file_name(a) _test_file_name(__LINE__,a)
@@ -2167,7 +2163,7 @@ static void test_pipe_local_info(HANDLE pipe, BOOL is_server, DWORD state)
 
 static void test_file_info(void)
 {
-    HANDLE server, client, device;
+    HANDLE server, client;
 
     if (!create_pipe_pair( &server, &client, FILE_FLAG_OVERLAPPED | PIPE_ACCESS_INBOUND,
                            PIPE_TYPE_MESSAGE, 4096 )) return;
@@ -2176,17 +2172,10 @@ static void test_file_info(void)
     test_file_name( server );
 
     DisconnectNamedPipe( server );
-    test_file_name_fail( client, STATUS_PIPE_DISCONNECTED, FALSE );
+    test_file_name_fail( client, STATUS_PIPE_DISCONNECTED );
 
     CloseHandle( server );
     CloseHandle( client );
-
-    device = CreateFileA("\\\\.\\pipe", 0, 0, NULL, OPEN_EXISTING, 0, NULL);
-    ok(device != INVALID_HANDLE_VALUE, "got error %u\n", GetLastError());
-
-    test_file_name_fail( device, STATUS_INVALID_PARAMETER, TRUE );
-
-    CloseHandle( device );
 }
 
 static PSECURITY_DESCRIPTOR get_security_descriptor(HANDLE handle, BOOL todo)
diff --git a/dlls/ntdll/tests/string.c b/dlls/ntdll/tests/string.c
index b6a40f6709..21d2b4511e 100644
--- a/dlls/ntdll/tests/string.c
+++ b/dlls/ntdll/tests/string.c
@@ -86,18 +86,6 @@ static int      (__cdecl *piswlower)(WCHAR);
 static int      (__cdecl *piswspace)(WCHAR);
 static int      (__cdecl *piswxdigit)(WCHAR);
 
-static int      (__cdecl *pisalnum)(int);
-static int      (__cdecl *pisalpha)(int);
-static int      (__cdecl *piscntrl)(int);
-static int      (__cdecl *pisdigit)(int);
-static int      (__cdecl *pisgraph)(int);
-static int      (__cdecl *pislower)(int);
-static int      (__cdecl *pisprint)(int);
-static int      (__cdecl *pispunct)(int);
-static int      (__cdecl *pisspace)(int);
-static int      (__cdecl *pisupper)(int);
-static int      (__cdecl *pisxdigit)(int);
-
 static void InitFunctionPtrs(void)
 {
     hntdll = LoadLibraryA("ntdll.dll");
@@ -150,17 +138,6 @@ static void InitFunctionPtrs(void)
     X(iswlower);
     X(iswspace);
     X(iswxdigit);
-    X(isalnum);
-    X(isalpha);
-    X(iscntrl);
-    X(isdigit);
-    X(isgraph);
-    X(islower);
-    X(isprint);
-    X(ispunct);
-    X(isspace);
-    X(isupper);
-    X(isxdigit);
 #undef X
 }
 
@@ -1529,14 +1506,6 @@ static void test__snprintf(void)
     ok(!memcmp(buffer, "tes", 3), "buf = %s\n", buffer);
     ok(buffer[3] == 0x7c, "buffer[3] = %x\n", buffer[3]);
 
-    res = p_snprintf(buffer, sizeof(buffer), "%ls", L"test");
-    ok(res == strlen(buffer), "wrong size %d\n", res);
-    ok(!strcmp(buffer, "test"), "got %s\n", debugstr_a(buffer));
-
-    res = p_snprintf(buffer, sizeof(buffer), "%Ls", "test");
-    ok(res == strlen(buffer), "wrong size %d\n", res);
-    ok(!strcmp(buffer, "test"), "got %s\n", debugstr_a(buffer));
-
     res = p_snprintf(buffer, sizeof(buffer), "%I64x %d", (ULONGLONG)0x1234567890, 1);
     ok(res == strlen(buffer), "wrong size %d\n", res);
     ok(!strcmp(buffer, "1234567890 1"), "got %s\n", debugstr_a(buffer));
@@ -1985,56 +1954,6 @@ static void test_wctype(void)
     }
 }
 
-/* we could reuse wctypes except for TAB, which doesn't have C1_BLANK for some reason... */
-static const unsigned short ctypes[256] =
-{
-    /* 00 */
-    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
-    0x0020, 0x0028, 0x0028, 0x0028, 0x0028, 0x0028, 0x0020, 0x0020,
-    /* 10 */
-    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
-    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
-    /* 20 */
-    0x0048, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    /* 30 */
-    0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084,
-    0x0084, 0x0084, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    /* 40 */
-    0x0010, 0x0181, 0x0181, 0x0181, 0x0181, 0x0181, 0x0181, 0x0101,
-    0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,
-    /* 50 */
-    0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,
-    0x0101, 0x0101, 0x0101, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-    /* 60 */
-    0x0010, 0x0182, 0x0182, 0x0182, 0x0182, 0x0182, 0x0182, 0x0102,
-    0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102,
-    /* 70 */
-    0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102,
-    0x0102, 0x0102, 0x0102, 0x0010, 0x0010, 0x0010, 0x0010, 0x0020
-};
-
-static void test_ctype(void)
-{
-    int i;
-
-    for (i = -1; i < 256; i++)
-    {
-        unsigned short type = (i >= 0 ? ctypes[i] : 0);
-        ok( pisalnum( i ) == (type & (C1_DIGIT|C1_LOWER|C1_UPPER)), "%u: wrong isalnum %x / %x\n", i, pisalnum(i), type );
-        ok( pisalpha( i ) == (type & (C1_LOWER|C1_UPPER)), "%u: wrong isalpha %x / %x\n", i, pisalpha(i), type );
-        ok( piscntrl( i ) == (type & C1_CNTRL), "%u: wrong iscntrl %x / %x\n", i, piscntrl( i ), type );
-        ok( pisdigit( i ) == (type & C1_DIGIT), "%u: wrong isdigit %x / %x\n", i, pisdigit( i ), type );
-        ok( pisgraph( i ) == (type & (C1_DIGIT|C1_PUNCT|C1_LOWER|C1_UPPER)), "%u: wrong isgraph %x / %x\n", i, pisgraph( i ), type );
-        ok( pislower( i ) == (type & C1_LOWER), "%u: wrong islower %x / %x\n", i, pislower( i ), type );
-        ok( pisprint( i ) == (type & (C1_DIGIT|C1_BLANK|C1_PUNCT|C1_LOWER|C1_UPPER)), "%u: wrong isprint %x / %x\n", i, pisprint( i ), type );
-        ok( pispunct( i ) == (type & C1_PUNCT), "%u: wrong ispunct %x / %x\n", i, pispunct( i ), type );
-        ok( pisspace( i ) == (type & C1_SPACE), "%u: wrong isspace %x / %x\n", i, pisspace( i ), type );
-        ok( pisupper( i ) == (type & C1_UPPER), "%u: wrong isupper %x / %x\n", i, pisupper( i ), type );
-        ok( pisxdigit( i ) == (type & C1_XDIGIT), "%u: wrong isxdigit %x / %x\n", i, pisxdigit( i ), type );
-    }
-}
-
 START_TEST(string)
 {
     InitFunctionPtrs();
@@ -2065,5 +1984,4 @@ START_TEST(string)
     test_wcsicmp();
     test_sscanf();
     test_wctype();
-    test_ctype();
 }
diff --git a/dlls/ntdll/tests/time.c b/dlls/ntdll/tests/time.c
index a00d507e4e..99bddd4fec 100644
--- a/dlls/ntdll/tests/time.c
+++ b/dlls/ntdll/tests/time.c
@@ -29,8 +29,6 @@
 static VOID (WINAPI *pRtlTimeToTimeFields)( const LARGE_INTEGER *liTime, PTIME_FIELDS TimeFields) ;
 static VOID (WINAPI *pRtlTimeFieldsToTime)(  PTIME_FIELDS TimeFields,  PLARGE_INTEGER Time) ;
 static NTSTATUS (WINAPI *pNtQueryPerformanceCounter)( LARGE_INTEGER *counter, LARGE_INTEGER *frequency );
-static NTSTATUS (WINAPI *pNtQuerySystemInformation)( SYSTEM_INFORMATION_CLASS class,
-                                                     void *info, ULONG size, ULONG *ret_size );
 static NTSTATUS (WINAPI *pRtlQueryTimeZoneInformation)( RTL_TIME_ZONE_INFORMATION *);
 static NTSTATUS (WINAPI *pRtlQueryDynamicTimeZoneInformation)( RTL_DYNAMIC_TIME_ZONE_INFORMATION *);
 static BOOL     (WINAPI *pRtlQueryUnbiasedInterruptTime)( ULONGLONG *time );
@@ -124,19 +122,18 @@ static void test_NtQueryPerformanceCounter(void)
 
 static void test_RtlQueryTimeZoneInformation(void)
 {
-    RTL_DYNAMIC_TIME_ZONE_INFORMATION tzinfo, tzinfo2;
+    RTL_DYNAMIC_TIME_ZONE_INFORMATION tzinfo;
     NTSTATUS status;
-    ULONG len;
 
     /* test RtlQueryTimeZoneInformation returns an indirect string,
        e.g. @tzres.dll,-32 (Vista or later) */
     if (!pRtlQueryTimeZoneInformation || !pRtlQueryDynamicTimeZoneInformation)
     {
-        win_skip("Time zone name tests require Vista or later\n");
+        win_skip("Time zone name tests requires Vista or later\n");
         return;
     }
 
-    memset(&tzinfo, 0xcc, sizeof(tzinfo));
+    memset(&tzinfo, 0, sizeof(tzinfo));
     status = pRtlQueryDynamicTimeZoneInformation(&tzinfo);
     ok(status == STATUS_SUCCESS,
        "RtlQueryDynamicTimeZoneInformation failed, got %08x\n", status);
@@ -147,24 +144,7 @@ static void test_RtlQueryTimeZoneInformation(void)
        "daylight time zone name isn't an indirect string, got %s\n",
        wine_dbgstr_w(tzinfo.DaylightName));
 
-    memset(&tzinfo2, 0xcc, sizeof(tzinfo2));
-    status = pNtQuerySystemInformation( SystemDynamicTimeZoneInformation, &tzinfo2, sizeof(tzinfo2), &len );
-    ok( !status, "NtQuerySystemInformation failed %x\n", status );
-    ok( len == sizeof(tzinfo2), "wrong len %u\n", len );
-    ok( !memcmp( &tzinfo, &tzinfo2, sizeof(tzinfo2) ), "tz data is different\n" );
-
-    memset(&tzinfo, 0xcc, sizeof(tzinfo));
-    status = pRtlQueryTimeZoneInformation((RTL_TIME_ZONE_INFORMATION *)&tzinfo);
-    ok(status == STATUS_SUCCESS,
-       "RtlQueryTimeZoneInformation failed, got %08x\n", status);
-    ok(tzinfo.StandardName[0] == '@',
-       "standard time zone name isn't an indirect string, got %s\n",
-       wine_dbgstr_w(tzinfo.StandardName));
-    ok(tzinfo.DaylightName[0] == '@',
-       "daylight time zone name isn't an indirect string, got %s\n",
-       wine_dbgstr_w(tzinfo.DaylightName));
-
-    memset(&tzinfo, 0xcc, sizeof(tzinfo));
+    memset(&tzinfo, 0, sizeof(tzinfo));
     status = pRtlQueryTimeZoneInformation((RTL_TIME_ZONE_INFORMATION *)&tzinfo);
     ok(status == STATUS_SUCCESS,
        "RtlQueryTimeZoneInformation failed, got %08x\n", status);
@@ -174,13 +154,6 @@ static void test_RtlQueryTimeZoneInformation(void)
     ok(tzinfo.DaylightName[0] == '@',
        "daylight time zone name isn't an indirect string, got %s\n",
        wine_dbgstr_w(tzinfo.DaylightName));
-
-    memset(&tzinfo2, 0xcc, sizeof(tzinfo2));
-    status = pNtQuerySystemInformation( SystemTimeZoneInformation, &tzinfo2,
-                                        sizeof(RTL_TIME_ZONE_INFORMATION), &len );
-    ok( !status, "NtQuerySystemInformation failed %x\n", status );
-    ok( len == sizeof(RTL_TIME_ZONE_INFORMATION), "wrong len %u\n", len );
-    ok( !memcmp( &tzinfo, &tzinfo2, sizeof(RTL_TIME_ZONE_INFORMATION) ), "tz data is different\n" );
 }
 
 static ULONGLONG read_ksystem_time(volatile KSYSTEM_TIME *time)
@@ -199,7 +172,7 @@ static void test_user_shared_data_time(void)
 {
     KSHARED_USER_DATA *user_shared_data = (void *)0x7ffe0000;
     ULONGLONG t1, t2, t3;
-    int i = 0, changed = 0;
+    int i = 0;
 
     i = 0;
     do
@@ -253,15 +226,6 @@ static void test_user_shared_data_time(void)
            "USD InterruptTime / RtlQueryUnbiasedInterruptTime are out of order %s %s\n",
            wine_dbgstr_longlong(t2), wine_dbgstr_longlong(t3));
     }
-
-    for (i = 0; i < 100; i++)
-    {
-        t1 = GetTickCount();
-        Sleep(1);
-        t2 = GetTickCount();
-        if (t1 != t2) changed++;
-    }
-    todo_wine ok(changed >= 90, "tick count isn't updated after sleeping one millisecond (%d%% correct)\n", changed);
 }
 
 START_TEST(time)
@@ -270,7 +234,6 @@ START_TEST(time)
     pRtlTimeToTimeFields = (void *)GetProcAddress(mod,"RtlTimeToTimeFields");
     pRtlTimeFieldsToTime = (void *)GetProcAddress(mod,"RtlTimeFieldsToTime");
     pNtQueryPerformanceCounter = (void *)GetProcAddress(mod, "NtQueryPerformanceCounter");
-    pNtQuerySystemInformation = (void *)GetProcAddress(mod, "NtQuerySystemInformation");
     pRtlQueryTimeZoneInformation =
         (void *)GetProcAddress(mod, "RtlQueryTimeZoneInformation");
     pRtlQueryDynamicTimeZoneInformation =
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index ab34f0ba96..52f8b6ec61 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -18,24 +18,133 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <stdarg.h>
 #include <limits.h>
 #include <sys/types.h>
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#ifdef HAVE_SYS_TIMES_H
+#include <sys/times.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
 
 #define NONAMELESSUNION
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "winternl.h"
+#include "wine/library.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
 #include "ddk/wdm.h"
 #include "wine/exception.h"
 
-WINE_DECLARE_DEBUG_CHANNEL(relay);
+WINE_DEFAULT_DEBUG_CHANNEL(thread);
+
+#ifndef PTHREAD_STACK_MIN
+#define PTHREAD_STACK_MIN 16384
+#endif
+
+struct _KUSER_SHARED_DATA *user_shared_data = NULL;
 
-struct _KUSER_SHARED_DATA *user_shared_data = (void *)0x7ffe0000;
+void (WINAPI *kernel32_start_process)(LPTHREAD_START_ROUTINE,void*) = NULL;
+
+/* info passed to a starting thread */
+struct startup_info
+{
+    TEB                            *teb;
+    PRTL_THREAD_START_ROUTINE       entry_point;
+    void                           *entry_arg;
+};
+
+static PEB *peb;
+static PEB_LDR_DATA ldr;
+static RTL_BITMAP tls_bitmap;
+static RTL_BITMAP tls_expansion_bitmap;
+static RTL_BITMAP fls_bitmap;
+static int nb_threads = 1;
+
+static RTL_CRITICAL_SECTION peb_lock;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &peb_lock,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": peb_lock") }
+};
+static RTL_CRITICAL_SECTION peb_lock = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+#ifdef __linux__
+
+#ifdef HAVE_ELF_H
+# include <elf.h>
+#endif
+#ifdef HAVE_LINK_H
+# include <link.h>
+#endif
+#ifdef HAVE_SYS_AUXV_H
+# include <sys/auxv.h>
+#endif
+#ifndef HAVE_GETAUXVAL
+static unsigned long getauxval( unsigned long id )
+{
+    extern char **__wine_main_environ;
+    char **ptr = __wine_main_environ;
+    ElfW(auxv_t) *auxv;
+
+    while (*ptr) ptr++;
+    while (!*ptr) ptr++;
+    for (auxv = (ElfW(auxv_t) *)ptr; auxv->a_type; auxv++)
+        if (auxv->a_type == id) return auxv->a_un.a_val;
+    return 0;
+}
+#endif
+
+static ULONG_PTR get_image_addr(void)
+{
+    ULONG_PTR size, num, phdr_addr = getauxval( AT_PHDR );
+    ElfW(Phdr) *phdr;
+
+    if (!phdr_addr) return 0;
+    phdr = (ElfW(Phdr) *)phdr_addr;
+    size = getauxval( AT_PHENT );
+    num = getauxval( AT_PHNUM );
+    while (num--)
+    {
+        if (phdr->p_type == PT_PHDR) return phdr_addr - phdr->p_offset;
+        phdr = (ElfW(Phdr) *)((char *)phdr + size);
+    }
+    return 0;
+}
+
+#elif defined(__APPLE__)
+#include <mach/mach.h>
+#include <mach/mach_error.h>
+
+static ULONG_PTR get_image_addr(void)
+{
+    ULONG_PTR ret = 0;
+#ifdef TASK_DYLD_INFO
+    struct task_dyld_info dyld_info;
+    mach_msg_type_number_t size = TASK_DYLD_INFO_COUNT;
+    if (task_info(mach_task_self(), TASK_DYLD_INFO, (task_info_t)&dyld_info, &size) == KERN_SUCCESS)
+        ret = dyld_info.all_image_info_addr;
+#endif
+    return ret;
+}
+
+#else
+static ULONG_PTR get_image_addr(void)
+{
+    return 0;
+}
+#endif
 
 
 /***********************************************************************
@@ -73,94 +182,301 @@ int __cdecl __wine_dbg_output( const char *str )
     return unix_funcs->dbg_output( str );
 }
 
+static void fill_user_shared_data( struct _KUSER_SHARED_DATA *data )
+{
+    RTL_OSVERSIONINFOEXW version;
+    SYSTEM_CPU_INFORMATION sci;
+    SYSTEM_BASIC_INFORMATION sbi;
+    BOOLEAN *features = data->ProcessorFeatures;
+
+    version.dwOSVersionInfoSize = sizeof(version);
+    RtlGetVersion( &version );
+    virtual_get_system_info( &sbi );
+    NtQuerySystemInformation( SystemCpuInformation, &sci, sizeof(sci), NULL );
+
+    data->TickCountMultiplier         = 1 << 24;
+    data->LargePageMinimum            = 2 * 1024 * 1024;
+    data->NtBuildNumber               = version.dwBuildNumber;
+    data->NtProductType               = version.wProductType;
+    data->ProductTypeIsValid          = TRUE;
+    data->NativeProcessorArchitecture = sci.Architecture;
+    data->NtMajorVersion              = version.dwMajorVersion;
+    data->NtMinorVersion              = version.dwMinorVersion;
+    data->SuiteMask                   = version.wSuiteMask;
+    data->NumberOfPhysicalPages       = sbi.MmNumberOfPhysicalPages;
+    wcscpy( data->NtSystemRoot, windows_dir );
+
+    switch (sci.Architecture)
+    {
+    case PROCESSOR_ARCHITECTURE_INTEL:
+    case PROCESSOR_ARCHITECTURE_AMD64:
+        features[PF_COMPARE_EXCHANGE_DOUBLE]              = !!(sci.FeatureSet & CPU_FEATURE_CX8);
+        features[PF_MMX_INSTRUCTIONS_AVAILABLE]           = !!(sci.FeatureSet & CPU_FEATURE_MMX);
+        features[PF_XMMI_INSTRUCTIONS_AVAILABLE]          = !!(sci.FeatureSet & CPU_FEATURE_SSE);
+        features[PF_3DNOW_INSTRUCTIONS_AVAILABLE]         = !!(sci.FeatureSet & CPU_FEATURE_3DNOW);
+        features[PF_RDTSC_INSTRUCTION_AVAILABLE]          = !!(sci.FeatureSet & CPU_FEATURE_TSC);
+        features[PF_PAE_ENABLED]                          = !!(sci.FeatureSet & CPU_FEATURE_PAE);
+        features[PF_XMMI64_INSTRUCTIONS_AVAILABLE]        = !!(sci.FeatureSet & CPU_FEATURE_SSE2);
+        features[PF_SSE3_INSTRUCTIONS_AVAILABLE]          = !!(sci.FeatureSet & CPU_FEATURE_SSE3);
+        features[PF_XSAVE_ENABLED]                        = !!(sci.FeatureSet & CPU_FEATURE_XSAVE);
+        features[PF_COMPARE_EXCHANGE128]                  = !!(sci.FeatureSet & CPU_FEATURE_CX128);
+        features[PF_SSE_DAZ_MODE_AVAILABLE]               = !!(sci.FeatureSet & CPU_FEATURE_DAZ);
+        features[PF_NX_ENABLED]                           = !!(sci.FeatureSet & CPU_FEATURE_NX);
+        features[PF_SECOND_LEVEL_ADDRESS_TRANSLATION]     = !!(sci.FeatureSet & CPU_FEATURE_2NDLEV);
+        features[PF_VIRT_FIRMWARE_ENABLED]                = !!(sci.FeatureSet & CPU_FEATURE_VIRT);
+        features[PF_RDWRFSGSBASE_AVAILABLE]               = !!(sci.FeatureSet & CPU_FEATURE_RDFS);
+        features[PF_FASTFAIL_AVAILABLE]                   = TRUE;
+        break;
+    case PROCESSOR_ARCHITECTURE_ARM:
+        features[PF_ARM_VFP_32_REGISTERS_AVAILABLE]       = !!(sci.FeatureSet & CPU_FEATURE_ARM_VFP_32);
+        features[PF_ARM_NEON_INSTRUCTIONS_AVAILABLE]      = !!(sci.FeatureSet & CPU_FEATURE_ARM_NEON);
+        features[PF_ARM_V8_INSTRUCTIONS_AVAILABLE]        = (sci.Level >= 8);
+        break;
+    case PROCESSOR_ARCHITECTURE_ARM64:
+        features[PF_ARM_V8_INSTRUCTIONS_AVAILABLE]        = TRUE;
+        features[PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE]  = !!(sci.FeatureSet & CPU_FEATURE_ARM_V8_CRC32);
+        features[PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE] = !!(sci.FeatureSet & CPU_FEATURE_ARM_V8_CRYPTO);
+        break;
+    }
+    data->ActiveProcessorCount = NtCurrentTeb()->Peb->NumberOfProcessors;
+    data->ActiveGroupCount = 1;
+}
+
+HANDLE user_shared_data_init_done(void)
+{
+    static const WCHAR wine_usdW[] = {'\\','K','e','r','n','e','l','O','b','j','e','c','t','s',
+                                      '\\','_','_','w','i','n','e','_','u','s','e','r','_','s','h','a','r','e','d','_','d','a','t','a',0};
+    OBJECT_ATTRIBUTES attr = {sizeof(attr)};
+    UNICODE_STRING wine_usd_str;
+    LARGE_INTEGER section_size;
+    NTSTATUS status;
+    HANDLE section;
+    SIZE_T size;
+    void *addr;
+    int res, fd, needs_close;
+
+    section_size.QuadPart = sizeof(*user_shared_data);
 
-/*******************************************************************
- *		KiUserApcDispatcher (NTDLL.@)
+    RtlInitUnicodeString( &wine_usd_str, wine_usdW );
+    InitializeObjectAttributes( &attr, &wine_usd_str, OBJ_OPENIF, NULL, NULL );
+    if ((status = NtCreateSection( &section, SECTION_ALL_ACCESS, &attr,
+                                   &section_size, PAGE_READWRITE, SEC_COMMIT, NULL )) &&
+        status != STATUS_OBJECT_NAME_EXISTS)
+    {
+        MESSAGE( "wine: failed to create or open the USD section: %08x\n", status );
+        exit(1);
+    }
+
+    if (status != STATUS_OBJECT_NAME_EXISTS)
+    {
+        addr = NULL;
+        size = sizeof(*user_shared_data);
+        if ((status = NtMapViewOfSection( section, NtCurrentProcess(), &addr, 0, 0, 0,
+                                          &size, 0, 0, PAGE_READWRITE )))
+        {
+            MESSAGE( "wine: failed to initialize the USD section: %08x\n", status );
+            exit(1);
+        }
+
+        fill_user_shared_data( addr );
+        NtUnmapViewOfSection( NtCurrentProcess(), addr );
+    }
+
+    if ((res = server_get_unix_fd( section, 0, &fd, &needs_close, NULL, NULL )) ||
+        (user_shared_data != mmap( user_shared_data, sizeof(*user_shared_data),
+                                   PROT_READ, MAP_SHARED | MAP_FIXED, fd, 0 )))
+    {
+        MESSAGE( "wine: failed to remap the process USD: %d\n", res );
+        exit(1);
+    }
+    if (needs_close) close( fd );
+
+    return section;
+}
+
+/***********************************************************************
+ *           thread_init
+ *
+ * Setup the initial thread.
+ *
+ * NOTES: The first allocated TEB on NT is at 0x7ffde000.
  */
-void WINAPI KiUserApcDispatcher( CONTEXT *context, ULONG_PTR ctx, ULONG_PTR arg1, ULONG_PTR arg2,
-                                 PNTAPCFUNC func )
+TEB *thread_init(void)
 {
-    func( ctx, arg1, arg2 );
-    NtContinue( context, TRUE );
+    TEB *teb;
+    void *addr;
+    SIZE_T size;
+    NTSTATUS status;
+    struct ntdll_thread_data *thread_data;
+
+    virtual_init();
+
+    /* reserve space for shared user data */
+
+    addr = (void *)0x7ffe0000;
+    size = 0x1000;
+    status = NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size,
+                                      MEM_RESERVE|MEM_COMMIT, PAGE_READONLY );
+    if (status)
+    {
+        MESSAGE( "wine: failed to map the shared user data: %08x\n", status );
+        exit(1);
+    }
+    user_shared_data = addr;
+
+    /* allocate and initialize the PEB and initial TEB */
+
+    teb = virtual_alloc_first_teb();
+    peb = teb->Peb;
+    peb->FastPebLock        = &peb_lock;
+    peb->TlsBitmap          = &tls_bitmap;
+    peb->TlsExpansionBitmap = &tls_expansion_bitmap;
+    peb->FlsBitmap          = &fls_bitmap;
+    peb->LdrData            = &ldr;
+    peb->OSMajorVersion     = 5;
+    peb->OSMinorVersion     = 1;
+    peb->OSBuildNumber      = 0xA28;
+    peb->OSPlatformId       = VER_PLATFORM_WIN32_NT;
+    ldr.Length = sizeof(ldr);
+    ldr.Initialized = TRUE;
+    RtlInitializeBitMap( &tls_bitmap, peb->TlsBitmapBits, sizeof(peb->TlsBitmapBits) * 8 );
+    RtlInitializeBitMap( &tls_expansion_bitmap, peb->TlsExpansionBitmapBits,
+                         sizeof(peb->TlsExpansionBitmapBits) * 8 );
+    RtlInitializeBitMap( &fls_bitmap, peb->FlsBitmapBits, sizeof(peb->FlsBitmapBits) * 8 );
+    RtlSetBits( peb->TlsBitmap, 0, 1 ); /* TLS index 0 is reserved and should be initialized to NULL. */
+    RtlSetBits( peb->FlsBitmap, 0, 1 );
+    InitializeListHead( &peb->FlsListHead );
+    InitializeListHead( &ldr.InLoadOrderModuleList );
+    InitializeListHead( &ldr.InMemoryOrderModuleList );
+    InitializeListHead( &ldr.InInitializationOrderModuleList );
+    *(ULONG_PTR *)peb->Reserved = get_image_addr();
+
+    /*
+     * Starting with Vista, the first user to log on has session id 1.
+     * Session id 0 is for processes that don't interact with the user (like services).
+     */
+    peb->SessionId = 1;
+
+    thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+    thread_data->request_fd = -1;
+    thread_data->reply_fd   = -1;
+    thread_data->wait_fd[0] = -1;
+    thread_data->wait_fd[1] = -1;
+
+    unix_funcs->dbg_init();
+    unix_funcs->get_paths( &build_dir, &data_dir, &config_dir );
+    fill_cpu_info();
+    return teb;
 }
 
 
 /***********************************************************************
- *           RtlExitUserThread  (NTDLL.@)
+ *           abort_thread
  */
-void WINAPI RtlExitUserThread( ULONG status )
+void abort_thread( int status )
 {
-    ULONG last;
-
-    NtQueryInformationThread( GetCurrentThread(), ThreadAmILastThread, &last, sizeof(last), NULL );
-    if (last) RtlExitUserProcess( status );
-    LdrShutdownThread();
-    RtlFreeThreadActivationContextStack();
-    for (;;) NtTerminateThread( GetCurrentThread(), status );
+    pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
+    if (InterlockedDecrement( &nb_threads ) <= 0) _exit( get_unix_exit_code( status ));
+    signal_exit_thread( status );
 }
 
 
 /***********************************************************************
- *           RtlUserThreadStart (NTDLL.@)
+ *           exit_thread
  */
-#ifdef __i386__
-__ASM_STDCALL_FUNC( RtlUserThreadStart, 8,
-                   "pushl %ebp\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
-                   __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
-                   "movl %esp,%ebp\n\t"
-                   __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
-                   "pushl %ebx\n\t"  /* arg */
-                   "pushl %eax\n\t"  /* entry */
-                   "call " __ASM_NAME("call_thread_func") )
+void exit_thread( int status )
+{
+    close( ntdll_get_thread_data()->wait_fd[0] );
+    close( ntdll_get_thread_data()->wait_fd[1] );
+    close( ntdll_get_thread_data()->reply_fd );
+    close( ntdll_get_thread_data()->request_fd );
+    pthread_exit( UIntToPtr(status) );
+}
 
-/* wrapper for apps that don't declare the thread function correctly */
-extern DWORD call_thread_func_wrapper( PRTL_THREAD_START_ROUTINE entry, void *arg );
-__ASM_GLOBAL_FUNC(call_thread_func_wrapper,
-                  "pushl %ebp\n\t"
-                  __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
-                  __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
-                  "movl %esp,%ebp\n\t"
-                  __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
-                  "subl $4,%esp\n\t"
-                  "pushl 12(%ebp)\n\t"
-                  "call *8(%ebp)\n\t"
-                  "leave\n\t"
-                  __ASM_CFI(".cfi_def_cfa %esp,4\n\t")
-                  __ASM_CFI(".cfi_same_value %ebp\n\t")
-                  "ret" )
 
-void DECLSPEC_HIDDEN call_thread_func( PRTL_THREAD_START_ROUTINE entry, void *arg )
+/***********************************************************************
+ *           RtlExitUserThread  (NTDLL.@)
+ */
+void WINAPI RtlExitUserThread( ULONG status )
 {
-    __TRY
+    static void *prev_teb;
+    TEB *teb;
+
+    if (status)  /* send the exit code to the server (0 is already the default) */
     {
-        TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", entry, arg );
-        RtlExitUserThread( call_thread_func_wrapper( entry, arg ));
+        SERVER_START_REQ( terminate_thread )
+        {
+            req->handle    = wine_server_obj_handle( GetCurrentThread() );
+            req->exit_code = status;
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
     }
-    __EXCEPT(call_unhandled_exception_filter)
+
+    if (InterlockedDecrement( &nb_threads ) <= 0)
     {
-        NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+        LdrShutdownProcess();
+        pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
+        signal_exit_process( get_unix_exit_code( status ));
     }
-    __ENDTRY
-}
 
-#else  /* __i386__ */
+    LdrShutdownThread();
+    RtlFreeThreadActivationContextStack();
 
-void WINAPI RtlUserThreadStart( PRTL_THREAD_START_ROUTINE entry, void *arg )
-{
-    __TRY
-    {
-        TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", entry, arg );
-        RtlExitUserThread( ((LPTHREAD_START_ROUTINE)entry)( arg ));
-    }
-    __EXCEPT(call_unhandled_exception_filter)
+    pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
+
+    if ((teb = InterlockedExchangePointer( &prev_teb, NtCurrentTeb() )))
     {
-        NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+        struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+
+        if (thread_data->pthread_id)
+        {
+            pthread_join( thread_data->pthread_id, NULL );
+            virtual_free_teb( teb );
+        }
     }
-    __ENDTRY
+
+    signal_exit_thread( status );
+}
+
+
+/***********************************************************************
+ *           start_thread
+ *
+ * Startup routine for a newly created thread.
+ */
+static void start_thread( struct startup_info *info )
+{
+    BOOL suspend;
+    TEB *teb = info->teb;
+    struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+    struct debug_info debug_info;
+
+    debug_info.str_pos = debug_info.out_pos = 0;
+    thread_data->debug_info = &debug_info;
+    thread_data->pthread_id = pthread_self();
+
+    signal_init_thread( teb );
+    server_init_thread( info->entry_point, &suspend );
+    signal_start_thread( (LPTHREAD_START_ROUTINE)info->entry_point, info->entry_arg, suspend );
 }
 
-#endif  /* __i386__ */
+
+/***********************************************************************
+ *              NtCreateThreadEx   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle_ptr, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
+                                  HANDLE process, LPTHREAD_START_ROUTINE start, void *param,
+                                  ULONG flags, ULONG zero_bits, ULONG stack_commit,
+                                  ULONG stack_reserve, void *attribute_list )
+{
+    FIXME( "%p, %x, %p, %p, %p, %p, %x, %x, %x, %x, %p semi-stub!\n", handle_ptr, access, attr,
+           process, start, param, flags, zero_bits, stack_commit, stack_reserve, attribute_list );
+
+    return RtlCreateUserThread( process, NULL, flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED,
+                                NULL, stack_reserve, stack_commit, (PRTL_THREAD_START_ROUTINE)start,
+                                param, handle_ptr, NULL );
+}
 
 
 /***********************************************************************
@@ -172,46 +488,149 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
                                      PRTL_THREAD_START_ROUTINE start, void *param,
                                      HANDLE *handle_ptr, CLIENT_ID *id )
 {
-    ULONG flags = suspended ? THREAD_CREATE_FLAGS_CREATE_SUSPENDED : 0;
-    ULONG_PTR buffer[offsetof( PS_ATTRIBUTE_LIST, Attributes[2] ) / sizeof(ULONG_PTR)];
-    PS_ATTRIBUTE_LIST *attr_list = (PS_ATTRIBUTE_LIST *)buffer;
-    HANDLE handle, actctx;
-    TEB *teb;
-    ULONG ret;
+    sigset_t sigset;
+    pthread_t pthread_id;
+    pthread_attr_t attr;
+    struct ntdll_thread_data *thread_data;
+    struct startup_info *info;
+    HANDLE handle = 0, actctx = 0;
+    TEB *teb = NULL;
+    DWORD tid = 0;
+    int request_pipe[2];
     NTSTATUS status;
-    CLIENT_ID client_id;
-    OBJECT_ATTRIBUTES attr;
+    SIZE_T extra_stack = PTHREAD_STACK_MIN;
+    data_size_t len = 0;
+    struct object_attributes *objattr = NULL;
+    INITIAL_TEB stack;
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
 
-    attr_list->TotalLength = sizeof(buffer);
-    attr_list->Attributes[0].Attribute    = PS_ATTRIBUTE_CLIENT_ID;
-    attr_list->Attributes[0].Size         = sizeof(client_id);
-    attr_list->Attributes[0].ValuePtr     = &client_id;
-    attr_list->Attributes[0].ReturnLength = NULL;
-    attr_list->Attributes[1].Attribute    = PS_ATTRIBUTE_TEB_ADDRESS;
-    attr_list->Attributes[1].Size         = sizeof(teb);
-    attr_list->Attributes[1].ValuePtr     = &teb;
-    attr_list->Attributes[1].ReturnLength = NULL;
+        memset( &call, 0, sizeof(call) );
 
-    InitializeObjectAttributes( &attr, NULL, 0, NULL, descr );
+        call.create_thread.type    = APC_CREATE_THREAD;
+        call.create_thread.func    = wine_server_client_ptr( start );
+        call.create_thread.arg     = wine_server_client_ptr( param );
+        call.create_thread.reserve = stack_reserve;
+        call.create_thread.commit  = stack_commit;
+        call.create_thread.suspend = suspended;
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
 
-    RtlGetActiveActivationContext( &actctx );
-    if (actctx) flags |= THREAD_CREATE_FLAGS_CREATE_SUSPENDED;
+        if (result.create_thread.status == STATUS_SUCCESS)
+        {
+            if (id) id->UniqueThread = ULongToHandle(result.create_thread.tid);
+            if (handle_ptr) *handle_ptr = wine_server_ptr_handle( result.create_thread.handle );
+            else NtClose( wine_server_ptr_handle( result.create_thread.handle ));
+        }
+        return result.create_thread.status;
+    }
+
+    if (descr)
+    {
+        OBJECT_ATTRIBUTES thread_attr;
+        InitializeObjectAttributes( &thread_attr, NULL, 0, NULL, descr );
+        if ((status = alloc_object_attributes( &thread_attr, &objattr, &len ))) return status;
+    }
 
-    status = NtCreateThreadEx( &handle, THREAD_ALL_ACCESS, &attr, process, start, param,
-                               flags, 0, stack_commit, stack_reserve, attr_list );
-    if (!status)
+    if (server_pipe( request_pipe ) == -1)
     {
-        if (actctx)
+        RtlFreeHeap( GetProcessHeap(), 0, objattr );
+        return STATUS_TOO_MANY_OPENED_FILES;
+    }
+    wine_server_send_fd( request_pipe[0] );
+
+    SERVER_START_REQ( new_thread )
+    {
+        req->process    = wine_server_obj_handle( process );
+        req->access     = THREAD_ALL_ACCESS;
+        req->suspend    = suspended;
+        req->request_fd = request_pipe[0];
+        wine_server_add_data( req, objattr, len );
+        if (!(status = wine_server_call( req )))
         {
-            ULONG_PTR cookie;
-            RtlActivateActivationContextEx( 0, teb, actctx, &cookie );
-            if (!suspended) NtResumeThread( handle, &ret );
+            handle = wine_server_ptr_handle( reply->handle );
+            tid = reply->tid;
         }
-        if (id) *id = client_id;
-        if (handle_ptr) *handle_ptr = handle;
-        else NtClose( handle );
+        close( request_pipe[0] );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    if (status)
+    {
+        close( request_pipe[1] );
+        return status;
+    }
+
+    pthread_sigmask( SIG_BLOCK, &server_block_set, &sigset );
+
+    if ((status = virtual_alloc_teb( &teb ))) goto error;
+
+    teb->ClientId.UniqueProcess = ULongToHandle(GetCurrentProcessId());
+    teb->ClientId.UniqueThread  = ULongToHandle(tid);
+
+    /* create default activation context frame for new thread */
+    RtlGetActiveActivationContext(&actctx);
+    if (actctx)
+    {
+        RTL_ACTIVATION_CONTEXT_STACK_FRAME *frame;
+
+        frame = RtlAllocateHeap(GetProcessHeap(), 0, sizeof(*frame));
+        frame->Previous = NULL;
+        frame->ActivationContext = actctx;
+        frame->Flags = 0;
+        teb->ActivationContextStack.ActiveFrame = frame;
+    }
+
+    info = (struct startup_info *)(teb + 1);
+    info->teb         = teb;
+    info->entry_point = start;
+    info->entry_arg   = param;
+
+    if ((status = virtual_alloc_thread_stack( &stack, stack_reserve, stack_commit, &extra_stack )))
+        goto error;
+
+    teb->Tib.StackBase = stack.StackBase;
+    teb->Tib.StackLimit = stack.StackLimit;
+    teb->DeallocationStack = stack.DeallocationStack;
+
+    thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+    thread_data->request_fd  = request_pipe[1];
+    thread_data->reply_fd    = -1;
+    thread_data->wait_fd[0]  = -1;
+    thread_data->wait_fd[1]  = -1;
+    thread_data->start_stack = (char *)teb->Tib.StackBase;
+
+    pthread_attr_init( &attr );
+    pthread_attr_setstack( &attr, teb->DeallocationStack,
+                         (char *)teb->Tib.StackBase + extra_stack - (char *)teb->DeallocationStack );
+    pthread_attr_setguardsize( &attr, 0 );
+    pthread_attr_setscope( &attr, PTHREAD_SCOPE_SYSTEM ); /* force creating a kernel thread */
+    InterlockedIncrement( &nb_threads );
+    if (pthread_create( &pthread_id, &attr, (void * (*)(void *))start_thread, info ))
+    {
+        InterlockedDecrement( &nb_threads );
+        pthread_attr_destroy( &attr );
+        status = STATUS_NO_MEMORY;
+        goto error;
     }
-    if (actctx) RtlReleaseActivationContext( actctx );
+    pthread_attr_destroy( &attr );
+    pthread_sigmask( SIG_SETMASK, &sigset, NULL );
+
+    if (id) id->UniqueThread = ULongToHandle(tid);
+    if (handle_ptr) *handle_ptr = handle;
+    else NtClose( handle );
+
+    return STATUS_SUCCESS;
+
+error:
+    if (teb) virtual_free_teb( teb );
+    if (handle) NtClose( handle );
+    pthread_sigmask( SIG_SETMASK, &sigset, NULL );
+    close( request_pipe[1] );
     return status;
 }
 
@@ -221,7 +640,145 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
  */
 ULONG WINAPI RtlGetNtGlobalFlags(void)
 {
-    return NtCurrentTeb()->Peb->NtGlobalFlag;
+    if (!peb) return 0;  /* init not done yet */
+    return peb->NtGlobalFlag;
+}
+
+
+/***********************************************************************
+ *              NtOpenThread   (NTDLL.@)
+ *              ZwOpenThread   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtOpenThread( HANDLE *handle, ACCESS_MASK access,
+                              const OBJECT_ATTRIBUTES *attr, const CLIENT_ID *id )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( open_thread )
+    {
+        req->tid        = HandleToULong(id->UniqueThread);
+        req->access     = access;
+        req->attributes = attr ? attr->Attributes : 0;
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/******************************************************************************
+ *              NtSuspendThread   (NTDLL.@)
+ *              ZwSuspendThread   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSuspendThread( HANDLE handle, PULONG count )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( suspend_thread )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            if (count) *count = reply->count;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/******************************************************************************
+ *              NtResumeThread   (NTDLL.@)
+ *              ZwResumeThread   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtResumeThread( HANDLE handle, PULONG count )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( resume_thread )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            if (count) *count = reply->count;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/******************************************************************************
+ *              NtAlertResumeThread   (NTDLL.@)
+ *              ZwAlertResumeThread   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAlertResumeThread( HANDLE handle, PULONG count )
+{
+    FIXME( "stub: should alert thread %p\n", handle );
+    return NtResumeThread( handle, count );
+}
+
+
+/******************************************************************************
+ *              NtAlertThread   (NTDLL.@)
+ *              ZwAlertThread   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAlertThread( HANDLE handle )
+{
+    FIXME( "stub: %p\n", handle );
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+
+/******************************************************************************
+ *              NtTerminateThread  (NTDLL.@)
+ *              ZwTerminateThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtTerminateThread( HANDLE handle, LONG exit_code )
+{
+    NTSTATUS ret;
+    BOOL self = (handle == GetCurrentThread());
+
+    if (!self || exit_code)
+    {
+        SERVER_START_REQ( terminate_thread )
+        {
+            req->handle    = wine_server_obj_handle( handle );
+            req->exit_code = exit_code;
+            ret = wine_server_call( req );
+            self = !ret && reply->self;
+        }
+        SERVER_END_REQ;
+    }
+    if (self) abort_thread( exit_code );
+    return ret;
+}
+
+
+/******************************************************************************
+ *              NtQueueApcThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueueApcThread( HANDLE handle, PNTAPCFUNC func, ULONG_PTR arg1,
+                                  ULONG_PTR arg2, ULONG_PTR arg3 )
+{
+    NTSTATUS ret;
+    SERVER_START_REQ( queue_apc )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (func)
+        {
+            req->call.type              = APC_USER;
+            req->call.user.user.func    = wine_server_client_ptr( func );
+            req->call.user.user.args[0] = arg1;
+            req->call.user.user.args[1] = arg2;
+            req->call.user.user.args[2] = arg3;
+        }
+        else req->call.type = APC_NONE;  /* wake up only */
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
@@ -251,3 +808,525 @@ TEB_ACTIVE_FRAME * WINAPI RtlGetFrame(void)
 {
     return NtCurrentTeb()->ActiveFrame;
 }
+
+
+/***********************************************************************
+ *              set_thread_context
+ */
+NTSTATUS set_thread_context( HANDLE handle, const context_t *context, BOOL *self )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( set_thread_context )
+    {
+        req->handle  = wine_server_obj_handle( handle );
+        wine_server_add_data( req, context, sizeof(*context) );
+        ret = wine_server_call( req );
+        *self = reply->self;
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
+
+/***********************************************************************
+ *              get_thread_context
+ */
+NTSTATUS get_thread_context( HANDLE handle, context_t *context, unsigned int flags, BOOL *self )
+{
+    NTSTATUS ret;
+
+    SERVER_START_REQ( get_thread_context )
+    {
+        req->handle  = wine_server_obj_handle( handle );
+        req->flags   = flags;
+        wine_server_set_reply( req, context, sizeof(*context) );
+        ret = wine_server_call( req );
+        *self = reply->self;
+        handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    if (ret == STATUS_PENDING)
+    {
+        LARGE_INTEGER timeout;
+        timeout.QuadPart = -1000000;
+        if (NtWaitForSingleObject( handle, FALSE, &timeout ))
+        {
+            NtClose( handle );
+            return STATUS_ACCESS_DENIED;
+        }
+        SERVER_START_REQ( get_thread_context )
+        {
+            req->handle  = wine_server_obj_handle( handle );
+            req->flags   = flags;
+            wine_server_set_reply( req, context, sizeof(*context) );
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+    return ret;
+}
+
+
+/******************************************************************************
+ *              NtQueryInformationThread  (NTDLL.@)
+ *              ZwQueryInformationThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryInformationThread( HANDLE handle, THREADINFOCLASS class,
+                                          void *data, ULONG length, ULONG *ret_len )
+{
+    NTSTATUS status;
+
+    switch(class)
+    {
+    case ThreadBasicInformation:
+        {
+            THREAD_BASIC_INFORMATION info;
+            const ULONG_PTR affinity_mask = get_system_affinity_mask();
+
+            SERVER_START_REQ( get_thread_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->tid_in = 0;
+                if (!(status = wine_server_call( req )))
+                {
+                    info.ExitStatus             = reply->exit_code;
+                    info.TebBaseAddress         = wine_server_get_ptr( reply->teb );
+                    info.ClientId.UniqueProcess = ULongToHandle(reply->pid);
+                    info.ClientId.UniqueThread  = ULongToHandle(reply->tid);
+                    info.AffinityMask           = reply->affinity & affinity_mask;
+                    info.Priority               = reply->priority;
+                    info.BasePriority           = reply->priority;  /* FIXME */
+                }
+            }
+            SERVER_END_REQ;
+            if (status == STATUS_SUCCESS)
+            {
+                if (data) memcpy( data, &info, min( length, sizeof(info) ));
+                if (ret_len) *ret_len = min( length, sizeof(info) );
+            }
+        }
+        return status;
+    case ThreadAffinityMask:
+        {
+            const ULONG_PTR affinity_mask = get_system_affinity_mask();
+            ULONG_PTR affinity = 0;
+
+            SERVER_START_REQ( get_thread_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->tid_in = 0;
+                if (!(status = wine_server_call( req )))
+                    affinity = reply->affinity & affinity_mask;
+            }
+            SERVER_END_REQ;
+            if (status == STATUS_SUCCESS)
+            {
+                if (data) memcpy( data, &affinity, min( length, sizeof(affinity) ));
+                if (ret_len) *ret_len = min( length, sizeof(affinity) );
+            }
+        }
+        return status;
+    case ThreadTimes:
+        {
+            KERNEL_USER_TIMES   kusrt;
+
+            SERVER_START_REQ( get_thread_times )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                status = wine_server_call( req );
+                if (status == STATUS_SUCCESS)
+                {
+                    kusrt.CreateTime.QuadPart = reply->creation_time;
+                    kusrt.ExitTime.QuadPart = reply->exit_time;
+                }
+            }
+            SERVER_END_REQ;
+            if (status == STATUS_SUCCESS)
+            {
+                /* We call times(2) for kernel time or user time */
+                /* We can only (portably) do this for the current thread */
+                if (handle == GetCurrentThread())
+                {
+                    struct tms time_buf;
+                    long clocks_per_sec = sysconf(_SC_CLK_TCK);
+
+                    times(&time_buf);
+                    kusrt.KernelTime.QuadPart = (ULONGLONG)time_buf.tms_stime * 10000000 / clocks_per_sec;
+                    kusrt.UserTime.QuadPart = (ULONGLONG)time_buf.tms_utime * 10000000 / clocks_per_sec;
+                }
+                else
+                {
+                    static BOOL reported = FALSE;
+
+                    kusrt.KernelTime.QuadPart = 0;
+                    kusrt.UserTime.QuadPart = 0;
+                    if (reported)
+                        TRACE("Cannot get kerneltime or usertime of other threads\n");
+                    else
+                    {
+                        FIXME("Cannot get kerneltime or usertime of other threads\n");
+                        reported = TRUE;
+                    }
+                }
+                if (data) memcpy( data, &kusrt, min( length, sizeof(kusrt) ));
+                if (ret_len) *ret_len = min( length, sizeof(kusrt) );
+            }
+        }
+        return status;
+
+    case ThreadDescriptorTableEntry:
+        return get_thread_ldt_entry( handle, data, length, ret_len );
+
+    case ThreadAmILastThread:
+        {
+            SERVER_START_REQ(get_thread_info)
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->tid_in = 0;
+                status = wine_server_call( req );
+                if (status == STATUS_SUCCESS)
+                {
+                    BOOLEAN last = reply->last;
+                    if (data) memcpy( data, &last, min( length, sizeof(last) ));
+                    if (ret_len) *ret_len = min( length, sizeof(last) );
+                }
+            }
+            SERVER_END_REQ;
+            return status;
+        }
+    case ThreadQuerySetWin32StartAddress:
+        {
+            SERVER_START_REQ( get_thread_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->tid_in = 0;
+                status = wine_server_call( req );
+                if (status == STATUS_SUCCESS)
+                {
+                    PRTL_THREAD_START_ROUTINE entry = wine_server_get_ptr( reply->entry_point );
+                    if (data) memcpy( data, &entry, min( length, sizeof(entry) ) );
+                    if (ret_len) *ret_len = min( length, sizeof(entry) );
+                }
+            }
+            SERVER_END_REQ;
+            return status;
+        }
+    case ThreadGroupInformation:
+        {
+            const ULONG_PTR affinity_mask = get_system_affinity_mask();
+            GROUP_AFFINITY affinity;
+
+            memset(&affinity, 0, sizeof(affinity));
+            affinity.Group = 0; /* Wine only supports max 64 processors */
+
+            SERVER_START_REQ( get_thread_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->tid_in = 0;
+                if (!(status = wine_server_call( req )))
+                    affinity.Mask = reply->affinity & affinity_mask;
+            }
+            SERVER_END_REQ;
+            if (status == STATUS_SUCCESS)
+            {
+                if (data) memcpy( data, &affinity, min( length, sizeof(affinity) ));
+                if (ret_len) *ret_len = min( length, sizeof(affinity) );
+            }
+        }
+        return status;
+    case ThreadIsIoPending:
+        FIXME( "ThreadIsIoPending info class not supported yet\n" );
+        if (length != sizeof(BOOL)) return STATUS_INFO_LENGTH_MISMATCH;
+        if (!data) return STATUS_ACCESS_DENIED;
+
+        *(BOOL*)data = FALSE;
+        if (ret_len) *ret_len = sizeof(BOOL);
+        return STATUS_SUCCESS;
+    case ThreadSuspendCount:
+        {
+            ULONG count = 0;
+
+            if (length != sizeof(ULONG)) return STATUS_INFO_LENGTH_MISMATCH;
+            if (!data) return STATUS_ACCESS_VIOLATION;
+
+            SERVER_START_REQ( get_thread_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->tid_in = 0;
+                if (!(status = wine_server_call( req )))
+                    count = reply->suspend_count;
+            }
+            SERVER_END_REQ;
+
+            if (!status)
+                *(ULONG *)data = count;
+
+            return status;
+        }
+    case ThreadDescription:
+        {
+            THREAD_DESCRIPTION_INFORMATION *info = data;
+            data_size_t len, desc_len = 0;
+            WCHAR *ptr;
+
+            len = length >= sizeof(*info) ? length - sizeof(*info) : 0;
+            ptr = info ? (WCHAR *)(info + 1) : NULL;
+
+            SERVER_START_REQ( get_thread_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                if (ptr) wine_server_set_reply( req, ptr, len );
+                status = wine_server_call( req );
+                desc_len = reply->desc_len;
+            }
+            SERVER_END_REQ;
+
+            if (!info)
+                status = STATUS_BUFFER_TOO_SMALL;
+            else if (status == STATUS_SUCCESS)
+            {
+                info->Description.Length = info->Description.MaximumLength = desc_len;
+                info->Description.Buffer = ptr;
+            }
+
+            if (ret_len && (status == STATUS_SUCCESS || status == STATUS_BUFFER_TOO_SMALL))
+                *ret_len = sizeof(*info) + desc_len;
+        }
+        return status;
+    case ThreadPriority:
+    case ThreadBasePriority:
+    case ThreadImpersonationToken:
+    case ThreadEnableAlignmentFaultFixup:
+    case ThreadEventPair_Reusable:
+    case ThreadZeroTlsCell:
+    case ThreadPerformanceCount:
+    case ThreadIdealProcessor:
+    case ThreadPriorityBoost:
+    case ThreadSetTlsArrayAddress:
+    default:
+        FIXME( "info class %d not supported yet\n", class );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+}
+
+
+/******************************************************************************
+ *              NtSetInformationThread  (NTDLL.@)
+ *              ZwSetInformationThread  (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetInformationThread( HANDLE handle, THREADINFOCLASS class,
+                                        LPCVOID data, ULONG length )
+{
+    NTSTATUS status;
+    switch(class)
+    {
+    case ThreadZeroTlsCell:
+        if (handle == GetCurrentThread())
+        {
+            LIST_ENTRY *entry;
+            DWORD index;
+
+            if (length != sizeof(DWORD)) return STATUS_INVALID_PARAMETER;
+            index = *(const DWORD *)data;
+            if (index < TLS_MINIMUM_AVAILABLE)
+            {
+                RtlAcquirePebLock();
+                for (entry = tls_links.Flink; entry != &tls_links; entry = entry->Flink)
+                {
+                    TEB *teb = CONTAINING_RECORD(entry, TEB, TlsLinks);
+                    teb->TlsSlots[index] = 0;
+                }
+                RtlReleasePebLock();
+            }
+            else
+            {
+                index -= TLS_MINIMUM_AVAILABLE;
+                if (index >= 8 * sizeof(NtCurrentTeb()->Peb->TlsExpansionBitmapBits))
+                    return STATUS_INVALID_PARAMETER;
+                RtlAcquirePebLock();
+                for (entry = tls_links.Flink; entry != &tls_links; entry = entry->Flink)
+                {
+                    TEB *teb = CONTAINING_RECORD(entry, TEB, TlsLinks);
+                    if (teb->TlsExpansionSlots) teb->TlsExpansionSlots[index] = 0;
+                }
+                RtlReleasePebLock();
+            }
+            return STATUS_SUCCESS;
+        }
+        FIXME( "ZeroTlsCell not supported on other threads\n" );
+        return STATUS_NOT_IMPLEMENTED;
+
+    case ThreadImpersonationToken:
+        {
+            const HANDLE *phToken = data;
+            if (length != sizeof(HANDLE)) return STATUS_INVALID_PARAMETER;
+            TRACE("Setting ThreadImpersonationToken handle to %p\n", *phToken );
+            SERVER_START_REQ( set_thread_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->token    = wine_server_obj_handle( *phToken );
+                req->mask     = SET_THREAD_INFO_TOKEN;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        return status;
+    case ThreadBasePriority:
+        {
+            const DWORD *pprio = data;
+            if (length != sizeof(DWORD)) return STATUS_INVALID_PARAMETER;
+            SERVER_START_REQ( set_thread_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->priority = *pprio;
+                req->mask     = SET_THREAD_INFO_PRIORITY;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        return status;
+    case ThreadAffinityMask:
+        {
+            const ULONG_PTR affinity_mask = get_system_affinity_mask();
+            ULONG_PTR req_aff;
+
+            if (length != sizeof(ULONG_PTR)) return STATUS_INVALID_PARAMETER;
+            req_aff = *(const ULONG_PTR *)data & affinity_mask;
+            if (!req_aff) return STATUS_INVALID_PARAMETER;
+
+            SERVER_START_REQ( set_thread_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->affinity = req_aff;
+                req->mask     = SET_THREAD_INFO_AFFINITY;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        return status;
+    case ThreadHideFromDebugger:
+        /* pretend the call succeeded to satisfy some code protectors */
+        return STATUS_SUCCESS;
+    case ThreadQuerySetWin32StartAddress:
+        {
+            const PRTL_THREAD_START_ROUTINE *entry = data;
+            if (length != sizeof(PRTL_THREAD_START_ROUTINE)) return STATUS_INVALID_PARAMETER;
+            SERVER_START_REQ( set_thread_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->mask     = SET_THREAD_INFO_ENTRYPOINT;
+                req->entry_point = wine_server_client_ptr( *entry );
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        return status;
+    case ThreadGroupInformation:
+        {
+            const ULONG_PTR affinity_mask = get_system_affinity_mask();
+            const GROUP_AFFINITY *req_aff;
+
+            if (length != sizeof(*req_aff)) return STATUS_INVALID_PARAMETER;
+            if (!data) return STATUS_ACCESS_VIOLATION;
+            req_aff = data;
+
+            /* On Windows the request fails if the reserved fields are set */
+            if (req_aff->Reserved[0] || req_aff->Reserved[1] || req_aff->Reserved[2])
+                return STATUS_INVALID_PARAMETER;
+
+            /* Wine only supports max 64 processors */
+            if (req_aff->Group) return STATUS_INVALID_PARAMETER;
+            if (req_aff->Mask & ~affinity_mask) return STATUS_INVALID_PARAMETER;
+            if (!req_aff->Mask) return STATUS_INVALID_PARAMETER;
+            SERVER_START_REQ( set_thread_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->affinity = req_aff->Mask;
+                req->mask     = SET_THREAD_INFO_AFFINITY;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        return status;
+    case ThreadDescription:
+        {
+            const THREAD_DESCRIPTION_INFORMATION *info = data;
+
+            if (length != sizeof(*info)) return STATUS_INFO_LENGTH_MISMATCH;
+            if (!info) return STATUS_ACCESS_VIOLATION;
+
+            if (info->Description.Length != info->Description.MaximumLength) return STATUS_INVALID_PARAMETER;
+            if (info->Description.Length && !info->Description.Buffer) return STATUS_ACCESS_VIOLATION;
+
+            SERVER_START_REQ( set_thread_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->mask   = SET_THREAD_INFO_DESCRIPTION;
+                wine_server_add_data( req, info->Description.Buffer, info->Description.Length );
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        return status;
+    case ThreadBasicInformation:
+    case ThreadTimes:
+    case ThreadPriority:
+    case ThreadDescriptorTableEntry:
+    case ThreadEnableAlignmentFaultFixup:
+    case ThreadEventPair_Reusable:
+    case ThreadPerformanceCount:
+    case ThreadAmILastThread:
+    case ThreadIdealProcessor:
+    case ThreadPriorityBoost:
+    case ThreadSetTlsArrayAddress:
+    case ThreadIsIoPending:
+    default:
+        FIXME( "info class %d not supported yet\n", class );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+}
+
+/******************************************************************************
+ * NtGetCurrentProcessorNumber (NTDLL.@)
+ *
+ * Return the processor, on which the thread is running
+ *
+ */
+ULONG WINAPI NtGetCurrentProcessorNumber(void)
+{
+    ULONG processor;
+
+#if defined(__linux__) && defined(__NR_getcpu)
+    int res = syscall(__NR_getcpu, &processor, NULL, NULL);
+    if (res != -1) return processor;
+#endif
+
+    if (NtCurrentTeb()->Peb->NumberOfProcessors > 1)
+    {
+        ULONG_PTR thread_mask, processor_mask;
+        NTSTATUS status;
+
+        status = NtQueryInformationThread(GetCurrentThread(), ThreadAffinityMask,
+                                          &thread_mask, sizeof(thread_mask), NULL);
+        if (status == STATUS_SUCCESS)
+        {
+            for (processor = 0; processor < NtCurrentTeb()->Peb->NumberOfProcessors; processor++)
+            {
+                processor_mask = (1 << processor);
+                if (thread_mask & processor_mask)
+                {
+                    if (thread_mask != processor_mask)
+                        FIXME("need multicore support (%d processors)\n",
+                              NtCurrentTeb()->Peb->NumberOfProcessors);
+                    return processor;
+                }
+            }
+        }
+    }
+
+    /* fallback to the first processor */
+    return 0;
+}
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 1d64bd82bf..84286fbee9 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <stdarg.h>
 #include <limits.h>
diff --git a/dlls/ntdll/time.c b/dlls/ntdll/time.c
index f92443500d..f900b55d83 100644
--- a/dlls/ntdll/time.c
+++ b/dlls/ntdll/time.c
@@ -23,12 +23,24 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <stdarg.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <string.h>
 #include <limits.h>
 #include <time.h>
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef __APPLE__
+# include <mach/mach_time.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -42,6 +54,23 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
+#define SHORT_TZ_NAME_MAX 8
+struct tz_name_map {
+    WCHAR key_name[128];
+    char short_name[SHORT_TZ_NAME_MAX];
+};
+
+static int init_tz_info(RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi);
+
+static RTL_CRITICAL_SECTION TIME_tz_section;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &TIME_tz_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": TIME_tz_section") }
+};
+static RTL_CRITICAL_SECTION TIME_tz_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 #define SECSPERDAY         86400
@@ -74,6 +103,33 @@ static inline BOOL IsLeapYear(int Year)
     return Year % 4 == 0 && (Year % 100 != 0 || Year % 400 == 0);
 }
 
+/* return a monotonic time counter, in Win32 ticks */
+static inline ULONGLONG monotonic_counter(void)
+{
+    struct timeval now;
+
+#ifdef __APPLE__
+    static mach_timebase_info_data_t timebase;
+
+    if (!timebase.denom) mach_timebase_info( &timebase );
+#ifdef HAVE_MACH_CONTINUOUS_TIME
+    if (&mach_continuous_time != NULL)
+        return mach_continuous_time() * timebase.numer / timebase.denom / 100;
+#endif
+    return mach_absolute_time() * timebase.numer / timebase.denom / 100;
+#elif defined(HAVE_CLOCK_GETTIME)
+    struct timespec ts;
+#ifdef CLOCK_MONOTONIC_RAW
+    if (!clock_gettime( CLOCK_MONOTONIC_RAW, &ts ))
+        return ts.tv_sec * (ULONGLONG)TICKSPERSEC + ts.tv_nsec / 100;
+#endif
+    if (!clock_gettime( CLOCK_MONOTONIC, &ts ))
+        return ts.tv_sec * (ULONGLONG)TICKSPERSEC + ts.tv_nsec / 100;
+#endif
+
+    gettimeofday( &now, 0 );
+    return now.tv_sec * (ULONGLONG)TICKSPERSEC + now.tv_usec * 10 + TICKS_1601_TO_1970 - server_start_time;
+}
 
 /******************************************************************************
  *       RtlTimeToTimeFields [NTDLL.@]
@@ -202,6 +258,44 @@ BOOLEAN WINAPI RtlTimeFieldsToTime(
         return TRUE;
 }
 
+/***********************************************************************
+ *       TIME_GetBias [internal]
+ *
+ * Helper function calculates delta local time from UTC. 
+ *
+ * PARAMS
+ *   utc [I] The current utc time.
+ *   pdaylight [I] Local daylight.
+ *
+ * RETURNS
+ *   The bias for the current timezone.
+ */
+static LONG TIME_GetBias(void)
+{
+    static time_t last_utc;
+    static LONG last_bias;
+    LONG ret;
+    time_t utc;
+
+    utc = time( NULL );
+
+    RtlEnterCriticalSection( &TIME_tz_section );
+    if (utc != last_utc)
+    {
+        RTL_DYNAMIC_TIME_ZONE_INFORMATION tzi;
+        int is_dst = init_tz_info( &tzi );
+
+	last_utc = utc;
+        last_bias = tzi.Bias;
+        last_bias += is_dst ? tzi.DaylightBias : tzi.StandardBias;
+        last_bias *= SECSPERMIN;
+    }
+
+    ret = last_bias;
+
+    RtlLeaveCriticalSection( &TIME_tz_section );
+    return ret;
+}
 
 /******************************************************************************
  *        RtlLocalTimeToSystemTime [NTDLL.@]
@@ -219,12 +313,12 @@ BOOLEAN WINAPI RtlTimeFieldsToTime(
 NTSTATUS WINAPI RtlLocalTimeToSystemTime( const LARGE_INTEGER *LocalTime,
                                           PLARGE_INTEGER SystemTime)
 {
-    SYSTEM_TIMEOFDAY_INFORMATION info;
+    LONG bias;
 
     TRACE("(%p, %p)\n", LocalTime, SystemTime);
 
-    NtQuerySystemInformation( SystemTimeOfDayInformation, &info, sizeof(info), NULL );
-    SystemTime->QuadPart = LocalTime->QuadPart + info.TimeZoneBias.QuadPart;
+    bias = TIME_GetBias();
+    SystemTime->QuadPart = LocalTime->QuadPart + bias * (LONGLONG)TICKSPERSEC;
     return STATUS_SUCCESS;
 }
 
@@ -244,12 +338,12 @@ NTSTATUS WINAPI RtlLocalTimeToSystemTime( const LARGE_INTEGER *LocalTime,
 NTSTATUS WINAPI RtlSystemTimeToLocalTime( const LARGE_INTEGER *SystemTime,
                                           PLARGE_INTEGER LocalTime )
 {
-    SYSTEM_TIMEOFDAY_INFORMATION info;
+    LONG bias;
 
     TRACE("(%p, %p)\n", SystemTime, LocalTime);
 
-    NtQuerySystemInformation( SystemTimeOfDayInformation, &info, sizeof(info), NULL );
-    LocalTime->QuadPart = SystemTime->QuadPart - info.TimeZoneBias.QuadPart;
+    bias = TIME_GetBias();
+    LocalTime->QuadPart = SystemTime->QuadPart - bias * (LONGLONG)TICKSPERSEC;
     return STATUS_SUCCESS;
 }
 
@@ -362,6 +456,55 @@ void WINAPI RtlTimeToElapsedTimeFields( const LARGE_INTEGER *Time, PTIME_FIELDS
     TimeFields->Hour = rem / 60;
 }
 
+/***********************************************************************
+ *       NtQuerySystemTime [NTDLL.@]
+ *       ZwQuerySystemTime [NTDLL.@]
+ *
+ * Get the current system time.
+ *
+ * PARAMS
+ *   time [O] Destination for the current system time.
+ *
+ * RETURNS
+ *   Success: STATUS_SUCCESS.
+ *   Failure: An NTSTATUS error code indicating the problem.
+ */
+NTSTATUS WINAPI NtQuerySystemTime( LARGE_INTEGER *time )
+{
+#ifdef HAVE_CLOCK_GETTIME
+    struct timespec ts;
+    static clockid_t clock_id = CLOCK_MONOTONIC; /* placeholder */
+
+    if (clock_id == CLOCK_MONOTONIC)
+    {
+#ifdef CLOCK_REALTIME_COARSE
+        struct timespec res;
+
+        /* Use CLOCK_REALTIME_COARSE if it has 1 ms or better resolution */
+        if (!clock_getres( CLOCK_REALTIME_COARSE, &res ) && res.tv_sec == 0 && res.tv_nsec <= 1000000)
+            clock_id = CLOCK_REALTIME_COARSE;
+        else
+#endif /* CLOCK_REALTIME_COARSE */
+            clock_id = CLOCK_REALTIME;
+    }
+
+    if (!clock_gettime( clock_id, &ts ))
+    {
+        time->QuadPart = ts.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
+        time->QuadPart += (ts.tv_nsec + 50) / 100;
+    }
+    else
+#endif /* HAVE_CLOCK_GETTIME */
+    {
+        struct timeval now;
+
+        gettimeofday( &now, 0 );
+        time->QuadPart = now.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
+        time->QuadPart += now.tv_usec * 10;
+    }
+    return STATUS_SUCCESS;
+}
+
 /***********************************************************************
  *       RtlGetSystemTimePrecise [NTDLL.@]
  *
@@ -372,7 +515,46 @@ void WINAPI RtlTimeToElapsedTimeFields( const LARGE_INTEGER *Time, PTIME_FIELDS
  */
 LONGLONG WINAPI RtlGetSystemTimePrecise( void )
 {
-    return unix_funcs->RtlGetSystemTimePrecise();
+    LONGLONG time;
+
+#ifdef HAVE_CLOCK_GETTIME
+    struct timespec ts;
+
+    if (!clock_gettime( CLOCK_REALTIME, &ts ))
+    {
+        time = ts.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
+        time += (ts.tv_nsec + 50) / 100;
+    }
+    else
+#endif
+    {
+        struct timeval now;
+
+        gettimeofday( &now, 0 );
+        time = now.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
+        time += now.tv_usec * 10;
+    }
+
+    return time;
+}
+
+/******************************************************************************
+ *  NtQueryPerformanceCounter	[NTDLL.@]
+ */
+NTSTATUS WINAPI NtQueryPerformanceCounter( LARGE_INTEGER *counter, LARGE_INTEGER *frequency )
+{
+    __TRY
+    {
+        counter->QuadPart = monotonic_counter();
+        if (frequency) frequency->QuadPart = TICKSPERSEC;
+    }
+    __EXCEPT_PAGE_FAULT
+    {
+        return STATUS_ACCESS_VIOLATION;
+    }
+    __ENDTRY
+
+    return STATUS_SUCCESS;
 }
 
 /******************************************************************************
@@ -380,7 +562,7 @@ LONGLONG WINAPI RtlGetSystemTimePrecise( void )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH RtlQueryPerformanceCounter( LARGE_INTEGER *counter )
 {
-    NtQueryPerformanceCounter( counter, NULL );
+    counter->QuadPart = monotonic_counter();
     return TRUE;
 }
 
@@ -403,6 +585,430 @@ ULONG WINAPI DECLSPEC_HOTPATCH NtGetTickCount(void)
     return user_shared_data->u.TickCount.LowPart;
 }
 
+/* calculate the mday of dst change date, so that for instance Sun 5 Oct 2007
+ * (last Sunday in October of 2007) becomes Sun Oct 28 2007
+ *
+ * Note: year, day and month must be in unix format.
+ */
+static int weekday_to_mday(int year, int day, int mon, int day_of_week)
+{
+    struct tm date;
+    time_t tmp;
+    int wday, mday;
+
+    /* find first day in the month matching week day of the date */
+    memset(&date, 0, sizeof(date));
+    date.tm_year = year;
+    date.tm_mon = mon;
+    date.tm_mday = -1;
+    date.tm_wday = -1;
+    do
+    {
+        date.tm_mday++;
+        tmp = mktime(&date);
+    } while (date.tm_wday != day_of_week || date.tm_mon != mon);
+
+    mday = date.tm_mday;
+
+    /* find number of week days in the month matching week day of the date */
+    wday = 1; /* 1 - 1st, ...., 5 - last */
+    while (wday < day)
+    {
+        struct tm *tm;
+
+        date.tm_mday += 7;
+        tmp = mktime(&date);
+        tm = localtime(&tmp);
+        if (tm->tm_mon != mon)
+            break;
+        mday = tm->tm_mday;
+        wday++;
+    }
+
+    return mday;
+}
+
+static BOOL match_tz_date(const RTL_SYSTEM_TIME *st, const RTL_SYSTEM_TIME *reg_st)
+{
+    WORD wDay;
+
+    if (st->wMonth != reg_st->wMonth) return FALSE;
+
+    if (!st->wMonth) return TRUE; /* no transition dates */
+
+    wDay = reg_st->wDay;
+    if (!reg_st->wYear) /* date in a day-of-week format */
+        wDay = weekday_to_mday(st->wYear - 1900, reg_st->wDay, reg_st->wMonth - 1, reg_st->wDayOfWeek);
+
+    if (st->wDay != wDay ||
+        st->wHour != reg_st->wHour ||
+        st->wMinute != reg_st->wMinute ||
+        st->wSecond != reg_st->wSecond ||
+        st->wMilliseconds != reg_st->wMilliseconds) return FALSE;
+
+    return TRUE;
+}
+
+static BOOL match_tz_info(const RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi, const RTL_DYNAMIC_TIME_ZONE_INFORMATION *reg_tzi)
+{
+    if (tzi->Bias == reg_tzi->Bias &&
+        match_tz_date(&tzi->StandardDate, &reg_tzi->StandardDate) &&
+        match_tz_date(&tzi->DaylightDate, &reg_tzi->DaylightDate))
+        return TRUE;
+
+    return FALSE;
+}
+
+static int compare_tz_key(const void *a, const void *b)
+{
+    const struct tz_name_map *map_a, *map_b;
+    map_a = (const struct tz_name_map *)a;
+    map_b = (const struct tz_name_map *)b;
+    return wcscmp(map_a->key_name, map_b->key_name);
+}
+
+static BOOL match_tz_name(const char* tz_name,
+                          const RTL_DYNAMIC_TIME_ZONE_INFORMATION *reg_tzi)
+{
+    static const struct tz_name_map mapping[] = {
+        { {'K','o','r','e','a',' ','S','t','a','n','d','a','r','d',' ','T','i',
+           'm','e',0 },
+          "KST" },
+        { {'T','o','k','y','o',' ','S','t','a','n','d','a','r','d',' ','T','i',
+           'm','e',0 },
+          "JST" },
+        { {'Y','a','k','u','t','s','k',' ','S','t','a','n','d','a','r','d',' ',
+           'T','i','m','e',0 },
+          "+09" }, /* YAKST was used until tzdata 2016f */
+    };
+    struct tz_name_map *match, key;
+
+    if (reg_tzi->DaylightDate.wMonth)
+        return TRUE;
+
+    wcscpy(key.key_name, reg_tzi->TimeZoneKeyName);
+    match = bsearch(&key, mapping, ARRAY_SIZE(mapping), sizeof(mapping[0]), compare_tz_key);
+    if (!match)
+        return TRUE;
+
+    return !strcmp(match->short_name, tz_name);
+}
+
+static BOOL reg_query_value(HKEY hkey, LPCWSTR name, DWORD type, void *data, DWORD count)
+{
+    UNICODE_STRING nameW;
+    char buf[256];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buf;
+
+    if (count > sizeof(buf) - sizeof(KEY_VALUE_PARTIAL_INFORMATION))
+        return FALSE;
+
+    RtlInitUnicodeString(&nameW, name);
+
+    if (NtQueryValueKey(hkey, &nameW, KeyValuePartialInformation,
+                        buf, sizeof(buf), &count))
+        return FALSE;
+
+    if (info->Type != type) return FALSE;
+
+    memcpy(data, info->Data, info->DataLength);
+    return TRUE;
+}
+
+static void find_reg_tz_info(RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi, const char* tz_name, int year)
+{
+    static const WCHAR Time_ZonesW[] = { 'M','a','c','h','i','n','e','\\',
+        'S','o','f','t','w','a','r','e','\\',
+        'M','i','c','r','o','s','o','f','t','\\',
+        'W','i','n','d','o','w','s',' ','N','T','\\',
+        'C','u','r','r','e','n','t','V','e','r','s','i','o','n','\\',
+        'T','i','m','e',' ','Z','o','n','e','s',0 };
+    static const WCHAR Dynamic_DstW[] = { 'D','y','n','a','m','i','c',' ','D','S','T',0 };
+    static const WCHAR fmtW[] = { '%','d',0 };
+    HANDLE hkey;
+    ULONG idx;
+    OBJECT_ATTRIBUTES attr, attrDynamic;
+    UNICODE_STRING nameW, nameDynamicW;
+    WCHAR buf[128], yearW[16];
+
+    NTDLL_swprintf(yearW, fmtW, year);
+
+    attrDynamic.Length = sizeof(attrDynamic);
+    attrDynamic.RootDirectory = 0; /* will be replaced later */
+    attrDynamic.ObjectName = &nameDynamicW;
+    attrDynamic.Attributes = 0;
+    attrDynamic.SecurityDescriptor = NULL;
+    attrDynamic.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString(&nameDynamicW, Dynamic_DstW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString(&nameW, Time_ZonesW);
+    if (NtOpenKey(&hkey, KEY_READ, &attr))
+    {
+        WARN("Unable to open the time zones key\n");
+        return;
+    }
+
+    idx = 0;
+    nameW.Buffer = buf;
+    nameW.Length = sizeof(buf);
+    nameW.MaximumLength = sizeof(buf);
+
+    while (!RtlpNtEnumerateSubKey(hkey, &nameW, idx++))
+    {
+        static const WCHAR stdW[] = { 'S','t','d',0 };
+        static const WCHAR dltW[] = { 'D','l','t',0 };
+        static const WCHAR mui_stdW[] = { 'M','U','I','_','S','t','d',0 };
+        static const WCHAR mui_dltW[] = { 'M','U','I','_','D','l','t',0 };
+        static const WCHAR tziW[] = { 'T','Z','I',0 };
+        RTL_DYNAMIC_TIME_ZONE_INFORMATION reg_tzi;
+        HANDLE hSubkey, hSubkeyDynamicDST;
+        BOOL is_dynamic = FALSE;
+
+        struct tz_reg_data
+        {
+            LONG bias;
+            LONG std_bias;
+            LONG dlt_bias;
+            RTL_SYSTEM_TIME std_date;
+            RTL_SYSTEM_TIME dlt_date;
+        } tz_data;
+
+        attr.Length = sizeof(attr);
+        attr.RootDirectory = hkey;
+        attr.ObjectName = &nameW;
+        attr.Attributes = 0;
+        attr.SecurityDescriptor = NULL;
+        attr.SecurityQualityOfService = NULL;
+        if (NtOpenKey(&hSubkey, KEY_READ, &attr))
+        {
+            WARN("Unable to open subkey %s\n", debugstr_wn(nameW.Buffer, nameW.Length/sizeof(WCHAR)));
+            continue;
+        }
+
+#define get_value(hkey, name, type, data, len) \
+    if (!reg_query_value(hkey, name, type, data, len)) \
+    { \
+        WARN("can't read data from %s\n", debugstr_w(name)); \
+        NtClose(hkey); \
+        continue; \
+    }
+
+        memset(&reg_tzi, 0, sizeof(reg_tzi));
+
+        if (!reg_query_value(hSubkey, mui_stdW, REG_SZ, reg_tzi.StandardName, sizeof(reg_tzi.StandardName)))
+            get_value(hSubkey, stdW, REG_SZ, reg_tzi.StandardName, sizeof(reg_tzi.StandardName));
+        if (!reg_query_value(hSubkey, mui_dltW, REG_SZ, reg_tzi.DaylightName, sizeof(reg_tzi.DaylightName)))
+            get_value(hSubkey, dltW, REG_SZ, reg_tzi.DaylightName, sizeof(reg_tzi.DaylightName));
+        memcpy(reg_tzi.TimeZoneKeyName, nameW.Buffer, nameW.Length);
+        reg_tzi.TimeZoneKeyName[nameW.Length/sizeof(WCHAR)] = 0;
+
+        /* Check for Dynamic DST entry first */
+        attrDynamic.RootDirectory = hSubkey;
+        if (!NtOpenKey(&hSubkeyDynamicDST, KEY_READ, &attrDynamic))
+        {
+            is_dynamic = reg_query_value(hSubkeyDynamicDST, yearW, REG_BINARY, &tz_data, sizeof(tz_data));
+            NtClose(hSubkeyDynamicDST);
+        }
+
+        if (!is_dynamic)
+            get_value(hSubkey, tziW, REG_BINARY, &tz_data, sizeof(tz_data));
+
+#undef get_value
+
+        reg_tzi.Bias = tz_data.bias;
+        reg_tzi.StandardBias = tz_data.std_bias;
+        reg_tzi.DaylightBias = tz_data.dlt_bias;
+        reg_tzi.StandardDate = tz_data.std_date;
+        reg_tzi.DaylightDate = tz_data.dlt_date;
+
+        TRACE("%s: bias %d\n", debugstr_wn(nameW.Buffer, nameW.Length/sizeof(WCHAR)), reg_tzi.Bias);
+        TRACE("std (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
+            reg_tzi.StandardDate.wDay, reg_tzi.StandardDate.wMonth,
+            reg_tzi.StandardDate.wYear, reg_tzi.StandardDate.wDayOfWeek,
+            reg_tzi.StandardDate.wHour, reg_tzi.StandardDate.wMinute,
+            reg_tzi.StandardDate.wSecond, reg_tzi.StandardDate.wMilliseconds,
+            reg_tzi.StandardBias);
+        TRACE("dst (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
+            reg_tzi.DaylightDate.wDay, reg_tzi.DaylightDate.wMonth,
+            reg_tzi.DaylightDate.wYear, reg_tzi.DaylightDate.wDayOfWeek,
+            reg_tzi.DaylightDate.wHour, reg_tzi.DaylightDate.wMinute,
+            reg_tzi.DaylightDate.wSecond, reg_tzi.DaylightDate.wMilliseconds,
+            reg_tzi.DaylightBias);
+
+        NtClose(hSubkey);
+
+        if (match_tz_info(tzi, &reg_tzi)
+            && match_tz_name(tz_name, &reg_tzi))
+        {
+            *tzi = reg_tzi;
+            NtClose(hkey);
+            return;
+        }
+
+        /* reset len */
+        nameW.Length = sizeof(buf);
+        nameW.MaximumLength = sizeof(buf);
+    }
+
+    NtClose(hkey);
+
+    if (idx == 1) return;  /* registry info not initialized yet */
+
+    FIXME("Can't find matching timezone information in the registry for "
+          "%s, bias %d, std (d/m/y): %u/%02u/%04u, dlt (d/m/y): %u/%02u/%04u\n",
+          tz_name, tzi->Bias,
+          tzi->StandardDate.wDay, tzi->StandardDate.wMonth, tzi->StandardDate.wYear,
+          tzi->DaylightDate.wDay, tzi->DaylightDate.wMonth, tzi->DaylightDate.wYear);
+}
+
+static time_t find_dst_change(unsigned long min, unsigned long max, int *is_dst)
+{
+    time_t start;
+    struct tm *tm;
+
+    start = min;
+    tm = localtime(&start);
+    *is_dst = !tm->tm_isdst;
+    TRACE("starting date isdst %d, %s", !*is_dst, ctime(&start));
+
+    while (min <= max)
+    {
+        time_t pos = (min + max) / 2;
+        tm = localtime(&pos);
+
+        if (tm->tm_isdst != *is_dst)
+            min = pos + 1;
+        else
+            max = pos - 1;
+    }
+    return min;
+}
+
+static int init_tz_info(RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi)
+{
+    static RTL_DYNAMIC_TIME_ZONE_INFORMATION cached_tzi;
+    static int current_year = -1, current_bias = 65535;
+    struct tm *tm;
+    char tz_name[SHORT_TZ_NAME_MAX];
+    time_t year_start, year_end, tmp, dlt = 0, std = 0;
+    int is_dst, current_is_dst, bias;
+
+    RtlEnterCriticalSection( &TIME_tz_section );
+
+    year_start = time(NULL);
+    tm = gmtime(&year_start);
+    bias = (LONG)(mktime(tm) - year_start) / 60;
+
+    tm = localtime(&year_start);
+    current_is_dst = tm->tm_isdst;
+    if (current_year == tm->tm_year && current_bias == bias)
+    {
+        *tzi = cached_tzi;
+        RtlLeaveCriticalSection( &TIME_tz_section );
+        return current_is_dst;
+    }
+
+    memset(tzi, 0, sizeof(*tzi));
+    if (!strftime(tz_name, sizeof(tz_name), "%Z", tm)) {
+        /* not enough room or another error */
+        tz_name[0] = '\0';
+    }
+
+    TRACE("tz data will be valid through year %d, bias %d\n", tm->tm_year + 1900, bias);
+    current_year = tm->tm_year;
+    current_bias = bias;
+
+    tzi->Bias = bias;
+
+    tm->tm_isdst = 0;
+    tm->tm_mday = 1;
+    tm->tm_mon = tm->tm_hour = tm->tm_min = tm->tm_sec = tm->tm_wday = tm->tm_yday = 0;
+    year_start = mktime(tm);
+    TRACE("year_start: %s", ctime(&year_start));
+
+    tm->tm_mday = tm->tm_wday = tm->tm_yday = 0;
+    tm->tm_mon = 12;
+    tm->tm_hour = 23;
+    tm->tm_min = tm->tm_sec = 59;
+    year_end = mktime(tm);
+    TRACE("year_end: %s", ctime(&year_end));
+
+    tmp = find_dst_change(year_start, year_end, &is_dst);
+    if (is_dst)
+        dlt = tmp;
+    else
+        std = tmp;
+
+    tmp = find_dst_change(tmp, year_end, &is_dst);
+    if (is_dst)
+        dlt = tmp;
+    else
+        std = tmp;
+
+    TRACE("std: %s", ctime(&std));
+    TRACE("dlt: %s", ctime(&dlt));
+
+    if (dlt == std || !dlt || !std)
+        TRACE("there is no daylight saving rules in this time zone\n");
+    else
+    {
+        tmp = dlt - tzi->Bias * 60;
+        tm = gmtime(&tmp);
+        TRACE("dlt gmtime: %s", asctime(tm));
+
+        tzi->DaylightBias = -60;
+        tzi->DaylightDate.wYear = tm->tm_year + 1900;
+        tzi->DaylightDate.wMonth = tm->tm_mon + 1;
+        tzi->DaylightDate.wDayOfWeek = tm->tm_wday;
+        tzi->DaylightDate.wDay = tm->tm_mday;
+        tzi->DaylightDate.wHour = tm->tm_hour;
+        tzi->DaylightDate.wMinute = tm->tm_min;
+        tzi->DaylightDate.wSecond = tm->tm_sec;
+        tzi->DaylightDate.wMilliseconds = 0;
+
+        TRACE("daylight (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
+            tzi->DaylightDate.wDay, tzi->DaylightDate.wMonth,
+            tzi->DaylightDate.wYear, tzi->DaylightDate.wDayOfWeek,
+            tzi->DaylightDate.wHour, tzi->DaylightDate.wMinute,
+            tzi->DaylightDate.wSecond, tzi->DaylightDate.wMilliseconds,
+            tzi->DaylightBias);
+
+        tmp = std - tzi->Bias * 60 - tzi->DaylightBias * 60;
+        tm = gmtime(&tmp);
+        TRACE("std gmtime: %s", asctime(tm));
+
+        tzi->StandardBias = 0;
+        tzi->StandardDate.wYear = tm->tm_year + 1900;
+        tzi->StandardDate.wMonth = tm->tm_mon + 1;
+        tzi->StandardDate.wDayOfWeek = tm->tm_wday;
+        tzi->StandardDate.wDay = tm->tm_mday;
+        tzi->StandardDate.wHour = tm->tm_hour;
+        tzi->StandardDate.wMinute = tm->tm_min;
+        tzi->StandardDate.wSecond = tm->tm_sec;
+        tzi->StandardDate.wMilliseconds = 0;
+
+        TRACE("standard (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
+            tzi->StandardDate.wDay, tzi->StandardDate.wMonth,
+            tzi->StandardDate.wYear, tzi->StandardDate.wDayOfWeek,
+            tzi->StandardDate.wHour, tzi->StandardDate.wMinute,
+            tzi->StandardDate.wSecond, tzi->StandardDate.wMilliseconds,
+            tzi->StandardBias);
+    }
+
+    find_reg_tz_info(tzi, tz_name, current_year + 1900);
+    cached_tzi = *tzi;
+
+    RtlLeaveCriticalSection( &TIME_tz_section );
+
+    return current_is_dst;
+}
+
 /***********************************************************************
  *      RtlQueryTimeZoneInformation [NTDLL.@]
  *
@@ -417,7 +1023,11 @@ ULONG WINAPI DECLSPEC_HOTPATCH NtGetTickCount(void)
  */
 NTSTATUS WINAPI RtlQueryTimeZoneInformation(RTL_TIME_ZONE_INFORMATION *ret)
 {
-    return NtQuerySystemInformation( SystemTimeZoneInformation, ret, sizeof(*ret), NULL );
+    RTL_DYNAMIC_TIME_ZONE_INFORMATION tzinfo;
+
+    init_tz_info( &tzinfo );
+    memcpy( ret, &tzinfo, sizeof(*ret) );
+    return STATUS_SUCCESS;
 }
 
 /***********************************************************************
@@ -432,9 +1042,11 @@ NTSTATUS WINAPI RtlQueryTimeZoneInformation(RTL_TIME_ZONE_INFORMATION *ret)
  *   Success: STATUS_SUCCESS.
  *   Failure: An NTSTATUS error code indicating the problem.
  */
-NTSTATUS WINAPI RtlQueryDynamicTimeZoneInformation(RTL_DYNAMIC_TIME_ZONE_INFORMATION *ret)
+NTSTATUS WINAPI RtlQueryDynamicTimeZoneInformation(RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzinfo)
 {
-    return NtQuerySystemInformation( SystemDynamicTimeZoneInformation, ret, sizeof(*ret), NULL );
+    init_tz_info( tzinfo );
+
+    return STATUS_SUCCESS;
 }
 
 /***********************************************************************
@@ -455,6 +1067,63 @@ NTSTATUS WINAPI RtlSetTimeZoneInformation( const RTL_TIME_ZONE_INFORMATION *tzin
     return STATUS_PRIVILEGE_NOT_HELD;
 }
 
+/***********************************************************************
+ *        NtSetSystemTime [NTDLL.@]
+ *        ZwSetSystemTime [NTDLL.@]
+ *
+ * Set the system time.
+ *
+ * PARAMS
+ *   NewTime [I] The time to set.
+ *   OldTime [O] Optional destination for the previous system time.
+ *
+ * RETURNS
+ *   Success: STATUS_SUCCESS.
+ *   Failure: An NTSTATUS error code indicating the problem.
+ */
+NTSTATUS WINAPI NtSetSystemTime(const LARGE_INTEGER *NewTime, LARGE_INTEGER *OldTime)
+{
+    struct timeval tv;
+    time_t tm_t;
+    DWORD sec, oldsec;
+    LARGE_INTEGER tm;
+
+    /* Return the old time if necessary */
+    if (!OldTime) OldTime = &tm;
+
+    NtQuerySystemTime( OldTime );
+    if (!RtlTimeToSecondsSince1970( OldTime, &oldsec )) return STATUS_INVALID_PARAMETER;
+    if (!RtlTimeToSecondsSince1970( NewTime, &sec )) return STATUS_INVALID_PARAMETER;
+
+    /* fake success if time didn't change */
+    if (oldsec == sec)
+        return STATUS_SUCCESS;
+
+    /* set the new time */
+    tv.tv_sec = sec;
+    tv.tv_usec = 0;
+
+#ifdef HAVE_SETTIMEOFDAY
+    tm_t = sec;
+    if (!settimeofday(&tv, NULL)) /* 0 is OK, -1 is error */
+    {
+        TRACE("OS time changed to %s\n", ctime(&tm_t));
+        return STATUS_SUCCESS;
+    }
+    ERR("Cannot set time to %s, time adjustment %ld: %s\n",
+        ctime(&tm_t), (long)(sec-oldsec), strerror(errno));
+    if (errno == EPERM)
+        return STATUS_PRIVILEGE_NOT_HELD;
+    else
+        return STATUS_INVALID_PARAMETER;
+#else
+    tm_t = sec;
+    FIXME("setting time to %s not implemented for missing settimeofday\n",
+        ctime(&tm_t));
+    return STATUS_NOT_IMPLEMENTED;
+#endif
+}
+
 /***********************************************************************
  *        RtlQueryUnbiasedInterruptTime [NTDLL.@]
  */
diff --git a/dlls/ntdll/unix/debug.c b/dlls/ntdll/unix/debug.c
index 368baac46f..748b509c4b 100644
--- a/dlls/ntdll/unix/debug.c
+++ b/dlls/ntdll/unix/debug.c
@@ -34,11 +34,8 @@
 # include <unistd.h>
 #endif
 
-#include "windef.h"
-#include "winnt.h"
-#include "winternl.h"
-#include "unix_private.h"
 #include "wine/debug.h"
+#include "ntdll_misc.h"
 
 WINE_DECLARE_DEBUG_CHANNEL(pid);
 WINE_DECLARE_DEBUG_CHANNEL(timestamp);
@@ -290,7 +287,7 @@ int __cdecl __wine_dbg_header( enum __wine_debug_class cls, struct __wine_debug_
 /***********************************************************************
  *		dbg_init
  */
-void dbg_init(void)
+void CDECL dbg_init(void)
 {
     setbuf( stdout, NULL );
     setbuf( stderr, NULL );
diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
deleted file mode 100644
index d157465edb..0000000000
--- a/dlls/ntdll/unix/env.c
+++ /dev/null
@@ -1,1311 +0,0 @@
-/*
- * Ntdll environment functions
- *
- * Copyright 1996, 1998 Alexandre Julliard
- * Copyright 2003       Eric Pouech
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-
-#include <assert.h>
-#include <errno.h>
-#include <locale.h>
-#include <langinfo.h>
-#include <fcntl.h>
-#include <stdarg.h>
-#include <sys/types.h>
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef HAVE_SYS_PRCTL_H
-# include <sys/prctl.h>
-#endif
-#ifdef HAVE_PWD_H
-# include <pwd.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef __APPLE__
-# include <CoreFoundation/CFLocale.h>
-# include <CoreFoundation/CFString.h>
-#endif
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winternl.h"
-#include "winbase.h"
-#include "winnls.h"
-#include "wine/debug.h"
-#include "unix_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(environ);
-
-extern int __wine_main_argc;
-extern char **__wine_main_argv;
-extern char **__wine_main_environ;
-extern WCHAR **__wine_main_wargv;
-
-USHORT *uctable = NULL, *lctable = NULL;
-SIZE_T startup_info_size = 0;
-
-int main_argc = 0;
-char **main_argv = NULL;
-char **main_envp = NULL;
-static WCHAR **main_wargv;
-
-static LCID user_lcid, system_lcid;
-static LANGID user_ui_language, system_ui_language;
-
-static char system_locale[LOCALE_NAME_MAX_LENGTH];
-static char user_locale[LOCALE_NAME_MAX_LENGTH];
-
-static struct
-{
-    USHORT *data;
-    USHORT *dbcs;
-    USHORT *mbtable;
-    void   *wctable;
-} unix_cp;
-
-static void *read_nls_file( const char *name )
-{
-    const char *dir = build_dir ? build_dir : data_dir;
-    struct stat st;
-    char *path;
-    void *data, *ret = NULL;
-    int fd;
-
-    if (!(path = malloc( strlen(dir) + 22 ))) return NULL;
-    sprintf( path, "%s/nls/%s.nls", dir, name );
-    if ((fd = open( path, O_RDONLY )) != -1)
-    {
-        fstat( fd, &st );
-        if ((data = malloc( st.st_size )) && st.st_size > 0x1000 &&
-            read( fd, data, st.st_size ) == st.st_size)
-        {
-            ret = data;
-        }
-        else
-        {
-            free( data );
-            data = NULL;
-        }
-        close( fd );
-    }
-    else ERR( "failed to load %s\n", path );
-    free( path );
-    return ret;
-}
-
-
-static int get_utf16( const WCHAR *src, unsigned int srclen, unsigned int *ch )
-{
-    if (IS_HIGH_SURROGATE( src[0] ))
-    {
-        if (srclen <= 1) return 0;
-        if (!IS_LOW_SURROGATE( src[1] )) return 0;
-        *ch = 0x10000 + ((src[0] & 0x3ff) << 10) + (src[1] & 0x3ff);
-        return 2;
-    }
-    if (IS_LOW_SURROGATE( src[0] )) return 0;
-    *ch = src[0];
-    return 1;
-}
-
-
-#ifdef __APPLE__
-
-/* The Apple filesystem enforces NFD so we need the compose tables to put it back into NFC */
-
-struct norm_table
-{
-    WCHAR   name[13];      /* 00 file name */
-    USHORT  checksum[3];   /* 1a checksum? */
-    USHORT  version[4];    /* 20 Unicode version */
-    USHORT  form;          /* 28 normalization form */
-    USHORT  len_factor;    /* 2a factor for length estimates */
-    USHORT  unknown1;      /* 2c */
-    USHORT  decomp_size;   /* 2e decomposition hash size */
-    USHORT  comp_size;     /* 30 composition hash size */
-    USHORT  unknown2;      /* 32 */
-    USHORT  classes;       /* 34 combining classes table offset */
-    USHORT  props_level1;  /* 36 char properties table level 1 offset */
-    USHORT  props_level2;  /* 38 char properties table level 2 offset */
-    USHORT  decomp_hash;   /* 3a decomposition hash table offset */
-    USHORT  decomp_map;    /* 3c decomposition character map table offset */
-    USHORT  decomp_seq;    /* 3e decomposition character sequences offset */
-    USHORT  comp_hash;     /* 40 composition hash table offset */
-    USHORT  comp_seq;      /* 42 composition character sequences offset */
-    /* BYTE[]       combining class values */
-    /* BYTE[0x2200] char properties index level 1 */
-    /* BYTE[]       char properties index level 2 */
-    /* WORD[]       decomposition hash table */
-    /* WORD[]       decomposition character map */
-    /* WORD[]       decomposition character sequences */
-    /* WORD[]       composition hash table */
-    /* WORD[]       composition character sequences */
-};
-
-static struct norm_table *nfc_table;
-
-static void init_unix_codepage(void)
-{
-    nfc_table = read_nls_file( "normnfc" );
-}
-
-static void put_utf16( WCHAR *dst, unsigned int ch )
-{
-    if (ch >= 0x10000)
-    {
-        ch -= 0x10000;
-        dst[0] = 0xd800 | (ch >> 10);
-        dst[1] = 0xdc00 | (ch & 0x3ff);
-    }
-    else dst[0] = ch;
-}
-
-static BYTE rol( BYTE val, BYTE count )
-{
-    return (val << count) | (val >> (8 - count));
-}
-
-
-static BYTE get_char_props( const struct norm_table *info, unsigned int ch )
-{
-    const BYTE *level1 = (const BYTE *)((const USHORT *)info + info->props_level1);
-    const BYTE *level2 = (const BYTE *)((const USHORT *)info + info->props_level2);
-    BYTE off = level1[ch / 128];
-
-    if (!off || off >= 0xfb) return rol( off, 5 );
-    return level2[(off - 1) * 128 + ch % 128];
-}
-
-static BYTE get_combining_class( const struct norm_table *info, unsigned int c )
-{
-    const BYTE *classes = (const BYTE *)((const USHORT *)info + info->classes);
-    BYTE class = get_char_props( info, c ) & 0x3f;
-
-    if (class == 0x3f) return 0;
-    return classes[class];
-}
-
-#define HANGUL_SBASE  0xac00
-#define HANGUL_LBASE  0x1100
-#define HANGUL_VBASE  0x1161
-#define HANGUL_TBASE  0x11a7
-#define HANGUL_LCOUNT 19
-#define HANGUL_VCOUNT 21
-#define HANGUL_TCOUNT 28
-#define HANGUL_NCOUNT (HANGUL_VCOUNT * HANGUL_TCOUNT)
-#define HANGUL_SCOUNT (HANGUL_LCOUNT * HANGUL_NCOUNT)
-
-static unsigned int compose_hangul( unsigned int ch1, unsigned int ch2 )
-{
-    if (ch1 >= HANGUL_LBASE && ch1 < HANGUL_LBASE + HANGUL_LCOUNT)
-    {
-        int lindex = ch1 - HANGUL_LBASE;
-        int vindex = ch2 - HANGUL_VBASE;
-        if (vindex >= 0 && vindex < HANGUL_VCOUNT)
-            return HANGUL_SBASE + (lindex * HANGUL_VCOUNT + vindex) * HANGUL_TCOUNT;
-    }
-    if (ch1 >= HANGUL_SBASE && ch1 < HANGUL_SBASE + HANGUL_SCOUNT)
-    {
-        int sindex = ch1 - HANGUL_SBASE;
-        if (!(sindex % HANGUL_TCOUNT))
-        {
-            int tindex = ch2 - HANGUL_TBASE;
-            if (tindex > 0 && tindex < HANGUL_TCOUNT) return ch1 + tindex;
-        }
-    }
-    return 0;
-}
-
-static unsigned int compose_chars( const struct norm_table *info, unsigned int ch1, unsigned int ch2 )
-{
-    const USHORT *table = (const USHORT *)info + info->comp_hash;
-    const WCHAR *chars = (const USHORT *)info + info->comp_seq;
-    unsigned int hash, start, end, i, len, ch[3];
-
-    hash = (ch1 + 95 * ch2) % info->comp_size;
-    start = table[hash];
-    end = table[hash + 1];
-    while (start < end)
-    {
-        for (i = 0; i < 3; i++, start += len) len = get_utf16( chars + start, end - start, ch + i );
-        if (ch[0] == ch1 && ch[1] == ch2) return ch[2];
-    }
-    return 0;
-}
-
-static unsigned int compose_string( const struct norm_table *info, WCHAR *str, unsigned int srclen )
-{
-    unsigned int i, ch, comp, len, start_ch = 0, last_starter = srclen;
-    BYTE class, prev_class = 0;
-
-    for (i = 0; i < srclen; i += len)
-    {
-        if (!(len = get_utf16( str + i, srclen - i, &ch ))) return 0;
-        class = get_combining_class( info, ch );
-        if (last_starter == srclen || (prev_class && prev_class >= class) ||
-            (!(comp = compose_hangul( start_ch, ch )) &&
-             !(comp = compose_chars( info, start_ch, ch ))))
-        {
-            if (!class)
-            {
-                last_starter = i;
-                start_ch = ch;
-            }
-            prev_class = class;
-        }
-        else
-        {
-            int comp_len = 1 + (comp >= 0x10000);
-            int start_len = 1 + (start_ch >= 0x10000);
-
-            if (comp_len != start_len)
-                memmove( str + last_starter + comp_len, str + last_starter + start_len,
-                         (i - (last_starter + start_len)) * sizeof(WCHAR) );
-            memmove( str + i + comp_len - start_len, str + i + len, (srclen - i - len) * sizeof(WCHAR) );
-            srclen += comp_len - start_len - len;
-            start_ch = comp;
-            i = last_starter;
-            len = comp_len;
-            prev_class = 0;
-            put_utf16( str + i, comp );
-        }
-    }
-    return srclen;
-}
-
-#elif defined(__ANDROID__)  /* Android always uses UTF-8 */
-
-static void init_unix_codepage(void) { }
-
-#else  /* __APPLE__ || __ANDROID__ */
-
-/* charset to codepage map, sorted by name */
-static const struct { const char *name; UINT cp; } charset_names[] =
-{
-    { "ANSIX341968", 20127 },
-    { "BIG5", 950 },
-    { "BIG5HKSCS", 950 },
-    { "CP1250", 1250 },
-    { "CP1251", 1251 },
-    { "CP1252", 1252 },
-    { "CP1253", 1253 },
-    { "CP1254", 1254 },
-    { "CP1255", 1255 },
-    { "CP1256", 1256 },
-    { "CP1257", 1257 },
-    { "CP1258", 1258 },
-    { "CP932", 932 },
-    { "CP936", 936 },
-    { "CP949", 949 },
-    { "CP950", 950 },
-    { "EUCJP", 20932 },
-    { "EUCKR", 949 },
-    { "GB18030", 936  /* 54936 */ },
-    { "GB2312", 936 },
-    { "GBK", 936 },
-    { "IBM037", 37 },
-    { "IBM1026", 1026 },
-    { "IBM424", 20424 },
-    { "IBM437", 437 },
-    { "IBM500", 500 },
-    { "IBM850", 850 },
-    { "IBM852", 852 },
-    { "IBM855", 855 },
-    { "IBM857", 857 },
-    { "IBM860", 860 },
-    { "IBM861", 861 },
-    { "IBM862", 862 },
-    { "IBM863", 863 },
-    { "IBM864", 864 },
-    { "IBM865", 865 },
-    { "IBM866", 866 },
-    { "IBM869", 869 },
-    { "IBM874", 874 },
-    { "IBM875", 875 },
-    { "ISO88591", 28591 },
-    { "ISO885913", 28603 },
-    { "ISO885915", 28605 },
-    { "ISO88592", 28592 },
-    { "ISO88593", 28593 },
-    { "ISO88594", 28594 },
-    { "ISO88595", 28595 },
-    { "ISO88596", 28596 },
-    { "ISO88597", 28597 },
-    { "ISO88598", 28598 },
-    { "ISO88599", 28599 },
-    { "KOI8R", 20866 },
-    { "KOI8U", 21866 },
-    { "TIS620", 28601 },
-    { "UTF8", CP_UTF8 }
-};
-
-static void init_unix_cptable( USHORT *ptr )
-{
-    unix_cp.data = ptr;
-    ptr += ptr[0];
-    unix_cp.wctable = ptr + ptr[0] + 1;
-    unix_cp.mbtable = ++ptr;
-    ptr += 256;
-    if (*ptr++) ptr += 256;  /* glyph table */
-    if (*ptr) unix_cp.dbcs = ptr + 1; /* dbcs ranges */
-}
-
-static void init_unix_codepage(void)
-{
-    char charset_name[16];
-    const char *name;
-    size_t i, j;
-    int min = 0, max = ARRAY_SIZE(charset_names) - 1;
-
-    setlocale( LC_CTYPE, "" );
-    if (!(name = nl_langinfo( CODESET ))) return;
-
-    /* remove punctuation characters from charset name */
-    for (i = j = 0; name[i] && j < sizeof(charset_name)-1; i++)
-    {
-        if (name[i] >= '0' && name[i] <= '9') charset_name[j++] = name[i];
-        else if (name[i] >= 'A' && name[i] <= 'Z') charset_name[j++] = name[i];
-        else if (name[i] >= 'a' && name[i] <= 'z') charset_name[j++] = name[i] + ('A' - 'a');
-    }
-    charset_name[j] = 0;
-
-    while (min <= max)
-    {
-        int pos = (min + max) / 2;
-        int res = strcmp( charset_names[pos].name, charset_name );
-        if (!res)
-        {
-            if (charset_names[pos].cp != CP_UTF8)
-            {
-                char name[16];
-                void *data;
-
-                sprintf( name, "c_%03u", charset_names[pos].cp );
-                if ((data = read_nls_file( name ))) init_unix_cptable( data );
-            }
-            return;
-        }
-        if (res > 0) max = pos - 1;
-        else min = pos + 1;
-    }
-    ERR( "unrecognized charset '%s'\n", name );
-}
-
-#endif  /* __APPLE__ || __ANDROID__ */
-
-
-static inline SIZE_T get_env_length( const WCHAR *env )
-{
-    const WCHAR *end = env;
-    while (*end) end += wcslen(end) + 1;
-    return end + 1 - env;
-}
-
-
-/***********************************************************************
- *           is_special_env_var
- *
- * Check if an environment variable needs to be handled specially when
- * passed through the Unix environment (i.e. prefixed with "WINE").
- */
-static inline BOOL is_special_env_var( const char *var )
-{
-    return (!strncmp( var, "PATH=", sizeof("PATH=")-1 ) ||
-            !strncmp( var, "PWD=", sizeof("PWD=")-1 ) ||
-            !strncmp( var, "HOME=", sizeof("HOME=")-1 ) ||
-            !strncmp( var, "TEMP=", sizeof("TEMP=")-1 ) ||
-            !strncmp( var, "TMP=", sizeof("TMP=")-1 ) ||
-            !strncmp( var, "QT_", sizeof("QT_")-1 ) ||
-            !strncmp( var, "VK_", sizeof("VK_")-1 ));
-}
-
-
-static unsigned int decode_utf8_char( unsigned char ch, const char **str, const char *strend )
-{
-    /* number of following bytes in sequence based on first byte value (for bytes above 0x7f) */
-    static const char utf8_length[128] =
-    {
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0x80-0x8f */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0x90-0x9f */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0xa0-0xaf */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0xb0-0xbf */
-        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 0xc0-0xcf */
-        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 0xd0-0xdf */
-        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* 0xe0-0xef */
-        3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0  /* 0xf0-0xff */
-    };
-
-    /* first byte mask depending on UTF-8 sequence length */
-    static const unsigned char utf8_mask[4] = { 0x7f, 0x1f, 0x0f, 0x07 };
-
-    unsigned int len = utf8_length[ch - 0x80];
-    unsigned int res = ch & utf8_mask[len];
-    const char *end = *str + len;
-
-    if (end > strend)
-    {
-        *str = end;
-        return ~0;
-    }
-    switch (len)
-    {
-    case 3:
-        if ((ch = end[-3] ^ 0x80) >= 0x40) break;
-        res = (res << 6) | ch;
-        (*str)++;
-        if (res < 0x10) break;
-    case 2:
-        if ((ch = end[-2] ^ 0x80) >= 0x40) break;
-        res = (res << 6) | ch;
-        if (res >= 0x110000 >> 6) break;
-        (*str)++;
-        if (res < 0x20) break;
-        if (res >= 0xd800 >> 6 && res <= 0xdfff >> 6) break;
-    case 1:
-        if ((ch = end[-1] ^ 0x80) >= 0x40) break;
-        res = (res << 6) | ch;
-        (*str)++;
-        if (res < 0x80) break;
-        return res;
-    }
-    return ~0;
-}
-
-
-/******************************************************************
- *      ntdll_umbstowcs
- */
-DWORD ntdll_umbstowcs( const char *src, DWORD srclen, WCHAR *dst, DWORD dstlen )
-{
-    DWORD reslen;
-
-    if (unix_cp.data)
-    {
-        DWORD i;
-
-        if (unix_cp.dbcs)
-        {
-            for (i = dstlen; srclen && i; i--, srclen--, src++, dst++)
-            {
-                USHORT off = unix_cp.dbcs[(unsigned char)*src];
-                if (off && srclen > 1)
-                {
-                    src++;
-                    srclen--;
-                    *dst = unix_cp.dbcs[off + (unsigned char)*src];
-                }
-                else *dst = unix_cp.mbtable[(unsigned char)*src];
-            }
-            reslen = dstlen - i;
-        }
-        else
-        {
-            reslen = min( srclen, dstlen );
-            for (i = 0; i < reslen; i++) dst[i] = unix_cp.mbtable[(unsigned char)src[i]];
-        }
-    }
-    else  /* utf-8 */
-    {
-        unsigned int res;
-        const char *srcend = src + srclen;
-        WCHAR *dstend = dst + dstlen;
-
-        while ((dst < dstend) && (src < srcend))
-        {
-            unsigned char ch = *src++;
-            if (ch < 0x80)  /* special fast case for 7-bit ASCII */
-            {
-                *dst++ = ch;
-                continue;
-            }
-            if ((res = decode_utf8_char( ch, &src, srcend )) <= 0xffff)
-            {
-                *dst++ = res;
-            }
-            else if (res <= 0x10ffff)  /* we need surrogates */
-            {
-                res -= 0x10000;
-                *dst++ = 0xd800 | (res >> 10);
-                if (dst == dstend) break;
-                *dst++ = 0xdc00 | (res & 0x3ff);
-            }
-            else
-            {
-                *dst++ = 0xfffd;
-            }
-        }
-        reslen = dstlen - (dstend - dst);
-#ifdef __APPLE__  /* work around broken Mac OS X filesystem that enforces NFD */
-        if (reslen && nfc_table) reslen = compose_string( nfc_table, dst - reslen, reslen );
-#endif
-    }
-    return reslen;
-}
-
-
-/******************************************************************
- *      ntdll_wcstoumbs
- */
-int ntdll_wcstoumbs( const WCHAR *src, DWORD srclen, char *dst, DWORD dstlen, BOOL strict )
-{
-    DWORD i, reslen;
-
-    if (unix_cp.data)
-    {
-        if (unix_cp.dbcs)
-        {
-            const unsigned short *uni2cp = unix_cp.wctable;
-            for (i = dstlen; srclen && i; i--, srclen--, src++)
-            {
-                unsigned short ch = uni2cp[*src];
-                if (ch >> 8)
-                {
-                    if (strict && unix_cp.dbcs[unix_cp.dbcs[ch >> 8] + (ch & 0xff)] != *src) return -1;
-                    if (i == 1) break;  /* do not output a partial char */
-                    i--;
-                    *dst++ = ch >> 8;
-                }
-                else
-                {
-                    if (unix_cp.mbtable[ch] != *src) return -1;
-                    *dst++ = (char)ch;
-                }
-            }
-            reslen = dstlen - i;
-        }
-        else
-        {
-            const unsigned char *uni2cp = unix_cp.wctable;
-            reslen = min( srclen, dstlen );
-            for (i = 0; i < reslen; i++)
-            {
-                unsigned char ch = uni2cp[src[i]];
-                if (strict && unix_cp.mbtable[ch] != src[i]) return -1;
-                dst[i] = ch;
-            }
-        }
-    }
-    else  /* utf-8 */
-    {
-        char *end;
-        unsigned int val;
-
-        for (end = dst + dstlen; srclen; srclen--, src++)
-        {
-            WCHAR ch = *src;
-
-            if (ch < 0x80)  /* 0x00-0x7f: 1 byte */
-            {
-                if (dst > end - 1) break;
-                *dst++ = ch;
-                continue;
-            }
-            if (ch < 0x800)  /* 0x80-0x7ff: 2 bytes */
-            {
-                if (dst > end - 2) break;
-                dst[1] = 0x80 | (ch & 0x3f);
-                ch >>= 6;
-                dst[0] = 0xc0 | ch;
-                dst += 2;
-                continue;
-            }
-            if (!get_utf16( src, srclen, &val ))
-            {
-                if (strict) return -1;
-                val = 0xfffd;
-            }
-            if (val < 0x10000)  /* 0x800-0xffff: 3 bytes */
-            {
-                if (dst > end - 3) break;
-                dst[2] = 0x80 | (val & 0x3f);
-                val >>= 6;
-                dst[1] = 0x80 | (val & 0x3f);
-                val >>= 6;
-                dst[0] = 0xe0 | val;
-                dst += 3;
-            }
-            else   /* 0x10000-0x10ffff: 4 bytes */
-            {
-                if (dst > end - 4) break;
-                dst[3] = 0x80 | (val & 0x3f);
-                val >>= 6;
-                dst[2] = 0x80 | (val & 0x3f);
-                val >>= 6;
-                dst[1] = 0x80 | (val & 0x3f);
-                val >>= 6;
-                dst[0] = 0xf0 | val;
-                dst += 4;
-                src++;
-                srclen--;
-            }
-        }
-        reslen = dstlen - (end - dst);
-    }
-    return reslen;
-}
-
-
-/***********************************************************************
- *           build_envp
- *
- * Build the environment of a new child process.
- */
-char **build_envp( const WCHAR *envW )
-{
-    static const char * const unix_vars[] = { "PATH", "TEMP", "TMP", "HOME" };
-    char **envp;
-    char *env, *p;
-    int count = 1, length, lenW;
-    unsigned int i;
-
-    lenW = get_env_length( envW );
-    if (!(env = malloc( lenW * 3 ))) return NULL;
-    length = ntdll_wcstoumbs( envW, lenW, env, lenW * 3, FALSE );
-
-    for (p = env; *p; p += strlen(p) + 1, count++)
-        if (is_special_env_var( p )) length += 4; /* prefix it with "WINE" */
-
-    for (i = 0; i < ARRAY_SIZE( unix_vars ); i++)
-    {
-        if (!(p = getenv(unix_vars[i]))) continue;
-        length += strlen(unix_vars[i]) + strlen(p) + 2;
-        count++;
-    }
-
-    if ((envp = malloc( count * sizeof(*envp) + length )))
-    {
-        char **envptr = envp;
-        char *dst = (char *)(envp + count);
-
-        /* some variables must not be modified, so we get them directly from the unix env */
-        for (i = 0; i < ARRAY_SIZE( unix_vars ); i++)
-        {
-            if (!(p = getenv( unix_vars[i] ))) continue;
-            *envptr++ = strcpy( dst, unix_vars[i] );
-            strcat( dst, "=" );
-            strcat( dst, p );
-            dst += strlen(dst) + 1;
-        }
-
-        /* now put the Windows environment strings */
-        for (p = env; *p; p += strlen(p) + 1)
-        {
-            if (*p == '=') continue;  /* skip drive curdirs, this crashes some unix apps */
-            if (!strncmp( p, "WINEPRELOADRESERVE=", sizeof("WINEPRELOADRESERVE=")-1 )) continue;
-            if (!strncmp( p, "WINELOADERNOEXEC=", sizeof("WINELOADERNOEXEC=")-1 )) continue;
-            if (!strncmp( p, "WINESERVERSOCKET=", sizeof("WINESERVERSOCKET=")-1 )) continue;
-            if (is_special_env_var( p ))  /* prefix it with "WINE" */
-            {
-                *envptr++ = strcpy( dst, "WINE" );
-                strcat( dst, p );
-            }
-            else
-            {
-                *envptr++ = strcpy( dst, p );
-            }
-            dst += strlen(dst) + 1;
-        }
-        *envptr = 0;
-    }
-    free( env );
-    return envp;
-}
-
-
-/***********************************************************************
- *           set_process_name
- *
- * Change the process name in the ps output.
- */
-static void set_process_name( int argc, char *argv[] )
-{
-    BOOL shift_strings;
-    char *p, *name;
-    int i;
-
-#ifdef HAVE_SETPROCTITLE
-    setproctitle("-%s", argv[1]);
-    shift_strings = FALSE;
-#else
-    p = argv[0];
-
-    shift_strings = (argc >= 2);
-    for (i = 1; i < argc; i++)
-    {
-        p += strlen(p) + 1;
-        if (p != argv[i])
-        {
-            shift_strings = FALSE;
-            break;
-        }
-    }
-#endif
-
-    if (shift_strings)
-    {
-        int offset = argv[1] - argv[0];
-        char *end = argv[argc-1] + strlen(argv[argc-1]) + 1;
-        memmove( argv[0], argv[1], end - argv[1] );
-        memset( end - offset, 0, offset );
-        for (i = 1; i < argc; i++)
-            argv[i-1] = argv[i] - offset;
-        argv[i-1] = NULL;
-    }
-    else
-    {
-        /* remove argv[0] */
-        memmove( argv, argv + 1, argc * sizeof(argv[0]) );
-    }
-
-    name = argv[0];
-    if ((p = strrchr( name, '\\' ))) name = p + 1;
-    if ((p = strrchr( name, '/' ))) name = p + 1;
-
-#if defined(HAVE_SETPROGNAME)
-    setprogname( name );
-#endif
-
-#ifdef HAVE_PRCTL
-#ifndef PR_SET_NAME
-# define PR_SET_NAME 15
-#endif
-    prctl( PR_SET_NAME, name );
-#endif  /* HAVE_PRCTL */
-}
-
-
-/***********************************************************************
- *              build_wargv
- *
- * Build the Unicode argv array.
- */
-static WCHAR **build_wargv( char **argv )
-{
-    int argc;
-    WCHAR *p, **wargv;
-    DWORD total = 0;
-
-    for (argc = 0; argv[argc]; argc++) total += strlen(argv[argc]) + 1;
-
-    wargv = malloc( total * sizeof(WCHAR) + (argc + 1) * sizeof(*wargv) );
-    p = (WCHAR *)(wargv + argc + 1);
-    for (argc = 0; argv[argc]; argc++)
-    {
-        DWORD reslen = ntdll_umbstowcs( argv[argc], strlen(argv[argc]) + 1, p, total );
-        wargv[argc] = p;
-        p += reslen;
-        total -= reslen;
-    }
-    wargv[argc] = NULL;
-    return wargv;
-}
-
-
-/* Unix format is: lang[_country][.charset][@modifier]
- * Windows format is: lang[-script][-country][_modifier] */
-static BOOL unix_to_win_locale( const char *unix_name, char *win_name )
-{
-    static const char sep[] = "_.@";
-    char buffer[LOCALE_NAME_MAX_LENGTH];
-    char *p, *country = NULL, *modifier = NULL;
-
-    if (!unix_name || !unix_name[0] || !strcmp( unix_name, "C" ))
-    {
-        unix_name = getenv( "LC_ALL" );
-        if (!unix_name || !unix_name[0]) return FALSE;
-    }
-
-    if (strlen( unix_name ) >= LOCALE_NAME_MAX_LENGTH) return FALSE;
-    strcpy( buffer, unix_name );
-    if (!(p = strpbrk( buffer, sep )))
-    {
-        if (!strcmp( buffer, "POSIX" ) || !strcmp( buffer, "C" ))
-            strcpy( win_name, "en-US" );
-        else
-            strcpy( win_name, buffer );
-        return TRUE;
-    }
-
-    if (*p == '_')
-    {
-        *p++ = 0;
-        country = p;
-        p = strpbrk( p, sep + 1 );
-    }
-    if (p && *p == '.')
-    {
-        *p++ = 0;
-        /* charset, ignore */
-        p = strchr( p, '@' );
-    }
-    if (p)
-    {
-        *p++ = 0;
-        modifier = p;
-    }
-
-    /* rebuild a Windows name */
-
-    strcpy( win_name, buffer );
-    if (modifier)
-    {
-        if (!strcmp( modifier, "latin" )) strcat( win_name, "-Latn" );
-        else if (!strcmp( modifier, "euro" )) {} /* ignore */
-        else return FALSE;
-    }
-    if (country)
-    {
-        p = win_name + strlen(win_name);
-        *p++ = '-';
-        strcpy( p, country );
-    }
-    return TRUE;
-}
-
-
-/******************************************************************
- *		init_locale
- */
-static void init_locale(void)
-{
-    setlocale( LC_ALL, "" );
-    if (!unix_to_win_locale( setlocale( LC_CTYPE, NULL ), system_locale )) system_locale[0] = 0;
-    if (!unix_to_win_locale( setlocale( LC_MESSAGES, NULL ), user_locale )) user_locale[0] = 0;
-
-#ifdef __APPLE__
-    if (!system_locale[0])
-    {
-        CFLocaleRef locale = CFLocaleCopyCurrent();
-        CFStringRef lang = CFLocaleGetValue( locale, kCFLocaleLanguageCode );
-        CFStringRef country = CFLocaleGetValue( locale, kCFLocaleCountryCode );
-        CFStringRef locale_string;
-
-        if (country)
-            locale_string = CFStringCreateWithFormat(NULL, NULL, CFSTR("%@_%@"), lang, country);
-        else
-            locale_string = CFStringCreateCopy(NULL, lang);
-
-        CFStringGetCString(locale_string, system_locale, sizeof(system_locale), kCFStringEncodingUTF8);
-        CFRelease(locale);
-        CFRelease(locale_string);
-    }
-    if (!user_locale[0])
-    {
-        /* Retrieve the preferred language as chosen in System Preferences. */
-        CFArrayRef preferred_langs = CFLocaleCopyPreferredLanguages();
-        if (preferred_langs && CFArrayGetCount( preferred_langs ))
-        {
-            CFStringRef preferred_lang = CFArrayGetValueAtIndex( preferred_langs, 0 );
-            CFDictionaryRef components = CFLocaleCreateComponentsFromLocaleIdentifier( NULL, preferred_lang );
-            if (components)
-            {
-                CFStringRef lang = CFDictionaryGetValue( components, kCFLocaleLanguageCode );
-                CFStringRef country = CFDictionaryGetValue( components, kCFLocaleCountryCode );
-                CFLocaleRef locale = NULL;
-                CFStringRef locale_string;
-
-                if (!country)
-                {
-                    locale = CFLocaleCopyCurrent();
-                    country = CFLocaleGetValue( locale, kCFLocaleCountryCode );
-                }
-                if (country)
-                    locale_string = CFStringCreateWithFormat( NULL, NULL, CFSTR("%@_%@"), lang, country );
-                else
-                    locale_string = CFStringCreateCopy( NULL, lang );
-                CFStringGetCString( locale_string, user_locale, sizeof(user_locale), kCFStringEncodingUTF8 );
-                CFRelease( locale_string );
-                if (locale) CFRelease( locale );
-                CFRelease( components );
-            }
-        }
-        if (preferred_langs) CFRelease( preferred_langs );
-    }
-#endif
-    setlocale( LC_NUMERIC, "C" );  /* FIXME: oleaut32 depends on this */
-}
-
-
-/***********************************************************************
- *              init_environment
- */
-void init_environment( int argc, char *argv[], char *envp[] )
-{
-    USHORT *case_table;
-
-    init_unix_codepage();
-    init_locale();
-    set_process_name( argc, argv );
-
-    if ((case_table = read_nls_file( "l_intl" )))
-    {
-        uctable = case_table + 2;
-        lctable = case_table + case_table[1] + 2;
-    }
-    __wine_main_argc = main_argc = argc;
-    __wine_main_argv = main_argv = argv;
-    __wine_main_wargv = main_wargv = build_wargv( argv );
-    __wine_main_environ = main_envp = envp;
-}
-
-
-static const char overrides_help_message[] =
-    "Syntax:\n"
-    "  WINEDLLOVERRIDES=\"entry;entry;entry...\"\n"
-    "    where each entry is of the form:\n"
-    "        module[,module...]={native|builtin}[,{b|n}]\n"
-    "\n"
-    "    Only the first letter of the override (native or builtin)\n"
-    "    is significant.\n\n"
-    "Example:\n"
-    "  WINEDLLOVERRIDES=\"comdlg32=n,b;shell32,shlwapi=b\"\n";
-
-/*************************************************************************
- *		get_initial_environment
- *
- * Return the initial environment.
- */
-NTSTATUS CDECL get_initial_environment( WCHAR **wargv[], WCHAR *env, SIZE_T *size )
-{
-    char **e;
-    WCHAR *ptr = env, *end = env + *size;
-
-    *wargv = main_wargv;
-    for (e = main_envp; *e && ptr < end; e++)
-    {
-        char *str = *e;
-
-        /* skip Unix special variables and use the Wine variants instead */
-        if (!strncmp( str, "WINE", 4 ))
-        {
-            if (is_special_env_var( str + 4 )) str += 4;
-            else if (!strncmp( str, "WINEPRELOADRESERVE=", 19 )) continue;  /* skip it */
-            else if (!strcmp( str, "WINEDLLOVERRIDES=help" ))
-            {
-                MESSAGE( overrides_help_message );
-                exit(0);
-            }
-        }
-        else if (is_special_env_var( str )) continue;  /* skip it */
-
-        ptr += ntdll_umbstowcs( str, strlen(str) + 1, ptr, end - ptr );
-    }
-
-    if (ptr < end)
-    {
-        *ptr++ = 0;
-        *size = ptr - env;
-        return STATUS_SUCCESS;
-    }
-
-    /* estimate needed size */
-    for (e = main_envp, *size = 1; *e; e++) if (!is_special_env_var( *e )) *size += strlen(*e) + 1;
-    return STATUS_BUFFER_TOO_SMALL;
-}
-
-
-/* append a variable to the environment */
-static void append_envA( WCHAR *env, SIZE_T *pos, const char *name, const char *value )
-{
-    SIZE_T i = *pos;
-
-    while (*name) env[i++] = (unsigned char)*name++;
-    if (value)
-    {
-        env[i++] = '=';
-        i += ntdll_umbstowcs( value, strlen(value), env + i, strlen(value) );
-    }
-    env[i++] = 0;
-    *pos = i;
-}
-
-static void append_envW( WCHAR *env, SIZE_T *pos, const char *name, const WCHAR *value )
-{
-    SIZE_T i = *pos;
-
-    while (*name) env[i++] = (unsigned char)*name++;
-    if (value)
-    {
-        env[i++] = '=';
-        while (*value) env[i++] = *value++;
-    }
-    env[i++] = 0;
-    *pos = i;
-}
-
-/* set an environment variable for one of the wine path variables */
-static void add_path_var( WCHAR *env, SIZE_T *pos, const char *name, const char *path )
-{
-    WCHAR *nt_name;
-
-    if (!path) append_envW( env, pos, name, NULL );
-    else
-    {
-        if (unix_to_nt_file_name( path, &nt_name )) return;
-        append_envW( env, pos, name, nt_name );
-        free( nt_name );
-    }
-}
-
-
-/*************************************************************************
- *		get_startup_info
- *
- * Get the startup information from the server.
- */
-NTSTATUS CDECL get_startup_info( startup_info_t *info, SIZE_T *total_size, SIZE_T *info_size )
-{
-    NTSTATUS status;
-
-    if (*total_size < startup_info_size)
-    {
-        *total_size = startup_info_size;
-        return STATUS_BUFFER_TOO_SMALL;
-    }
-    SERVER_START_REQ( get_startup_info )
-    {
-        wine_server_set_reply( req, info, *total_size );
-        status = wine_server_call( req );
-        *total_size = wine_server_reply_size( reply );
-        *info_size = reply->info_size;
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/*************************************************************************
- *		get_dynamic_environment
- *
- * Get the environment variables that can differ between processes.
- */
-NTSTATUS CDECL get_dynamic_environment( WCHAR *env, SIZE_T *size )
-{
-    const char *overrides = getenv( "WINEDLLOVERRIDES" );
-    SIZE_T alloc, pos = 0;
-    WCHAR *buffer;
-    DWORD i;
-    char dlldir[22];
-    NTSTATUS status = STATUS_SUCCESS;
-
-    alloc = 20 * 7;  /* 7 variable names */
-    if (data_dir) alloc += strlen( data_dir ) + 9;
-    if (home_dir) alloc += strlen( home_dir ) + 9;
-    if (build_dir) alloc += strlen( build_dir ) + 9;
-    if (config_dir) alloc += strlen( config_dir ) + 9;
-    if (user_name) alloc += strlen( user_name );
-    if (overrides) alloc += strlen( overrides );
-    for (i = 0; dll_paths[i]; i++) alloc += 20 + strlen( dll_paths[i] ) + 9;
-
-    if (!(buffer = malloc( alloc * sizeof(WCHAR) ))) return STATUS_NO_MEMORY;
-    pos = 0;
-    add_path_var( buffer, &pos, "WINEDATADIR", data_dir );
-    add_path_var( buffer, &pos, "WINEHOMEDIR", home_dir );
-    add_path_var( buffer, &pos, "WINEBUILDDIR", build_dir );
-    add_path_var( buffer, &pos, "WINECONFIGDIR", config_dir );
-    for (i = 0; dll_paths[i]; i++)
-    {
-        sprintf( dlldir, "WINEDLLDIR%u", i );
-        add_path_var( buffer, &pos, dlldir, dll_paths[i] );
-    }
-    sprintf( dlldir, "WINEDLLDIR%u", i );
-    append_envW( buffer, &pos, dlldir, NULL );
-    append_envA( buffer, &pos, "WINEUSERNAME", user_name );
-    append_envA( buffer, &pos, "WINEDLLOVERRIDES", overrides );
-    assert( pos <= alloc );
-
-    if (pos < *size)
-    {
-        memcpy( env, buffer, pos * sizeof(WCHAR) );
-        env[pos] = 0;
-    }
-    else status = STATUS_BUFFER_TOO_SMALL;
-    *size = pos + 1;
-    free( buffer );
-    return status;
-}
-
-
-/*************************************************************************
- *		get_initial_console
- *
- * Return the initial console handles.
- */
-void CDECL get_initial_console( HANDLE *handle, HANDLE *std_in, HANDLE *std_out, HANDLE *std_err )
-{
-    *handle = *std_in = *std_out = *std_err = 0;
-    if (isatty(0) || isatty(1) || isatty(2)) *handle = (HANDLE)2; /* see kernel32/kernel_private.h */
-    if (!isatty(0)) server_fd_to_handle( 0, GENERIC_READ|SYNCHRONIZE,  OBJ_INHERIT, std_in );
-    if (!isatty(1)) server_fd_to_handle( 1, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, std_out );
-    if (!isatty(2)) server_fd_to_handle( 2, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, std_err );
-}
-
-
-/*************************************************************************
- *		get_initial_directory
- *
- * Get the current directory at startup.
- */
-void CDECL get_initial_directory( UNICODE_STRING *dir )
-{
-    const char *pwd;
-    char *cwd;
-    int size;
-
-    dir->Length = 0;
-
-    /* try to get it from the Unix cwd */
-
-    for (size = 1024; ; size *= 2)
-    {
-        if (!(cwd = malloc( size ))) break;
-        if (getcwd( cwd, size )) break;
-        free( cwd );
-        if (errno == ERANGE) continue;
-        cwd = NULL;
-        break;
-    }
-
-    /* try to use PWD if it is valid, so that we don't resolve symlinks */
-
-    pwd = getenv( "PWD" );
-    if (cwd)
-    {
-        struct stat st1, st2;
-
-        if (!pwd || stat( pwd, &st1 ) == -1 ||
-            (!stat( cwd, &st2 ) && (st1.st_dev != st2.st_dev || st1.st_ino != st2.st_ino)))
-            pwd = cwd;
-    }
-
-    if (pwd)
-    {
-        WCHAR *nt_name;
-
-        if (!unix_to_nt_file_name( pwd, &nt_name ))
-        {
-            /* skip the \??\ prefix */
-            ULONG len = wcslen( nt_name );
-            if (len > 6 && nt_name[5] == ':')
-            {
-                dir->Length = (len - 4) * sizeof(WCHAR);
-                memcpy( dir->Buffer, nt_name + 4, dir->Length );
-            }
-            else  /* change \??\ to \\?\ */
-            {
-                dir->Length = len * sizeof(WCHAR);
-                memcpy( dir->Buffer, nt_name, dir->Length );
-                dir->Buffer[1] = '\\';
-            }
-            free( nt_name );
-        }
-    }
-
-    if (!dir->Length)  /* still not initialized */
-        MESSAGE("Warning: could not find DOS drive for current working directory '%s', "
-                "starting in the Windows directory.\n", cwd ? cwd : "" );
-    free( cwd );
-    chdir( "/" ); /* avoid locking removable devices */
-}
-
-
-/*************************************************************************
- *		get_unix_codepage_data
- *
- * Return the Unix codepage data.
- */
-USHORT * CDECL get_unix_codepage_data(void)
-{
-    return unix_cp.data;
-}
-
-
-/*************************************************************************
- *		get_locales
- *
- * Return the system and user locales. Buffers must be at least LOCALE_NAME_MAX_LENGTH chars long.
- */
-void CDECL get_locales( WCHAR *sys, WCHAR *user )
-{
-    ntdll_umbstowcs( system_locale, strlen(system_locale) + 1, sys, LOCALE_NAME_MAX_LENGTH );
-    ntdll_umbstowcs( user_locale, strlen(user_locale) + 1, user, LOCALE_NAME_MAX_LENGTH );
-}
-
-
-/**********************************************************************
- *      NtQueryDefaultLocale  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryDefaultLocale( BOOLEAN user, LCID *lcid )
-{
-    *lcid = user ? user_lcid : system_lcid;
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *      NtSetDefaultLocale  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetDefaultLocale( BOOLEAN user, LCID lcid )
-{
-    if (user) user_lcid = lcid;
-    else
-    {
-        system_lcid = lcid;
-        system_ui_language = LANGIDFROMLCID(lcid); /* there is no separate call to set it */
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *      NtQueryDefaultUILanguage  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryDefaultUILanguage( LANGID *lang )
-{
-    *lang = user_ui_language;
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *      NtSetDefaultUILanguage  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetDefaultUILanguage( LANGID lang )
-{
-    user_ui_language = lang;
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *      NtQueryInstallUILanguage  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryInstallUILanguage( LANGID *lang )
-{
-    *lang = system_ui_language;
-    return STATUS_SUCCESS;
-}
diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
deleted file mode 100644
index 03e92a5c59..0000000000
--- a/dlls/ntdll/unix/file.c
+++ /dev/null
@@ -1,6664 +0,0 @@
-/*
- * NTDLL directory and file functions
- *
- * Copyright 1993 Erik Bos
- * Copyright 2003 Eric Pouech
- * Copyright 1996, 2004 Alexandre Julliard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <sys/types.h>
-#include <dirent.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdarg.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <limits.h>
-#ifdef HAVE_MNTENT_H
-#include <mntent.h>
-#endif
-#ifdef HAVE_POLL_H
-#include <poll.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef HAVE_SYS_STATVFS_H
-# include <sys/statvfs.h>
-#endif
-#ifdef HAVE_SYS_SYSCALL_H
-# include <sys/syscall.h>
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef HAVE_SYS_TIME_H
-# include <sys/time.h>
-#endif
-#ifdef HAVE_SYS_ATTR_H
-#include <sys/attr.h>
-#endif
-#ifdef MAJOR_IN_MKDEV
-# include <sys/mkdev.h>
-#elif defined(MAJOR_IN_SYSMACROS)
-# include <sys/sysmacros.h>
-#endif
-#ifdef HAVE_SYS_VNODE_H
-# ifdef HAVE_STDINT_H
-# include <stdint.h>  /* needed for kfreebsd */
-# endif
-/* Work around a conflict with Solaris' system list defined in sys/list.h. */
-#define list SYSLIST
-#define list_next SYSLIST_NEXT
-#define list_prev SYSLIST_PREV
-#define list_head SYSLIST_HEAD
-#define list_tail SYSLIST_TAIL
-#define list_move_tail SYSLIST_MOVE_TAIL
-#define list_remove SYSLIST_REMOVE
-#include <sys/vnode.h>
-#undef list
-#undef list_next
-#undef list_prev
-#undef list_head
-#undef list_tail
-#undef list_move_tail
-#undef list_remove
-#endif
-#ifdef HAVE_SYS_IOCTL_H
-#include <sys/ioctl.h>
-#endif
-#ifdef HAVE_LINUX_IOCTL_H
-#include <linux/ioctl.h>
-#endif
-#ifdef HAVE_LINUX_MAJOR_H
-# include <linux/major.h>
-#endif
-#ifdef HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-#ifdef HAVE_SYS_MOUNT_H
-#include <sys/mount.h>
-#endif
-#ifdef HAVE_SYS_STATFS_H
-#include <sys/statfs.h>
-#endif
-#include <time.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#define NONAMELESSUNION
-#include "windef.h"
-#include "winnt.h"
-#include "winioctl.h"
-#include "winternl.h"
-#include "ddk/ntddk.h"
-#include "ddk/ntddser.h"
-#include "ddk/wdm.h"
-#define WINE_MOUNTMGR_EXTENSIONS
-#include "ddk/mountmgr.h"
-#include "wine/server.h"
-#include "wine/list.h"
-#include "wine/debug.h"
-#include "unix_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(file);
-WINE_DECLARE_DEBUG_CHANNEL(winediag);
-
-#define MAX_DOS_DRIVES 26
-
-#define FILE_WRITE_TO_END_OF_FILE      ((LONGLONG)-1)
-#define FILE_USE_FILE_POINTER_POSITION ((LONGLONG)-2)
-
-/* just in case... */
-#undef VFAT_IOCTL_READDIR_BOTH
-#undef EXT2_IOC_GETFLAGS
-#undef EXT4_CASEFOLD_FL
-
-#ifdef linux
-
-/* We want the real kernel dirent structure, not the libc one */
-typedef struct
-{
-    long d_ino;
-    long d_off;
-    unsigned short d_reclen;
-    char d_name[256];
-} KERNEL_DIRENT;
-
-/* Define the VFAT ioctl to get both short and long file names */
-#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, KERNEL_DIRENT [2] )
-
-/* Define the ext2 ioctl for handling extra attributes */
-#define EXT2_IOC_GETFLAGS _IOR('f', 1, long)
-
-/* Case-insensitivity attribute */
-#define EXT4_CASEFOLD_FL 0x40000000
-
-#ifndef O_DIRECTORY
-# define O_DIRECTORY 0200000 /* must be directory */
-#endif
-
-#ifndef AT_NO_AUTOMOUNT
-#define AT_NO_AUTOMOUNT 0x800
-#endif
-
-#endif  /* linux */
-
-#define IS_SEPARATOR(ch)   ((ch) == '\\' || (ch) == '/')
-
-#define INVALID_NT_CHARS   '*','?','<','>','|','"'
-#define INVALID_DOS_CHARS  INVALID_NT_CHARS,'+','=',',',';','[',']',' ','\345'
-
-#define MAX_DIR_ENTRY_LEN 255  /* max length of a directory entry in chars */
-
-#define MAX_IGNORED_FILES 4
-
-struct file_identity
-{
-    dev_t dev;
-    ino_t ino;
-};
-
-static struct file_identity ignored_files[MAX_IGNORED_FILES];
-static unsigned int ignored_files_count;
-
-union file_directory_info
-{
-    ULONG                              next;
-    FILE_DIRECTORY_INFORMATION         dir;
-    FILE_BOTH_DIRECTORY_INFORMATION    both;
-    FILE_FULL_DIRECTORY_INFORMATION    full;
-    FILE_ID_BOTH_DIRECTORY_INFORMATION id_both;
-    FILE_ID_FULL_DIRECTORY_INFORMATION id_full;
-    FILE_ID_GLOBAL_TX_DIR_INFORMATION  id_tx;
-    FILE_NAMES_INFORMATION             names;
-};
-
-struct dir_data_buffer
-{
-    struct dir_data_buffer *next;    /* next buffer in the list */
-    unsigned int            size;    /* total size of the buffer */
-    unsigned int            pos;     /* current position in the buffer */
-    char                    data[1];
-};
-
-struct dir_data_names
-{
-    const WCHAR *long_name;          /* long file name in Unicode */
-    const WCHAR *short_name;         /* short file name in Unicode */
-    const char  *unix_name;          /* Unix file name in host encoding */
-};
-
-struct dir_data
-{
-    unsigned int            size;    /* size of the names array */
-    unsigned int            count;   /* count of used entries in the names array */
-    unsigned int            pos;     /* current reading position in the names array */
-    struct file_identity    id;      /* directory file identity */
-    struct dir_data_names  *names;   /* directory file names */
-    struct dir_data_buffer *buffer;  /* head of data buffers list */
-};
-
-static const unsigned int dir_data_buffer_initial_size = 4096;
-static const unsigned int dir_data_cache_initial_size  = 256;
-static const unsigned int dir_data_names_initial_size  = 64;
-
-static struct dir_data **dir_data_cache;
-static unsigned int dir_data_cache_size;
-
-static BOOL show_dot_files;
-static mode_t start_umask;
-
-/* at some point we may want to allow Winelib apps to set this */
-static const BOOL is_case_sensitive = FALSE;
-
-static struct file_identity windir;
-
-static pthread_mutex_t dir_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t mnt_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-/* check if a given Unicode char is OK in a DOS short name */
-static inline BOOL is_invalid_dos_char( WCHAR ch )
-{
-    static const WCHAR invalid_chars[] = { INVALID_DOS_CHARS,'~','.',0 };
-    if (ch > 0x7f) return TRUE;
-    return wcschr( invalid_chars, ch ) != NULL;
-}
-
-/* check if the device can be a mounted volume */
-static inline BOOL is_valid_mounted_device( const struct stat *st )
-{
-#if defined(linux) || defined(__sun__)
-    return S_ISBLK( st->st_mode );
-#else
-    /* disks are char devices on *BSD */
-    return S_ISCHR( st->st_mode );
-#endif
-}
-
-static inline void ignore_file( const char *name )
-{
-    struct stat st;
-    assert( ignored_files_count < MAX_IGNORED_FILES );
-    if (!stat( name, &st ))
-    {
-        ignored_files[ignored_files_count].dev = st.st_dev;
-        ignored_files[ignored_files_count].ino = st.st_ino;
-        ignored_files_count++;
-    }
-}
-
-static inline BOOL is_same_file( const struct file_identity *file, const struct stat *st )
-{
-    return st->st_dev == file->dev && st->st_ino == file->ino;
-}
-
-static inline BOOL is_ignored_file( const struct stat *st )
-{
-    unsigned int i;
-
-    for (i = 0; i < ignored_files_count; i++)
-        if (is_same_file( &ignored_files[i], st )) return TRUE;
-    return FALSE;
-}
-
-static inline unsigned int dir_info_align( unsigned int len )
-{
-    return (len + 7) & ~7;
-}
-
-static inline unsigned int dir_info_size( FILE_INFORMATION_CLASS class, unsigned int len )
-{
-    switch (class)
-    {
-    case FileDirectoryInformation:
-        return offsetof( FILE_DIRECTORY_INFORMATION, FileName[len] );
-    case FileBothDirectoryInformation:
-        return offsetof( FILE_BOTH_DIRECTORY_INFORMATION, FileName[len] );
-    case FileFullDirectoryInformation:
-        return offsetof( FILE_FULL_DIRECTORY_INFORMATION, FileName[len] );
-    case FileIdBothDirectoryInformation:
-        return offsetof( FILE_ID_BOTH_DIRECTORY_INFORMATION, FileName[len] );
-    case FileIdFullDirectoryInformation:
-        return offsetof( FILE_ID_FULL_DIRECTORY_INFORMATION, FileName[len] );
-    case FileIdGlobalTxDirectoryInformation:
-        return offsetof( FILE_ID_GLOBAL_TX_DIR_INFORMATION, FileName[len] );
-    case FileNamesInformation:
-        return offsetof( FILE_NAMES_INFORMATION, FileName[len] );
-    default:
-        assert(0);
-        return 0;
-    }
-}
-
-static inline BOOL has_wildcard( const UNICODE_STRING *mask )
-{
-    int i;
-
-    if (!mask) return TRUE;
-    for (i = 0; i < mask->Length / sizeof(WCHAR); i++)
-        if (mask->Buffer[i] == '*' || mask->Buffer[i] == '?') return TRUE;
-    return FALSE;
-}
-
-NTSTATUS errno_to_status( int err )
-{
-    TRACE( "errno = %d\n", err );
-    switch (err)
-    {
-    case EAGAIN:    return STATUS_SHARING_VIOLATION;
-    case EBADF:     return STATUS_INVALID_HANDLE;
-    case EBUSY:     return STATUS_DEVICE_BUSY;
-    case ENOSPC:    return STATUS_DISK_FULL;
-    case EPERM:
-    case EROFS:
-    case EACCES:    return STATUS_ACCESS_DENIED;
-    case ENOTDIR:   return STATUS_OBJECT_PATH_NOT_FOUND;
-    case ENOENT:    return STATUS_OBJECT_NAME_NOT_FOUND;
-    case EISDIR:    return STATUS_FILE_IS_A_DIRECTORY;
-    case EMFILE:
-    case ENFILE:    return STATUS_TOO_MANY_OPENED_FILES;
-    case EINVAL:    return STATUS_INVALID_PARAMETER;
-    case ENOTEMPTY: return STATUS_DIRECTORY_NOT_EMPTY;
-    case EPIPE:     return STATUS_PIPE_DISCONNECTED;
-    case EIO:       return STATUS_DEVICE_NOT_READY;
-#ifdef ENOMEDIUM
-    case ENOMEDIUM: return STATUS_NO_MEDIA_IN_DEVICE;
-#endif
-    case ENXIO:     return STATUS_NO_SUCH_DEVICE;
-    case ENOTTY:
-    case EOPNOTSUPP:return STATUS_NOT_SUPPORTED;
-    case ECONNRESET:return STATUS_PIPE_DISCONNECTED;
-    case EFAULT:    return STATUS_ACCESS_VIOLATION;
-    case ESPIPE:    return STATUS_ILLEGAL_FUNCTION;
-    case ELOOP:     return STATUS_REPARSE_POINT_NOT_RESOLVED;
-#ifdef ETIME /* Missing on FreeBSD */
-    case ETIME:     return STATUS_IO_TIMEOUT;
-#endif
-    case ENOEXEC:   /* ?? */
-    case EEXIST:    /* ?? */
-    default:
-        FIXME( "Converting errno %d to STATUS_UNSUCCESSFUL\n", err );
-        return STATUS_UNSUCCESSFUL;
-    }
-}
-
-/* get space from the current directory data buffer, allocating a new one if necessary */
-static void *get_dir_data_space( struct dir_data *data, unsigned int size )
-{
-    struct dir_data_buffer *buffer = data->buffer;
-    void *ret;
-
-    if (!buffer || size > buffer->size - buffer->pos)
-    {
-        unsigned int new_size = buffer ? buffer->size * 2 : dir_data_buffer_initial_size;
-        if (new_size < size) new_size = size;
-        if (!(buffer = malloc( offsetof( struct dir_data_buffer, data[new_size] ) ))) return NULL;
-        buffer->pos  = 0;
-        buffer->size = new_size;
-        buffer->next = data->buffer;
-        data->buffer = buffer;
-    }
-    ret = buffer->data + buffer->pos;
-    buffer->pos += size;
-    return ret;
-}
-
-/* add a string to the directory data buffer */
-static const char *add_dir_data_nameA( struct dir_data *data, const char *name )
-{
-    /* keep buffer data WCHAR-aligned */
-    char *ptr = get_dir_data_space( data, (strlen( name ) + sizeof(WCHAR)) & ~(sizeof(WCHAR) - 1) );
-    if (ptr) strcpy( ptr, name );
-    return ptr;
-}
-
-/* add a Unicode string to the directory data buffer */
-static const WCHAR *add_dir_data_nameW( struct dir_data *data, const WCHAR *name )
-{
-    WCHAR *ptr = get_dir_data_space( data, (wcslen( name ) + 1) * sizeof(WCHAR) );
-    if (ptr) wcscpy( ptr, name );
-    return ptr;
-}
-
-/* add an entry to the directory names array */
-static BOOL add_dir_data_names( struct dir_data *data, const WCHAR *long_name,
-                                const WCHAR *short_name, const char *unix_name )
-{
-    static const WCHAR empty[1];
-    struct dir_data_names *names = data->names;
-
-    if (data->count >= data->size)
-    {
-        unsigned int new_size = max( data->size * 2, dir_data_names_initial_size );
-
-        if (!(names = realloc( names, new_size * sizeof(*names) ))) return FALSE;
-        data->size  = new_size;
-        data->names = names;
-    }
-
-    if (short_name[0])
-    {
-        if (!(names[data->count].short_name = add_dir_data_nameW( data, short_name ))) return FALSE;
-    }
-    else names[data->count].short_name = empty;
-
-    if (!(names[data->count].long_name = add_dir_data_nameW( data, long_name ))) return FALSE;
-    if (!(names[data->count].unix_name = add_dir_data_nameA( data, unix_name ))) return FALSE;
-    data->count++;
-    return TRUE;
-}
-
-/* free the complete directory data structure */
-static void free_dir_data( struct dir_data *data )
-{
-    struct dir_data_buffer *buffer, *next;
-
-    if (!data) return;
-
-    for (buffer = data->buffer; buffer; buffer = next)
-    {
-        next = buffer->next;
-        free( buffer );
-    }
-    free( data->names );
-    free( data );
-}
-
-
-/* support for a directory queue for filesystem searches */
-
-struct dir_name
-{
-    struct list entry;
-    char name[1];
-};
-
-static struct list dir_queue = LIST_INIT( dir_queue );
-
-static NTSTATUS add_dir_to_queue( const char *name )
-{
-    int len = strlen( name ) + 1;
-    struct dir_name *dir = malloc( offsetof( struct dir_name, name[len] ));
-    if (!dir) return STATUS_NO_MEMORY;
-    strcpy( dir->name, name );
-    list_add_tail( &dir_queue, &dir->entry );
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS next_dir_in_queue( char *name )
-{
-    struct list *head = list_head( &dir_queue );
-    if (head)
-    {
-        struct dir_name *dir = LIST_ENTRY( head, struct dir_name, entry );
-        strcpy( name, dir->name );
-        list_remove( &dir->entry );
-        free( dir );
-        return STATUS_SUCCESS;
-    }
-    return STATUS_OBJECT_NAME_NOT_FOUND;
-}
-
-static void flush_dir_queue(void)
-{
-    struct list *head;
-
-    while ((head = list_head( &dir_queue )))
-    {
-        struct dir_name *dir = LIST_ENTRY( head, struct dir_name, entry );
-        list_remove( &dir->entry );
-        free( dir );
-    }
-}
-
-
-#ifdef __ANDROID__
-
-static char *unescape_field( char *str )
-{
-    char *in, *out;
-
-    for (in = out = str; *in; in++, out++)
-    {
-        *out = *in;
-        if (in[0] == '\\')
-        {
-            if (in[1] == '\\')
-            {
-                out[0] = '\\';
-                in++;
-            }
-            else if (in[1] == '0' && in[2] == '4' && in[3] == '0')
-            {
-                out[0] = ' ';
-                in += 3;
-            }
-            else if (in[1] == '0' && in[2] == '1' && in[3] == '1')
-            {
-                out[0] = '\t';
-                in += 3;
-            }
-            else if (in[1] == '0' && in[2] == '1' && in[3] == '2')
-            {
-                out[0] = '\n';
-                in += 3;
-            }
-            else if (in[1] == '1' && in[2] == '3' && in[3] == '4')
-            {
-                out[0] = '\\';
-                in += 3;
-            }
-        }
-    }
-    *out = '\0';
-
-    return str;
-}
-
-static inline char *get_field( char **str )
-{
-    char *ret;
-
-    ret = strsep( str, " \t" );
-    if (*str) *str += strspn( *str, " \t" );
-
-    return ret;
-}
-/************************************************************************
- *                    getmntent_replacement
- *
- * getmntent replacement for Android.
- *
- * NB returned static buffer is not thread safe; protect with mnt_mutex.
- */
-static struct mntent *getmntent_replacement( FILE *f )
-{
-    static struct mntent entry;
-    static char buf[4096];
-    char *p, *start;
-
-    do
-    {
-        if (!fgets( buf, sizeof(buf), f )) return NULL;
-        p = strchr( buf, '\n' );
-        if (p) *p = '\0';
-        else /* Partially unread line, move file ptr to end */
-        {
-            char tmp[1024];
-            while (fgets( tmp, sizeof(tmp), f ))
-                if (strchr( tmp, '\n' )) break;
-        }
-        start = buf + strspn( buf, " \t" );
-    } while (start[0] == '\0' || start[0] == '#');
-
-    p = get_field( &start );
-    entry.mnt_fsname = p ? unescape_field( p ) : (char *)"";
-
-    p = get_field( &start );
-    entry.mnt_dir = p ? unescape_field( p ) : (char *)"";
-
-    p = get_field( &start );
-    entry.mnt_type = p ? unescape_field( p ) : (char *)"";
-
-    p = get_field( &start );
-    entry.mnt_opts = p ? unescape_field( p ) : (char *)"";
-
-    p = get_field( &start );
-    entry.mnt_freq = p ? atoi(p) : 0;
-
-    p = get_field( &start );
-    entry.mnt_passno = p ? atoi(p) : 0;
-
-    return &entry;
-}
-#define getmntent getmntent_replacement
-#endif
-
-/***********************************************************************
- *           parse_mount_entries
- *
- * Parse mount entries looking for a given device. Helper for get_default_drive_device.
- */
-
-#ifdef sun
-#include <sys/vfstab.h>
-static char *parse_vfstab_entries( FILE *f, dev_t dev, ino_t ino)
-{
-    struct vfstab entry;
-    struct stat st;
-    char *device;
-
-    while (! getvfsent( f, &entry ))
-    {
-        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
-        if (!strcmp( entry.vfs_fstype, "nfs" ) ||
-            !strcmp( entry.vfs_fstype, "smbfs" ) ||
-            !strcmp( entry.vfs_fstype, "ncpfs" )) continue;
-
-        if (stat( entry.vfs_mountp, &st ) == -1) continue;
-        if (st.st_dev != dev || st.st_ino != ino) continue;
-        if (!strcmp( entry.vfs_fstype, "fd" ))
-        {
-            if ((device = strstr( entry.vfs_mntopts, "dev=" )))
-            {
-                char *p = strchr( device + 4, ',' );
-                if (p) *p = 0;
-                return device + 4;
-            }
-        }
-        else
-            return entry.vfs_special;
-    }
-    return NULL;
-}
-#endif
-
-#ifdef linux
-static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
-{
-    struct mntent *entry;
-    struct stat st;
-    char *device;
-
-    while ((entry = getmntent( f )))
-    {
-        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
-        if (!strcmp( entry->mnt_type, "nfs" ) ||
-            !strcmp( entry->mnt_type, "cifs" ) ||
-            !strcmp( entry->mnt_type, "smbfs" ) ||
-            !strcmp( entry->mnt_type, "ncpfs" )) continue;
-
-        if (stat( entry->mnt_dir, &st ) == -1) continue;
-        if (st.st_dev != dev || st.st_ino != ino) continue;
-        if (!strcmp( entry->mnt_type, "supermount" ))
-        {
-            if ((device = strstr( entry->mnt_opts, "dev=" )))
-            {
-                char *p = strchr( device + 4, ',' );
-                if (p) *p = 0;
-                return device + 4;
-            }
-        }
-        else if (!stat( entry->mnt_fsname, &st ) && S_ISREG(st.st_mode))
-        {
-            /* if device is a regular file check for a loop mount */
-            if ((device = strstr( entry->mnt_opts, "loop=" )))
-            {
-                char *p = strchr( device + 5, ',' );
-                if (p) *p = 0;
-                return device + 5;
-            }
-        }
-        else
-            return entry->mnt_fsname;
-    }
-    return NULL;
-}
-#endif
-
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
-#include <fstab.h>
-static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
-{
-    struct fstab *entry;
-    struct stat st;
-
-    while ((entry = getfsent()))
-    {
-        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
-        if (!strcmp( entry->fs_vfstype, "nfs" ) ||
-            !strcmp( entry->fs_vfstype, "smbfs" ) ||
-            !strcmp( entry->fs_vfstype, "ncpfs" )) continue;
-
-        if (stat( entry->fs_file, &st ) == -1) continue;
-        if (st.st_dev != dev || st.st_ino != ino) continue;
-        return entry->fs_spec;
-    }
-    return NULL;
-}
-#endif
-
-#ifdef sun
-#include <sys/mnttab.h>
-static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
-{
-    struct mnttab entry;
-    struct stat st;
-    char *device;
-
-
-    while (( ! getmntent( f, &entry) ))
-    {
-        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
-        if (!strcmp( entry.mnt_fstype, "nfs" ) ||
-            !strcmp( entry.mnt_fstype, "smbfs" ) ||
-            !strcmp( entry.mnt_fstype, "ncpfs" )) continue;
-
-        if (stat( entry.mnt_mountp, &st ) == -1) continue;
-        if (st.st_dev != dev || st.st_ino != ino) continue;
-        if (!strcmp( entry.mnt_fstype, "fd" ))
-        {
-            if ((device = strstr( entry.mnt_mntopts, "dev=" )))
-            {
-                char *p = strchr( device + 4, ',' );
-                if (p) *p = 0;
-                return device + 4;
-            }
-        }
-        else
-            return entry.mnt_special;
-    }
-    return NULL;
-}
-#endif
-
-/***********************************************************************
- *           get_default_drive_device
- *
- * Return the default device to use for a given drive mount point.
- */
-static char *get_default_drive_device( const char *root )
-{
-    char *ret = NULL;
-
-#ifdef linux
-    FILE *f;
-    char *device = NULL;
-    int fd, res = -1;
-    struct stat st;
-
-    /* try to open it first to force it to get mounted */
-    if ((fd = open( root, O_RDONLY | O_DIRECTORY )) != -1)
-    {
-        res = fstat( fd, &st );
-        close( fd );
-    }
-    /* now try normal stat just in case */
-    if (res == -1) res = stat( root, &st );
-    if (res == -1) return NULL;
-
-    pthread_mutex_lock( &mnt_mutex );
-
-#ifdef __ANDROID__
-    if ((f = fopen( "/proc/mounts", "r" )))
-    {
-        device = parse_mount_entries( f, st.st_dev, st.st_ino );
-        fclose( f );
-    }
-#else
-    if ((f = fopen( "/etc/mtab", "r" )))
-    {
-        device = parse_mount_entries( f, st.st_dev, st.st_ino );
-        fclose( f );
-    }
-    /* look through fstab too in case it's not mounted (for instance if it's an audio CD) */
-    if (!device && (f = fopen( "/etc/fstab", "r" )))
-    {
-        device = parse_mount_entries( f, st.st_dev, st.st_ino );
-        fclose( f );
-    }
-#endif
-    if (device) ret = strdup( device );
-    pthread_mutex_unlock( &mnt_mutex );
-
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__ ) || defined(__DragonFly__)
-    char *device = NULL;
-    int fd, res = -1;
-    struct stat st;
-
-    /* try to open it first to force it to get mounted */
-    if ((fd = open( root, O_RDONLY )) != -1)
-    {
-        res = fstat( fd, &st );
-        close( fd );
-    }
-    /* now try normal stat just in case */
-    if (res == -1) res = stat( root, &st );
-    if (res == -1) return NULL;
-
-    pthread_mutex_lock( &mnt_mutex );
-
-    /* The FreeBSD parse_mount_entries doesn't require a file argument, so just
-     * pass NULL.  Leave the argument in for symmetry.
-     */
-    device = parse_mount_entries( NULL, st.st_dev, st.st_ino );
-    if (device) ret = strdup( device );
-    pthread_mutex_unlock( &mnt_mutex );
-
-#elif defined( sun )
-    FILE *f;
-    char *device = NULL;
-    int fd, res = -1;
-    struct stat st;
-
-    /* try to open it first to force it to get mounted */
-    if ((fd = open( root, O_RDONLY )) != -1)
-    {
-        res = fstat( fd, &st );
-        close( fd );
-    }
-    /* now try normal stat just in case */
-    if (res == -1) res = stat( root, &st );
-    if (res == -1) return NULL;
-
-    pthread_mutex_lock( &mnt_mutex );
-
-    if ((f = fopen( "/etc/mnttab", "r" )))
-    {
-        device = parse_mount_entries( f, st.st_dev, st.st_ino);
-        fclose( f );
-    }
-    /* look through fstab too in case it's not mounted (for instance if it's an audio CD) */
-    if (!device && (f = fopen( "/etc/vfstab", "r" )))
-    {
-        device = parse_vfstab_entries( f, st.st_dev, st.st_ino );
-        fclose( f );
-    }
-    if (device) ret = strdup( device );
-    pthread_mutex_unlock( &mnt_mutex );
-
-#elif defined(__APPLE__)
-    struct statfs *mntStat;
-    struct stat st;
-    int i;
-    int mntSize;
-    dev_t dev;
-    ino_t ino;
-    static const char path_bsd_device[] = "/dev/disk";
-    int res;
-
-    res = stat( root, &st );
-    if (res == -1) return NULL;
-
-    dev = st.st_dev;
-    ino = st.st_ino;
-
-    pthread_mutex_lock( &mnt_mutex );
-
-    mntSize = getmntinfo(&mntStat, MNT_NOWAIT);
-
-    for (i = 0; i < mntSize && !ret; i++)
-    {
-        if (stat(mntStat[i].f_mntonname, &st ) == -1) continue;
-        if (st.st_dev != dev || st.st_ino != ino) continue;
-
-        /* FIXME add support for mounted network drive */
-        if ( strncmp(mntStat[i].f_mntfromname, path_bsd_device, strlen(path_bsd_device)) == 0)
-        {
-            /* set return value to the corresponding raw BSD node */
-            ret = malloc( strlen(mntStat[i].f_mntfromname) + 2 /* 2 : r and \0 */ );
-            if (ret)
-            {
-                strcpy(ret, "/dev/r");
-                strcat(ret, mntStat[i].f_mntfromname+sizeof("/dev/")-1);
-            }
-        }
-    }
-    pthread_mutex_unlock( &mnt_mutex );
-#else
-    static int warned;
-    if (!warned++) FIXME( "auto detection of DOS devices not supported on this platform\n" );
-#endif
-    return ret;
-}
-
-
-/***********************************************************************
- *           get_device_mount_point
- *
- * Return the current mount point for a device.
- */
-static char *get_device_mount_point( dev_t dev )
-{
-    char *ret = NULL;
-
-#ifdef linux
-    FILE *f;
-
-    pthread_mutex_lock( &mnt_mutex );
-
-#ifdef __ANDROID__
-    if ((f = fopen( "/proc/mounts", "r" )))
-#else
-    if ((f = fopen( "/etc/mtab", "r" )))
-#endif
-    {
-        struct mntent *entry;
-        struct stat st;
-        char *p, *device;
-
-        while ((entry = getmntent( f )))
-        {
-            /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
-            if (!strcmp( entry->mnt_type, "nfs" ) ||
-                !strcmp( entry->mnt_type, "cifs" ) ||
-                !strcmp( entry->mnt_type, "smbfs" ) ||
-                !strcmp( entry->mnt_type, "ncpfs" )) continue;
-
-            if (!strcmp( entry->mnt_type, "supermount" ))
-            {
-                if ((device = strstr( entry->mnt_opts, "dev=" )))
-                {
-                    device += 4;
-                    if ((p = strchr( device, ',' ))) *p = 0;
-                }
-            }
-            else if (!stat( entry->mnt_fsname, &st ) && S_ISREG(st.st_mode))
-            {
-                /* if device is a regular file check for a loop mount */
-                if ((device = strstr( entry->mnt_opts, "loop=" )))
-                {
-                    device += 5;
-                    if ((p = strchr( device, ',' ))) *p = 0;
-                }
-            }
-            else device = entry->mnt_fsname;
-
-            if (device && !stat( device, &st ) && S_ISBLK(st.st_mode) && st.st_rdev == dev)
-            {
-                ret = strdup( entry->mnt_dir );
-                break;
-            }
-        }
-        fclose( f );
-    }
-    pthread_mutex_unlock( &mnt_mutex );
-#elif defined(__APPLE__)
-    struct statfs *entry;
-    struct stat st;
-    int i, size;
-
-    pthread_mutex_lock( &mnt_mutex );
-
-    size = getmntinfo( &entry, MNT_NOWAIT );
-    for (i = 0; i < size; i++)
-    {
-        if (stat( entry[i].f_mntfromname, &st ) == -1) continue;
-        if (S_ISBLK(st.st_mode) && st.st_rdev == dev)
-        {
-            ret = strdup( entry[i].f_mntonname );
-            break;
-        }
-    }
-    pthread_mutex_unlock( &mnt_mutex );
-#else
-    static int warned;
-    if (!warned++) FIXME( "unmounting devices not supported on this platform\n" );
-#endif
-    return ret;
-}
-
-
-#if defined(HAVE_GETATTRLIST) && defined(ATTR_VOL_CAPABILITIES) && \
-    defined(VOL_CAPABILITIES_FORMAT) && defined(VOL_CAP_FMT_CASE_SENSITIVE)
-
-struct get_fsid
-{
-    ULONG size;
-    dev_t dev;
-    fsid_t fsid;
-};
-
-struct fs_cache
-{
-    dev_t dev;
-    fsid_t fsid;
-    BOOLEAN case_sensitive;
-} fs_cache[64];
-
-struct vol_caps
-{
-    ULONG size;
-    vol_capabilities_attr_t caps;
-};
-
-/***********************************************************************
- *           look_up_fs_cache
- *
- * Checks if the specified file system is in the cache.
- */
-static struct fs_cache *look_up_fs_cache( dev_t dev )
-{
-    int i;
-    for (i = 0; i < ARRAY_SIZE( fs_cache ); i++)
-        if (fs_cache[i].dev == dev)
-            return fs_cache+i;
-    return NULL;
-}
-
-/***********************************************************************
- *           add_fs_cache
- *
- * Adds the specified file system to the cache.
- */
-static void add_fs_cache( dev_t dev, fsid_t fsid, BOOLEAN case_sensitive )
-{
-    int i;
-    struct fs_cache *entry = look_up_fs_cache( dev );
-    static int once = 0;
-    if (entry)
-    {
-        /* Update the cache */
-        entry->fsid = fsid;
-        entry->case_sensitive = case_sensitive;
-        return;
-    }
-
-    /* Add a new entry */
-    for (i = 0; i < ARRAY_SIZE( fs_cache ); i++)
-        if (fs_cache[i].dev == 0)
-        {
-            /* This entry is empty, use it */
-            fs_cache[i].dev = dev;
-            fs_cache[i].fsid = fsid;
-            fs_cache[i].case_sensitive = case_sensitive;
-            return;
-        }
-
-    /* Cache is out of space, warn */
-    if (!once++)
-        WARN( "FS cache is out of space, expect performance problems\n" );
-}
-
-/***********************************************************************
- *           get_dir_case_sensitivity_attr
- *
- * Checks if the volume containing the specified directory is case
- * sensitive or not. Uses getattrlist(2).
- */
-static int get_dir_case_sensitivity_attr( const char *dir )
-{
-    char *mntpoint;
-    struct attrlist attr;
-    struct vol_caps caps;
-    struct get_fsid get_fsid;
-    struct fs_cache *entry;
-
-    /* First get the FS ID of the volume */
-    attr.bitmapcount = ATTR_BIT_MAP_COUNT;
-    attr.reserved = 0;
-    attr.commonattr = ATTR_CMN_DEVID|ATTR_CMN_FSID;
-    attr.volattr = attr.dirattr = attr.fileattr = attr.forkattr = 0;
-    get_fsid.size = 0;
-    if (getattrlist( dir, &attr, &get_fsid, sizeof(get_fsid), 0 ) != 0 ||
-        get_fsid.size != sizeof(get_fsid))
-        return -1;
-    /* Try to look it up in the cache */
-    entry = look_up_fs_cache( get_fsid.dev );
-    if (entry && !memcmp( &entry->fsid, &get_fsid.fsid, sizeof(fsid_t) ))
-        /* Cache lookup succeeded */
-        return entry->case_sensitive;
-    /* Cache is stale at this point, we have to update it */
-
-    mntpoint = get_device_mount_point( get_fsid.dev );
-    /* Now look up the case-sensitivity */
-    attr.commonattr = 0;
-    attr.volattr = ATTR_VOL_INFO|ATTR_VOL_CAPABILITIES;
-    if (getattrlist( mntpoint, &attr, &caps, sizeof(caps), 0 ) < 0)
-    {
-        free( mntpoint );
-        add_fs_cache( get_fsid.dev, get_fsid.fsid, TRUE );
-        return TRUE;
-    }
-    free( mntpoint );
-    if (caps.size == sizeof(caps) &&
-        (caps.caps.valid[VOL_CAPABILITIES_FORMAT] &
-         (VOL_CAP_FMT_CASE_SENSITIVE | VOL_CAP_FMT_CASE_PRESERVING)) ==
-        (VOL_CAP_FMT_CASE_SENSITIVE | VOL_CAP_FMT_CASE_PRESERVING))
-    {
-        BOOLEAN ret;
-
-        if ((caps.caps.capabilities[VOL_CAPABILITIES_FORMAT] &
-            VOL_CAP_FMT_CASE_SENSITIVE) != VOL_CAP_FMT_CASE_SENSITIVE)
-            ret = FALSE;
-        else
-            ret = TRUE;
-        /* Update the cache */
-        add_fs_cache( get_fsid.dev, get_fsid.fsid, ret );
-        return ret;
-    }
-    return FALSE;
-}
-#endif
-
-/***********************************************************************
- *           get_dir_case_sensitivity_stat
- *
- * Checks if the volume containing the specified directory is case
- * sensitive or not. Uses (f)statfs(2), statvfs(2), fstatat(2), or ioctl(2).
- */
-static BOOLEAN get_dir_case_sensitivity_stat( const char *dir )
-{
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
-    struct statfs stfs;
-
-    if (statfs( dir, &stfs ) == -1) return FALSE;
-    /* Assume these file systems are always case insensitive on Mac OS.
-     * For FreeBSD, only assume CIOPFS is case insensitive (AFAIK, Mac OS
-     * is the only UNIX that supports case-insensitive lookup).
-     */
-    if (!strcmp( stfs.f_fstypename, "fusefs" ) &&
-        !strncmp( stfs.f_mntfromname, "ciopfs", 5 ))
-        return FALSE;
-#ifdef __APPLE__
-    if (!strcmp( stfs.f_fstypename, "msdos" ) ||
-        !strcmp( stfs.f_fstypename, "cd9660" ) ||
-        !strcmp( stfs.f_fstypename, "udf" ) ||
-        !strcmp( stfs.f_fstypename, "ntfs" ) ||
-        !strcmp( stfs.f_fstypename, "smbfs" ))
-        return FALSE;
-#ifdef _DARWIN_FEATURE_64_BIT_INODE
-     if (!strcmp( stfs.f_fstypename, "hfs" ) && (stfs.f_fssubtype == 0 ||
-                                                 stfs.f_fssubtype == 1 ||
-                                                 stfs.f_fssubtype == 128))
-        return FALSE;
-#else
-     /* The field says "reserved", but a quick look at the kernel source
-      * tells us that this "reserved" field is really the same as the
-      * "fssubtype" field from the inode64 structure (see munge_statfs()
-      * in <xnu-source>/bsd/vfs/vfs_syscalls.c).
-      */
-     if (!strcmp( stfs.f_fstypename, "hfs" ) && (stfs.f_reserved1 == 0 ||
-                                                 stfs.f_reserved1 == 1 ||
-                                                 stfs.f_reserved1 == 128))
-        return FALSE;
-#endif
-#endif
-    return TRUE;
-
-#elif defined(__NetBSD__)
-    struct statvfs stfs;
-
-    if (statvfs( dir, &stfs ) == -1) return FALSE;
-    /* Only assume CIOPFS is case insensitive. */
-    if (strcmp( stfs.f_fstypename, "fusefs" ) ||
-        strncmp( stfs.f_mntfromname, "ciopfs", 5 ))
-        return TRUE;
-    return FALSE;
-
-#elif defined(__linux__)
-    BOOLEAN sens = TRUE;
-    struct statfs stfs;
-    struct stat st;
-    int fd, flags;
-
-    if ((fd = open( dir, O_RDONLY | O_NONBLOCK | O_LARGEFILE )) == -1)
-        return TRUE;
-
-    if (ioctl( fd, EXT2_IOC_GETFLAGS, &flags ) != -1 && (flags & EXT4_CASEFOLD_FL))
-    {
-        sens = FALSE;
-    }
-    else if (fstatfs( fd, &stfs ) == 0 &&                          /* CIOPFS is case insensitive.  Instead of */
-             stfs.f_type == 0x65735546 /* FUSE_SUPER_MAGIC */ &&   /* parsing mtab to discover if the FUSE FS */
-             fstatat( fd, ".ciopfs", &st, AT_NO_AUTOMOUNT ) == 0)  /* is CIOPFS, look for .ciopfs in the dir. */
-    {
-        sens = FALSE;
-    }
-
-    close( fd );
-    return sens;
-#else
-    return TRUE;
-#endif
-}
-
-
-/***********************************************************************
- *           get_dir_case_sensitivity
- *
- * Checks if the volume containing the specified directory is case
- * sensitive or not. Uses multiple methods, depending on platform.
- */
-static BOOLEAN get_dir_case_sensitivity( const char *dir )
-{
-#if defined(HAVE_GETATTRLIST) && defined(ATTR_VOL_CAPABILITIES) && \
-    defined(VOL_CAPABILITIES_FORMAT) && defined(VOL_CAP_FMT_CASE_SENSITIVE)
-    int case_sensitive = get_dir_case_sensitivity_attr( dir );
-    if (case_sensitive != -1) return case_sensitive;
-#endif
-    return get_dir_case_sensitivity_stat( dir );
-}
-
-
-/***********************************************************************
- *           is_hidden_file
- *
- * Check if the specified file should be hidden based on its name and the show dot files option.
- */
-static BOOL is_hidden_file( const UNICODE_STRING *name )
-{
-    WCHAR *p, *end;
-
-    if (show_dot_files) return FALSE;
-
-    end = p = name->Buffer + name->Length/sizeof(WCHAR);
-    while (p > name->Buffer && IS_SEPARATOR(p[-1])) p--;
-    while (p > name->Buffer && !IS_SEPARATOR(p[-1])) p--;
-    if (p == end || *p != '.') return FALSE;
-    /* make sure it isn't '.' or '..' */
-    if (p + 1 == end) return FALSE;
-    if (p[1] == '.' && p + 2 == end) return FALSE;
-    return TRUE;
-}
-
-
-/***********************************************************************
- *           hash_short_file_name
- *
- * Transform a Unix file name into a hashed DOS name. If the name is not a valid
- * DOS name, it is replaced by a hashed version that fits in 8.3 format.
- * 'buffer' must be at least 12 characters long.
- * Returns length of short name in bytes; short name is NOT null-terminated.
- */
-static ULONG hash_short_file_name( const WCHAR *name, int length, LPWSTR buffer )
-{
-    static const char hash_chars[32] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345";
-
-    LPCWSTR p, ext, end = name + length;
-    LPWSTR dst;
-    unsigned short hash;
-    int i;
-
-    /* Compute the hash code of the file name */
-    /* If you know something about hash functions, feel free to */
-    /* insert a better algorithm here... */
-    if (!is_case_sensitive)
-    {
-        for (p = name, hash = 0xbeef; p < end - 1; p++)
-            hash = (hash<<3) ^ (hash>>5) ^ towlower(*p) ^ (towlower(p[1]) << 8);
-        hash = (hash<<3) ^ (hash>>5) ^ towlower(*p); /* Last character */
-    }
-    else
-    {
-        for (p = name, hash = 0xbeef; p < end - 1; p++)
-            hash = (hash << 3) ^ (hash >> 5) ^ *p ^ (p[1] << 8);
-        hash = (hash << 3) ^ (hash >> 5) ^ *p;  /* Last character */
-    }
-
-    /* Find last dot for start of the extension */
-    for (p = name + 1, ext = NULL; p < end - 1; p++) if (*p == '.') ext = p;
-
-    /* Copy first 4 chars, replacing invalid chars with '_' */
-    for (i = 4, p = name, dst = buffer; i > 0; i--, p++)
-    {
-        if (p == end || p == ext) break;
-        *dst++ = is_invalid_dos_char(*p) ? '_' : *p;
-    }
-    /* Pad to 5 chars with '~' */
-    while (i-- >= 0) *dst++ = '~';
-
-    /* Insert hash code converted to 3 ASCII chars */
-    *dst++ = hash_chars[(hash >> 10) & 0x1f];
-    *dst++ = hash_chars[(hash >> 5) & 0x1f];
-    *dst++ = hash_chars[hash & 0x1f];
-
-    /* Copy the first 3 chars of the extension (if any) */
-    if (ext)
-    {
-        *dst++ = '.';
-        for (i = 3, ext++; (i > 0) && ext < end; i--, ext++)
-            *dst++ = is_invalid_dos_char(*ext) ? '_' : *ext;
-    }
-    return dst - buffer;
-}
-
-
-/***********************************************************************
- *           match_filename
- *
- * Check a long file name against a mask.
- *
- * Tests (done in W95 DOS shell - case insensitive):
- * *.txt			test1.test.txt				*
- * *st1*			test1.txt				*
- * *.t??????.t*			test1.ta.tornado.txt			*
- * *tornado*			test1.ta.tornado.txt			*
- * t*t				test1.ta.tornado.txt			*
- * ?est*			test1.txt				*
- * ?est???			test1.txt				-
- * *test1.txt*			test1.txt				*
- * h?l?o*t.dat			hellothisisatest.dat			*
- */
-static BOOLEAN match_filename( const WCHAR *name, int length, const UNICODE_STRING *mask_str )
-{
-    BOOL mismatch;
-    const WCHAR *mask = mask_str->Buffer;
-    const WCHAR *name_end = name + length;
-    const WCHAR *mask_end = mask + mask_str->Length / sizeof(WCHAR);
-    const WCHAR *lastjoker = NULL;
-    const WCHAR *next_to_retry = NULL;
-
-    while (name < name_end && mask < mask_end)
-    {
-        switch(*mask)
-        {
-        case '*':
-            mask++;
-            while (mask < mask_end && *mask == '*') mask++;  /* Skip consecutive '*' */
-            if (mask == mask_end) return TRUE; /* end of mask is all '*', so match */
-            lastjoker = mask;
-
-            /* skip to the next match after the joker(s) */
-            if (is_case_sensitive)
-                while (name < name_end && (*name != *mask)) name++;
-            else
-                while (name < name_end && (towupper(*name) != towupper(*mask))) name++;
-            next_to_retry = name;
-            break;
-        case '?':
-            mask++;
-            name++;
-            break;
-        default:
-            if (is_case_sensitive) mismatch = (*mask != *name);
-            else mismatch = (towupper(*mask) != towupper(*name));
-
-            if (!mismatch)
-            {
-                mask++;
-                name++;
-                if (mask == mask_end)
-                {
-                    if (name == name_end) return TRUE;
-                    if (lastjoker) mask = lastjoker;
-                }
-            }
-            else /* mismatch ! */
-            {
-                if (lastjoker) /* we had an '*', so we can try unlimitedly */
-                {
-                    mask = lastjoker;
-
-                    /* this scan sequence was a mismatch, so restart
-                     * 1 char after the first char we checked last time */
-                    next_to_retry++;
-                    name = next_to_retry;
-                }
-                else return FALSE; /* bad luck */
-            }
-            break;
-        }
-    }
-    while (mask < mask_end && ((*mask == '.') || (*mask == '*')))
-        mask++;  /* Ignore trailing '.' or '*' in mask */
-    return (name == name_end && mask == mask_end);
-}
-
-
-/***********************************************************************
- *           is_legal_8dot3_name
- *
- * Simplified version of RtlIsNameLegalDOS8Dot3.
- */
-static BOOLEAN is_legal_8dot3_name( const WCHAR *name, int len )
-{
-    static const WCHAR invalid_chars[] = { INVALID_DOS_CHARS,':','/','\\',0 };
-    int i, dot = -1;
-
-    if (len > 12) return FALSE;
-
-    /* a starting . is invalid, except for . and .. */
-    if (len > 0 && name[0] == '.') return (len == 1 || (len == 2 && name[1] == '.'));
-
-    for (i = 0; i < len; i++)
-    {
-        if (name[i] > 0x7f) return FALSE;
-        if (wcschr( invalid_chars, name[i] )) return FALSE;
-        if (name[i] == '.')
-        {
-            if (dot != -1) return FALSE;
-            dot = i;
-        }
-    }
-
-    if (dot == -1) return (len <= 8);
-    if (dot > 8) return FALSE;
-    return (len - dot > 1 && len - dot < 5);
-}
-
-
-/***********************************************************************
- *           append_entry
- *
- * Add a file to the directory data if it matches the mask.
- */
-static BOOL append_entry( struct dir_data *data, const char *long_name,
-                          const char *short_name, const UNICODE_STRING *mask )
-{
-    int long_len, short_len;
-    WCHAR long_nameW[MAX_DIR_ENTRY_LEN + 1];
-    WCHAR short_nameW[13];
-
-    long_len = ntdll_umbstowcs( long_name, strlen(long_name), long_nameW, ARRAY_SIZE(long_nameW) );
-    if (long_len == ARRAY_SIZE(long_nameW)) return TRUE;
-    long_nameW[long_len] = 0;
-
-    if (short_name)
-    {
-        short_len = ntdll_umbstowcs( short_name, strlen(short_name),
-                                     short_nameW, ARRAY_SIZE( short_nameW ) - 1 );
-    }
-    else  /* generate a short name if necessary */
-    {
-        short_len = 0;
-        if (!is_legal_8dot3_name( long_nameW, long_len ))
-            short_len = hash_short_file_name( long_nameW, long_len, short_nameW );
-    }
-    short_nameW[short_len] = 0;
-    wcsupr( short_nameW );
-
-    TRACE( "long %s short %s mask %s\n",
-           debugstr_w( long_nameW ), debugstr_w( short_nameW ), debugstr_us( mask ));
-
-    if (mask && !match_filename( long_nameW, long_len, mask ))
-    {
-        if (!short_len) return TRUE;  /* no short name to match */
-        if (!match_filename( short_nameW, short_len, mask )) return TRUE;
-    }
-
-    return add_dir_data_names( data, long_nameW, short_nameW, long_name );
-}
-
-
-/* fetch the attributes of a file */
-static inline ULONG get_file_attributes( const struct stat *st )
-{
-    ULONG attr;
-
-    if (S_ISDIR(st->st_mode))
-        attr = FILE_ATTRIBUTE_DIRECTORY;
-    else
-        attr = FILE_ATTRIBUTE_ARCHIVE;
-    if (!(st->st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
-        attr |= FILE_ATTRIBUTE_READONLY;
-    return attr;
-}
-
-
-static BOOL fd_is_mount_point( int fd, const struct stat *st )
-{
-    struct stat parent;
-    return S_ISDIR( st->st_mode ) && !fstatat( fd, "..", &parent, 0 )
-            && (parent.st_dev != st->st_dev || parent.st_ino == st->st_ino);
-}
-
-
-/* get the stat info and file attributes for a file (by file descriptor) */
-static int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULONG *attr )
-{
-    int ret;
-
-    *attr = 0;
-    ret = fstat( fd, st );
-    if (ret == -1) return ret;
-    *attr |= get_file_attributes( st );
-    /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
-    if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, st ))
-        *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
-    return ret;
-}
-
-
-/* get the stat info and file attributes for a file (by name) */
-static int get_file_info( const char *path, struct stat *st, ULONG *attr )
-{
-    char *parent_path;
-    int ret;
-
-    *attr = 0;
-    ret = lstat( path, st );
-    if (ret == -1) return ret;
-    if (S_ISLNK( st->st_mode ))
-    {
-        ret = stat( path, st );
-        if (ret == -1) return ret;
-        /* is a symbolic link and a directory, consider these "reparse points" */
-        if (S_ISDIR( st->st_mode )) *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
-    }
-    else if (S_ISDIR( st->st_mode ) && (parent_path = malloc( strlen(path) + 4 )))
-    {
-        struct stat parent_st;
-
-        /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
-        strcpy( parent_path, path );
-        strcat( parent_path, "/.." );
-        if (!stat( parent_path, &parent_st )
-                && (st->st_dev != parent_st.st_dev || st->st_ino == parent_st.st_ino))
-            *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
-
-        free( parent_path );
-    }
-    *attr |= get_file_attributes( st );
-    return ret;
-}
-
-
-#if defined(__ANDROID__) && !defined(HAVE_FUTIMENS)
-static int futimens( int fd, const struct timespec spec[2] )
-{
-    return syscall( __NR_utimensat, fd, NULL, spec, 0 );
-}
-#define HAVE_FUTIMENS
-#endif  /* __ANDROID__ */
-
-#ifndef UTIME_OMIT
-#define UTIME_OMIT ((1 << 30) - 2)
-#endif
-
-static BOOL set_file_times_precise( int fd, const LARGE_INTEGER *mtime,
-                                    const LARGE_INTEGER *atime, NTSTATUS *status )
-{
-#ifdef HAVE_FUTIMENS
-    struct timespec tv[2];
-
-    tv[0].tv_sec = tv[1].tv_sec = 0;
-    tv[0].tv_nsec = tv[1].tv_nsec = UTIME_OMIT;
-    if (atime->QuadPart)
-    {
-        tv[0].tv_sec = atime->QuadPart / 10000000 - SECS_1601_TO_1970;
-        tv[0].tv_nsec = (atime->QuadPart % 10000000) * 100;
-    }
-    if (mtime->QuadPart)
-    {
-        tv[1].tv_sec = mtime->QuadPart / 10000000 - SECS_1601_TO_1970;
-        tv[1].tv_nsec = (mtime->QuadPart % 10000000) * 100;
-    }
-#ifdef __APPLE__
-    if (!&futimens) return FALSE;
-#endif
-    if (futimens( fd, tv ) == -1) *status = errno_to_status( errno );
-    else *status = STATUS_SUCCESS;
-    return TRUE;
-#else
-    return FALSE;
-#endif
-}
-
-
-static NTSTATUS set_file_times( int fd, const LARGE_INTEGER *mtime, const LARGE_INTEGER *atime )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMESAT)
-    struct timeval tv[2];
-    struct stat st;
-#endif
-
-    if (set_file_times_precise( fd, mtime, atime, &status ))
-        return status;
-
-#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMESAT)
-    if (!atime->QuadPart || !mtime->QuadPart)
-    {
-
-        tv[0].tv_sec = tv[0].tv_usec = 0;
-        tv[1].tv_sec = tv[1].tv_usec = 0;
-        if (!fstat( fd, &st ))
-        {
-            tv[0].tv_sec = st.st_atime;
-            tv[1].tv_sec = st.st_mtime;
-#ifdef HAVE_STRUCT_STAT_ST_ATIM
-            tv[0].tv_usec = st.st_atim.tv_nsec / 1000;
-#elif defined(HAVE_STRUCT_STAT_ST_ATIMESPEC)
-            tv[0].tv_usec = st.st_atimespec.tv_nsec / 1000;
-#endif
-#ifdef HAVE_STRUCT_STAT_ST_MTIM
-            tv[1].tv_usec = st.st_mtim.tv_nsec / 1000;
-#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC)
-            tv[1].tv_usec = st.st_mtimespec.tv_nsec / 1000;
-#endif
-        }
-    }
-    if (atime->QuadPart)
-    {
-        tv[0].tv_sec = atime->QuadPart / 10000000 - SECS_1601_TO_1970;
-        tv[0].tv_usec = (atime->QuadPart % 10000000) / 10;
-    }
-    if (mtime->QuadPart)
-    {
-        tv[1].tv_sec = mtime->QuadPart / 10000000 - SECS_1601_TO_1970;
-        tv[1].tv_usec = (mtime->QuadPart % 10000000) / 10;
-    }
-#ifdef HAVE_FUTIMES
-    if (futimes( fd, tv ) == -1) status = errno_to_status( errno );
-#elif defined(HAVE_FUTIMESAT)
-    if (futimesat( fd, NULL, tv ) == -1) status = errno_to_status( errno );
-#endif
-
-#else  /* HAVE_FUTIMES || HAVE_FUTIMESAT */
-    FIXME( "setting file times not supported\n" );
-    status = STATUS_NOT_IMPLEMENTED;
-#endif
-    return status;
-}
-
-
-static inline void get_file_times( const struct stat *st, LARGE_INTEGER *mtime, LARGE_INTEGER *ctime,
-                                   LARGE_INTEGER *atime, LARGE_INTEGER *creation )
-{
-    mtime->QuadPart = st->st_mtime * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
-    ctime->QuadPart = st->st_ctime * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
-    atime->QuadPart = st->st_atime * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
-#ifdef HAVE_STRUCT_STAT_ST_MTIM
-    mtime->QuadPart += st->st_mtim.tv_nsec / 100;
-#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC)
-    mtime->QuadPart += st->st_mtimespec.tv_nsec / 100;
-#endif
-#ifdef HAVE_STRUCT_STAT_ST_CTIM
-    ctime->QuadPart += st->st_ctim.tv_nsec / 100;
-#elif defined(HAVE_STRUCT_STAT_ST_CTIMESPEC)
-    ctime->QuadPart += st->st_ctimespec.tv_nsec / 100;
-#endif
-#ifdef HAVE_STRUCT_STAT_ST_ATIM
-    atime->QuadPart += st->st_atim.tv_nsec / 100;
-#elif defined(HAVE_STRUCT_STAT_ST_ATIMESPEC)
-    atime->QuadPart += st->st_atimespec.tv_nsec / 100;
-#endif
-#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME
-    creation->QuadPart = st->st_birthtime * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
-#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIM
-    creation->QuadPart += st->st_birthtim.tv_nsec / 100;
-#elif defined(HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC)
-    creation->QuadPart += st->st_birthtimespec.tv_nsec / 100;
-#endif
-#elif defined(HAVE_STRUCT_STAT___ST_BIRTHTIME)
-    creation->QuadPart = st->__st_birthtime * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
-#ifdef HAVE_STRUCT_STAT___ST_BIRTHTIM
-    creation->QuadPart += st->__st_birthtim.tv_nsec / 100;
-#endif
-#else
-    *creation = *mtime;
-#endif
-}
-
-
-/* fill in the file information that depends on the stat and attribute info */
-static NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
-                                FILE_INFORMATION_CLASS class )
-{
-    switch (class)
-    {
-    case FileBasicInformation:
-        {
-            FILE_BASIC_INFORMATION *info = ptr;
-
-            get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
-                            &info->LastAccessTime, &info->CreationTime );
-            info->FileAttributes = attr;
-        }
-        break;
-    case FileStandardInformation:
-        {
-            FILE_STANDARD_INFORMATION *info = ptr;
-
-            if ((info->Directory = S_ISDIR(st->st_mode)))
-            {
-                info->AllocationSize.QuadPart = 0;
-                info->EndOfFile.QuadPart      = 0;
-                info->NumberOfLinks           = 1;
-            }
-            else
-            {
-                info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
-                info->EndOfFile.QuadPart      = st->st_size;
-                info->NumberOfLinks           = st->st_nlink;
-            }
-        }
-        break;
-    case FileInternalInformation:
-        {
-            FILE_INTERNAL_INFORMATION *info = ptr;
-            info->IndexNumber.QuadPart = st->st_ino;
-        }
-        break;
-    case FileEndOfFileInformation:
-        {
-            FILE_END_OF_FILE_INFORMATION *info = ptr;
-            info->EndOfFile.QuadPart = S_ISDIR(st->st_mode) ? 0 : st->st_size;
-        }
-        break;
-    case FileAllInformation:
-        {
-            FILE_ALL_INFORMATION *info = ptr;
-            fill_file_info( st, attr, &info->BasicInformation, FileBasicInformation );
-            fill_file_info( st, attr, &info->StandardInformation, FileStandardInformation );
-            fill_file_info( st, attr, &info->InternalInformation, FileInternalInformation );
-        }
-        break;
-    /* all directory structures start with the FileDirectoryInformation layout */
-    case FileBothDirectoryInformation:
-    case FileFullDirectoryInformation:
-    case FileDirectoryInformation:
-        {
-            FILE_DIRECTORY_INFORMATION *info = ptr;
-
-            get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
-                            &info->LastAccessTime, &info->CreationTime );
-            if (S_ISDIR(st->st_mode))
-            {
-                info->AllocationSize.QuadPart = 0;
-                info->EndOfFile.QuadPart      = 0;
-            }
-            else
-            {
-                info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
-                info->EndOfFile.QuadPart      = st->st_size;
-            }
-            info->FileAttributes = attr;
-        }
-        break;
-    case FileIdFullDirectoryInformation:
-        {
-            FILE_ID_FULL_DIRECTORY_INFORMATION *info = ptr;
-            info->FileId.QuadPart = st->st_ino;
-            fill_file_info( st, attr, info, FileDirectoryInformation );
-        }
-        break;
-    case FileIdBothDirectoryInformation:
-        {
-            FILE_ID_BOTH_DIRECTORY_INFORMATION *info = ptr;
-            info->FileId.QuadPart = st->st_ino;
-            fill_file_info( st, attr, info, FileDirectoryInformation );
-        }
-        break;
-    case FileIdGlobalTxDirectoryInformation:
-        {
-            FILE_ID_GLOBAL_TX_DIR_INFORMATION *info = ptr;
-            info->FileId.QuadPart = st->st_ino;
-            fill_file_info( st, attr, info, FileDirectoryInformation );
-        }
-        break;
-
-    default:
-        return STATUS_INVALID_INFO_CLASS;
-    }
-    return STATUS_SUCCESS;
-}
-
-
-static NTSTATUS server_get_unix_name( HANDLE handle, char **unix_name )
-{
-    data_size_t size = 1024;
-    NTSTATUS ret;
-    char *name;
-
-    for (;;)
-    {
-        if (!(name = malloc( size + 1 ))) return STATUS_NO_MEMORY;
-
-        SERVER_START_REQ( get_handle_unix_name )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            wine_server_set_reply( req, name, size );
-            ret = wine_server_call( req );
-            size = reply->name_len;
-        }
-        SERVER_END_REQ;
-
-        if (!ret)
-        {
-            name[size] = 0;
-            *unix_name = name;
-            break;
-        }
-        free( name );
-        if (ret != STATUS_BUFFER_OVERFLOW) break;
-    }
-    return ret;
-}
-
-static NTSTATUS fill_name_info( const char *unix_name, FILE_NAME_INFORMATION *info, LONG *name_len )
-{
-    WCHAR *nt_name;
-    NTSTATUS status;
-
-    if (!(status = unix_to_nt_file_name( unix_name, &nt_name )))
-    {
-        const WCHAR *ptr = nt_name;
-        const WCHAR *end = ptr + wcslen( nt_name );
-
-        /* Skip the volume mount point. */
-        while (ptr != end && *ptr == '\\') ++ptr;
-        while (ptr != end && *ptr != '\\') ++ptr;
-        while (ptr != end && *ptr == '\\') ++ptr;
-        while (ptr != end && *ptr != '\\') ++ptr;
-
-        info->FileNameLength = (end - ptr) * sizeof(WCHAR);
-        if (*name_len < info->FileNameLength) status = STATUS_BUFFER_OVERFLOW;
-        else *name_len = info->FileNameLength;
-
-        memcpy( info->FileName, ptr, *name_len );
-        free( nt_name );
-    }
-
-    return status;
-}
-
-
-static NTSTATUS server_get_file_info( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer,
-                                      ULONG length, FILE_INFORMATION_CLASS info_class )
-{
-    SERVER_START_REQ( get_file_info )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->info_class = info_class;
-        wine_server_set_reply( req, buffer, length );
-        io->u.Status = wine_server_call( req );
-        io->Information = wine_server_reply_size( reply );
-    }
-    SERVER_END_REQ;
-    if (io->u.Status == STATUS_NOT_IMPLEMENTED)
-        FIXME( "Unsupported info class %x\n", info_class );
-    return io->u.Status;
-
-}
-
-
-/* retrieve device/inode number for all the drives */
-static unsigned int get_drives_info( struct file_identity info[MAX_DOS_DRIVES] )
-{
-    static pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;
-    static struct file_identity cache[MAX_DOS_DRIVES];
-    static time_t last_update;
-    static unsigned int nb_drives;
-    unsigned int ret;
-    time_t now = time(NULL);
-
-    pthread_mutex_lock( &cache_mutex );
-    if (now != last_update)
-    {
-        char *buffer, *p;
-        struct stat st;
-        unsigned int i;
-
-        if ((buffer = malloc( strlen(config_dir) + sizeof("/dosdevices/a:") )))
-        {
-            strcpy( buffer, config_dir );
-            strcat( buffer, "/dosdevices/a:" );
-            p = buffer + strlen(buffer) - 2;
-
-            for (i = nb_drives = 0; i < MAX_DOS_DRIVES; i++)
-            {
-                *p = 'a' + i;
-                if (!stat( buffer, &st ))
-                {
-                    cache[i].dev = st.st_dev;
-                    cache[i].ino = st.st_ino;
-                    nb_drives++;
-                }
-                else
-                {
-                    cache[i].dev = 0;
-                    cache[i].ino = 0;
-                }
-            }
-            free( buffer );
-        }
-        last_update = now;
-    }
-    memcpy( info, cache, sizeof(cache) );
-    ret = nb_drives;
-    pthread_mutex_unlock( &cache_mutex );
-    return ret;
-}
-
-
-/* Find a DOS device which can act as the root of "path".
- * Similar to find_drive_root(), but returns -1 instead of crossing volumes. */
-static int find_dos_device( const char *path )
-{
-    int len = strlen(path);
-    int drive;
-    char *buffer;
-    struct stat st;
-    struct file_identity info[MAX_DOS_DRIVES];
-    dev_t dev_id;
-
-    if (!get_drives_info( info )) return -1;
-
-    if (stat( path, &st ) < 0) return -1;
-    dev_id = st.st_dev;
-
-    /* strip off trailing slashes */
-    while (len > 1 && path[len - 1] == '/') len--;
-
-    /* make a copy of the path */
-    if (!(buffer = malloc( len + 1 ))) return -1;
-    memcpy( buffer, path, len );
-    buffer[len] = 0;
-
-    for (;;)
-    {
-        if (!stat( buffer, &st ) && S_ISDIR( st.st_mode ))
-        {
-            if (st.st_dev != dev_id) break;
-
-            for (drive = 0; drive < MAX_DOS_DRIVES; drive++)
-            {
-                if ((info[drive].dev == st.st_dev) && (info[drive].ino == st.st_ino))
-                {
-                    TRACE( "%s -> drive %c:, root=%s, name=%s\n",
-                           debugstr_a(path), 'A' + drive, debugstr_a(buffer), debugstr_a(path + len));
-                    free( buffer );
-                    return drive;
-                }
-            }
-        }
-        if (len <= 1) break;  /* reached root */
-        while (len > 1 && path[len - 1] != '/') len--;
-        while (len > 1 && path[len - 1] == '/') len--;
-        buffer[len] = 0;
-    }
-    free( buffer );
-    return -1;
-}
-
-static NTSTATUS get_mountmgr_fs_info( HANDLE handle, int fd, struct mountmgr_unix_drive *drive, ULONG size )
-{
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING string;
-    char *unix_name;
-    IO_STATUS_BLOCK io;
-    HANDLE mountmgr;
-    NTSTATUS status;
-    int letter;
-
-    if ((status = server_get_unix_name( handle, &unix_name ))) return status;
-    letter = find_dos_device( unix_name );
-    free( unix_name );
-
-    if (letter == -1)
-    {
-        struct stat st;
-
-        fstat( fd, &st );
-        drive->unix_dev = st.st_dev;
-        drive->letter = 0;
-    }
-    else
-        drive->letter = 'a' + letter;
-
-    string.Buffer = (WCHAR *)MOUNTMGR_DEVICE_NAME;
-    string.Length = sizeof(MOUNTMGR_DEVICE_NAME) - sizeof(WCHAR);
-    InitializeObjectAttributes( &attr, &string, 0, NULL, NULL );
-    status = NtOpenFile( &mountmgr, GENERIC_READ | SYNCHRONIZE, &attr, &io,
-                         FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT );
-    if (status) return status;
-
-    status = NtDeviceIoControlFile( mountmgr, NULL, NULL, NULL, &io, IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE,
-                                    drive, sizeof(*drive), drive, size );
-    NtClose( mountmgr );
-    if (status == STATUS_BUFFER_OVERFLOW) status = STATUS_SUCCESS;
-    else if (status) WARN("failed to retrieve filesystem type from mountmgr, status %#x\n", status);
-    return status;
-}
-
-
-/***********************************************************************
- *           get_dir_data_entry
- *
- * Return a directory entry from the cached data.
- */
-static NTSTATUS get_dir_data_entry( struct dir_data *dir_data, void *info_ptr, IO_STATUS_BLOCK *io,
-                                    ULONG max_length, FILE_INFORMATION_CLASS class,
-                                    union file_directory_info **last_info )
-{
-    const struct dir_data_names *names = &dir_data->names[dir_data->pos];
-    union file_directory_info *info;
-    struct stat st;
-    ULONG name_len, start, dir_size, attributes;
-
-    if (get_file_info( names->unix_name, &st, &attributes ) == -1)
-    {
-        TRACE( "file no longer exists %s\n", names->unix_name );
-        return STATUS_SUCCESS;
-    }
-    if (is_ignored_file( &st ))
-    {
-        TRACE( "ignoring file %s\n", names->unix_name );
-        return STATUS_SUCCESS;
-    }
-    start = dir_info_align( io->Information );
-    dir_size = dir_info_size( class, 0 );
-    if (start + dir_size > max_length) return STATUS_MORE_ENTRIES;
-
-    max_length -= start + dir_size;
-    name_len = wcslen( names->long_name ) * sizeof(WCHAR);
-    /* if this is not the first entry, fail; the first entry is always returned (but truncated) */
-    if (*last_info && name_len > max_length) return STATUS_MORE_ENTRIES;
-
-    info = (union file_directory_info *)((char *)info_ptr + start);
-    info->dir.NextEntryOffset = 0;
-    info->dir.FileIndex = 0;  /* NTFS always has 0 here, so let's not bother with it */
-
-    /* all the structures except FileNamesInformation start with a FileDirectoryInformation layout */
-    if (class != FileNamesInformation)
-    {
-        if (st.st_dev != dir_data->id.dev) st.st_ino = 0;  /* ignore inode if on a different device */
-
-        if (!show_dot_files && names->long_name[0] == '.' && names->long_name[1] &&
-            (names->long_name[1] != '.' || names->long_name[2]))
-            attributes |= FILE_ATTRIBUTE_HIDDEN;
-
-        fill_file_info( &st, attributes, info, class );
-    }
-
-    switch (class)
-    {
-    case FileDirectoryInformation:
-        info->dir.FileNameLength = name_len;
-        break;
-
-    case FileFullDirectoryInformation:
-        info->full.EaSize = 0; /* FIXME */
-        info->full.FileNameLength = name_len;
-        break;
-
-    case FileIdFullDirectoryInformation:
-        info->id_full.EaSize = 0; /* FIXME */
-        info->id_full.FileNameLength = name_len;
-        break;
-
-    case FileBothDirectoryInformation:
-        info->both.EaSize = 0; /* FIXME */
-        info->both.ShortNameLength = wcslen( names->short_name ) * sizeof(WCHAR);
-        memcpy( info->both.ShortName, names->short_name, info->both.ShortNameLength );
-        info->both.FileNameLength = name_len;
-        break;
-
-    case FileIdBothDirectoryInformation:
-        info->id_both.EaSize = 0; /* FIXME */
-        info->id_both.ShortNameLength = wcslen( names->short_name ) * sizeof(WCHAR);
-        memcpy( info->id_both.ShortName, names->short_name, info->id_both.ShortNameLength );
-        info->id_both.FileNameLength = name_len;
-        break;
-
-    case FileIdGlobalTxDirectoryInformation:
-        info->id_tx.TxInfoFlags = 0;
-        info->id_tx.FileNameLength = name_len;
-        break;
-
-    case FileNamesInformation:
-        info->names.FileNameLength = name_len;
-        break;
-
-    default:
-        assert(0);
-        return 0;
-    }
-
-    memcpy( (char *)info + dir_size, names->long_name, min( name_len, max_length ) );
-    io->Information = start + dir_size + min( name_len, max_length );
-    if (*last_info) (*last_info)->next = (char *)info - (char *)*last_info;
-    *last_info = info;
-    return name_len > max_length ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
-}
-
-#ifdef VFAT_IOCTL_READDIR_BOTH
-
-/***********************************************************************
- *           read_directory_vfat
- *
- * Read a directory using the VFAT ioctl; helper for NtQueryDirectoryFile.
- */
-static NTSTATUS read_directory_data_vfat( struct dir_data *data, int fd, const UNICODE_STRING *mask )
-{
-    char *short_name, *long_name;
-    KERNEL_DIRENT de[2];
-    NTSTATUS status = STATUS_NO_MEMORY;
-    off_t old_pos = lseek( fd, 0, SEEK_CUR );
-
-    lseek( fd, 0, SEEK_SET );
-
-    if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)de ) == -1)
-    {
-        if (errno != ENOENT)
-        {
-            status = STATUS_NOT_SUPPORTED;
-            goto done;
-        }
-        de[0].d_reclen = 0;
-    }
-
-    if (!append_entry( data, ".", NULL, mask )) goto done;
-    if (!append_entry( data, "..", NULL, mask )) goto done;
-
-    while (de[0].d_reclen)
-    {
-        if (strcmp( de[0].d_name, "." ) && strcmp( de[0].d_name, ".." ))
-        {
-            if (de[1].d_name[0])
-            {
-                short_name = de[0].d_name;
-                long_name = de[1].d_name;
-            }
-            else
-            {
-                long_name = de[0].d_name;
-                short_name = NULL;
-            }
-            if (!append_entry( data, long_name, short_name, mask )) goto done;
-        }
-        if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)de ) == -1) break;
-    }
-    status = STATUS_SUCCESS;
-done:
-    lseek( fd, old_pos, SEEK_SET );
-    return status;
-}
-#endif /* VFAT_IOCTL_READDIR_BOTH */
-
-
-#ifdef HAVE_GETATTRLIST
-/***********************************************************************
- *           read_directory_getattrlist
- *
- * Read a single file from a directory by determining whether the file
- * identified by mask exists using getattrlist.
- */
-static NTSTATUS read_directory_data_getattrlist( struct dir_data *data, const char *unix_name )
-{
-    struct attrlist attrlist;
-#include "pshpack4.h"
-    struct
-    {
-        u_int32_t length;
-        struct attrreference name_reference;
-        fsobj_type_t type;
-        char name[NAME_MAX * 3 + 1];
-    } buffer;
-#include "poppack.h"
-
-    memset( &attrlist, 0, sizeof(attrlist) );
-    attrlist.bitmapcount = ATTR_BIT_MAP_COUNT;
-    attrlist.commonattr = ATTR_CMN_NAME | ATTR_CMN_OBJTYPE;
-    if (getattrlist( unix_name, &attrlist, &buffer, sizeof(buffer), FSOPT_NOFOLLOW ) == -1)
-        return STATUS_NO_SUCH_FILE;
-    /* If unix_name named a symlink, the above may have succeeded even if the symlink is broken.
-       Check that with another call without FSOPT_NOFOLLOW.  We don't ask for any attributes. */
-    if (buffer.type == VLNK)
-    {
-        u_int32_t dummy;
-        attrlist.commonattr = 0;
-        if (getattrlist( unix_name, &attrlist, &dummy, sizeof(dummy), 0 ) == -1)
-            return STATUS_NO_SUCH_FILE;
-    }
-
-    TRACE( "found %s\n", buffer.name );
-
-    if (!append_entry( data, buffer.name, NULL, NULL )) return STATUS_NO_MEMORY;
-
-    return STATUS_SUCCESS;
-}
-#endif  /* HAVE_GETATTRLIST */
-
-
-/***********************************************************************
- *           read_directory_stat
- *
- * Read a single file from a directory by determining whether the file
- * identified by mask exists using stat.
- */
-static NTSTATUS read_directory_data_stat( struct dir_data *data, const char *unix_name )
-{
-    struct stat st;
-
-    /* if the file system is not case sensitive we can't find the actual name through stat() */
-    if (!get_dir_case_sensitivity(".")) return STATUS_NO_SUCH_FILE;
-    if (stat( unix_name, &st ) == -1) return STATUS_NO_SUCH_FILE;
-
-    TRACE( "found %s\n", unix_name );
-
-    if (!append_entry( data, unix_name, NULL, NULL )) return STATUS_NO_MEMORY;
-
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           read_directory_readdir
- *
- * Read a directory using the POSIX readdir interface; helper for NtQueryDirectoryFile.
- */
-static NTSTATUS read_directory_data_readdir( struct dir_data *data, const UNICODE_STRING *mask )
-{
-    struct dirent *de;
-    NTSTATUS status = STATUS_NO_MEMORY;
-    DIR *dir = opendir( "." );
-
-    if (!dir) return STATUS_NO_SUCH_FILE;
-
-    if (!append_entry( data, ".", NULL, mask )) goto done;
-    if (!append_entry( data, "..", NULL, mask )) goto done;
-    while ((de = readdir( dir )))
-    {
-        if (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." )) continue;
-        if (!append_entry( data, de->d_name, NULL, mask )) goto done;
-    }
-    status = STATUS_SUCCESS;
-
-done:
-    closedir( dir );
-    return status;
-}
-
-
-/***********************************************************************
- *           read_directory_data
- *
- * Read the full contents of a directory, using one of the above helper functions.
- */
-static NTSTATUS read_directory_data( struct dir_data *data, int fd, const UNICODE_STRING *mask )
-{
-    NTSTATUS status;
-
-#ifdef VFAT_IOCTL_READDIR_BOTH
-    if (!(status = read_directory_data_vfat( data, fd, mask ))) return status;
-#endif
-
-    if (!has_wildcard( mask ))
-    {
-        /* convert the mask to a Unix name and check for it */
-        char unix_name[MAX_DIR_ENTRY_LEN * 3 + 1];
-        int ret = ntdll_wcstoumbs( mask->Buffer, mask->Length / sizeof(WCHAR),
-                                   unix_name, sizeof(unix_name) - 1, TRUE );
-        if (ret > 0)
-        {
-            unix_name[ret] = 0;
-#ifdef HAVE_GETATTRLIST
-            if (!(status = read_directory_data_getattrlist( data, unix_name ))) return status;
-#endif
-            if (!(status = read_directory_data_stat( data, unix_name ))) return status;
-        }
-    }
-
-    return read_directory_data_readdir( data, mask );
-}
-
-
-/* compare file names for directory sorting */
-static int name_compare( const void *a, const void *b )
-{
-    const struct dir_data_names *file_a = (const struct dir_data_names *)a;
-    const struct dir_data_names *file_b = (const struct dir_data_names *)b;
-    int ret = wcsicmp( file_a->long_name, file_b->long_name );
-    if (!ret) ret = wcscmp( file_a->long_name, file_b->long_name );
-    return ret;
-}
-
-
-/***********************************************************************
- *           init_cached_dir_data
- *
- * Initialize the cached directory contents.
- */
-static NTSTATUS init_cached_dir_data( struct dir_data **data_ret, int fd, const UNICODE_STRING *mask )
-{
-    struct dir_data *data;
-    struct stat st;
-    NTSTATUS status;
-    unsigned int i;
-
-    if (!(data = calloc( 1, sizeof(*data) ))) return STATUS_NO_MEMORY;
-
-    if ((status = read_directory_data( data, fd, mask )))
-    {
-        free_dir_data( data );
-        return status;
-    }
-
-    /* sort filenames, but not "." and ".." */
-    i = 0;
-    if (i < data->count && !strcmp( data->names[i].unix_name, "." )) i++;
-    if (i < data->count && !strcmp( data->names[i].unix_name, ".." )) i++;
-    if (i < data->count) qsort( data->names + i, data->count - i, sizeof(*data->names), name_compare );
-
-    if (data->count)
-    {
-        fstat( fd, &st );
-        data->id.dev = st.st_dev;
-        data->id.ino = st.st_ino;
-    }
-
-    TRACE( "mask %s found %u files\n", debugstr_us( mask ), data->count );
-    for (i = 0; i < data->count; i++)
-        TRACE( "%s %s\n", debugstr_w(data->names[i].long_name), debugstr_w(data->names[i].short_name) );
-
-    *data_ret = data;
-    return data->count ? STATUS_SUCCESS : STATUS_NO_SUCH_FILE;
-}
-
-
-/***********************************************************************
- *           get_cached_dir_data
- *
- * Retrieve the cached directory data, or initialize it if necessary.
- */
-static NTSTATUS get_cached_dir_data( HANDLE handle, struct dir_data **data_ret, int fd,
-                                     const UNICODE_STRING *mask )
-{
-    unsigned int i;
-    int entry = -1, free_entries[16];
-    NTSTATUS status;
-
-    SERVER_START_REQ( get_directory_cache_entry )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        wine_server_set_reply( req, free_entries, sizeof(free_entries) );
-        if (!(status = wine_server_call( req ))) entry = reply->entry;
-
-        for (i = 0; i < wine_server_reply_size( reply ) / sizeof(*free_entries); i++)
-        {
-            int free_idx = free_entries[i];
-            if (free_idx < dir_data_cache_size)
-            {
-                free_dir_data( dir_data_cache[free_idx] );
-                dir_data_cache[free_idx] = NULL;
-            }
-        }
-    }
-    SERVER_END_REQ;
-
-    if (status)
-    {
-        if (status == STATUS_SHARING_VIOLATION) FIXME( "shared directory handle not supported yet\n" );
-        return status;
-    }
-
-    if (entry >= dir_data_cache_size)
-    {
-        unsigned int size = max( dir_data_cache_initial_size, max( dir_data_cache_size * 2, entry + 1 ) );
-        struct dir_data **new_cache = realloc( dir_data_cache, size * sizeof(*new_cache) );
-
-        if (!new_cache) return STATUS_NO_MEMORY;
-        memset( new_cache + dir_data_cache_size, 0, (size - dir_data_cache_size) * sizeof(*new_cache) );
-        dir_data_cache = new_cache;
-        dir_data_cache_size = size;
-    }
-
-    if (!dir_data_cache[entry]) status = init_cached_dir_data( &dir_data_cache[entry], fd, mask );
-
-    *data_ret = dir_data_cache[entry];
-    return status;
-}
-
-
-/******************************************************************************
- *              NtQueryDirectoryFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryDirectoryFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc_routine,
-                                      void *apc_context, IO_STATUS_BLOCK *io, void *buffer, ULONG length,
-                                      FILE_INFORMATION_CLASS info_class, BOOLEAN single_entry,
-                                      UNICODE_STRING *mask, BOOLEAN restart_scan )
-{
-    int cwd, fd, needs_close;
-    enum server_fd_type type;
-    struct dir_data *data;
-    NTSTATUS status;
-
-    TRACE("(%p %p %p %p %p %p 0x%08x 0x%08x 0x%08x %s 0x%08x\n",
-          handle, event, apc_routine, apc_context, io, buffer,
-          length, info_class, single_entry, debugstr_us(mask),
-          restart_scan);
-
-    if (event || apc_routine)
-    {
-        FIXME( "Unsupported yet option\n" );
-        return STATUS_NOT_IMPLEMENTED;
-    }
-    switch (info_class)
-    {
-    case FileDirectoryInformation:
-    case FileBothDirectoryInformation:
-    case FileFullDirectoryInformation:
-    case FileIdBothDirectoryInformation:
-    case FileIdFullDirectoryInformation:
-    case FileIdGlobalTxDirectoryInformation:
-    case FileNamesInformation:
-        if (length < dir_info_align( dir_info_size( info_class, 1 ))) return STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    case FileObjectIdInformation:
-        if (length != sizeof(FILE_OBJECTID_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-        return STATUS_INVALID_INFO_CLASS;
-    case FileQuotaInformation:
-        if (length != sizeof(FILE_QUOTA_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-        return STATUS_INVALID_INFO_CLASS;
-    case FileReparsePointInformation:
-        if (length != sizeof(FILE_REPARSE_POINT_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-        return STATUS_INVALID_INFO_CLASS;
-    default:
-        return STATUS_INVALID_INFO_CLASS;
-    }
-    if (!buffer) return STATUS_ACCESS_VIOLATION;
-
-    if ((status = server_get_unix_fd( handle, FILE_LIST_DIRECTORY, &fd, &needs_close, &type, NULL )))
-        return status;
-
-    if (type != FD_TYPE_DIR)
-    {
-        if (needs_close) close( fd );
-        return STATUS_INVALID_PARAMETER;
-    }
-
-    io->Information = 0;
-
-    pthread_mutex_lock( &dir_mutex );
-
-    cwd = open( ".", O_RDONLY );
-    if (fchdir( fd ) != -1)
-    {
-        if (!(status = get_cached_dir_data( handle, &data, fd, mask )))
-        {
-            union file_directory_info *last_info = NULL;
-
-            if (restart_scan) data->pos = 0;
-
-            while (!status && data->pos < data->count)
-            {
-                status = get_dir_data_entry( data, buffer, io, length, info_class, &last_info );
-                if (!status || status == STATUS_BUFFER_OVERFLOW) data->pos++;
-                if (single_entry && last_info) break;
-            }
-
-            if (!last_info) status = STATUS_NO_MORE_FILES;
-            else if (status == STATUS_MORE_ENTRIES) status = STATUS_SUCCESS;
-
-            io->u.Status = status;
-        }
-        if (cwd == -1 || fchdir( cwd ) == -1) chdir( "/" );
-    }
-    else status = errno_to_status( errno );
-
-    pthread_mutex_unlock( &dir_mutex );
-
-    if (needs_close) close( fd );
-    if (cwd != -1) close( cwd );
-    TRACE( "=> %x (%ld)\n", status, io->Information );
-    return status;
-}
-
-
-/***********************************************************************
- *           find_file_in_dir
- *
- * Find a file in a directory the hard way, by doing a case-insensitive search.
- * The file found is appended to unix_name at pos.
- * There must be at least MAX_DIR_ENTRY_LEN+2 chars available at pos.
- */
-static NTSTATUS find_file_in_dir( char *unix_name, int pos, const WCHAR *name, int length,
-                                  BOOLEAN check_case, BOOLEAN *is_win_dir )
-{
-    WCHAR buffer[MAX_DIR_ENTRY_LEN];
-    BOOLEAN is_name_8_dot_3;
-    DIR *dir;
-    struct dirent *de;
-    struct stat st;
-    int ret;
-
-    /* try a shortcut for this directory */
-
-    unix_name[pos++] = '/';
-    ret = ntdll_wcstoumbs( name, length, unix_name + pos, MAX_DIR_ENTRY_LEN + 1, TRUE );
-    if (ret >= 0 && ret <= MAX_DIR_ENTRY_LEN)
-    {
-        unix_name[pos + ret] = 0;
-        if (!stat( unix_name, &st ))
-        {
-            if (is_win_dir) *is_win_dir = is_same_file( &windir, &st );
-            return STATUS_SUCCESS;
-        }
-    }
-    if (check_case) goto not_found;  /* we want an exact match */
-
-    if (pos > 1) unix_name[pos - 1] = 0;
-    else unix_name[1] = 0;  /* keep the initial slash */
-
-    /* check if it fits in 8.3 so that we don't look for short names if we won't need them */
-
-    is_name_8_dot_3 = is_legal_8dot3_name( name, length );
-#ifndef VFAT_IOCTL_READDIR_BOTH
-    is_name_8_dot_3 = is_name_8_dot_3 && length >= 8 && name[4] == '~';
-#endif
-
-    if (!is_name_8_dot_3 && !get_dir_case_sensitivity( unix_name )) goto not_found;
-
-    /* now look for it through the directory */
-
-#ifdef VFAT_IOCTL_READDIR_BOTH
-    if (is_name_8_dot_3)
-    {
-        int fd = open( unix_name, O_RDONLY | O_DIRECTORY );
-        if (fd != -1)
-        {
-            KERNEL_DIRENT kde[2];
-
-            if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)kde ) != -1)
-            {
-                unix_name[pos - 1] = '/';
-                while (kde[0].d_reclen)
-                {
-                    if (kde[1].d_name[0])
-                    {
-                        ret = ntdll_umbstowcs( kde[1].d_name, strlen(kde[1].d_name),
-                                               buffer, MAX_DIR_ENTRY_LEN );
-                        if (ret == length && !wcsnicmp( buffer, name, ret ))
-                        {
-                            strcpy( unix_name + pos, kde[1].d_name );
-                            close( fd );
-                            goto success;
-                        }
-                    }
-                    ret = ntdll_umbstowcs( kde[0].d_name, strlen(kde[0].d_name),
-                                           buffer, MAX_DIR_ENTRY_LEN );
-                    if (ret == length && !wcsnicmp( buffer, name, ret ))
-                    {
-                        strcpy( unix_name + pos,
-                                kde[1].d_name[0] ? kde[1].d_name : kde[0].d_name );
-                        close( fd );
-                        goto success;
-                    }
-                    if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)kde ) == -1)
-                    {
-                        close( fd );
-                        goto not_found;
-                    }
-                }
-            }
-            close( fd );
-        }
-        /* fall through to normal handling */
-    }
-#endif /* VFAT_IOCTL_READDIR_BOTH */
-
-    if (!(dir = opendir( unix_name ))) return errno_to_status( errno );
-
-    unix_name[pos - 1] = '/';
-    while ((de = readdir( dir )))
-    {
-        ret = ntdll_umbstowcs( de->d_name, strlen(de->d_name), buffer, MAX_DIR_ENTRY_LEN );
-        if (ret == length && !wcsnicmp( buffer, name, ret ))
-        {
-            strcpy( unix_name + pos, de->d_name );
-            closedir( dir );
-            goto success;
-        }
-
-        if (!is_name_8_dot_3) continue;
-
-        if (!is_legal_8dot3_name( buffer, ret ))
-        {
-            WCHAR short_nameW[12];
-            ret = hash_short_file_name( buffer, ret, short_nameW );
-            if (ret == length && !wcsnicmp( short_nameW, name, length ))
-            {
-                strcpy( unix_name + pos, de->d_name );
-                closedir( dir );
-                goto success;
-            }
-        }
-    }
-    closedir( dir );
-
-not_found:
-    unix_name[pos - 1] = 0;
-    return STATUS_OBJECT_PATH_NOT_FOUND;
-
-success:
-    if (is_win_dir && !stat( unix_name, &st )) *is_win_dir = is_same_file( &windir, &st );
-    return STATUS_SUCCESS;
-}
-
-
-#ifndef _WIN64
-
-static const WCHAR catrootW[] = {'s','y','s','t','e','m','3','2','\\','c','a','t','r','o','o','t',0};
-static const WCHAR catroot2W[] = {'s','y','s','t','e','m','3','2','\\','c','a','t','r','o','o','t','2',0};
-static const WCHAR driversstoreW[] = {'s','y','s','t','e','m','3','2','\\','d','r','i','v','e','r','s','s','t','o','r','e',0};
-static const WCHAR driversetcW[] = {'s','y','s','t','e','m','3','2','\\','d','r','i','v','e','r','s','\\','e','t','c',0};
-static const WCHAR logfilesW[] = {'s','y','s','t','e','m','3','2','\\','l','o','g','f','i','l','e','s',0};
-static const WCHAR spoolW[] = {'s','y','s','t','e','m','3','2','\\','s','p','o','o','l',0};
-static const WCHAR system32W[] = {'s','y','s','t','e','m','3','2',0};
-static const WCHAR sysnativeW[] = {'s','y','s','n','a','t','i','v','e',0};
-static const WCHAR regeditW[] = {'r','e','g','e','d','i','t','.','e','x','e',0};
-
-static struct
-{
-    const WCHAR *source;
-    const char *unix_target;
-} redirects[] =
-{
-    { catrootW, NULL },
-    { catroot2W, NULL },
-    { driversstoreW, NULL },
-    { driversetcW, NULL },
-    { logfilesW, NULL },
-    { spoolW, NULL },
-    { system32W, "syswow64" },
-    { sysnativeW, "system32" },
-    { regeditW, "syswow64/regedit.exe" }
-};
-
-static unsigned int nb_redirects;
-
-
-/***********************************************************************
- *           init_redirects
- */
-static void init_redirects(void)
-{
-    static const char windows_dir[] = "/dosdevices/c:/windows";
-    char *dir;
-    struct stat st;
-
-    if (!(dir = malloc( strlen(config_dir) + sizeof(windows_dir) ))) return;
-    strcpy( dir, config_dir );
-    strcat( dir, windows_dir );
-    if (!stat( dir, &st ))
-    {
-        windir.dev = st.st_dev;
-        windir.ino = st.st_ino;
-        nb_redirects = ARRAY_SIZE( redirects );
-    }
-    else ERR( "%s: %s\n", dir, strerror(errno) );
-    free( dir );
-
-}
-
-
-/***********************************************************************
- *           match_redirect
- *
- * Check if path matches a redirect name. If yes, return matched length.
- */
-static int match_redirect( const WCHAR *path, int len, const WCHAR *redir, BOOLEAN check_case )
-{
-    int i = 0;
-
-    while (i < len)
-    {
-        int start = i;
-        while (i < len && !IS_SEPARATOR(path[i])) i++;
-        if (check_case)
-        {
-            if (wcsncmp( path + start, redir, i - start )) return 0;
-        }
-        else
-        {
-            if (wcsnicmp( path + start, redir, i - start )) return 0;
-        }
-        redir += i - start;
-        while (i < len && IS_SEPARATOR(path[i])) i++;
-        if (!*redir) return i;
-        if (*redir++ != '\\') return 0;
-    }
-    return 0;
-}
-
-
-/***********************************************************************
- *           get_redirect_path
- *
- * Retrieve the Unix path corresponding to a redirected path if any.
- */
-static int get_redirect_path( char *unix_name, int pos, const WCHAR *name, int length, BOOLEAN check_case )
-{
-    unsigned int i;
-    int len;
-
-    for (i = 0; i < nb_redirects; i++)
-    {
-        if ((len = match_redirect( name, length, redirects[i].source, check_case )))
-        {
-            if (!redirects[i].unix_target) break;
-            unix_name[pos++] = '/';
-            strcpy( unix_name + pos, redirects[i].unix_target );
-            return len;
-        }
-    }
-    return 0;
-}
-
-#else  /* _WIN64 */
-
-/* there are no redirects on 64-bit */
-static int get_redirect_path( char *unix_name, int pos, const WCHAR *name, int length, BOOLEAN check_case )
-{
-    return 0;
-}
-
-#endif
-
-/***********************************************************************
- *           init_files
- */
-void init_files(void)
-{
-#ifndef _WIN64
-    if (is_wow64) init_redirects();
-#endif
-    /* a couple of directories that we don't want to return in directory searches */
-    ignore_file( config_dir );
-    ignore_file( "/dev" );
-    ignore_file( "/proc" );
-#ifdef linux
-    ignore_file( "/sys" );
-#endif
-    /* retrieve initial umask */
-    start_umask = umask( 0777 );
-    umask( start_umask );
-}
-
-
-/******************************************************************************
- *           get_dos_device
- *
- * Get the Unix path of a DOS device.
- */
-static NTSTATUS get_dos_device( const WCHAR *name, UINT name_len, char **unix_name_ret )
-{
-    struct stat st;
-    char *unix_name, *new_name, *dev;
-    unsigned int i;
-    int unix_len;
-
-    /* make sure the device name is ASCII */
-    for (i = 0; i < name_len; i++)
-        if (name[i] <= 32 || name[i] >= 127) return STATUS_BAD_DEVICE_TYPE;
-
-    unix_len = strlen(config_dir) + sizeof("/dosdevices/") + name_len + 1;
-
-    if (!(unix_name = malloc( unix_len ))) return STATUS_NO_MEMORY;
-
-    strcpy( unix_name, config_dir );
-    strcat( unix_name, "/dosdevices/" );
-    dev = unix_name + strlen(unix_name);
-
-    for (i = 0; i < name_len; i++) dev[i] = (name[i] >= 'A' && name[i] <= 'Z' ? name[i] + 32 : name[i]);
-    dev[i] = 0;
-
-    /* special case for drive devices */
-    if (name_len == 2 && dev[1] == ':')
-    {
-        dev[i++] = ':';
-        dev[i] = 0;
-    }
-
-    for (;;)
-    {
-        if (!stat( unix_name, &st ))
-        {
-            TRACE( "%s -> %s\n", debugstr_wn(name,name_len), debugstr_a(unix_name) );
-            *unix_name_ret = unix_name;
-            return STATUS_SUCCESS;
-        }
-        if (!dev) break;
-
-        /* now try some defaults for it */
-        if (!strcmp( dev, "aux" ))
-        {
-            strcpy( dev, "com1" );
-            continue;
-        }
-        if (!strcmp( dev, "prn" ))
-        {
-            strcpy( dev, "lpt1" );
-            continue;
-        }
-
-        new_name = NULL;
-        if (dev[1] == ':' && dev[2] == ':')  /* drive device */
-        {
-            dev[2] = 0;  /* remove last ':' to get the drive mount point symlink */
-            new_name = get_default_drive_device( unix_name );
-        }
-
-        if (!new_name) break;
-        free( unix_name );
-        unix_name = new_name;
-        unix_len = strlen(unix_name) + 1;
-        dev = NULL; /* last try */
-    }
-    free( unix_name );
-    return STATUS_BAD_DEVICE_TYPE;
-}
-
-
-/* return the length of the DOS namespace prefix if any */
-static inline int get_dos_prefix_len( const UNICODE_STRING *name )
-{
-    static const WCHAR nt_prefixW[] = {'\\','?','?','\\'};
-    static const WCHAR dosdev_prefixW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\'};
-
-    if (name->Length >= sizeof(nt_prefixW) &&
-        !memcmp( name->Buffer, nt_prefixW, sizeof(nt_prefixW) ))
-        return ARRAY_SIZE( nt_prefixW );
-
-    if (name->Length >= sizeof(dosdev_prefixW) &&
-        !wcsnicmp( name->Buffer, dosdev_prefixW, ARRAY_SIZE( dosdev_prefixW )))
-        return ARRAY_SIZE( dosdev_prefixW );
-
-    return 0;
-}
-
-
-/***********************************************************************
- *           remove_last_componentA
- *
- * Remove the last component of the path. Helper for find_drive_rootA.
- */
-static inline unsigned int remove_last_componentA( const char *path, unsigned int len )
-{
-    int level = 0;
-
-    while (level < 1)
-    {
-        /* find start of the last path component */
-        unsigned int prev = len;
-        if (prev <= 1) break;  /* reached root */
-        while (prev > 1 && path[prev - 1] != '/') prev--;
-        /* does removing it take us up a level? */
-        if (len - prev != 1 || path[prev] != '.')  /* not '.' */
-        {
-            if (len - prev == 2 && path[prev] == '.' && path[prev+1] == '.')  /* is it '..'? */
-                level--;
-            else
-                level++;
-        }
-        /* strip off trailing slashes */
-        while (prev > 1 && path[prev - 1] == '/') prev--;
-        len = prev;
-    }
-    return len;
-}
-
-
-/***********************************************************************
- *           find_drive_rootA
- *
- * Find a drive for which the root matches the beginning of the given path.
- * This can be used to translate a Unix path into a drive + DOS path.
- * Return value is the drive, or -1 on error. On success, ppath is modified
- * to point to the beginning of the DOS path.
- */
-static NTSTATUS find_drive_rootA( LPCSTR *ppath, unsigned int len, int *drive_ret )
-{
-    /* Starting with the full path, check if the device and inode match any of
-     * the wine 'drives'. If not then remove the last path component and try
-     * again. If the last component was a '..' then skip a normal component
-     * since it's a directory that's ascended back out of.
-     */
-    int drive;
-    char *buffer;
-    const char *path = *ppath;
-    struct stat st;
-    struct file_identity info[MAX_DOS_DRIVES];
-
-    /* get device and inode of all drives */
-    if (!get_drives_info( info )) return STATUS_OBJECT_PATH_NOT_FOUND;
-
-    /* strip off trailing slashes */
-    while (len > 1 && path[len - 1] == '/') len--;
-
-    /* make a copy of the path */
-    if (!(buffer = malloc( len + 1 ))) return STATUS_NO_MEMORY;
-    memcpy( buffer, path, len );
-    buffer[len] = 0;
-
-    for (;;)
-    {
-        if (!stat( buffer, &st ) && S_ISDIR( st.st_mode ))
-        {
-            /* Find the drive */
-            for (drive = 0; drive < MAX_DOS_DRIVES; drive++)
-            {
-                if ((info[drive].dev == st.st_dev) && (info[drive].ino == st.st_ino))
-                {
-                    if (len == 1) len = 0;  /* preserve root slash in returned path */
-                    TRACE( "%s -> drive %c:, root=%s, name=%s\n",
-                           debugstr_a(path), 'A' + drive, debugstr_a(buffer), debugstr_a(path + len));
-                    *ppath += len;
-                    *drive_ret = drive;
-                    free( buffer );
-                    return STATUS_SUCCESS;
-                }
-            }
-        }
-        if (len <= 1) break;  /* reached root */
-        len = remove_last_componentA( buffer, len );
-        buffer[len] = 0;
-    }
-    free( buffer );
-    return STATUS_OBJECT_PATH_NOT_FOUND;
-}
-
-
-/******************************************************************************
- *           find_file_id
- *
- * Recursively search directories from the dir queue for a given inode.
- */
-static NTSTATUS find_file_id( char **unix_name, ULONG *len, ULONGLONG file_id, dev_t dev )
-{
-    unsigned int pos;
-    DIR *dir;
-    struct dirent *de;
-    NTSTATUS status;
-    struct stat st;
-    char *name = *unix_name;
-
-    while (!(status = next_dir_in_queue( name )))
-    {
-        if (!(dir = opendir( name ))) continue;
-        TRACE( "searching %s for %s\n", debugstr_a(name), wine_dbgstr_longlong(file_id) );
-        pos = strlen( name );
-        if (pos + MAX_DIR_ENTRY_LEN >= *len / sizeof(WCHAR))
-        {
-            if (!(name = realloc( name, *len * 2 )))
-            {
-                closedir( dir );
-                return STATUS_NO_MEMORY;
-            }
-            *len *= 2;
-            *unix_name = name;
-        }
-        name[pos++] = '/';
-        while ((de = readdir( dir )))
-        {
-            if (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." )) continue;
-            strcpy( name + pos, de->d_name );
-            if (lstat( name, &st ) == -1) continue;
-            if (st.st_dev != dev) continue;
-            if (st.st_ino == file_id)
-            {
-                closedir( dir );
-                return STATUS_SUCCESS;
-            }
-            if (!S_ISDIR( st.st_mode )) continue;
-            if ((status = add_dir_to_queue( name )) != STATUS_SUCCESS)
-            {
-                closedir( dir );
-                return status;
-            }
-        }
-        closedir( dir );
-    }
-    return status;
-}
-
-
-/******************************************************************************
- *           file_id_to_unix_file_name
- *
- * Lookup a file from its file id instead of its name.
- */
-static NTSTATUS file_id_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **unix_name_ret )
-{
-    enum server_fd_type type;
-    int old_cwd, root_fd, needs_close;
-    char *unix_name;
-    ULONG len;
-    NTSTATUS status;
-    ULONGLONG file_id;
-    struct stat st, root_st;
-
-    if (attr->ObjectName->Length != sizeof(ULONGLONG)) return STATUS_OBJECT_PATH_SYNTAX_BAD;
-    if (!attr->RootDirectory) return STATUS_INVALID_PARAMETER;
-    memcpy( &file_id, attr->ObjectName->Buffer, sizeof(file_id) );
-
-    len = 2 * MAX_DIR_ENTRY_LEN + 4;
-    if (!(unix_name = malloc( len ))) return STATUS_NO_MEMORY;
-    strcpy( unix_name, "." );
-
-    if ((status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
-        goto done;
-
-    if (type != FD_TYPE_DIR)
-    {
-        status = STATUS_OBJECT_TYPE_MISMATCH;
-        goto done;
-    }
-
-    fstat( root_fd, &root_st );
-    if (root_st.st_ino == file_id)  /* shortcut for "." */
-    {
-        status = STATUS_SUCCESS;
-        goto done;
-    }
-
-    pthread_mutex_lock( &dir_mutex );
-    if ((old_cwd = open( ".", O_RDONLY )) != -1 && fchdir( root_fd ) != -1)
-    {
-        /* shortcut for ".." */
-        if (!stat( "..", &st ) && st.st_dev == root_st.st_dev && st.st_ino == file_id)
-        {
-            strcpy( unix_name, ".." );
-            status = STATUS_SUCCESS;
-        }
-        else
-        {
-            status = add_dir_to_queue( "." );
-            if (!status)
-                status = find_file_id( &unix_name, &len, file_id, root_st.st_dev );
-            if (!status)  /* get rid of "./" prefix */
-                memmove( unix_name, unix_name + 2, strlen(unix_name) - 1 );
-            flush_dir_queue();
-        }
-        if (fchdir( old_cwd ) == -1) chdir( "/" );
-    }
-    else status = errno_to_status( errno );
-    pthread_mutex_unlock( &dir_mutex );
-    if (old_cwd != -1) close( old_cwd );
-
-done:
-    if (status == STATUS_SUCCESS)
-    {
-        TRACE( "%s -> %s\n", wine_dbgstr_longlong(file_id), debugstr_a(unix_name) );
-        *unix_name_ret = unix_name;
-    }
-    else
-    {
-        TRACE( "%s not found in dir %p\n", wine_dbgstr_longlong(file_id), attr->RootDirectory );
-        free( unix_name );
-    }
-    if (needs_close) close( root_fd );
-    return status;
-}
-
-
-/******************************************************************************
- *           lookup_unix_name
- *
- * Helper for nt_to_unix_file_name
- */
-static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer, int unix_len, int pos,
-                                  UINT disposition, BOOLEAN check_case )
-{
-    NTSTATUS status;
-    int ret, len;
-    struct stat st;
-    char *unix_name = *buffer;
-#ifdef _WIN64
-    const BOOL redirect = FALSE;
-#else
-    const BOOL redirect = NtCurrentTeb64() && !NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR];
-#endif
-
-    /* try a shortcut first */
-
-    while (name_len && IS_SEPARATOR(*name))
-    {
-        name++;
-        name_len--;
-    }
-
-    unix_name[pos] = '/';
-    ret = ntdll_wcstoumbs( name, name_len, unix_name + pos + 1, unix_len - pos - 1, TRUE );
-    if (ret >= 0 && ret < unix_len - pos - 1)
-    {
-        char *p;
-        unix_name[pos + 1 + ret] = 0;
-        for (p = unix_name + pos ; *p; p++) if (*p == '\\') *p = '/';
-        if (!name_len || !redirect || (!strstr( unix_name, "/windows/") && strncmp( unix_name, "windows/", 8 )))
-        {
-            if (!stat( unix_name, &st ))
-            {
-                if (disposition == FILE_CREATE)
-                    return STATUS_OBJECT_NAME_COLLISION;
-                return STATUS_SUCCESS;
-            }
-        }
-    }
-
-    if (!name_len)  /* empty name -> drive root doesn't exist */
-        return STATUS_OBJECT_PATH_NOT_FOUND;
-    if (check_case && !redirect && (disposition == FILE_OPEN || disposition == FILE_OVERWRITE))
-        return STATUS_OBJECT_NAME_NOT_FOUND;
-
-    /* now do it component by component */
-
-    while (name_len)
-    {
-        const WCHAR *end, *next;
-        BOOLEAN is_win_dir = FALSE;
-
-        end = name;
-        while (end < name + name_len && !IS_SEPARATOR(*end)) end++;
-        next = end;
-        while (next < name + name_len && IS_SEPARATOR(*next)) next++;
-        name_len -= next - name;
-
-        /* grow the buffer if needed */
-
-        if (unix_len - pos < MAX_DIR_ENTRY_LEN + 2)
-        {
-            char *new_name;
-            unix_len += 2 * MAX_DIR_ENTRY_LEN;
-            if (!(new_name = realloc( unix_name, unix_len ))) return STATUS_NO_MEMORY;
-            unix_name = *buffer = new_name;
-        }
-
-        status = find_file_in_dir( unix_name, pos, name, end - name,
-                                   check_case, redirect ? &is_win_dir : NULL );
-
-        /* if this is the last element, not finding it is not necessarily fatal */
-        if (!name_len)
-        {
-            if (status == STATUS_OBJECT_PATH_NOT_FOUND)
-            {
-                status = STATUS_OBJECT_NAME_NOT_FOUND;
-                if (disposition != FILE_OPEN && disposition != FILE_OVERWRITE)
-                {
-                    ret = ntdll_wcstoumbs( name, end - name, unix_name + pos + 1, MAX_DIR_ENTRY_LEN + 1, TRUE );
-                    if (ret > 0 && ret <= MAX_DIR_ENTRY_LEN)
-                    {
-                        unix_name[pos] = '/';
-                        unix_name[pos + 1 + ret] = 0;
-                        status = STATUS_NO_SUCH_FILE;
-                        break;
-                    }
-                }
-            }
-            else if (status == STATUS_SUCCESS && disposition == FILE_CREATE)
-            {
-                status = STATUS_OBJECT_NAME_COLLISION;
-            }
-        }
-
-        if (status != STATUS_SUCCESS) break;
-
-        pos += strlen( unix_name + pos );
-        name = next;
-
-        if (is_win_dir && (len = get_redirect_path( unix_name, pos, name, name_len, check_case )))
-        {
-            name += len;
-            name_len -= len;
-            pos += strlen( unix_name + pos );
-            TRACE( "redirecting -> %s + %s\n", debugstr_a(unix_name), debugstr_w(name) );
-        }
-    }
-
-    return status;
-}
-
-
-/******************************************************************************
- *           nt_to_unix_file_name_attr
- */
-static NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, char **name_ret,
-                                           UINT disposition )
-{
-    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
-    enum server_fd_type type;
-    int old_cwd, root_fd, needs_close;
-    const WCHAR *name, *p;
-    char *unix_name;
-    int name_len, unix_len;
-    NTSTATUS status;
-
-    if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
-        return nt_to_unix_file_name( attr->ObjectName, name_ret, disposition );
-
-    name     = attr->ObjectName->Buffer;
-    name_len = attr->ObjectName->Length / sizeof(WCHAR);
-
-    if (name_len && IS_SEPARATOR(name[0])) return STATUS_INVALID_PARAMETER;
-
-    /* check for invalid characters */
-    for (p = name; p < name + name_len; p++)
-        if (*p < 32 || wcschr( invalid_charsW, *p )) return STATUS_OBJECT_NAME_INVALID;
-
-    unix_len = name_len * 3 + MAX_DIR_ENTRY_LEN + 3;
-    if (!(unix_name = malloc( unix_len ))) return STATUS_NO_MEMORY;
-    unix_name[0] = '.';
-
-    if (!(status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
-    {
-        if (type != FD_TYPE_DIR)
-        {
-            if (needs_close) close( root_fd );
-            status = STATUS_BAD_DEVICE_TYPE;
-        }
-        else
-        {
-            pthread_mutex_lock( &dir_mutex );
-            if ((old_cwd = open( ".", O_RDONLY )) != -1 && fchdir( root_fd ) != -1)
-            {
-                status = lookup_unix_name( name, name_len, &unix_name, unix_len, 1,
-                                           disposition, FALSE );
-                if (fchdir( old_cwd ) == -1) chdir( "/" );
-            }
-            else status = errno_to_status( errno );
-            pthread_mutex_unlock( &dir_mutex );
-            if (old_cwd != -1) close( old_cwd );
-            if (needs_close) close( root_fd );
-        }
-    }
-    else if (status == STATUS_OBJECT_TYPE_MISMATCH) status = STATUS_BAD_DEVICE_TYPE;
-
-    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
-    {
-        TRACE( "%s -> %s\n", debugstr_us(attr->ObjectName), debugstr_a(unix_name) );
-        *name_ret = unix_name;
-    }
-    else
-    {
-        TRACE( "%s not found in %s\n", debugstr_w(name), unix_name );
-        free( unix_name );
-    }
-    return status;
-}
-
-
-/******************************************************************************
- *           nt_to_unix_file_name
- *
- * Convert a file name from NT namespace to Unix namespace.
- *
- * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
- * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
- * returned, but the unix name is still filled in properly.
- */
-NTSTATUS nt_to_unix_file_name( const UNICODE_STRING *nameW, char **unix_name_ret, UINT disposition )
-{
-    static const WCHAR unixW[] = {'u','n','i','x'};
-    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
-
-    NTSTATUS status = STATUS_SUCCESS;
-    const WCHAR *name, *p;
-    struct stat st;
-    char *unix_name;
-    int pos, ret, name_len, unix_len, prefix_len;
-    WCHAR prefix[MAX_DIR_ENTRY_LEN + 1];
-    BOOLEAN check_case = FALSE;
-    BOOLEAN is_unix = FALSE;
-
-    name     = nameW->Buffer;
-    name_len = nameW->Length / sizeof(WCHAR);
-
-    if (!name_len || !IS_SEPARATOR(name[0])) return STATUS_OBJECT_PATH_SYNTAX_BAD;
-
-    if (!(pos = get_dos_prefix_len( nameW )))
-        return STATUS_BAD_DEVICE_TYPE;  /* no DOS prefix, assume NT native name */
-
-    name += pos;
-    name_len -= pos;
-
-    if (!name_len) return STATUS_OBJECT_NAME_INVALID;
-
-    /* check for sub-directory */
-    for (pos = 0; pos < name_len && pos <= MAX_DIR_ENTRY_LEN; pos++)
-    {
-        if (IS_SEPARATOR(name[pos])) break;
-        if (name[pos] < 32 || wcschr( invalid_charsW, name[pos] ))
-            return STATUS_OBJECT_NAME_INVALID;
-        prefix[pos] = (name[pos] >= 'A' && name[pos] <= 'Z') ? name[pos] + 'a' - 'A' : name[pos];
-    }
-    if (pos > MAX_DIR_ENTRY_LEN) return STATUS_OBJECT_NAME_INVALID;
-
-    if (pos == name_len)  /* no subdir, plain DOS device */
-        return get_dos_device( name, name_len, unix_name_ret );
-
-    prefix_len = pos;
-    prefix[prefix_len] = 0;
-
-    name += prefix_len;
-    name_len -= prefix_len;
-
-    /* check for invalid characters (all chars except 0 are valid for unix) */
-    is_unix = (prefix_len == 4 && !memcmp( prefix, unixW, sizeof(unixW) ));
-    if (is_unix)
-    {
-        for (p = name; p < name + name_len; p++)
-            if (!*p) return STATUS_OBJECT_NAME_INVALID;
-        check_case = TRUE;
-    }
-    else
-    {
-        for (p = name; p < name + name_len; p++)
-            if (*p < 32 || wcschr( invalid_charsW, *p )) return STATUS_OBJECT_NAME_INVALID;
-    }
-
-    unix_len = (prefix_len + name_len) * 3 + MAX_DIR_ENTRY_LEN + 3;
-    unix_len += strlen(config_dir) + sizeof("/dosdevices/");
-    if (!(unix_name = malloc( unix_len ))) return STATUS_NO_MEMORY;
-    strcpy( unix_name, config_dir );
-    strcat( unix_name, "/dosdevices/" );
-    pos = strlen(unix_name);
-
-    ret = ntdll_wcstoumbs( prefix, prefix_len, unix_name + pos, unix_len - pos - 1, TRUE );
-    if (ret <= 0)
-    {
-        free( unix_name );
-        return STATUS_OBJECT_NAME_INVALID;
-    }
-    pos += ret;
-
-    /* check if prefix exists (except for DOS drives to avoid extra stat calls) */
-
-    if (prefix_len != 2 || prefix[1] != ':')
-    {
-        unix_name[pos] = 0;
-        if (lstat( unix_name, &st ) == -1 && errno == ENOENT)
-        {
-            if (!is_unix)
-            {
-                free( unix_name );
-                return STATUS_BAD_DEVICE_TYPE;
-            }
-            pos = 0;  /* fall back to unix root */
-        }
-    }
-
-    status = lookup_unix_name( name, name_len, &unix_name, unix_len, pos, disposition, check_case );
-    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
-    {
-        TRACE( "%s -> %s\n", debugstr_us(nameW), debugstr_a(unix_name) );
-        *unix_name_ret = unix_name;
-    }
-    else
-    {
-        TRACE( "%s not found in %s\n", debugstr_w(name), unix_name );
-        free( unix_name );
-    }
-    return status;
-}
-
-
-/******************************************************************************
- *           wine_nt_to_unix_file_name
- *
- * Convert a file name from NT namespace to Unix namespace.
- *
- * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
- * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
- * returned, but the unix name is still filled in properly.
- */
-NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, char *nameA, SIZE_T *size,
-                                          UINT disposition )
-{
-    char *buffer = NULL;
-    NTSTATUS status = nt_to_unix_file_name( nameW, &buffer, disposition );
-
-    if (buffer)
-    {
-        if (*size > strlen(buffer)) strcpy( nameA, buffer );
-        else status = STATUS_BUFFER_TOO_SMALL;
-        *size = strlen(buffer) + 1;
-        free( buffer );
-    }
-    return status;
-}
-
-
-/******************************************************************
- *           unix_to_nt_file_name
- */
-NTSTATUS unix_to_nt_file_name( const char *name, WCHAR **nt )
-{
-    static const WCHAR unix_prefixW[] = {'\\','?','?','\\','u','n','i','x',0};
-    WCHAR dos_prefixW[] = {'\\','?','?','\\','A',':','\\',0};
-    const WCHAR *prefix = unix_prefixW;
-    unsigned int lenW, lenA = strlen(name);
-    const char *path = name;
-    NTSTATUS status;
-    WCHAR *p, *buffer;
-    int drive;
-
-    status = find_drive_rootA( &path, lenA, &drive );
-    lenA -= path - name;
-
-    if (status == STATUS_SUCCESS)
-    {
-        while (lenA && path[0] == '/') { lenA--; path++; }
-        dos_prefixW[4] += drive;
-        prefix = dos_prefixW;
-    }
-    else if (status != STATUS_OBJECT_PATH_NOT_FOUND) return status;
-
-    lenW = wcslen( prefix );
-    if (!(buffer = malloc( (lenA + lenW + 1) * sizeof(WCHAR) ))) return STATUS_NO_MEMORY;
-    memcpy( buffer, prefix, lenW * sizeof(WCHAR) );
-    lenW += ntdll_umbstowcs( path, lenA, buffer + lenW, lenA );
-    buffer[lenW] = 0;
-    for (p = buffer; *p; p++) if (*p == '/') *p = '\\';
-    *nt = buffer;
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************
- *           wine_unix_to_nt_file_name
- */
-NTSTATUS CDECL wine_unix_to_nt_file_name( const char *name, WCHAR *buffer, SIZE_T *size )
-{
-    WCHAR *nt_name = NULL;
-    NTSTATUS status;
-
-    if (name[0] != '/') return STATUS_INVALID_PARAMETER;  /* relative paths are not supported */
-
-    status = unix_to_nt_file_name( name, &nt_name );
-    if (nt_name)
-    {
-        if (*size > wcslen(nt_name)) wcscpy( buffer, nt_name );
-        else status = STATUS_BUFFER_TOO_SMALL;
-        *size = wcslen(nt_name) + 1;
-        free( nt_name );
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *           unmount_device
- *
- * Unmount the specified device.
- */
-static NTSTATUS unmount_device( HANDLE handle )
-{
-    NTSTATUS status;
-    int unix_fd, needs_close;
-
-    if (!(status = server_get_unix_fd( handle, 0, &unix_fd, &needs_close, NULL, NULL )))
-    {
-        struct stat st;
-        char *mount_point = NULL;
-
-        if (fstat( unix_fd, &st ) == -1 || !is_valid_mounted_device( &st ))
-            status = STATUS_INVALID_PARAMETER;
-        else
-        {
-            if ((mount_point = get_device_mount_point( st.st_rdev )))
-            {
-#ifdef __APPLE__
-                static const char umount[] = "diskutil unmount >/dev/null 2>&1 ";
-#else
-                static const char umount[] = "umount >/dev/null 2>&1 ";
-#endif
-                char *cmd = malloc( strlen(mount_point)+sizeof(umount));
-                if (cmd)
-                {
-                    strcpy( cmd, umount );
-                    strcat( cmd, mount_point );
-                    system( cmd );
-                    free( cmd );
-#ifdef linux
-                    /* umount will fail to release the loop device since we still have
-                       a handle to it, so we release it here */
-                    if (major(st.st_rdev) == LOOP_MAJOR) ioctl( unix_fd, 0x4c01 /*LOOP_CLR_FD*/, 0 );
-#endif
-                }
-                free( mount_point );
-            }
-        }
-        if (needs_close) close( unix_fd );
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *           set_show_dot_files
- */
-void CDECL set_show_dot_files( BOOL enable )
-{
-    show_dot_files = enable;
-}
-
-
-/******************************************************************************
- *              open_unix_file
- *
- * Helper for NtCreateFile that takes a Unix path.
- */
-NTSTATUS open_unix_file( HANDLE *handle, const char *unix_name, ACCESS_MASK access,
-                         OBJECT_ATTRIBUTES *attr, ULONG attributes, ULONG sharing, ULONG disposition,
-                         ULONG options, void *ea_buffer, ULONG ea_length )
-{
-    static UNICODE_STRING empty_string;
-    struct object_attributes *objattr;
-    OBJECT_ATTRIBUTES unix_attr = *attr;
-    NTSTATUS status;
-    data_size_t len;
-
-    unix_attr.ObjectName = &empty_string;  /* we send the unix name instead */
-    if ((status = alloc_object_attributes( &unix_attr, &objattr, &len ))) return status;
-
-    SERVER_START_REQ( create_file )
-    {
-        req->access     = access;
-        req->sharing    = sharing;
-        req->create     = disposition;
-        req->options    = options;
-        req->attrs      = attributes;
-        wine_server_add_data( req, objattr, len );
-        wine_server_add_data( req, unix_name, strlen(unix_name) );
-        status = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    return status;
-}
-
-
-/******************************************************************************
- *              NtCreateFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateFile( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
-                              IO_STATUS_BLOCK *io, LARGE_INTEGER *alloc_size,
-                              ULONG attributes, ULONG sharing, ULONG disposition,
-                              ULONG options, void *ea_buffer, ULONG ea_length )
-{
-    char *unix_name;
-    BOOL created = FALSE;
-
-    TRACE( "handle=%p access=%08x name=%s objattr=%08x root=%p sec=%p io=%p alloc_size=%p "
-           "attr=%08x sharing=%08x disp=%d options=%08x ea=%p.0x%08x\n",
-           handle, access, debugstr_us(attr->ObjectName), attr->Attributes,
-           attr->RootDirectory, attr->SecurityDescriptor, io, alloc_size,
-           attributes, sharing, disposition, options, ea_buffer, ea_length );
-
-    if (!attr || !attr->ObjectName) return STATUS_INVALID_PARAMETER;
-
-    if (alloc_size) FIXME( "alloc_size not supported\n" );
-
-    if (options & FILE_OPEN_BY_FILE_ID)
-        io->u.Status = file_id_to_unix_file_name( attr, &unix_name );
-    else
-        io->u.Status = nt_to_unix_file_name_attr( attr, &unix_name, disposition );
-
-    if (io->u.Status == STATUS_BAD_DEVICE_TYPE)
-    {
-        SERVER_START_REQ( open_file_object )
-        {
-            req->access     = access;
-            req->attributes = attr->Attributes;
-            req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-            req->sharing    = sharing;
-            req->options    = options;
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-            io->u.Status = wine_server_call( req );
-            *handle = wine_server_ptr_handle( reply->handle );
-        }
-        SERVER_END_REQ;
-        if (io->u.Status == STATUS_SUCCESS) io->Information = FILE_OPENED;
-        return io->u.Status;
-    }
-
-    if (io->u.Status == STATUS_NO_SUCH_FILE && disposition != FILE_OPEN && disposition != FILE_OVERWRITE)
-    {
-        created = TRUE;
-        io->u.Status = STATUS_SUCCESS;
-    }
-
-    if (io->u.Status == STATUS_SUCCESS)
-    {
-        io->u.Status = open_unix_file( handle, unix_name, access, attr, attributes,
-                                       sharing, disposition, options, ea_buffer, ea_length );
-        free( unix_name );
-    }
-    else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
-
-    if (io->u.Status == STATUS_SUCCESS)
-    {
-        if (created) io->Information = FILE_CREATED;
-        else switch(disposition)
-        {
-        case FILE_SUPERSEDE:
-            io->Information = FILE_SUPERSEDED;
-            break;
-        case FILE_CREATE:
-            io->Information = FILE_CREATED;
-            break;
-        case FILE_OPEN:
-        case FILE_OPEN_IF:
-            io->Information = FILE_OPENED;
-            break;
-        case FILE_OVERWRITE:
-        case FILE_OVERWRITE_IF:
-            io->Information = FILE_OVERWRITTEN;
-            break;
-        }
-    }
-    else if (io->u.Status == STATUS_TOO_MANY_OPENED_FILES)
-    {
-        static int once;
-        if (!once++) ERR_(winediag)( "Too many open files, ulimit -n probably needs to be increased\n" );
-    }
-
-    return io->u.Status;
-}
-
-
-/******************************************************************************
- *              NtOpenFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenFile( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
-                            IO_STATUS_BLOCK *io, ULONG sharing, ULONG options )
-{
-    return NtCreateFile( handle, access, attr, io, NULL, 0, sharing, FILE_OPEN, options, NULL, 0 );
-}
-
-
-/******************************************************************************
- *		NtCreateMailslotFile    (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateMailslotFile( HANDLE *handle, ULONG access, OBJECT_ATTRIBUTES *attr,
-                                      IO_STATUS_BLOCK *io, ULONG options, ULONG quota, ULONG msg_size,
-                                      LARGE_INTEGER *timeout )
-{
-    NTSTATUS status;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    TRACE( "%p %08x %p %p %08x %08x %08x %p\n",
-           handle, access, attr, io, options, quota, msg_size, timeout );
-
-    if (!handle) return STATUS_ACCESS_VIOLATION;
-    if (!attr) return STATUS_INVALID_PARAMETER;
-
-    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
-
-    SERVER_START_REQ( create_mailslot )
-    {
-        req->access       = access;
-        req->max_msgsize  = msg_size;
-        req->read_timeout = timeout ? timeout->QuadPart : -1;
-        wine_server_add_data( req, objattr, len );
-        if (!(status = wine_server_call( req ))) *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return status;
-}
-
-
-/******************************************************************
- *		NtCreateNamedPipeFile    (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateNamedPipeFile( HANDLE *handle, ULONG access, OBJECT_ATTRIBUTES *attr,
-                                       IO_STATUS_BLOCK *io, ULONG sharing, ULONG dispo, ULONG options,
-                                       ULONG pipe_type, ULONG read_mode, ULONG completion_mode,
-                                       ULONG max_inst, ULONG inbound_quota, ULONG outbound_quota,
-                                       LARGE_INTEGER *timeout )
-{
-    NTSTATUS status;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if (!attr) return STATUS_INVALID_PARAMETER;
-
-    TRACE( "(%p %x %s %p %x %d %x %d %d %d %d %d %d %p)\n",
-           handle, access, debugstr_us(attr->ObjectName), io, sharing, dispo,
-           options, pipe_type, read_mode, completion_mode, max_inst, inbound_quota,
-           outbound_quota, timeout );
-
-    /* assume we only get relative timeout */
-    if (timeout->QuadPart > 0) FIXME( "Wrong time %s\n", wine_dbgstr_longlong(timeout->QuadPart) );
-
-    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
-
-    SERVER_START_REQ( create_named_pipe )
-    {
-        req->access  = access;
-        req->options = options;
-        req->sharing = sharing;
-        req->flags =
-            (pipe_type ? NAMED_PIPE_MESSAGE_STREAM_WRITE   : 0) |
-            (read_mode ? NAMED_PIPE_MESSAGE_STREAM_READ    : 0) |
-            (completion_mode ? NAMED_PIPE_NONBLOCKING_MODE : 0);
-        req->maxinstances = max_inst;
-        req->outsize = outbound_quota;
-        req->insize  = inbound_quota;
-        req->timeout = timeout->QuadPart;
-        wine_server_add_data( req, objattr, len );
-        if (!(status = wine_server_call( req ))) *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return status;
-}
-
-
-/******************************************************************
- *              NtDeleteFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtDeleteFile( OBJECT_ATTRIBUTES *attr )
-{
-    HANDLE handle;
-    NTSTATUS status;
-    IO_STATUS_BLOCK io;
-
-    status = NtCreateFile( &handle, GENERIC_READ | GENERIC_WRITE | DELETE, attr, &io, NULL, 0,
-                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN,
-                           FILE_DELETE_ON_CLOSE, NULL, 0 );
-    if (status == STATUS_SUCCESS) NtClose( handle );
-    return status;
-}
-
-
-/******************************************************************************
- *              NtQueryFullAttributesFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
-                                           FILE_NETWORK_OPEN_INFORMATION *info )
-{
-    char *unix_name;
-    NTSTATUS status;
-
-    if (!(status = nt_to_unix_file_name_attr( attr, &unix_name, FILE_OPEN )))
-    {
-        ULONG attributes;
-        struct stat st;
-
-        if (get_file_info( unix_name, &st, &attributes ) == -1)
-            status = errno_to_status( errno );
-        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
-            status = STATUS_INVALID_INFO_CLASS;
-        else
-        {
-            FILE_BASIC_INFORMATION basic;
-            FILE_STANDARD_INFORMATION std;
-
-            fill_file_info( &st, attributes, &basic, FileBasicInformation );
-            fill_file_info( &st, attributes, &std, FileStandardInformation );
-
-            info->CreationTime   = basic.CreationTime;
-            info->LastAccessTime = basic.LastAccessTime;
-            info->LastWriteTime  = basic.LastWriteTime;
-            info->ChangeTime     = basic.ChangeTime;
-            info->AllocationSize = std.AllocationSize;
-            info->EndOfFile      = std.EndOfFile;
-            info->FileAttributes = basic.FileAttributes;
-            if (is_hidden_file( attr->ObjectName )) info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
-        }
-        free( unix_name );
-    }
-    else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
-    return status;
-}
-
-
-/******************************************************************************
- *              NtQueryAttributesFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC_INFORMATION *info )
-{
-    char *unix_name;
-    NTSTATUS status;
-
-    if (!(status = nt_to_unix_file_name_attr( attr, &unix_name, FILE_OPEN )))
-    {
-        ULONG attributes;
-        struct stat st;
-
-        if (get_file_info( unix_name, &st, &attributes ) == -1)
-            status = errno_to_status( errno );
-        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
-            status = STATUS_INVALID_INFO_CLASS;
-        else
-        {
-            status = fill_file_info( &st, attributes, info, FileBasicInformation );
-            if (is_hidden_file( attr->ObjectName )) info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
-        }
-        free( unix_name );
-    }
-    else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
-    return status;
-}
-
-
-/******************************************************************************
- *              NtQueryInformationFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
-                                        void *ptr, LONG len, FILE_INFORMATION_CLASS class )
-{
-    static const size_t info_sizes[] =
-    {
-        0,
-        sizeof(FILE_DIRECTORY_INFORMATION),            /* FileDirectoryInformation */
-        sizeof(FILE_FULL_DIRECTORY_INFORMATION),       /* FileFullDirectoryInformation */
-        sizeof(FILE_BOTH_DIRECTORY_INFORMATION),       /* FileBothDirectoryInformation */
-        sizeof(FILE_BASIC_INFORMATION),                /* FileBasicInformation */
-        sizeof(FILE_STANDARD_INFORMATION),             /* FileStandardInformation */
-        sizeof(FILE_INTERNAL_INFORMATION),             /* FileInternalInformation */
-        sizeof(FILE_EA_INFORMATION),                   /* FileEaInformation */
-        0,                                             /* FileAccessInformation */
-        sizeof(FILE_NAME_INFORMATION),                 /* FileNameInformation */
-        sizeof(FILE_RENAME_INFORMATION)-sizeof(WCHAR), /* FileRenameInformation */
-        0,                                             /* FileLinkInformation */
-        sizeof(FILE_NAMES_INFORMATION)-sizeof(WCHAR),  /* FileNamesInformation */
-        sizeof(FILE_DISPOSITION_INFORMATION),          /* FileDispositionInformation */
-        sizeof(FILE_POSITION_INFORMATION),             /* FilePositionInformation */
-        sizeof(FILE_FULL_EA_INFORMATION),              /* FileFullEaInformation */
-        0,                                             /* FileModeInformation */
-        sizeof(FILE_ALIGNMENT_INFORMATION),            /* FileAlignmentInformation */
-        sizeof(FILE_ALL_INFORMATION),                  /* FileAllInformation */
-        sizeof(FILE_ALLOCATION_INFORMATION),           /* FileAllocationInformation */
-        sizeof(FILE_END_OF_FILE_INFORMATION),          /* FileEndOfFileInformation */
-        0,                                             /* FileAlternateNameInformation */
-        sizeof(FILE_STREAM_INFORMATION)-sizeof(WCHAR), /* FileStreamInformation */
-        sizeof(FILE_PIPE_INFORMATION),                 /* FilePipeInformation */
-        sizeof(FILE_PIPE_LOCAL_INFORMATION),           /* FilePipeLocalInformation */
-        0,                                             /* FilePipeRemoteInformation */
-        sizeof(FILE_MAILSLOT_QUERY_INFORMATION),       /* FileMailslotQueryInformation */
-        0,                                             /* FileMailslotSetInformation */
-        0,                                             /* FileCompressionInformation */
-        0,                                             /* FileObjectIdInformation */
-        0,                                             /* FileCompletionInformation */
-        0,                                             /* FileMoveClusterInformation */
-        0,                                             /* FileQuotaInformation */
-        0,                                             /* FileReparsePointInformation */
-        sizeof(FILE_NETWORK_OPEN_INFORMATION),         /* FileNetworkOpenInformation */
-        sizeof(FILE_ATTRIBUTE_TAG_INFORMATION),        /* FileAttributeTagInformation */
-        0,                                             /* FileTrackingInformation */
-        0,                                             /* FileIdBothDirectoryInformation */
-        0,                                             /* FileIdFullDirectoryInformation */
-        0,                                             /* FileValidDataLengthInformation */
-        0,                                             /* FileShortNameInformation */
-        0,                                             /* FileIoCompletionNotificationInformation, */
-        0,                                             /* FileIoStatusBlockRangeInformation */
-        0,                                             /* FileIoPriorityHintInformation */
-        0,                                             /* FileSfioReserveInformation */
-        0,                                             /* FileSfioVolumeInformation */
-        0,                                             /* FileHardLinkInformation */
-        0,                                             /* FileProcessIdsUsingFileInformation */
-        0,                                             /* FileNormalizedNameInformation */
-        0,                                             /* FileNetworkPhysicalNameInformation */
-        0,                                             /* FileIdGlobalTxDirectoryInformation */
-        0,                                             /* FileIsRemoteDeviceInformation */
-        0,                                             /* FileAttributeCacheInformation */
-        0,                                             /* FileNumaNodeInformation */
-        0,                                             /* FileStandardLinkInformation */
-        0,                                             /* FileRemoteProtocolInformation */
-        0,                                             /* FileRenameInformationBypassAccessCheck */
-        0,                                             /* FileLinkInformationBypassAccessCheck */
-        0,                                             /* FileVolumeNameInformation */
-        sizeof(FILE_ID_INFORMATION),                   /* FileIdInformation */
-        0,                                             /* FileIdExtdDirectoryInformation */
-        0,                                             /* FileReplaceCompletionInformation */
-        0,                                             /* FileHardLinkFullIdInformation */
-        0,                                             /* FileIdExtdBothDirectoryInformation */
-    };
-
-    struct stat st;
-    int fd, needs_close = FALSE;
-    ULONG attr;
-    unsigned int options;
-
-    TRACE( "(%p,%p,%p,0x%08x,0x%08x)\n", handle, io, ptr, len, class);
-
-    io->Information = 0;
-
-    if (class <= 0 || class >= FileMaximumInformation)
-        return io->u.Status = STATUS_INVALID_INFO_CLASS;
-    if (!info_sizes[class])
-        return server_get_file_info( handle, io, ptr, len, class );
-    if (len < info_sizes[class])
-        return io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
-
-    if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
-    {
-        if (io->u.Status != STATUS_BAD_DEVICE_TYPE) return io->u.Status;
-        return server_get_file_info( handle, io, ptr, len, class );
-    }
-
-    switch (class)
-    {
-    case FileBasicInformation:
-        if (fd_get_file_info( fd, options, &st, &attr ) == -1)
-            io->u.Status = errno_to_status( errno );
-        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
-            io->u.Status = STATUS_INVALID_INFO_CLASS;
-        else
-            fill_file_info( &st, attr, ptr, class );
-        break;
-    case FileStandardInformation:
-        {
-            FILE_STANDARD_INFORMATION *info = ptr;
-
-            if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = errno_to_status( errno );
-            else
-            {
-                fill_file_info( &st, attr, info, class );
-                info->DeletePending = FALSE; /* FIXME */
-            }
-        }
-        break;
-    case FilePositionInformation:
-        {
-            FILE_POSITION_INFORMATION *info = ptr;
-            off_t res = lseek( fd, 0, SEEK_CUR );
-            if (res == (off_t)-1) io->u.Status = errno_to_status( errno );
-            else info->CurrentByteOffset.QuadPart = res;
-        }
-        break;
-    case FileInternalInformation:
-        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = errno_to_status( errno );
-        else fill_file_info( &st, attr, ptr, class );
-        break;
-    case FileEaInformation:
-        {
-            FILE_EA_INFORMATION *info = ptr;
-            info->EaSize = 0;
-        }
-        break;
-    case FileEndOfFileInformation:
-        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = errno_to_status( errno );
-        else fill_file_info( &st, attr, ptr, class );
-        break;
-    case FileAllInformation:
-        {
-            FILE_ALL_INFORMATION *info = ptr;
-            char *unix_name;
-
-            if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = errno_to_status( errno );
-            else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
-                io->u.Status = STATUS_INVALID_INFO_CLASS;
-            else if (!(io->u.Status = server_get_unix_name( handle, &unix_name )))
-            {
-                LONG name_len = len - FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName);
-
-                fill_file_info( &st, attr, info, FileAllInformation );
-                info->StandardInformation.DeletePending = FALSE; /* FIXME */
-                info->EaInformation.EaSize = 0;
-                info->AccessInformation.AccessFlags = 0;  /* FIXME */
-                info->PositionInformation.CurrentByteOffset.QuadPart = lseek( fd, 0, SEEK_CUR );
-                info->ModeInformation.Mode = 0;  /* FIXME */
-                info->AlignmentInformation.AlignmentRequirement = 1;  /* FIXME */
-
-                io->u.Status = fill_name_info( unix_name, &info->NameInformation, &name_len );
-                free( unix_name );
-                io->Information = FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName) + name_len;
-            }
-        }
-        break;
-    case FileMailslotQueryInformation:
-        {
-            FILE_MAILSLOT_QUERY_INFORMATION *info = ptr;
-
-            SERVER_START_REQ( set_mailslot_info )
-            {
-                req->handle = wine_server_obj_handle( handle );
-                req->flags = 0;
-                io->u.Status = wine_server_call( req );
-                if( io->u.Status == STATUS_SUCCESS )
-                {
-                    info->MaximumMessageSize = reply->max_msgsize;
-                    info->MailslotQuota = 0;
-                    info->NextMessageSize = 0;
-                    info->MessagesAvailable = 0;
-                    info->ReadTimeout.QuadPart = reply->read_timeout;
-                }
-            }
-            SERVER_END_REQ;
-            if (!io->u.Status)
-            {
-                char *tmpbuf;
-                ULONG size = info->MaximumMessageSize ? info->MaximumMessageSize : 0x10000;
-                if (size > 0x10000) size = 0x10000;
-                if ((tmpbuf = malloc( size )))
-                {
-                    if (!server_get_unix_fd( handle, FILE_READ_DATA, &fd, &needs_close, NULL, NULL ))
-                    {
-                        int res = recv( fd, tmpbuf, size, MSG_PEEK );
-                        info->MessagesAvailable = (res > 0);
-                        info->NextMessageSize = (res >= 0) ? res : MAILSLOT_NO_MESSAGE;
-                        if (needs_close) close( fd );
-                    }
-                    free( tmpbuf );
-                }
-            }
-        }
-        break;
-    case FileNameInformation:
-        {
-            FILE_NAME_INFORMATION *info = ptr;
-            char *unix_name;
-
-            if (!(io->u.Status = server_get_unix_name( handle, &unix_name )))
-            {
-                LONG name_len = len - FIELD_OFFSET(FILE_NAME_INFORMATION, FileName);
-                io->u.Status = fill_name_info( unix_name, info, &name_len );
-                free( unix_name );
-                io->Information = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) + name_len;
-            }
-        }
-        break;
-    case FileNetworkOpenInformation:
-        {
-            FILE_NETWORK_OPEN_INFORMATION *info = ptr;
-            char *unix_name;
-
-            if (!(io->u.Status = server_get_unix_name( handle, &unix_name )))
-            {
-                ULONG attributes;
-                struct stat st;
-
-                if (get_file_info( unix_name, &st, &attributes ) == -1)
-                    io->u.Status = errno_to_status( errno );
-                else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
-                    io->u.Status = STATUS_INVALID_INFO_CLASS;
-                else
-                {
-                    FILE_BASIC_INFORMATION basic;
-                    FILE_STANDARD_INFORMATION std;
-
-                    fill_file_info( &st, attributes, &basic, FileBasicInformation );
-                    fill_file_info( &st, attributes, &std, FileStandardInformation );
-
-                    info->CreationTime   = basic.CreationTime;
-                    info->LastAccessTime = basic.LastAccessTime;
-                    info->LastWriteTime  = basic.LastWriteTime;
-                    info->ChangeTime     = basic.ChangeTime;
-                    info->AllocationSize = std.AllocationSize;
-                    info->EndOfFile      = std.EndOfFile;
-                    info->FileAttributes = basic.FileAttributes;
-                }
-                free( unix_name );
-            }
-        }
-        break;
-    case FileIdInformation:
-        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = errno_to_status( errno );
-        else
-        {
-            struct mountmgr_unix_drive drive;
-            FILE_ID_INFORMATION *info = ptr;
-
-            info->VolumeSerialNumber = 0;
-            if (!(io->u.Status = get_mountmgr_fs_info( handle, fd, &drive, sizeof(drive) )))
-                info->VolumeSerialNumber = drive.serial;
-            memset( &info->FileId, 0, sizeof(info->FileId) );
-            *(ULONGLONG *)&info->FileId = st.st_ino;
-        }
-        break;
-    case FileAttributeTagInformation:
-        if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = errno_to_status( errno );
-        else
-        {
-            FILE_ATTRIBUTE_TAG_INFORMATION *info = ptr;
-            info->FileAttributes = attr;
-            info->ReparseTag = 0; /* FIXME */
-            if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, &st ))
-                info->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
-        }
-        break;
-    default:
-        FIXME("Unsupported class (%d)\n", class);
-        io->u.Status = STATUS_NOT_IMPLEMENTED;
-        break;
-    }
-    if (needs_close) close( fd );
-    if (io->u.Status == STATUS_SUCCESS && !io->Information) io->Information = info_sizes[class];
-    return io->u.Status;
-}
-
-
-/******************************************************************************
- *              NtSetInformationFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
-                                      void *ptr, ULONG len, FILE_INFORMATION_CLASS class )
-{
-    int fd, needs_close;
-
-    TRACE( "(%p,%p,%p,0x%08x,0x%08x)\n", handle, io, ptr, len, class );
-
-    io->u.Status = STATUS_SUCCESS;
-    switch (class)
-    {
-    case FileBasicInformation:
-        if (len >= sizeof(FILE_BASIC_INFORMATION))
-        {
-            struct stat st;
-            const FILE_BASIC_INFORMATION *info = ptr;
-            LARGE_INTEGER mtime, atime;
-
-            if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
-                return io->u.Status;
-
-            mtime.QuadPart = info->LastWriteTime.QuadPart == -1 ? 0 : info->LastWriteTime.QuadPart;
-            atime.QuadPart = info->LastAccessTime.QuadPart == -1 ? 0 : info->LastAccessTime.QuadPart;
-
-            if (atime.QuadPart || mtime.QuadPart)
-                io->u.Status = set_file_times( fd, &mtime, &atime );
-
-            if (io->u.Status == STATUS_SUCCESS && info->FileAttributes)
-            {
-                if (fstat( fd, &st ) == -1) io->u.Status = errno_to_status( errno );
-                else
-                {
-                    if (info->FileAttributes & FILE_ATTRIBUTE_READONLY)
-                    {
-                        if (S_ISDIR( st.st_mode))
-                            WARN("FILE_ATTRIBUTE_READONLY ignored for directory.\n");
-                        else
-                            st.st_mode &= ~0222; /* clear write permission bits */
-                    }
-                    else
-                    {
-                        /* add write permission only where we already have read permission */
-                        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~start_umask);
-                    }
-                    if (fchmod( fd, st.st_mode ) == -1) io->u.Status = errno_to_status( errno );
-                }
-            }
-
-            if (needs_close) close( fd );
-        }
-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FilePositionInformation:
-        if (len >= sizeof(FILE_POSITION_INFORMATION))
-        {
-            const FILE_POSITION_INFORMATION *info = ptr;
-
-            if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
-                return io->u.Status;
-
-            if (lseek( fd, info->CurrentByteOffset.QuadPart, SEEK_SET ) == (off_t)-1)
-                io->u.Status = errno_to_status( errno );
-
-            if (needs_close) close( fd );
-        }
-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FileEndOfFileInformation:
-        if (len >= sizeof(FILE_END_OF_FILE_INFORMATION))
-        {
-            struct stat st;
-            const FILE_END_OF_FILE_INFORMATION *info = ptr;
-
-            if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
-                return io->u.Status;
-
-            /* first try normal truncate */
-            if (ftruncate( fd, (off_t)info->EndOfFile.QuadPart ) != -1) break;
-
-            /* now check for the need to extend the file */
-            if (fstat( fd, &st ) != -1 && (off_t)info->EndOfFile.QuadPart > st.st_size)
-            {
-                static const char zero;
-
-                /* extend the file one byte beyond the requested size and then truncate it */
-                /* this should work around ftruncate implementations that can't extend files */
-                if (pwrite( fd, &zero, 1, (off_t)info->EndOfFile.QuadPart ) != -1 &&
-                    ftruncate( fd, (off_t)info->EndOfFile.QuadPart ) != -1) break;
-            }
-            io->u.Status = errno_to_status( errno );
-
-            if (needs_close) close( fd );
-        }
-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FilePipeInformation:
-        if (len >= sizeof(FILE_PIPE_INFORMATION))
-        {
-            FILE_PIPE_INFORMATION *info = ptr;
-
-            if ((info->CompletionMode | info->ReadMode) & ~1)
-            {
-                io->u.Status = STATUS_INVALID_PARAMETER;
-                break;
-            }
-
-            SERVER_START_REQ( set_named_pipe_info )
-            {
-                req->handle = wine_server_obj_handle( handle );
-                req->flags  = (info->CompletionMode ? NAMED_PIPE_NONBLOCKING_MODE    : 0) |
-                              (info->ReadMode       ? NAMED_PIPE_MESSAGE_STREAM_READ : 0);
-                io->u.Status = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-        }
-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FileMailslotSetInformation:
-        {
-            FILE_MAILSLOT_SET_INFORMATION *info = ptr;
-
-            SERVER_START_REQ( set_mailslot_info )
-            {
-                req->handle = wine_server_obj_handle( handle );
-                req->flags = MAILSLOT_SET_READ_TIMEOUT;
-                req->read_timeout = info->ReadTimeout.QuadPart;
-                io->u.Status = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-        }
-        break;
-
-    case FileCompletionInformation:
-        if (len >= sizeof(FILE_COMPLETION_INFORMATION))
-        {
-            FILE_COMPLETION_INFORMATION *info = ptr;
-
-            SERVER_START_REQ( set_completion_info )
-            {
-                req->handle   = wine_server_obj_handle( handle );
-                req->chandle  = wine_server_obj_handle( info->CompletionPort );
-                req->ckey     = info->CompletionKey;
-                io->u.Status  = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-        } else
-            io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FileIoCompletionNotificationInformation:
-        if (len >= sizeof(FILE_IO_COMPLETION_NOTIFICATION_INFORMATION))
-        {
-            FILE_IO_COMPLETION_NOTIFICATION_INFORMATION *info = ptr;
-
-            if (info->Flags & FILE_SKIP_SET_USER_EVENT_ON_FAST_IO)
-                FIXME( "FILE_SKIP_SET_USER_EVENT_ON_FAST_IO not supported\n" );
-
-            SERVER_START_REQ( set_fd_completion_mode )
-            {
-                req->handle   = wine_server_obj_handle( handle );
-                req->flags    = info->Flags;
-                io->u.Status  = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-        } else
-            io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case FileIoPriorityHintInformation:
-        if (len >= sizeof(FILE_IO_PRIORITY_HINT_INFO))
-        {
-            FILE_IO_PRIORITY_HINT_INFO *info = ptr;
-            if (info->PriorityHint < MaximumIoPriorityHintType)
-                TRACE( "ignoring FileIoPriorityHintInformation %u\n", info->PriorityHint );
-            else
-                io->u.Status = STATUS_INVALID_PARAMETER;
-        }
-        else io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case FileAllInformation:
-        io->u.Status = STATUS_INVALID_INFO_CLASS;
-        break;
-
-    case FileValidDataLengthInformation:
-        if (len >= sizeof(FILE_VALID_DATA_LENGTH_INFORMATION))
-        {
-            struct stat st;
-            const FILE_VALID_DATA_LENGTH_INFORMATION *info = ptr;
-
-            if ((io->u.Status = server_get_unix_fd( handle, FILE_WRITE_DATA, &fd, &needs_close, NULL, NULL )))
-                return io->u.Status;
-
-            if (fstat( fd, &st ) == -1) io->u.Status = errno_to_status( errno );
-            else if (info->ValidDataLength.QuadPart <= 0 || (off_t)info->ValidDataLength.QuadPart > st.st_size)
-                io->u.Status = STATUS_INVALID_PARAMETER;
-            else
-            {
-#ifdef HAVE_FALLOCATE
-                if (fallocate( fd, 0, 0, (off_t)info->ValidDataLength.QuadPart ) == -1)
-                {
-                    NTSTATUS status = errno_to_status( errno );
-                    if (status == STATUS_NOT_SUPPORTED) WARN( "fallocate not supported on this filesystem\n" );
-                    else io->u.Status = status;
-                }
-#else
-                FIXME( "setting valid data length not supported\n" );
-#endif
-            }
-            if (needs_close) close( fd );
-        }
-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FileDispositionInformation:
-        if (len >= sizeof(FILE_DISPOSITION_INFORMATION))
-        {
-            FILE_DISPOSITION_INFORMATION *info = ptr;
-
-            SERVER_START_REQ( set_fd_disp_info )
-            {
-                req->handle   = wine_server_obj_handle( handle );
-                req->unlink   = info->DoDeleteFile;
-                io->u.Status  = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-        } else
-            io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FileRenameInformation:
-        if (len >= sizeof(FILE_RENAME_INFORMATION))
-        {
-            FILE_RENAME_INFORMATION *info = ptr;
-            UNICODE_STRING name_str;
-            OBJECT_ATTRIBUTES attr;
-            char *unix_name;
-
-            name_str.Buffer = info->FileName;
-            name_str.Length = info->FileNameLength;
-            name_str.MaximumLength = info->FileNameLength + sizeof(WCHAR);
-
-            attr.Length = sizeof(attr);
-            attr.ObjectName = &name_str;
-            attr.RootDirectory = info->RootDirectory;
-            attr.Attributes = OBJ_CASE_INSENSITIVE;
-
-            io->u.Status = nt_to_unix_file_name_attr( &attr, &unix_name, FILE_OPEN_IF );
-            if (io->u.Status != STATUS_SUCCESS && io->u.Status != STATUS_NO_SUCH_FILE)
-                break;
-
-            SERVER_START_REQ( set_fd_name_info )
-            {
-                req->handle   = wine_server_obj_handle( handle );
-                req->rootdir  = wine_server_obj_handle( attr.RootDirectory );
-                req->link     = FALSE;
-                req->replace  = info->ReplaceIfExists;
-                wine_server_add_data( req, unix_name, strlen(unix_name) );
-                io->u.Status = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-
-            free( unix_name );
-        }
-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    case FileLinkInformation:
-        if (len >= sizeof(FILE_LINK_INFORMATION))
-        {
-            FILE_LINK_INFORMATION *info = ptr;
-            UNICODE_STRING name_str;
-            OBJECT_ATTRIBUTES attr;
-            char *unix_name;
-
-            name_str.Buffer = info->FileName;
-            name_str.Length = info->FileNameLength;
-            name_str.MaximumLength = info->FileNameLength + sizeof(WCHAR);
-
-            attr.Length = sizeof(attr);
-            attr.ObjectName = &name_str;
-            attr.RootDirectory = info->RootDirectory;
-            attr.Attributes = OBJ_CASE_INSENSITIVE;
-
-            io->u.Status = nt_to_unix_file_name_attr( &attr, &unix_name, FILE_OPEN_IF );
-            if (io->u.Status != STATUS_SUCCESS && io->u.Status != STATUS_NO_SUCH_FILE)
-                break;
-
-            SERVER_START_REQ( set_fd_name_info )
-            {
-                req->handle   = wine_server_obj_handle( handle );
-                req->rootdir  = wine_server_obj_handle( attr.RootDirectory );
-                req->link     = TRUE;
-                req->replace  = info->ReplaceIfExists;
-                wine_server_add_data( req, unix_name, strlen(unix_name) );
-                io->u.Status  = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-
-            free( unix_name );
-        }
-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
-        break;
-
-    default:
-        FIXME("Unsupported class (%d)\n", class);
-        io->u.Status = STATUS_NOT_IMPLEMENTED;
-        break;
-    }
-    io->Information = 0;
-    return io->u.Status;
-}
-
-
-/***********************************************************************
- *                  Asynchronous file I/O                              *
- */
-
-typedef NTSTATUS async_callback_t( void *user, IO_STATUS_BLOCK *io, NTSTATUS status );
-
-struct async_fileio
-{
-    async_callback_t    *callback; /* must be the first field */
-    struct async_fileio *next;
-    HANDLE               handle;
-};
-
-struct async_fileio_read
-{
-    struct async_fileio io;
-    char               *buffer;
-    unsigned int        already;
-    unsigned int        count;
-    BOOL                avail_mode;
-};
-
-struct async_fileio_write
-{
-    struct async_fileio io;
-    const char         *buffer;
-    unsigned int        already;
-    unsigned int        count;
-};
-
-struct async_fileio_read_changes
-{
-    struct async_fileio io;
-    void               *buffer;
-    ULONG               buffer_size;
-    ULONG               data_size;
-    char                data[1];
-};
-
-struct async_irp
-{
-    struct async_fileio io;
-    void               *buffer;   /* buffer for output */
-    ULONG               size;     /* size of buffer */
-};
-
-static struct async_fileio *fileio_freelist;
-
-static void release_fileio( struct async_fileio *io )
-{
-    for (;;)
-    {
-        struct async_fileio *next = fileio_freelist;
-        io->next = next;
-        if (InterlockedCompareExchangePointer( (void **)&fileio_freelist, io, next ) == next) return;
-    }
-}
-
-static struct async_fileio *alloc_fileio( DWORD size, async_callback_t callback, HANDLE handle )
-{
-    /* first free remaining previous fileinfos */
-    struct async_fileio *io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
-
-    while (io)
-    {
-        struct async_fileio *next = io->next;
-        free( io );
-        io = next;
-    }
-
-    if ((io = malloc( size )))
-    {
-        io->callback = callback;
-        io->handle   = handle;
-    }
-    return io;
-}
-
-static async_data_t server_async( HANDLE handle, struct async_fileio *user, HANDLE event,
-                                  PIO_APC_ROUTINE apc, void *apc_context, IO_STATUS_BLOCK *io )
-{
-    async_data_t async;
-    async.handle      = wine_server_obj_handle( handle );
-    async.user        = wine_server_client_ptr( user );
-    async.iosb        = wine_server_client_ptr( io );
-    async.event       = wine_server_obj_handle( event );
-    async.apc         = wine_server_client_ptr( apc );
-    async.apc_context = wine_server_client_ptr( apc_context );
-    return async;
-}
-
-static NTSTATUS wait_async( HANDLE handle, BOOL alertable, IO_STATUS_BLOCK *io )
-{
-    if (NtWaitForSingleObject( handle, alertable, NULL )) return STATUS_PENDING;
-    return io->u.Status;
-}
-
-/* callback for irp async I/O completion */
-static NTSTATUS irp_completion( void *user, IO_STATUS_BLOCK *io, NTSTATUS status )
-{
-    struct async_irp *async = user;
-    ULONG information = 0;
-
-    if (status == STATUS_ALERTED)
-    {
-        SERVER_START_REQ( get_async_result )
-        {
-            req->user_arg = wine_server_client_ptr( async );
-            wine_server_set_reply( req, async->buffer, async->size );
-            status = virtual_locked_server_call( req );
-            information = reply->size;
-        }
-        SERVER_END_REQ;
-    }
-    if (status != STATUS_PENDING)
-    {
-        io->u.Status = status;
-        io->Information = information;
-        release_fileio( &async->io );
-    }
-    return status;
-}
-
-static NTSTATUS async_read_proc( void *user, IO_STATUS_BLOCK *iosb, NTSTATUS status )
-{
-    struct async_fileio_read *fileio = user;
-    int fd, needs_close, result;
-
-    switch (status)
-    {
-    case STATUS_ALERTED: /* got some new data */
-        /* check to see if the data is ready (non-blocking) */
-        if ((status = server_get_unix_fd( fileio->io.handle, FILE_READ_DATA, &fd,
-                                          &needs_close, NULL, NULL )))
-            break;
-
-        result = virtual_locked_read(fd, &fileio->buffer[fileio->already], fileio->count-fileio->already);
-        if (needs_close) close( fd );
-
-        if (result < 0)
-        {
-            if (errno == EAGAIN || errno == EINTR)
-                status = STATUS_PENDING;
-            else /* check to see if the transfer is complete */
-                status = errno_to_status( errno );
-        }
-        else if (result == 0)
-        {
-            status = fileio->already ? STATUS_SUCCESS : STATUS_PIPE_BROKEN;
-        }
-        else
-        {
-            fileio->already += result;
-            if (fileio->already >= fileio->count || fileio->avail_mode)
-                status = STATUS_SUCCESS;
-            else
-                status = STATUS_PENDING;
-        }
-        break;
-
-    case STATUS_TIMEOUT:
-    case STATUS_IO_TIMEOUT:
-        if (fileio->already) status = STATUS_SUCCESS;
-        break;
-    }
-    if (status != STATUS_PENDING)
-    {
-        iosb->u.Status = status;
-        iosb->Information = fileio->already;
-        release_fileio( &fileio->io );
-    }
-    return status;
-}
-
-static NTSTATUS async_write_proc( void *user, IO_STATUS_BLOCK *iosb, NTSTATUS status )
-{
-    struct async_fileio_write *fileio = user;
-    int result, fd, needs_close;
-    enum server_fd_type type;
-
-    switch (status)
-    {
-    case STATUS_ALERTED:
-        /* write some data (non-blocking) */
-        if ((status = server_get_unix_fd( fileio->io.handle, FILE_WRITE_DATA, &fd,
-                                          &needs_close, &type, NULL )))
-            break;
-
-        if (!fileio->count && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_SOCKET))
-            result = send( fd, fileio->buffer, 0, 0 );
-        else
-            result = write( fd, &fileio->buffer[fileio->already], fileio->count - fileio->already );
-
-        if (needs_close) close( fd );
-
-        if (result < 0)
-        {
-            if (errno == EAGAIN || errno == EINTR) status = STATUS_PENDING;
-            else status = errno_to_status( errno );
-        }
-        else
-        {
-            fileio->already += result;
-            status = (fileio->already < fileio->count) ? STATUS_PENDING : STATUS_SUCCESS;
-        }
-        break;
-
-    case STATUS_TIMEOUT:
-    case STATUS_IO_TIMEOUT:
-        if (fileio->already) status = STATUS_SUCCESS;
-        break;
-    }
-    if (status != STATUS_PENDING)
-    {
-        iosb->u.Status = status;
-        iosb->Information = fileio->already;
-        release_fileio( &fileio->io );
-    }
-    return status;
-}
-
-/* do a read call through the server */
-static NTSTATUS server_read_file( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
-                                  IO_STATUS_BLOCK *io, void *buffer, ULONG size,
-                                  LARGE_INTEGER *offset, ULONG *key )
-{
-    struct async_irp *async;
-    NTSTATUS status;
-    HANDLE wait_handle;
-    ULONG options;
-
-    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
-        return STATUS_NO_MEMORY;
-
-    async->buffer  = buffer;
-    async->size    = size;
-
-    SERVER_START_REQ( read )
-    {
-        req->async = server_async( handle, &async->io, event, apc, apc_context, io );
-        req->pos   = offset ? offset->QuadPart : 0;
-        wine_server_set_reply( req, buffer, size );
-        status = virtual_locked_server_call( req );
-        wait_handle = wine_server_ptr_handle( reply->wait );
-        options     = reply->options;
-        if (wait_handle && status != STATUS_PENDING)
-        {
-            io->u.Status    = status;
-            io->Information = wine_server_reply_size( reply );
-        }
-    }
-    SERVER_END_REQ;
-
-    if (status != STATUS_PENDING) free( async );
-
-    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT), io );
-    return status;
-}
-
-/* do a write call through the server */
-static NTSTATUS server_write_file( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
-                                   IO_STATUS_BLOCK *io, const void *buffer, ULONG size,
-                                   LARGE_INTEGER *offset, ULONG *key )
-{
-    struct async_irp *async;
-    NTSTATUS status;
-    HANDLE wait_handle;
-    ULONG options;
-
-    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
-        return STATUS_NO_MEMORY;
-
-    async->buffer  = NULL;
-    async->size    = 0;
-
-    SERVER_START_REQ( write )
-    {
-        req->async = server_async( handle, &async->io, event, apc, apc_context, io );
-        req->pos   = offset ? offset->QuadPart : 0;
-        wine_server_add_data( req, buffer, size );
-        status = wine_server_call( req );
-        wait_handle = wine_server_ptr_handle( reply->wait );
-        options     = reply->options;
-        if (wait_handle && status != STATUS_PENDING)
-        {
-            io->u.Status    = status;
-            io->Information = reply->size;
-        }
-    }
-    SERVER_END_REQ;
-
-    if (status != STATUS_PENDING) free( async );
-
-    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT), io );
-    return status;
-}
-
-/* do an ioctl call through the server */
-static NTSTATUS server_ioctl_file( HANDLE handle, HANDLE event,
-                                   PIO_APC_ROUTINE apc, PVOID apc_context,
-                                   IO_STATUS_BLOCK *io, ULONG code,
-                                   const void *in_buffer, ULONG in_size,
-                                   PVOID out_buffer, ULONG out_size )
-{
-    struct async_irp *async;
-    NTSTATUS status;
-    HANDLE wait_handle;
-    ULONG options;
-
-    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
-        return STATUS_NO_MEMORY;
-    async->buffer  = out_buffer;
-    async->size    = out_size;
-
-    SERVER_START_REQ( ioctl )
-    {
-        req->code        = code;
-        req->async       = server_async( handle, &async->io, event, apc, apc_context, io );
-        wine_server_add_data( req, in_buffer, in_size );
-        if ((code & 3) != METHOD_BUFFERED) wine_server_add_data( req, out_buffer, out_size );
-        wine_server_set_reply( req, out_buffer, out_size );
-        status = virtual_locked_server_call( req );
-        wait_handle = wine_server_ptr_handle( reply->wait );
-        options     = reply->options;
-        if (wait_handle && status != STATUS_PENDING)
-        {
-            io->u.Status    = status;
-            io->Information = wine_server_reply_size( reply );
-        }
-    }
-    SERVER_END_REQ;
-
-    if (status == STATUS_NOT_SUPPORTED)
-        WARN("Unsupported ioctl %x (device=%x access=%x func=%x method=%x)\n",
-             code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
-
-    if (status != STATUS_PENDING) free( async );
-
-    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT), io );
-    return status;
-}
-
-
-struct io_timeouts
-{
-    int interval;   /* max interval between two bytes */
-    int total;      /* total timeout for the whole operation */
-    int end_time;   /* absolute time of end of operation */
-};
-
-/* retrieve the I/O timeouts to use for a given handle */
-static NTSTATUS get_io_timeouts( HANDLE handle, enum server_fd_type type, ULONG count, BOOL is_read,
-                                 struct io_timeouts *timeouts )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-
-    timeouts->interval = timeouts->total = -1;
-
-    switch(type)
-    {
-    case FD_TYPE_SERIAL:
-    {
-        /* GetCommTimeouts */
-        SERIAL_TIMEOUTS st;
-        IO_STATUS_BLOCK io;
-
-        status = NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io,
-                                        IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) );
-        if (status) break;
-
-        if (is_read)
-        {
-            if (st.ReadIntervalTimeout)
-                timeouts->interval = st.ReadIntervalTimeout;
-
-            if (st.ReadTotalTimeoutMultiplier || st.ReadTotalTimeoutConstant)
-            {
-                timeouts->total = st.ReadTotalTimeoutConstant;
-                if (st.ReadTotalTimeoutMultiplier != MAXDWORD)
-                    timeouts->total += count * st.ReadTotalTimeoutMultiplier;
-            }
-            else if (st.ReadIntervalTimeout == MAXDWORD)
-                timeouts->interval = timeouts->total = 0;
-        }
-        else  /* write */
-        {
-            if (st.WriteTotalTimeoutMultiplier || st.WriteTotalTimeoutConstant)
-            {
-                timeouts->total = st.WriteTotalTimeoutConstant;
-                if (st.WriteTotalTimeoutMultiplier != MAXDWORD)
-                    timeouts->total += count * st.WriteTotalTimeoutMultiplier;
-            }
-        }
-        break;
-    }
-    case FD_TYPE_MAILSLOT:
-        if (is_read)
-        {
-            timeouts->interval = 0;  /* return as soon as we got something */
-            SERVER_START_REQ( set_mailslot_info )
-            {
-                req->handle = wine_server_obj_handle( handle );
-                req->flags = 0;
-                if (!(status = wine_server_call( req )) &&
-                    reply->read_timeout != TIMEOUT_INFINITE)
-                    timeouts->total = reply->read_timeout / -10000;
-            }
-            SERVER_END_REQ;
-        }
-        break;
-    case FD_TYPE_SOCKET:
-    case FD_TYPE_CHAR:
-        if (is_read) timeouts->interval = 0;  /* return as soon as we got something */
-        break;
-    default:
-        break;
-    }
-    if (timeouts->total != -1) timeouts->end_time = NtGetTickCount() + timeouts->total;
-    return STATUS_SUCCESS;
-}
-
-
-/* retrieve the timeout for the next wait, in milliseconds */
-static inline int get_next_io_timeout( const struct io_timeouts *timeouts, ULONG already )
-{
-    int ret = -1;
-
-    if (timeouts->total != -1)
-    {
-        ret = timeouts->end_time - NtGetTickCount();
-        if (ret < 0) ret = 0;
-    }
-    if (already && timeouts->interval != -1)
-    {
-        if (ret == -1 || ret > timeouts->interval) ret = timeouts->interval;
-    }
-    return ret;
-}
-
-
-/* retrieve the avail_mode flag for async reads */
-static NTSTATUS get_io_avail_mode( HANDLE handle, enum server_fd_type type, BOOL *avail_mode )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-
-    switch(type)
-    {
-    case FD_TYPE_SERIAL:
-    {
-        /* GetCommTimeouts */
-        SERIAL_TIMEOUTS st;
-        IO_STATUS_BLOCK io;
-
-        status = NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io,
-                                        IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) );
-        if (status) break;
-        *avail_mode = (!st.ReadTotalTimeoutMultiplier &&
-                       !st.ReadTotalTimeoutConstant &&
-                       st.ReadIntervalTimeout == MAXDWORD);
-        break;
-    }
-    case FD_TYPE_MAILSLOT:
-    case FD_TYPE_SOCKET:
-    case FD_TYPE_CHAR:
-        *avail_mode = TRUE;
-        break;
-    default:
-        *avail_mode = FALSE;
-        break;
-    }
-    return status;
-}
-
-/* register an async I/O for a file read; helper for NtReadFile */
-static NTSTATUS register_async_file_read( HANDLE handle, HANDLE event,
-                                          PIO_APC_ROUTINE apc, void *apc_user,
-                                          IO_STATUS_BLOCK *iosb, void *buffer,
-                                          ULONG already, ULONG length, BOOL avail_mode )
-{
-    struct async_fileio_read *fileio;
-    NTSTATUS status;
-
-    if (!(fileio = (struct async_fileio_read *)alloc_fileio( sizeof(*fileio), async_read_proc, handle )))
-        return STATUS_NO_MEMORY;
-
-    fileio->already = already;
-    fileio->count = length;
-    fileio->buffer = buffer;
-    fileio->avail_mode = avail_mode;
-
-    SERVER_START_REQ( register_async )
-    {
-        req->type   = ASYNC_TYPE_READ;
-        req->count  = length;
-        req->async  = server_async( handle, &fileio->io, event, apc, apc_user, iosb );
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    if (status != STATUS_PENDING) free( fileio );
-    return status;
-}
-
-static void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULONG info, BOOL async )
-{
-    SERVER_START_REQ( add_fd_completion )
-    {
-        req->handle      = wine_server_obj_handle( handle );
-        req->cvalue      = value;
-        req->status      = status;
-        req->information = info;
-        req->async       = async;
-        wine_server_call( req );
-    }
-    SERVER_END_REQ;
-}
-
-static NTSTATUS set_pending_write( HANDLE device )
-{
-    NTSTATUS status;
-
-    SERVER_START_REQ( set_serial_info )
-    {
-        req->handle = wine_server_obj_handle( device );
-        req->flags  = SERIALINFO_PENDING_WRITE;
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/******************************************************************************
- *              NtReadFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtReadFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                            IO_STATUS_BLOCK *io, void *buffer, ULONG length,
-                            LARGE_INTEGER *offset, ULONG *key )
-{
-    int result, unix_handle, needs_close;
-    unsigned int options;
-    struct io_timeouts timeouts;
-    NTSTATUS status, ret_status;
-    ULONG total = 0;
-    enum server_fd_type type;
-    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
-    BOOL send_completion = FALSE, async_read, timeout_init_done = FALSE;
-
-    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p)\n",
-           handle, event, apc, apc_user, io, buffer, length, offset, key );
-
-    if (!io) return STATUS_ACCESS_VIOLATION;
-
-    status = server_get_unix_fd( handle, FILE_READ_DATA, &unix_handle, &needs_close, &type, &options );
-    if (status && status != STATUS_BAD_DEVICE_TYPE) return status;
-
-    if (!virtual_check_buffer_for_write( buffer, length )) return STATUS_ACCESS_VIOLATION;
-
-    if (status == STATUS_BAD_DEVICE_TYPE)
-        return server_read_file( handle, event, apc, apc_user, io, buffer, length, offset, key );
-
-    async_read = !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
-
-    if (type == FD_TYPE_FILE)
-    {
-        if (async_read && (!offset || offset->QuadPart < 0))
-        {
-            status = STATUS_INVALID_PARAMETER;
-            goto done;
-        }
-
-        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
-        {
-            /* async I/O doesn't make sense on regular files */
-            while ((result = virtual_locked_pread( unix_handle, buffer, length, offset->QuadPart )) == -1)
-            {
-                if (errno != EINTR)
-                {
-                    status = errno_to_status( errno );
-                    goto done;
-                }
-            }
-            if (!async_read) /* update file pointer position */
-                lseek( unix_handle, offset->QuadPart + result, SEEK_SET );
-
-            total = result;
-            status = (total || !length) ? STATUS_SUCCESS : STATUS_END_OF_FILE;
-            goto done;
-        }
-    }
-    else if (type == FD_TYPE_SERIAL || type == FD_TYPE_DEVICE)
-    {
-        if (async_read && (!offset || offset->QuadPart < 0))
-        {
-            status = STATUS_INVALID_PARAMETER;
-            goto done;
-        }
-    }
-
-    if (type == FD_TYPE_SERIAL && async_read && length)
-    {
-        /* an asynchronous serial port read with a read interval timeout needs to
-           skip the synchronous read to make sure that the server starts the read
-           interval timer after the first read */
-        if ((status = get_io_timeouts( handle, type, length, TRUE, &timeouts ))) goto err;
-        if (timeouts.interval)
-        {
-            status = register_async_file_read( handle, event, apc, apc_user, io,
-                                               buffer, total, length, FALSE );
-            goto err;
-        }
-    }
-
-    for (;;)
-    {
-        if ((result = virtual_locked_read( unix_handle, (char *)buffer + total, length - total )) >= 0)
-        {
-            total += result;
-            if (!result || total == length)
-            {
-                if (total)
-                {
-                    status = STATUS_SUCCESS;
-                    goto done;
-                }
-                switch (type)
-                {
-                case FD_TYPE_FILE:
-                case FD_TYPE_CHAR:
-                case FD_TYPE_DEVICE:
-                    status = length ? STATUS_END_OF_FILE : STATUS_SUCCESS;
-                    goto done;
-                case FD_TYPE_SERIAL:
-                    if (!length)
-                    {
-                        status = STATUS_SUCCESS;
-                        goto done;
-                    }
-                    break;
-                default:
-                    status = STATUS_PIPE_BROKEN;
-                    goto err;
-                }
-            }
-            else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
-        }
-        else if (errno != EAGAIN)
-        {
-            if (errno == EINTR) continue;
-            if (!total) status = errno_to_status( errno );
-            goto err;
-        }
-
-        if (async_read)
-        {
-            BOOL avail_mode;
-
-            if ((status = get_io_avail_mode( handle, type, &avail_mode ))) goto err;
-            if (total && avail_mode)
-            {
-                status = STATUS_SUCCESS;
-                goto done;
-            }
-            status = register_async_file_read( handle, event, apc, apc_user, io,
-                                               buffer, total, length, avail_mode );
-            goto err;
-        }
-        else  /* synchronous read, wait for the fd to become ready */
-        {
-            struct pollfd pfd;
-            int ret, timeout;
-
-            if (!timeout_init_done)
-            {
-                timeout_init_done = TRUE;
-                if ((status = get_io_timeouts( handle, type, length, TRUE, &timeouts ))) goto err;
-                if (event) NtResetEvent( event, NULL );
-            }
-            timeout = get_next_io_timeout( &timeouts, total );
-
-            pfd.fd = unix_handle;
-            pfd.events = POLLIN;
-
-            if (!timeout || !(ret = poll( &pfd, 1, timeout )))
-            {
-                if (total)  /* return with what we got so far */
-                    status = STATUS_SUCCESS;
-                else
-                    status = (type == FD_TYPE_MAILSLOT) ? STATUS_IO_TIMEOUT : STATUS_TIMEOUT;
-                goto done;
-            }
-            if (ret == -1 && errno != EINTR)
-            {
-                status = errno_to_status( errno );
-                goto done;
-            }
-            /* will now restart the read */
-        }
-    }
-
-done:
-    send_completion = cvalue != 0;
-
-err:
-    if (needs_close) close( unix_handle );
-    if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && (!async_read || type == FD_TYPE_FILE)))
-    {
-        io->u.Status = status;
-        io->Information = total;
-        TRACE("= SUCCESS (%u)\n", total);
-        if (event) NtSetEvent( event, NULL );
-        if (apc && (!status || async_read)) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
-                                              (ULONG_PTR)apc_user, (ULONG_PTR)io, 0 );
-    }
-    else
-    {
-        TRACE("= 0x%08x\n", status);
-        if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
-    }
-
-    ret_status = async_read && type == FD_TYPE_FILE && (status == STATUS_SUCCESS || status == STATUS_END_OF_FILE)
-            ? STATUS_PENDING : status;
-
-    if (send_completion) add_completion( handle, cvalue, status, total, ret_status == STATUS_PENDING );
-    return ret_status;
-}
-
-
-/******************************************************************************
- *              NtReadFileScatter   (NTDLL.@)
- */
-NTSTATUS WINAPI NtReadFileScatter( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                   IO_STATUS_BLOCK *io, FILE_SEGMENT_ELEMENT *segments,
-                                   ULONG length, LARGE_INTEGER *offset, ULONG *key )
-{
-    int result, unix_handle, needs_close;
-    unsigned int options;
-    NTSTATUS status;
-    ULONG pos = 0, total = 0;
-    enum server_fd_type type;
-    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
-    BOOL send_completion = FALSE;
-
-    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p),partial stub!\n",
-           file, event, apc, apc_user, io, segments, length, offset, key );
-
-    if (!io) return STATUS_ACCESS_VIOLATION;
-
-    status = server_get_unix_fd( file, FILE_READ_DATA, &unix_handle, &needs_close, &type, &options );
-    if (status) return status;
-
-    if ((type != FD_TYPE_FILE) ||
-        (options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ||
-        !(options & FILE_NO_INTERMEDIATE_BUFFERING))
-    {
-        status = STATUS_INVALID_PARAMETER;
-        goto error;
-    }
-
-    while (length)
-    {
-        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
-            result = pread( unix_handle, (char *)segments->Buffer + pos,
-                            min( length - pos, page_size - pos ), offset->QuadPart + total );
-        else
-            result = read( unix_handle, (char *)segments->Buffer + pos, min( length - pos, page_size - pos ) );
-
-        if (result == -1)
-        {
-            if (errno == EINTR) continue;
-            status = errno_to_status( errno );
-            break;
-        }
-        if (!result) break;
-        total += result;
-        length -= result;
-        if ((pos += result) == page_size)
-        {
-            pos = 0;
-            segments++;
-        }
-    }
-
-    if (total == 0) status = STATUS_END_OF_FILE;
-
-    send_completion = cvalue != 0;
-
-    if (needs_close) close( unix_handle );
-    io->u.Status = status;
-    io->Information = total;
-    TRACE("= 0x%08x (%u)\n", status, total);
-    if (event) NtSetEvent( event, NULL );
-    if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
-                               (ULONG_PTR)apc_user, (ULONG_PTR)io, 0 );
-    if (send_completion) add_completion( file, cvalue, status, total, TRUE );
-
-    return STATUS_PENDING;
-
-error:
-    if (needs_close) close( unix_handle );
-    if (event) NtResetEvent( event, NULL );
-    TRACE("= 0x%08x\n", status);
-    return status;
-}
-
-
-/******************************************************************************
- *              NtWriteFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtWriteFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                             IO_STATUS_BLOCK *io, const void *buffer, ULONG length,
-                             LARGE_INTEGER *offset, ULONG *key )
-{
-    int result, unix_handle, needs_close;
-    unsigned int options;
-    struct io_timeouts timeouts;
-    NTSTATUS status, ret_status;
-    ULONG total = 0;
-    enum server_fd_type type;
-    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
-    BOOL send_completion = FALSE, async_write, append_write = FALSE, timeout_init_done = FALSE;
-    LARGE_INTEGER offset_eof;
-
-    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p)\n",
-           handle, event, apc, apc_user, io, buffer, length, offset, key );
-
-    if (!io) return STATUS_ACCESS_VIOLATION;
-
-    status = server_get_unix_fd( handle, FILE_WRITE_DATA, &unix_handle, &needs_close, &type, &options );
-    if (status == STATUS_ACCESS_DENIED)
-    {
-        status = server_get_unix_fd( handle, FILE_APPEND_DATA, &unix_handle,
-                                     &needs_close, &type, &options );
-        append_write = TRUE;
-    }
-    if (status && status != STATUS_BAD_DEVICE_TYPE) return status;
-
-    async_write = !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
-
-    if (!virtual_check_buffer_for_read( buffer, length ))
-    {
-        status = STATUS_INVALID_USER_BUFFER;
-        goto done;
-    }
-
-    if (status == STATUS_BAD_DEVICE_TYPE)
-        return server_write_file( handle, event, apc, apc_user, io, buffer, length, offset, key );
-
-    if (type == FD_TYPE_FILE)
-    {
-        if (async_write &&
-            (!offset || (offset->QuadPart < 0 && offset->QuadPart != FILE_WRITE_TO_END_OF_FILE)))
-        {
-            status = STATUS_INVALID_PARAMETER;
-            goto done;
-        }
-
-        if (append_write)
-        {
-            offset_eof.QuadPart = FILE_WRITE_TO_END_OF_FILE;
-            offset = &offset_eof;
-        }
-
-        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
-        {
-            off_t off = offset->QuadPart;
-
-            if (offset->QuadPart == FILE_WRITE_TO_END_OF_FILE)
-            {
-                struct stat st;
-
-                if (fstat( unix_handle, &st ) == -1)
-                {
-                    status = errno_to_status( errno );
-                    goto done;
-                }
-                off = st.st_size;
-            }
-            else if (offset->QuadPart < 0)
-            {
-                status = STATUS_INVALID_PARAMETER;
-                goto done;
-            }
-
-            /* async I/O doesn't make sense on regular files */
-            while ((result = pwrite( unix_handle, buffer, length, off )) == -1)
-            {
-                if (errno != EINTR)
-                {
-                    if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
-                    else status = errno_to_status( errno );
-                    goto done;
-                }
-            }
-
-            if (!async_write) /* update file pointer position */
-                lseek( unix_handle, off + result, SEEK_SET );
-
-            total = result;
-            status = STATUS_SUCCESS;
-            goto done;
-        }
-    }
-    else if (type == FD_TYPE_SERIAL || type == FD_TYPE_DEVICE)
-    {
-        if (async_write &&
-            (!offset || (offset->QuadPart < 0 && offset->QuadPart != FILE_WRITE_TO_END_OF_FILE)))
-        {
-            status = STATUS_INVALID_PARAMETER;
-            goto done;
-        }
-    }
-
-    for (;;)
-    {
-        /* zero-length writes on sockets may not work with plain write(2) */
-        if (!length && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_SOCKET))
-            result = send( unix_handle, buffer, 0, 0 );
-        else
-            result = write( unix_handle, (const char *)buffer + total, length - total );
-
-        if (result >= 0)
-        {
-            total += result;
-            if (total == length)
-            {
-                status = STATUS_SUCCESS;
-                goto done;
-            }
-            if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
-        }
-        else if (errno != EAGAIN)
-        {
-            if (errno == EINTR) continue;
-            if (!total)
-            {
-                if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
-                else status = errno_to_status( errno );
-            }
-            goto err;
-        }
-
-        if (async_write)
-        {
-            struct async_fileio_write *fileio;
-
-            fileio = (struct async_fileio_write *)alloc_fileio( sizeof(*fileio), async_write_proc, handle );
-            if (!fileio)
-            {
-                status = STATUS_NO_MEMORY;
-                goto err;
-            }
-            fileio->already = total;
-            fileio->count = length;
-            fileio->buffer = buffer;
-
-            SERVER_START_REQ( register_async )
-            {
-                req->type   = ASYNC_TYPE_WRITE;
-                req->count  = length;
-                req->async  = server_async( handle, &fileio->io, event, apc, apc_user, io );
-                status = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-
-            if (status != STATUS_PENDING) free( fileio );
-            goto err;
-        }
-        else  /* synchronous write, wait for the fd to become ready */
-        {
-            struct pollfd pfd;
-            int ret, timeout;
-
-            if (!timeout_init_done)
-            {
-                timeout_init_done = TRUE;
-                if ((status = get_io_timeouts( handle, type, length, FALSE, &timeouts )))
-                    goto err;
-                if (event) NtResetEvent( event, NULL );
-            }
-            timeout = get_next_io_timeout( &timeouts, total );
-
-            pfd.fd = unix_handle;
-            pfd.events = POLLOUT;
-
-            if (!timeout || !(ret = poll( &pfd, 1, timeout )))
-            {
-                /* return with what we got so far */
-                status = total ? STATUS_SUCCESS : STATUS_TIMEOUT;
-                goto done;
-            }
-            if (ret == -1 && errno != EINTR)
-            {
-                status = errno_to_status( errno );
-                goto done;
-            }
-            /* will now restart the write */
-        }
-    }
-
-done:
-    send_completion = cvalue != 0;
-
-err:
-    if (needs_close) close( unix_handle );
-
-    if (type == FD_TYPE_SERIAL && (status == STATUS_SUCCESS || status == STATUS_PENDING))
-        set_pending_write( handle );
-
-    if (status == STATUS_SUCCESS)
-    {
-        io->u.Status = status;
-        io->Information = total;
-        TRACE("= SUCCESS (%u)\n", total);
-        if (event) NtSetEvent( event, NULL );
-        if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
-                                   (ULONG_PTR)apc_user, (ULONG_PTR)io, 0 );
-    }
-    else
-    {
-        TRACE("= 0x%08x\n", status);
-        if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
-    }
-
-    ret_status = async_write && type == FD_TYPE_FILE && status == STATUS_SUCCESS ? STATUS_PENDING : status;
-    if (send_completion) add_completion( handle, cvalue, status, total, ret_status == STATUS_PENDING );
-    return ret_status;
-}
-
-
-/******************************************************************************
- *              NtWriteFileGather   (NTDLL.@)
- */
-NTSTATUS WINAPI NtWriteFileGather( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                   IO_STATUS_BLOCK *io, FILE_SEGMENT_ELEMENT *segments,
-                                   ULONG length, LARGE_INTEGER *offset, ULONG *key )
-{
-    int result, unix_handle, needs_close;
-    unsigned int options;
-    NTSTATUS status;
-    ULONG pos = 0, total = 0;
-    enum server_fd_type type;
-    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
-    BOOL send_completion = FALSE;
-
-    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p),partial stub!\n",
-           file, event, apc, apc_user, io, segments, length, offset, key );
-
-    if (length % page_size) return STATUS_INVALID_PARAMETER;
-    if (!io) return STATUS_ACCESS_VIOLATION;
-
-    status = server_get_unix_fd( file, FILE_WRITE_DATA, &unix_handle, &needs_close, &type, &options );
-    if (status) return status;
-
-    if ((type != FD_TYPE_FILE) ||
-        (options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ||
-        !(options & FILE_NO_INTERMEDIATE_BUFFERING))
-    {
-        status = STATUS_INVALID_PARAMETER;
-        goto done;
-    }
-
-    while (length)
-    {
-        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
-            result = pwrite( unix_handle, (char *)segments->Buffer + pos,
-                             page_size - pos, offset->QuadPart + total );
-        else
-            result = write( unix_handle, (char *)segments->Buffer + pos, page_size - pos );
-
-        if (result == -1)
-        {
-            if (errno == EINTR) continue;
-            if (errno == EFAULT)
-            {
-                status = STATUS_INVALID_USER_BUFFER;
-                goto done;
-            }
-            status = errno_to_status( errno );
-            break;
-        }
-        if (!result)
-        {
-            status = STATUS_DISK_FULL;
-            break;
-        }
-        total += result;
-        length -= result;
-        if ((pos += result) == page_size)
-        {
-            pos = 0;
-            segments++;
-        }
-    }
-
-    send_completion = cvalue != 0;
-
- done:
-    if (needs_close) close( unix_handle );
-    if (status == STATUS_SUCCESS)
-    {
-        io->u.Status = status;
-        io->Information = total;
-        TRACE("= SUCCESS (%u)\n", total);
-        if (event) NtSetEvent( event, NULL );
-        if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
-                                   (ULONG_PTR)apc_user, (ULONG_PTR)io, 0 );
-    }
-    else
-    {
-        TRACE("= 0x%08x\n", status);
-        if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
-    }
-    if (send_completion) add_completion( file, cvalue, status, total, FALSE );
-    return status;
-}
-
-
-/******************************************************************************
- *              NtDeviceIoControlFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtDeviceIoControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
-                                       IO_STATUS_BLOCK *io, ULONG code, void *in_buffer, ULONG in_size,
-                                       void *out_buffer, ULONG out_size )
-{
-    ULONG device = (code >> 16);
-    NTSTATUS status = STATUS_NOT_SUPPORTED;
-
-    TRACE( "(%p,%p,%p,%p,%p,0x%08x,%p,0x%08x,%p,0x%08x)\n",
-           handle, event, apc, apc_context, io, code, in_buffer, in_size, out_buffer, out_size );
-
-    switch (device)
-    {
-    case FILE_DEVICE_DISK:
-    case FILE_DEVICE_CD_ROM:
-    case FILE_DEVICE_DVD:
-    case FILE_DEVICE_CONTROLLER:
-    case FILE_DEVICE_MASS_STORAGE:
-        status = cdrom_DeviceIoControl( handle, event, apc, apc_context, io, code,
-                                        in_buffer, in_size, out_buffer, out_size );
-        break;
-    case FILE_DEVICE_SERIAL_PORT:
-        status = serial_DeviceIoControl( handle, event, apc, apc_context, io, code,
-                                         in_buffer, in_size, out_buffer, out_size );
-        break;
-    case FILE_DEVICE_TAPE:
-        status = tape_DeviceIoControl( handle, event, apc, apc_context, io, code,
-                                       in_buffer, in_size, out_buffer, out_size );
-        break;
-    }
-
-    if (status == STATUS_NOT_SUPPORTED || status == STATUS_BAD_DEVICE_TYPE)
-        return server_ioctl_file( handle, event, apc, apc_context, io, code,
-                                  in_buffer, in_size, out_buffer, out_size );
-
-    if (status != STATUS_PENDING) io->u.Status = status;
-    return status;
-}
-
-
-/* Tell Valgrind to ignore any holes in structs we will be passing to the
- * server */
-static void ignore_server_ioctl_struct_holes( ULONG code, const void *in_buffer, ULONG in_size )
-{
-#ifdef VALGRIND_MAKE_MEM_DEFINED
-# define IGNORE_STRUCT_HOLE(buf, size, t, f1, f2) \
-    do { \
-        if (FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1) < FIELD_OFFSET(t, f2)) \
-            if ((size) >= FIELD_OFFSET(t, f2)) \
-                VALGRIND_MAKE_MEM_DEFINED( \
-                    (const char *)(buf) + FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1), \
-                    FIELD_OFFSET(t, f2) - FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1)); \
-    } while (0)
-
-    switch (code)
-    {
-    case FSCTL_PIPE_WAIT:
-        IGNORE_STRUCT_HOLE(in_buffer, in_size, FILE_PIPE_WAIT_FOR_BUFFER, TimeoutSpecified, Name);
-        break;
-    }
-#endif
-}
-
-
-/******************************************************************************
- *              NtFsControlFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
-                                 IO_STATUS_BLOCK *io, ULONG code, void *in_buffer, ULONG in_size,
-                                 void *out_buffer, ULONG out_size )
-{
-    NTSTATUS status;
-
-    TRACE( "(%p,%p,%p,%p,%p,0x%08x,%p,0x%08x,%p,0x%08x)\n",
-           handle, event, apc, apc_context, io, code, in_buffer, in_size, out_buffer, out_size );
-
-    if (!io) return STATUS_INVALID_PARAMETER;
-
-    ignore_server_ioctl_struct_holes( code, in_buffer, in_size );
-
-    switch (code)
-    {
-    case FSCTL_DISMOUNT_VOLUME:
-        status = server_ioctl_file( handle, event, apc, apc_context, io, code,
-                                    in_buffer, in_size, out_buffer, out_size );
-        if (!status) status = unmount_device( handle );
-        return status;
-
-    case FSCTL_PIPE_IMPERSONATE:
-        FIXME("FSCTL_PIPE_IMPERSONATE: impersonating self\n");
-        return server_ioctl_file( handle, event, apc, apc_context, io, code,
-                                  in_buffer, in_size, out_buffer, out_size );
-
-    case FSCTL_IS_VOLUME_MOUNTED:
-    case FSCTL_LOCK_VOLUME:
-    case FSCTL_UNLOCK_VOLUME:
-        FIXME("stub! return success - Unsupported fsctl %x (device=%x access=%x func=%x method=%x)\n",
-              code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
-        status = STATUS_SUCCESS;
-        break;
-
-    case FSCTL_GET_RETRIEVAL_POINTERS:
-    {
-        RETRIEVAL_POINTERS_BUFFER *buffer = (RETRIEVAL_POINTERS_BUFFER *)out_buffer;
-
-        FIXME("stub: FSCTL_GET_RETRIEVAL_POINTERS\n");
-
-        if (out_size >= sizeof(RETRIEVAL_POINTERS_BUFFER))
-        {
-            buffer->ExtentCount                 = 1;
-            buffer->StartingVcn.QuadPart        = 1;
-            buffer->Extents[0].NextVcn.QuadPart = 0;
-            buffer->Extents[0].Lcn.QuadPart     = 0;
-            io->Information = sizeof(RETRIEVAL_POINTERS_BUFFER);
-            status = STATUS_SUCCESS;
-        }
-        else
-        {
-            io->Information = 0;
-            status = STATUS_BUFFER_TOO_SMALL;
-        }
-        break;
-    }
-
-    case FSCTL_GET_OBJECT_ID:
-    {
-        FILE_OBJECTID_BUFFER *info = out_buffer;
-        int fd, needs_close;
-        struct stat st;
-
-        io->Information = 0;
-        if (out_size >= sizeof(*info))
-        {
-            status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
-            if (status) break;
-            fstat( fd, &st );
-            if (needs_close) close( fd );
-            memset( info, 0, sizeof(*info) );
-            memcpy( info->ObjectId, &st.st_dev, sizeof(st.st_dev) );
-            memcpy( info->ObjectId + 8, &st.st_ino, sizeof(st.st_ino) );
-            io->Information = sizeof(*info);
-        }
-        else status = STATUS_BUFFER_TOO_SMALL;
-        break;
-    }
-
-    case FSCTL_SET_SPARSE:
-        TRACE("FSCTL_SET_SPARSE: Ignoring request\n");
-        io->Information = 0;
-        status = STATUS_SUCCESS;
-        break;
-    default:
-        return server_ioctl_file( handle, event, apc, apc_context, io, code,
-                                  in_buffer, in_size, out_buffer, out_size );
-    }
-
-    if (status != STATUS_PENDING) io->u.Status = status;
-    return status;
-}
-
-
-/******************************************************************************
- *              NtFlushBuffersFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtFlushBuffersFile( HANDLE handle, IO_STATUS_BLOCK *io )
-{
-    NTSTATUS ret;
-    HANDLE wait_handle;
-    enum server_fd_type type;
-    int fd, needs_close;
-
-    if (!io || !virtual_check_buffer_for_write( io, sizeof(*io) )) return STATUS_ACCESS_VIOLATION;
-
-    ret = server_get_unix_fd( handle, FILE_WRITE_DATA, &fd, &needs_close, &type, NULL );
-    if (ret == STATUS_ACCESS_DENIED)
-        ret = server_get_unix_fd( handle, FILE_APPEND_DATA, &fd, &needs_close, &type, NULL );
-
-    if (!ret && (type == FD_TYPE_FILE || type == FD_TYPE_DIR || type == FD_TYPE_CHAR))
-    {
-        if (fsync(fd)) ret = errno_to_status( errno );
-        io->u.Status    = ret;
-        io->Information = 0;
-    }
-    else if (!ret && type == FD_TYPE_SERIAL)
-    {
-        ret = serial_FlushBuffersFile( fd );
-    }
-    else if (ret != STATUS_ACCESS_DENIED)
-    {
-        struct async_irp *async;
-
-        if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
-            return STATUS_NO_MEMORY;
-        async->buffer  = NULL;
-        async->size    = 0;
-
-        SERVER_START_REQ( flush )
-        {
-            req->async = server_async( handle, &async->io, NULL, NULL, NULL, io );
-            ret = wine_server_call( req );
-            wait_handle = wine_server_ptr_handle( reply->event );
-            if (wait_handle && ret != STATUS_PENDING)
-            {
-                io->u.Status    = ret;
-                io->Information = 0;
-            }
-        }
-        SERVER_END_REQ;
-
-        if (ret != STATUS_PENDING) free( async );
-
-        if (wait_handle) ret = wait_async( wait_handle, FALSE, io );
-    }
-
-    if (needs_close) close( fd );
-    return ret;
-}
-
-
-/**************************************************************************
- *           NtCancelIoFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtCancelIoFile( HANDLE handle, IO_STATUS_BLOCK *io_status )
-{
-    TRACE( "%p %p\n", handle, io_status );
-
-    SERVER_START_REQ( cancel_async )
-    {
-        req->handle      = wine_server_obj_handle( handle );
-        req->only_thread = TRUE;
-        io_status->u.Status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return io_status->u.Status;
-}
-
-
-/**************************************************************************
- *           NtCancelIoFileEx   (NTDLL.@)
- */
-NTSTATUS WINAPI NtCancelIoFileEx( HANDLE handle, IO_STATUS_BLOCK *io, IO_STATUS_BLOCK *io_status )
-{
-    TRACE( "%p %p %p\n", handle, io, io_status );
-
-    SERVER_START_REQ( cancel_async )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->iosb   = wine_server_client_ptr( io );
-        io_status->u.Status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return io_status->u.Status;
-}
-
-
-/******************************************************************
- *           NtLockFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void* apc_user,
-                            IO_STATUS_BLOCK *io_status, LARGE_INTEGER *offset,
-                            LARGE_INTEGER *count, ULONG *key, BOOLEAN dont_wait, BOOLEAN exclusive )
-{
-    static int warn;
-    NTSTATUS ret;
-    HANDLE handle;
-    BOOLEAN async;
-
-    if (apc || io_status || key)
-    {
-        FIXME("Unimplemented yet parameter\n");
-        return STATUS_NOT_IMPLEMENTED;
-    }
-    if (apc_user && !warn++) FIXME("I/O completion on lock not implemented yet\n");
-
-    for (;;)
-    {
-        SERVER_START_REQ( lock_file )
-        {
-            req->handle      = wine_server_obj_handle( file );
-            req->offset      = offset->QuadPart;
-            req->count       = count->QuadPart;
-            req->shared      = !exclusive;
-            req->wait        = !dont_wait;
-            ret = wine_server_call( req );
-            handle = wine_server_ptr_handle( reply->handle );
-            async  = reply->overlapped;
-        }
-        SERVER_END_REQ;
-        if (ret != STATUS_PENDING)
-        {
-            if (!ret && event) NtSetEvent( event, NULL );
-            return ret;
-        }
-        if (async)
-        {
-            FIXME( "Async I/O lock wait not implemented, might deadlock\n" );
-            if (handle) NtClose( handle );
-            return STATUS_PENDING;
-        }
-        if (handle)
-        {
-            NtWaitForSingleObject( handle, FALSE, NULL );
-            NtClose( handle );
-        }
-        else  /* Unix lock conflict, sleep a bit and retry */
-        {
-            LARGE_INTEGER time;
-            time.QuadPart = -100 * (ULONGLONG)10000;
-            NtDelayExecution( FALSE, &time );
-        }
-    }
-}
-
-
-/******************************************************************
- *           NtUnlockFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtUnlockFile( HANDLE handle, IO_STATUS_BLOCK *io_status, LARGE_INTEGER *offset,
-                              LARGE_INTEGER *count, ULONG *key )
-{
-    NTSTATUS status;
-
-    TRACE( "%p %x%08x %x%08x\n",
-           handle, offset->u.HighPart, offset->u.LowPart, count->u.HighPart, count->u.LowPart );
-
-    if (io_status || key)
-    {
-        FIXME("Unimplemented yet parameter\n");
-        return STATUS_NOT_IMPLEMENTED;
-    }
-
-    SERVER_START_REQ( unlock_file )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->offset = offset->QuadPart;
-        req->count  = count->QuadPart;
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-static NTSTATUS read_changes_apc( void *user, IO_STATUS_BLOCK *iosb, NTSTATUS status )
-{
-    struct async_fileio_read_changes *fileio = user;
-    int size = 0;
-
-    if (status == STATUS_ALERTED)
-    {
-        SERVER_START_REQ( read_change )
-        {
-            req->handle = wine_server_obj_handle( fileio->io.handle );
-            wine_server_set_reply( req, fileio->data, fileio->data_size );
-            status = wine_server_call( req );
-            size = wine_server_reply_size( reply );
-        }
-        SERVER_END_REQ;
-
-        if (status == STATUS_SUCCESS && fileio->buffer)
-        {
-            FILE_NOTIFY_INFORMATION *pfni = fileio->buffer;
-            int i, left = fileio->buffer_size;
-            DWORD *last_entry_offset = NULL;
-            struct filesystem_event *event = (struct filesystem_event*)fileio->data;
-
-            while (size && left >= sizeof(*pfni))
-            {
-                DWORD len = (left - offsetof(FILE_NOTIFY_INFORMATION, FileName)) / sizeof(WCHAR);
-
-                /* convert to an NT style path */
-                for (i = 0; i < event->len; i++)
-                    if (event->name[i] == '/') event->name[i] = '\\';
-
-                pfni->Action = event->action;
-                pfni->FileNameLength = ntdll_umbstowcs( event->name, event->len, pfni->FileName, len );
-                last_entry_offset = &pfni->NextEntryOffset;
-
-                if (pfni->FileNameLength == len) break;
-
-                i = offsetof(FILE_NOTIFY_INFORMATION, FileName[pfni->FileNameLength]);
-                pfni->FileNameLength *= sizeof(WCHAR);
-                pfni->NextEntryOffset = i;
-                pfni = (FILE_NOTIFY_INFORMATION*)((char*)pfni + i);
-                left -= i;
-
-                i = (offsetof(struct filesystem_event, name[event->len])
-                     + sizeof(int)-1) / sizeof(int) * sizeof(int);
-                event = (struct filesystem_event*)((char*)event + i);
-                size -= i;
-            }
-
-            if (size)
-            {
-                status = STATUS_NOTIFY_ENUM_DIR;
-                size = 0;
-            }
-            else
-            {
-                if (last_entry_offset) *last_entry_offset = 0;
-                size = fileio->buffer_size - left;
-            }
-        }
-        else
-        {
-            status = STATUS_NOTIFY_ENUM_DIR;
-            size = 0;
-        }
-    }
-
-    if (status != STATUS_PENDING)
-    {
-        iosb->u.Status = status;
-        iosb->Information = size;
-        release_fileio( &fileio->io );
-    }
-    return status;
-}
-
-#define FILE_NOTIFY_ALL        (  \
- FILE_NOTIFY_CHANGE_FILE_NAME   | \
- FILE_NOTIFY_CHANGE_DIR_NAME    | \
- FILE_NOTIFY_CHANGE_ATTRIBUTES  | \
- FILE_NOTIFY_CHANGE_SIZE        | \
- FILE_NOTIFY_CHANGE_LAST_WRITE  | \
- FILE_NOTIFY_CHANGE_LAST_ACCESS | \
- FILE_NOTIFY_CHANGE_CREATION    | \
- FILE_NOTIFY_CHANGE_SECURITY   )
-
-/******************************************************************************
- *              NtNotifyChangeDirectoryFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtNotifyChangeDirectoryFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc,
-                                             void *apc_context, IO_STATUS_BLOCK *iosb, void *buffer,
-                                             ULONG buffer_size, ULONG filter, BOOLEAN subtree )
-{
-    struct async_fileio_read_changes *fileio;
-    NTSTATUS status;
-    ULONG size = max( 4096, buffer_size );
-
-    TRACE( "%p %p %p %p %p %p %u %u %d\n",
-           handle, event, apc, apc_context, iosb, buffer, buffer_size, filter, subtree );
-
-    if (!iosb) return STATUS_ACCESS_VIOLATION;
-    if (filter == 0 || (filter & ~FILE_NOTIFY_ALL)) return STATUS_INVALID_PARAMETER;
-
-    fileio = (struct async_fileio_read_changes *)alloc_fileio(
-        offsetof(struct async_fileio_read_changes, data[size]), read_changes_apc, handle );
-    if (!fileio) return STATUS_NO_MEMORY;
-
-    fileio->buffer      = buffer;
-    fileio->buffer_size = buffer_size;
-    fileio->data_size   = size;
-
-    SERVER_START_REQ( read_directory_changes )
-    {
-        req->filter    = filter;
-        req->want_data = (buffer != NULL);
-        req->subtree   = subtree;
-        req->async     = server_async( handle, &fileio->io, event, apc, apc_context, iosb );
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    if (status != STATUS_PENDING) free( fileio );
-    return status;
-}
-
-
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
-/* helper for FILE_GetDeviceInfo to hide some platform differences in fstatfs */
-static inline void get_device_info_fstatfs( FILE_FS_DEVICE_INFORMATION *info, const char *fstypename,
-                                            unsigned int flags )
-{
-    if (!strcmp("cd9660", fstypename) || !strcmp("udf", fstypename))
-    {
-        info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
-        /* Don't assume read-only, let the mount options set it below */
-        info->Characteristics |= FILE_REMOVABLE_MEDIA;
-    }
-    else if (!strcmp("nfs", fstypename) || !strcmp("nwfs", fstypename) ||
-             !strcmp("smbfs", fstypename) || !strcmp("afpfs", fstypename))
-    {
-        info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
-        info->Characteristics |= FILE_REMOTE_DEVICE;
-    }
-    else if (!strcmp("procfs", fstypename))
-        info->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
-    else
-        info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-
-    if (flags & MNT_RDONLY)
-        info->Characteristics |= FILE_READ_ONLY_DEVICE;
-
-    if (!(flags & MNT_LOCAL))
-    {
-        info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
-        info->Characteristics |= FILE_REMOTE_DEVICE;
-    }
-}
-#endif
-
-static inline BOOL is_device_placeholder( int fd )
-{
-    static const char wine_placeholder[] = "Wine device placeholder";
-    char buffer[sizeof(wine_placeholder)-1];
-
-    if (pread( fd, buffer, sizeof(wine_placeholder) - 1, 0 ) != sizeof(wine_placeholder) - 1)
-        return FALSE;
-    return !memcmp( buffer, wine_placeholder, sizeof(wine_placeholder) - 1 );
-}
-
-static NTSTATUS get_device_info( int fd, FILE_FS_DEVICE_INFORMATION *info )
-{
-    struct stat st;
-
-    info->Characteristics = 0;
-    if (fstat( fd, &st ) < 0) return errno_to_status( errno );
-    if (S_ISCHR( st.st_mode ))
-    {
-        info->DeviceType = FILE_DEVICE_UNKNOWN;
-#ifdef linux
-        switch(major(st.st_rdev))
-        {
-        case MEM_MAJOR:
-            info->DeviceType = FILE_DEVICE_NULL;
-            break;
-        case TTY_MAJOR:
-            info->DeviceType = FILE_DEVICE_SERIAL_PORT;
-            break;
-        case LP_MAJOR:
-            info->DeviceType = FILE_DEVICE_PARALLEL_PORT;
-            break;
-        case SCSI_TAPE_MAJOR:
-            info->DeviceType = FILE_DEVICE_TAPE;
-            break;
-        }
-#endif
-    }
-    else if (S_ISBLK( st.st_mode ))
-    {
-        info->DeviceType = FILE_DEVICE_DISK;
-    }
-    else if (S_ISFIFO( st.st_mode ) || S_ISSOCK( st.st_mode ))
-    {
-        info->DeviceType = FILE_DEVICE_NAMED_PIPE;
-    }
-    else if (is_device_placeholder( fd ))
-    {
-        info->DeviceType = FILE_DEVICE_DISK;
-    }
-    else  /* regular file or directory */
-    {
-#if defined(linux) && defined(HAVE_FSTATFS)
-        struct statfs stfs;
-
-        /* check for floppy disk */
-        if (major(st.st_dev) == FLOPPY_MAJOR)
-            info->Characteristics |= FILE_REMOVABLE_MEDIA;
-
-        if (fstatfs( fd, &stfs ) < 0) stfs.f_type = 0;
-        switch (stfs.f_type)
-        {
-        case 0x9660:      /* iso9660 */
-        case 0x9fa1:      /* supermount */
-        case 0x15013346:  /* udf */
-            info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
-            info->Characteristics |= FILE_REMOVABLE_MEDIA|FILE_READ_ONLY_DEVICE;
-            break;
-        case 0x6969:  /* nfs */
-        case 0xff534d42: /* cifs */
-        case 0xfe534d42: /* smb2 */
-        case 0x517b:  /* smbfs */
-        case 0x564c:  /* ncpfs */
-            info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
-            info->Characteristics |= FILE_REMOTE_DEVICE;
-            break;
-        case 0x1373:      /* devfs */
-        case 0x9fa0:      /* procfs */
-            info->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
-            break;
-        case 0x01021994:  /* tmpfs */
-        case 0x28cd3d45:  /* cramfs */
-            /* Don't map these to FILE_DEVICE_VIRTUAL_DISK by default. Virtual
-             * filesystems are rare on Windows, and some programs refuse to
-             * recognize them as valid. */
-        default:
-            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-            break;
-        }
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
-        struct statfs stfs;
-
-        if (fstatfs( fd, &stfs ) < 0)
-            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-        else
-            get_device_info_fstatfs( info, stfs.f_fstypename, stfs.f_flags );
-#elif defined(__NetBSD__)
-        struct statvfs stfs;
-
-        if (fstatvfs( fd, &stfs) < 0)
-            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-        else
-            get_device_info_fstatfs( info, stfs.f_fstypename, stfs.f_flag );
-#elif defined(sun)
-        /* Use dkio to work out device types */
-        {
-# include <sys/dkio.h>
-# include <sys/vtoc.h>
-            struct dk_cinfo dkinf;
-            int retval = ioctl(fd, DKIOCINFO, &dkinf);
-            if(retval==-1){
-                WARN("Unable to get disk device type information - assuming a disk like device\n");
-                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-            }
-            switch (dkinf.dki_ctype)
-            {
-            case DKC_CDROM:
-                info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
-                info->Characteristics |= FILE_REMOVABLE_MEDIA|FILE_READ_ONLY_DEVICE;
-                break;
-            case DKC_NCRFLOPPY:
-            case DKC_SMSFLOPPY:
-            case DKC_INTEL82072:
-            case DKC_INTEL82077:
-                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-                info->Characteristics |= FILE_REMOVABLE_MEDIA;
-                break;
-            case DKC_MD:
-            /* Don't map these to FILE_DEVICE_VIRTUAL_DISK by default. Virtual
-             * filesystems are rare on Windows, and some programs refuse to
-             * recognize them as valid. */
-            default:
-                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-            }
-        }
-#else
-        static int warned;
-        if (!warned++) FIXME( "device info not properly supported on this platform\n" );
-        info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
-#endif
-        info->Characteristics |= FILE_DEVICE_IS_MOUNTED;
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtQueryVolumeInformationFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
-                                              void *buffer, ULONG length,
-                                              FS_INFORMATION_CLASS info_class )
-{
-    int fd, needs_close;
-    struct stat st;
-
-    io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
-    if (io->u.Status == STATUS_BAD_DEVICE_TYPE)
-    {
-        SERVER_START_REQ( get_volume_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->info_class = info_class;
-            wine_server_set_reply( req, buffer, length );
-            io->u.Status = wine_server_call( req );
-            if (!io->u.Status) io->Information = wine_server_reply_size( reply );
-        }
-        SERVER_END_REQ;
-        return io->u.Status;
-    }
-    else if (io->u.Status) return io->u.Status;
-
-    io->u.Status = STATUS_NOT_IMPLEMENTED;
-    io->Information = 0;
-
-    switch( info_class )
-    {
-    case FileFsLabelInformation:
-        FIXME( "%p: label info not supported\n", handle );
-        break;
-
-    case FileFsSizeInformation:
-        if (length < sizeof(FILE_FS_SIZE_INFORMATION))
-            io->u.Status = STATUS_BUFFER_TOO_SMALL;
-        else
-        {
-            FILE_FS_SIZE_INFORMATION *info = buffer;
-
-            if (fstat( fd, &st ) < 0)
-            {
-                io->u.Status = errno_to_status( errno );
-                break;
-            }
-            if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
-            {
-                io->u.Status = STATUS_INVALID_DEVICE_REQUEST;
-            }
-            else
-            {
-                ULONGLONG bsize;
-                /* Linux's fstatvfs is buggy */
-#if !defined(linux) || !defined(HAVE_FSTATFS)
-                struct statvfs stfs;
-
-                if (fstatvfs( fd, &stfs ) < 0)
-                {
-                    io->u.Status = errno_to_status( errno );
-                    break;
-                }
-                bsize = stfs.f_frsize;
-#else
-                struct statfs stfs;
-                if (fstatfs( fd, &stfs ) < 0)
-                {
-                    io->u.Status = errno_to_status( errno );
-                    break;
-                }
-                bsize = stfs.f_bsize;
-#endif
-                if (bsize == 2048)  /* assume CD-ROM */
-                {
-                    info->BytesPerSector = 2048;
-                    info->SectorsPerAllocationUnit = 1;
-                }
-                else
-                {
-                    info->BytesPerSector = 512;
-                    info->SectorsPerAllocationUnit = 8;
-                }
-                info->TotalAllocationUnits.QuadPart = bsize * stfs.f_blocks / (info->BytesPerSector * info->SectorsPerAllocationUnit);
-                info->AvailableAllocationUnits.QuadPart = bsize * stfs.f_bavail / (info->BytesPerSector * info->SectorsPerAllocationUnit);
-                io->Information = sizeof(*info);
-                io->u.Status = STATUS_SUCCESS;
-            }
-        }
-        break;
-
-    case FileFsDeviceInformation:
-        if (length < sizeof(FILE_FS_DEVICE_INFORMATION))
-            io->u.Status = STATUS_BUFFER_TOO_SMALL;
-        else
-        {
-            FILE_FS_DEVICE_INFORMATION *info = buffer;
-
-            if ((io->u.Status = get_device_info( fd, info )) == STATUS_SUCCESS)
-                io->Information = sizeof(*info);
-        }
-        break;
-
-    case FileFsAttributeInformation:
-    {
-        static const WCHAR fatW[] = {'F','A','T'};
-        static const WCHAR fat32W[] = {'F','A','T','3','2'};
-        static const WCHAR ntfsW[] = {'N','T','F','S'};
-        static const WCHAR cdfsW[] = {'C','D','F','S'};
-        static const WCHAR udfW[] = {'U','D','F'};
-
-        FILE_FS_ATTRIBUTE_INFORMATION *info = buffer;
-        struct mountmgr_unix_drive drive;
-        enum mountmgr_fs_type fs_type = MOUNTMGR_FS_TYPE_NTFS;
-
-        if (length < sizeof(FILE_FS_ATTRIBUTE_INFORMATION))
-        {
-            io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
-            break;
-        }
-
-        if (!get_mountmgr_fs_info( handle, fd, &drive, sizeof(drive) )) fs_type = drive.fs_type;
-        else
-        {
-            struct statfs stfs;
-
-            if (!fstatfs( fd, &stfs ))
-            {
-#if defined(linux) && defined(HAVE_FSTATFS)
-                switch (stfs.f_type)
-                {
-                case 0x9660:
-                    fs_type = MOUNTMGR_FS_TYPE_ISO9660;
-                    break;
-                case 0x15013346:
-                    fs_type = MOUNTMGR_FS_TYPE_UDF;
-                    break;
-                case 0x4d44:
-                    fs_type = MOUNTMGR_FS_TYPE_FAT32;
-                    break;
-                }
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
-                if (!strcmp( stfs.f_fstypename, "cd9660" ))
-                    fs_type = MOUNTMGR_FS_TYPE_ISO9660;
-                else if (!strcmp( stfs.f_fstypename, "udf" ))
-                    fs_type = MOUNTMGR_FS_TYPE_UDF;
-                else if (!strcmp( stfs.f_fstypename, "msdos" ))
-                    fs_type = MOUNTMGR_FS_TYPE_FAT32;
-#endif
-            }
-        }
-
-        switch (fs_type)
-        {
-        case MOUNTMGR_FS_TYPE_ISO9660:
-            info->FileSystemAttributes = FILE_READ_ONLY_VOLUME;
-            info->MaximumComponentNameLength = 221;
-            info->FileSystemNameLength = min( sizeof(cdfsW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
-            memcpy(info->FileSystemName, cdfsW, info->FileSystemNameLength);
-            break;
-        case MOUNTMGR_FS_TYPE_UDF:
-            info->FileSystemAttributes = FILE_READ_ONLY_VOLUME | FILE_UNICODE_ON_DISK | FILE_CASE_SENSITIVE_SEARCH;
-            info->MaximumComponentNameLength = 255;
-            info->FileSystemNameLength = min( sizeof(udfW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
-            memcpy(info->FileSystemName, udfW, info->FileSystemNameLength);
-            break;
-        case MOUNTMGR_FS_TYPE_FAT:
-            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES; /* FIXME */
-            info->MaximumComponentNameLength = 255;
-            info->FileSystemNameLength = min( sizeof(fatW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
-            memcpy(info->FileSystemName, fatW, info->FileSystemNameLength);
-            break;
-        case MOUNTMGR_FS_TYPE_FAT32:
-            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES; /* FIXME */
-            info->MaximumComponentNameLength = 255;
-            info->FileSystemNameLength = min( sizeof(fat32W), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
-            memcpy(info->FileSystemName, fat32W, info->FileSystemNameLength);
-            break;
-        default:
-            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
-            info->MaximumComponentNameLength = 255;
-            info->FileSystemNameLength = min( sizeof(ntfsW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
-            memcpy(info->FileSystemName, ntfsW, info->FileSystemNameLength);
-            break;
-        }
-
-        io->Information = offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) + info->FileSystemNameLength;
-        io->u.Status = STATUS_SUCCESS;
-        break;
-    }
-
-    case FileFsVolumeInformation:
-    {
-        FILE_FS_VOLUME_INFORMATION *info = buffer;
-        ULONGLONG data[64];
-        struct mountmgr_unix_drive *drive = (struct mountmgr_unix_drive *)data;
-        const WCHAR *label;
-
-        if (length < sizeof(FILE_FS_VOLUME_INFORMATION))
-        {
-            io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
-            break;
-        }
-
-        if (get_mountmgr_fs_info( handle, fd, drive, sizeof(data) ))
-        {
-            io->u.Status = STATUS_NOT_IMPLEMENTED;
-            break;
-        }
-
-        label = (WCHAR *)((char *)drive + drive->label_offset);
-        info->VolumeCreationTime.QuadPart = 0; /* FIXME */
-        info->VolumeSerialNumber = drive->serial;
-        info->VolumeLabelLength = min( wcslen( label ) * sizeof(WCHAR),
-                                       length - offsetof( FILE_FS_VOLUME_INFORMATION, VolumeLabel ) );
-        info->SupportsObjects = (drive->fs_type == MOUNTMGR_FS_TYPE_NTFS);
-        memcpy( info->VolumeLabel, label, info->VolumeLabelLength );
-        io->Information = offsetof( FILE_FS_VOLUME_INFORMATION, VolumeLabel ) + info->VolumeLabelLength;
-        io->u.Status = STATUS_SUCCESS;
-        break;
-    }
-
-    case FileFsControlInformation:
-        FIXME( "%p: control info not supported\n", handle );
-        break;
-
-    case FileFsFullSizeInformation:
-        FIXME( "%p: full size info not supported\n", handle );
-        break;
-
-    case FileFsObjectIdInformation:
-        FIXME( "%p: object id info not supported\n", handle );
-        break;
-
-    case FileFsMaximumInformation:
-        FIXME( "%p: maximum info not supported\n", handle );
-        break;
-
-    default:
-        io->u.Status = STATUS_INVALID_PARAMETER;
-        break;
-    }
-    if (needs_close) close( fd );
-    return io->u.Status;
-}
-
-
-/******************************************************************************
- *              NtSetVolumeInformationFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetVolumeInformationFile( HANDLE handle, IO_STATUS_BLOCK *io, void *info,
-                                            ULONG length, FS_INFORMATION_CLASS class )
-{
-    FIXME( "(%p,%p,%p,0x%08x,0x%08x) stub\n", handle, io, info, length, class );
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************
- *           NtQueryEaFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryEaFile( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer, ULONG length,
-                               BOOLEAN single_entry, void *list, ULONG list_len,
-                               ULONG *index, BOOLEAN restart )
-{
-    FIXME( "(%p,%p,%p,%d,%d,%p,%d,%p,%d) stub\n",
-           handle, io, buffer, length, single_entry, list, list_len, index, restart );
-    return STATUS_ACCESS_DENIED;
-}
-
-
-/******************************************************************
- *           NtSetEaFile   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetEaFile( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer, ULONG length )
-{
-    FIXME( "(%p,%p,%p,%d) stub\n", handle, io, buffer, length );
-    return STATUS_ACCESS_DENIED;
-}
-
-
-/**************************************************************************
- *           NtQueryObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_class,
-                               void *ptr, ULONG len, ULONG *used_len )
-{
-    NTSTATUS status;
-
-    TRACE("(%p,0x%08x,%p,0x%08x,%p)\n", handle, info_class, ptr, len, used_len);
-
-    if (used_len) *used_len = 0;
-
-    switch (info_class)
-    {
-    case ObjectBasicInformation:
-    {
-        OBJECT_BASIC_INFORMATION *p = ptr;
-
-        if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
-
-        SERVER_START_REQ( get_object_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                memset( p, 0, sizeof(*p) );
-                p->GrantedAccess = reply->access;
-                p->PointerCount = reply->ref_count;
-                p->HandleCount = reply->handle_count;
-                if (used_len) *used_len = sizeof(*p);
-            }
-        }
-        SERVER_END_REQ;
-        break;
-    }
-
-    case ObjectNameInformation:
-    {
-        OBJECT_NAME_INFORMATION *p = ptr;
-        char *unix_name;
-        WCHAR *nt_name;
-
-        /* first try as a file object */
-
-        if (!(status = server_get_unix_name( handle, &unix_name )))
-        {
-            if (!(status = unix_to_nt_file_name( unix_name, &nt_name )))
-            {
-                ULONG size = (wcslen(nt_name) + 1) * sizeof(WCHAR);
-                if (len < sizeof(*p)) status = STATUS_INFO_LENGTH_MISMATCH;
-                else if (len < sizeof(*p) + size) status = STATUS_BUFFER_OVERFLOW;
-                else
-                {
-                    p->Name.Buffer = (WCHAR *)(p + 1);
-                    p->Name.Length = size - sizeof(WCHAR);
-                    p->Name.MaximumLength = size;
-                    wcscpy( p->Name.Buffer, nt_name );
-                }
-                if (used_len) *used_len = sizeof(*p) + size;
-                free( nt_name );
-            }
-            free( unix_name );
-            break;
-        }
-        else if (status != STATUS_OBJECT_TYPE_MISMATCH) break;
-
-        /* not a file, treat as a generic object */
-
-        SERVER_START_REQ( get_object_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (len > sizeof(*p)) wine_server_set_reply( req, p + 1, len - sizeof(*p) );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                if (!reply->total)  /* no name */
-                {
-                    if (sizeof(*p) > len) status = STATUS_INFO_LENGTH_MISMATCH;
-                    else memset( p, 0, sizeof(*p) );
-                    if (used_len) *used_len = sizeof(*p);
-                }
-                else if (sizeof(*p) + reply->total + sizeof(WCHAR) > len)
-                {
-                    if (used_len) *used_len = sizeof(*p) + reply->total + sizeof(WCHAR);
-                    status = STATUS_INFO_LENGTH_MISMATCH;
-                }
-                else
-                {
-                    ULONG res = wine_server_reply_size( reply );
-                    p->Name.Buffer = (WCHAR *)(p + 1);
-                    p->Name.Length = res;
-                    p->Name.MaximumLength = res + sizeof(WCHAR);
-                    p->Name.Buffer[res / sizeof(WCHAR)] = 0;
-                    if (used_len) *used_len = sizeof(*p) + p->Name.MaximumLength;
-                }
-            }
-        }
-        SERVER_END_REQ;
-        break;
-    }
-
-    case ObjectTypeInformation:
-    {
-        OBJECT_TYPE_INFORMATION *p = ptr;
-
-        SERVER_START_REQ( get_object_type )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (len > sizeof(*p)) wine_server_set_reply( req, p + 1, len - sizeof(*p) );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                if (!reply->total)  /* no name */
-                {
-                    if (sizeof(*p) > len) status = STATUS_INFO_LENGTH_MISMATCH;
-                    else memset( p, 0, sizeof(*p) );
-                    if (used_len) *used_len = sizeof(*p);
-                }
-                else if (sizeof(*p) + reply->total + sizeof(WCHAR) > len)
-                {
-                    if (used_len) *used_len = sizeof(*p) + reply->total + sizeof(WCHAR);
-                    status = STATUS_INFO_LENGTH_MISMATCH;
-                }
-                else
-                {
-                    ULONG res = wine_server_reply_size( reply );
-                    p->TypeName.Buffer = (WCHAR *)(p + 1);
-                    p->TypeName.Length = res;
-                    p->TypeName.MaximumLength = res + sizeof(WCHAR);
-                    p->TypeName.Buffer[res / sizeof(WCHAR)] = 0;
-                    if (used_len) *used_len = sizeof(*p) + p->TypeName.MaximumLength;
-                }
-            }
-        }
-        SERVER_END_REQ;
-        break;
-    }
-
-    case ObjectDataInformation:
-    {
-        OBJECT_DATA_INFORMATION* p = ptr;
-
-        if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
-
-        SERVER_START_REQ( set_handle_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->flags  = 0;
-            req->mask   = 0;
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                p->InheritHandle = (reply->old_flags & HANDLE_FLAG_INHERIT) != 0;
-                p->ProtectFromClose = (reply->old_flags & HANDLE_FLAG_PROTECT_FROM_CLOSE) != 0;
-                if (used_len) *used_len = sizeof(*p);
-            }
-        }
-        SERVER_END_REQ;
-        break;
-    }
-
-    default:
-        FIXME("Unsupported information class %u\n", info_class);
-        status = STATUS_NOT_IMPLEMENTED;
-        break;
-    }
-    return status;
-}
-
-
-/**************************************************************************
- *           NtSetInformationObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetInformationObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_class,
-                                        void *ptr, ULONG len )
-{
-    NTSTATUS status;
-
-    TRACE("(%p,0x%08x,%p,0x%08x)\n", handle, info_class, ptr, len);
-
-    switch (info_class)
-    {
-    case ObjectDataInformation:
-    {
-        OBJECT_DATA_INFORMATION* p = ptr;
-
-        if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
-
-        SERVER_START_REQ( set_handle_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->mask   = HANDLE_FLAG_INHERIT | HANDLE_FLAG_PROTECT_FROM_CLOSE;
-            if (p->InheritHandle)    req->flags |= HANDLE_FLAG_INHERIT;
-            if (p->ProtectFromClose) req->flags |= HANDLE_FLAG_PROTECT_FROM_CLOSE;
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-    break;
-    }
-
-    default:
-        FIXME("Unsupported information class %u\n", info_class);
-        status = STATUS_NOT_IMPLEMENTED;
-        break;
-    }
-    return status;
-}
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index e7cc050ba9..a19f0c0149 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -27,27 +27,20 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <locale.h>
+#include <langinfo.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <signal.h>
-#ifdef HAVE_LINK_H
-# include <link.h>
-#endif
 #ifdef HAVE_PWD_H
 # include <pwd.h>
 #endif
-#ifdef HAVE_ELF_H
-# include <elf.h>
-#endif
-#ifdef HAVE_LINK_H
-# include <link.h>
-#endif
-#ifdef HAVE_SYS_AUXV_H
-# include <sys/auxv.h>
-#endif
 #ifdef HAVE_SYS_MMAN_H
 # include <sys/mman.h>
 #endif
+#ifdef HAVE_SYS_PRCTL_H
+# include <sys/prctl.h>
+#endif
 #ifdef HAVE_SYS_RESOURCE_H
 # include <sys/resource.h>
 #endif
@@ -65,8 +58,6 @@
 # undef LoadResource
 # undef GetCurrentThread
 # include <pthread.h>
-# include <mach/mach.h>
-# include <mach/mach_error.h>
 # include <mach-o/getsect.h>
 # include <crt_externs.h>
 # include <spawn.h>
@@ -83,30 +74,24 @@
 #include "winnt.h"
 #include "winbase.h"
 #include "winnls.h"
-#include "winioctl.h"
 #include "winternl.h"
 #include "unix_private.h"
-#include "wine/list.h"
 #include "wine/library.h"
 #include "wine/debug.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(module);
+WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
 extern IMAGE_NT_HEADERS __wine_spec_nt_header;
-
-void     (WINAPI *pDbgUiRemoteBreakin)( void *arg ) = NULL;
-NTSTATUS (WINAPI *pKiRaiseUserExceptionDispatcher)(void) = NULL;
-void     (WINAPI *pKiUserApcDispatcher)(CONTEXT*,ULONG_PTR,ULONG_PTR,ULONG_PTR,PNTAPCFUNC) = NULL;
-NTSTATUS (WINAPI *pKiUserExceptionDispatcher)(EXCEPTION_RECORD*,CONTEXT*) = NULL;
-void     (WINAPI *pLdrInitializeThunk)(CONTEXT*,void**,ULONG_PTR,ULONG_PTR) = NULL;
-void     (WINAPI *pRtlUserThreadStart)( PRTL_THREAD_START_ROUTINE entry, void *arg ) = NULL;
-
-static void (CDECL *p__wine_set_unix_funcs)( int version, const struct unix_funcs *funcs );
+extern void CDECL __wine_set_unix_funcs( int version, const struct unix_funcs *funcs );
 
 #ifdef __GNUC__
 static void fatal_error( const char *err, ... ) __attribute__((noreturn, format(printf,1,2)));
 #endif
 
+extern int __wine_main_argc;
+extern char **__wine_main_argv;
+extern char **__wine_main_environ;
+
 #if defined(linux) || defined(__APPLE__)
 static const BOOL use_preloader = TRUE;
 #else
@@ -115,50 +100,19 @@ static const BOOL use_preloader = FALSE;
 
 static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
 
+static int main_argc;
+static char **main_argv;
+static char **main_envp;
 static char *argv0;
 static const char *bin_dir;
 static const char *dll_dir;
+static const char *data_dir;
+static const char *build_dir;
+static const char *config_dir;
+static const char **dll_paths;
 static SIZE_T dll_path_maxlen;
 
-const char *home_dir = NULL;
-const char *data_dir = NULL;
-const char *build_dir = NULL;
-const char *config_dir = NULL;
-const char **dll_paths = NULL;
-const char *user_name = NULL;
-static HMODULE ntdll_module;
-
-struct file_id
-{
-    dev_t dev;
-    ino_t ino;
-};
-
-struct builtin_module
-{
-    struct list    entry;
-    struct file_id id;
-    void          *handle;
-    void          *module;
-};
-
-static struct list builtin_modules = LIST_INIT( builtin_modules );
-
-static NTSTATUS add_builtin_module( void *module, void *handle, const struct stat *st )
-{
-    struct builtin_module *builtin;
-    if (!(builtin = malloc( sizeof(*builtin) ))) return STATUS_NO_MEMORY;
-    builtin->handle = handle;
-    builtin->module = module;
-    if (st)
-    {
-        builtin->id.dev = st->st_dev;
-        builtin->id.ino = st->st_ino;
-    }
-    else memset( &builtin->id, 0, sizeof(builtin->id) );
-    list_add_tail( &builtin_modules, &builtin->entry );
-    return STATUS_SUCCESS;
-}
+static CPTABLEINFO unix_table;
 
 static inline void *get_rva( const IMAGE_NT_HEADERS *nt, ULONG_PTR addr )
 {
@@ -290,29 +244,6 @@ static void set_dll_path(void)
 }
 
 
-static void set_home_dir(void)
-{
-    const char *home = getenv( "HOME" );
-    const char *name = getenv( "USER" );
-    const char *p;
-
-    if (!home || !name)
-    {
-        struct passwd *pwd = getpwuid( getuid() );
-        if (pwd)
-        {
-            if (!home) home = pwd->pw_dir;
-            if (!name) name = pwd->pw_name;
-        }
-        if (!name) name = "wine";
-    }
-    if ((p = strrchr( name, '/' ))) name = p + 1;
-    if ((p = strrchr( name, '\\' ))) name = p + 1;
-    home_dir = strdup( home );
-    user_name = strdup( name );
-}
-
-
 static void set_config_dir(void)
 {
     char *p, *dir;
@@ -327,9 +258,15 @@ static void set_config_dir(void)
     }
     else
     {
-        if (!home_dir) fatal_error( "could not determine your home directory\n" );
-        if (home_dir[0] != '/') fatal_error( "the home directory %s is not an absolute path\n", home_dir );
-        config_dir = build_path( home_dir, ".wine" );
+        const char *home = getenv( "HOME" );
+        if (!home)
+        {
+            struct passwd *pwd = getpwuid( getuid() );
+            if (pwd) home = pwd->pw_dir;
+        }
+        if (!home) fatal_error( "could not determine your home directory\n" );
+        if (home[0] != '/') fatal_error( "your home directory %s is not an absolute path\n", home );
+        config_dir = build_path( home, ".wine" );
     }
 }
 
@@ -337,6 +274,9 @@ static void init_paths( int argc, char *argv[], char *envp[] )
 {
     Dl_info info;
 
+    __wine_main_argc = main_argc = argc;
+    __wine_main_argv = main_argv = argv;
+    __wine_main_environ = main_envp = envp;
     argv0 = strdup( argv[0] );
 
     if (!dladdr( init_paths, &info ) || !(dll_dir = realpath_dirname( info.dli_fname )))
@@ -356,10 +296,139 @@ static void init_paths( int argc, char *argv[], char *envp[] )
     }
 
     set_dll_path();
-    set_home_dir();
     set_config_dir();
 }
 
+#if !defined(__APPLE__) && !defined(__ANDROID__)  /* these platforms always use UTF-8 */
+
+/* charset to codepage map, sorted by name */
+static const struct { const char *name; UINT cp; } charset_names[] =
+{
+    { "ANSIX341968", 20127 },
+    { "BIG5", 950 },
+    { "BIG5HKSCS", 950 },
+    { "CP1250", 1250 },
+    { "CP1251", 1251 },
+    { "CP1252", 1252 },
+    { "CP1253", 1253 },
+    { "CP1254", 1254 },
+    { "CP1255", 1255 },
+    { "CP1256", 1256 },
+    { "CP1257", 1257 },
+    { "CP1258", 1258 },
+    { "CP932", 932 },
+    { "CP936", 936 },
+    { "CP949", 949 },
+    { "CP950", 950 },
+    { "EUCJP", 20932 },
+    { "EUCKR", 949 },
+    { "GB18030", 936  /* 54936 */ },
+    { "GB2312", 936 },
+    { "GBK", 936 },
+    { "IBM037", 37 },
+    { "IBM1026", 1026 },
+    { "IBM424", 20424 },
+    { "IBM437", 437 },
+    { "IBM500", 500 },
+    { "IBM850", 850 },
+    { "IBM852", 852 },
+    { "IBM855", 855 },
+    { "IBM857", 857 },
+    { "IBM860", 860 },
+    { "IBM861", 861 },
+    { "IBM862", 862 },
+    { "IBM863", 863 },
+    { "IBM864", 864 },
+    { "IBM865", 865 },
+    { "IBM866", 866 },
+    { "IBM869", 869 },
+    { "IBM874", 874 },
+    { "IBM875", 875 },
+    { "ISO88591", 28591 },
+    { "ISO885913", 28603 },
+    { "ISO885915", 28605 },
+    { "ISO88592", 28592 },
+    { "ISO88593", 28593 },
+    { "ISO88594", 28594 },
+    { "ISO88595", 28595 },
+    { "ISO88596", 28596 },
+    { "ISO88597", 28597 },
+    { "ISO88598", 28598 },
+    { "ISO88599", 28599 },
+    { "KOI8R", 20866 },
+    { "KOI8U", 21866 },
+    { "TIS620", 28601 },
+    { "UTF8", CP_UTF8 }
+};
+
+static void load_unix_cptable( unsigned int cp )
+{
+    const char *dir = build_dir ? build_dir : data_dir;
+    struct stat st;
+    char *name;
+    void *data;
+    int fd;
+
+    if (!(name = malloc( strlen(dir) + 22 ))) return;
+    sprintf( name, "%s/nls/c_%03u.nls", dir, cp );
+    if ((fd = open( name, O_RDONLY )) != -1)
+    {
+        fstat( fd, &st );
+        if ((data = malloc( st.st_size )) && st.st_size > 0x10000 &&
+            read( fd, data, st.st_size ) == st.st_size)
+        {
+            RtlInitCodePageTable( data, &unix_table );
+        }
+        else
+        {
+            free( data );
+        }
+        close( fd );
+    }
+    else ERR( "failed to load %s\n", name );
+    free( name );
+}
+
+static void init_unix_codepage(void)
+{
+    char charset_name[16];
+    const char *name;
+    size_t i, j;
+    int min = 0, max = ARRAY_SIZE(charset_names) - 1;
+
+    setlocale( LC_CTYPE, "" );
+    if (!(name = nl_langinfo( CODESET ))) return;
+
+    /* remove punctuation characters from charset name */
+    for (i = j = 0; name[i] && j < sizeof(charset_name)-1; i++)
+    {
+        if (name[i] >= '0' && name[i] <= '9') charset_name[j++] = name[i];
+        else if (name[i] >= 'A' && name[i] <= 'Z') charset_name[j++] = name[i];
+        else if (name[i] >= 'a' && name[i] <= 'z') charset_name[j++] = name[i] + ('A' - 'a');
+    }
+    charset_name[j] = 0;
+
+    while (min <= max)
+    {
+        int pos = (min + max) / 2;
+        int res = strcmp( charset_names[pos].name, charset_name );
+        if (!res)
+        {
+            if (charset_names[pos].cp != CP_UTF8) load_unix_cptable( charset_names[pos].cp );
+            return;
+        }
+        if (res > 0) max = pos - 1;
+        else min = pos + 1;
+    }
+    ERR( "unrecognized charset '%s'\n", name );
+}
+
+#else  /* __APPLE__ || __ANDROID__ */
+
+static void init_unix_codepage(void) { }
+
+#endif  /* __APPLE__ || __ANDROID__ */
+
 
 /*********************************************************************
  *                  get_version
@@ -403,6 +472,55 @@ void CDECL get_host_version( const char **sysname, const char **release )
 }
 
 
+/*************************************************************************
+ *		get_main_args
+ *
+ * Return the initial arguments.
+ */
+static void CDECL get_main_args( int *argc, char **argv[], char **envp[] )
+{
+    *argc = main_argc;
+    *argv = main_argv;
+    *envp = main_envp;
+}
+
+
+/*************************************************************************
+ *		get_paths
+ *
+ * Return the various configuration paths.
+ */
+static void CDECL get_paths( const char **builddir, const char **datadir, const char **configdir )
+{
+    *builddir  = build_dir;
+    *datadir   = data_dir;
+    *configdir = config_dir;
+}
+
+
+/*************************************************************************
+ *		get_dll_path
+ *
+ * Return the various configuration paths.
+ */
+static void CDECL get_dll_path( const char ***paths, SIZE_T *maxlen )
+{
+    *paths = dll_paths;
+    *maxlen = dll_path_maxlen;
+}
+
+
+/*************************************************************************
+ *		get_unix_codepage
+ *
+ * Return the Unix codepage data.
+ */
+static void CDECL get_unix_codepage( CPTABLEINFO *table )
+{
+    *table = unix_table;
+}
+
+
 static void preloader_exec( char **argv )
 {
     if (use_preloader)
@@ -433,13 +551,13 @@ static void preloader_exec( char **argv )
     execv( argv[1], argv + 1 );
 }
 
-static NTSTATUS loader_exec( const char *loader, char **argv, client_cpu_t cpu )
+static NTSTATUS loader_exec( const char *loader, char **argv, int is_child_64bit )
 {
     char *p, *path;
 
     if (build_dir)
     {
-        argv[1] = build_path( build_dir, (cpu == CPU_x86_64) ? "loader/wine64" : "loader/wine" );
+        argv[1] = build_path( build_dir, is_child_64bit ? "loader/wine64" : "loader/wine" );
         preloader_exec( argv );
         return STATUS_INVALID_IMAGE_FORMAT;
     }
@@ -472,11 +590,9 @@ static NTSTATUS loader_exec( const char *loader, char **argv, client_cpu_t cpu )
  *
  * argv[0] and argv[1] must be reserved for the preloader and loader respectively.
  */
-NTSTATUS exec_wineloader( char **argv, int socketfd, const pe_image_info_t *pe_info )
+static NTSTATUS CDECL exec_wineloader( char **argv, int socketfd, int is_child_64bit,
+                                       ULONGLONG res_start, ULONGLONG res_end )
 {
-    int is_child_64bit = (pe_info->cpu == CPU_x86_64 || pe_info->cpu == CPU_ARM64);
-    ULONGLONG res_start = pe_info->base;
-    ULONGLONG res_end = pe_info->base + pe_info->map_size;
     const char *loader = argv0;
     const char *loader_env = getenv( "WINELOADER" );
     char preloader_reserve[64], socket_env[64];
@@ -516,7 +632,7 @@ NTSTATUS exec_wineloader( char **argv, int socketfd, const pe_image_info_t *pe_i
     putenv( preloader_reserve );
     putenv( socket_env );
 
-    return loader_exec( loader, argv, pe_info->cpu );
+    return loader_exec( loader, argv, is_child_64bit );
 }
 
 
@@ -570,7 +686,7 @@ static void exec_wineserver( char **argv )
  *
  * Start a new wine server.
  */
-void start_server( BOOL debug )
+static void CDECL start_server( BOOL debug )
 {
     static BOOL started;  /* we only try once */
     char *argv[3];
@@ -602,7 +718,7 @@ void start_server( BOOL debug )
  *
  * Map a builtin dll in memory and fixup RVAs.
  */
-static NTSTATUS map_so_dll( const IMAGE_NT_HEADERS *nt_descr, HMODULE module )
+static NTSTATUS CDECL map_so_dll( const IMAGE_NT_HEADERS *nt_descr, HMODULE module )
 {
     static const char builtin_signature[32] = "Wine builtin DLL";
     IMAGE_DATA_DIRECTORY *dir;
@@ -763,667 +879,124 @@ static ULONG_PTR find_ordinal_export( HMODULE module, const IMAGE_EXPORT_DIRECTO
 }
 
 static ULONG_PTR find_named_export( HMODULE module, const IMAGE_EXPORT_DIRECTORY *exports,
-                                    const char *name )
+                                    const IMAGE_IMPORT_BY_NAME *name )
 {
     const WORD *ordinals = (const WORD *)((BYTE *)module + exports->AddressOfNameOrdinals);
     const DWORD *names = (const DWORD *)((BYTE *)module + exports->AddressOfNames);
     int min = 0, max = exports->NumberOfNames - 1;
 
+    /* first check the hint */
+    if (name->Hint <= max)
+    {
+        char *ename = (char *)module + names[name->Hint];
+        if (!strcmp( ename, (char *)name->Name ))
+            return find_ordinal_export( module, exports, ordinals[name->Hint] );
+    }
+
+    /* then do a binary search */
     while (min <= max)
     {
         int res, pos = (min + max) / 2;
         char *ename = (char *)module + names[pos];
-        if (!(res = strcmp( ename, name ))) return find_ordinal_export( module, exports, ordinals[pos] );
+        if (!(res = strcmp( ename, (char *)name->Name )))
+            return find_ordinal_export( module, exports, ordinals[pos] );
         if (res > 0) max = pos - 1;
         else min = pos + 1;
     }
     return 0;
 }
 
-static ULONG_PTR find_pe_export( HMODULE module, const IMAGE_EXPORT_DIRECTORY *exports,
-                                 const IMAGE_IMPORT_BY_NAME *name )
-{
-    const WORD *ordinals = (const WORD *)((BYTE *)module + exports->AddressOfNameOrdinals);
-    const DWORD *names = (const DWORD *)((BYTE *)module + exports->AddressOfNames);
-
-    if (name->Hint < exports->NumberOfNames)
-    {
-        char *ename = (char *)module + names[name->Hint];
-        if (!strcmp( ename, (char *)name->Name ))
-            return find_ordinal_export( module, exports, ordinals[name->Hint] );
-    }
-    return find_named_export( module, exports, (char *)name->Name );
-}
-
-static void fixup_ntdll_imports( const IMAGE_NT_HEADERS *nt )
+static void fixup_ntdll_imports( const IMAGE_NT_HEADERS *nt, HMODULE ntdll_module )
 {
     const IMAGE_EXPORT_DIRECTORY *ntdll_exports = get_export_dir( ntdll_module );
     const IMAGE_IMPORT_DESCRIPTOR *descr;
     const IMAGE_THUNK_DATA *import_list;
     IMAGE_THUNK_DATA *thunk_list;
-    void **ptr;
 
     assert( ntdll_exports );
 
     descr = get_rva( nt, nt->OptionalHeader.DataDirectory[IMAGE_FILE_IMPORT_DIRECTORY].VirtualAddress );
-
-    /* ntdll must be the only import */
-    assert( !strcmp( get_rva( nt, descr->Name ), "ntdll.dll" ));
-    assert( !descr[1].Name );
-
-    thunk_list = get_rva( nt, (DWORD)descr->FirstThunk );
-    if (descr->u.OriginalFirstThunk)
-        import_list = get_rva( nt, (DWORD)descr->u.OriginalFirstThunk );
-    else
-        import_list = thunk_list;
-
-    while (import_list->u1.Ordinal)
+    while (descr->Name)
     {
-        if (IMAGE_SNAP_BY_ORDINAL( import_list->u1.Ordinal ))
-        {
-            int ordinal = IMAGE_ORDINAL( import_list->u1.Ordinal ) - ntdll_exports->Base;
-            thunk_list->u1.Function = find_ordinal_export( ntdll_module, ntdll_exports, ordinal );
-            if (!thunk_list->u1.Function) ERR( "ordinal %u not found\n", ordinal );
-        }
-        else  /* import by name */
-        {
-            IMAGE_IMPORT_BY_NAME *pe_name = get_rva( nt, import_list->u1.AddressOfData );
-            thunk_list->u1.Function = find_pe_export( ntdll_module, ntdll_exports, pe_name );
-            if (!thunk_list->u1.Function) ERR( "%s not found\n", pe_name->Name );
-        }
-        import_list++;
-        thunk_list++;
-    }
+        /* ntdll must be the only import */
+        assert( !strcmp( get_rva( nt, descr->Name ), "ntdll.dll" ));
 
-#define GET_FUNC(name) \
-    if (!(p##name = (void *)find_named_export( ntdll_module, ntdll_exports, #name ))) \
-        ERR( "%s not found\n", #name )
-
-    GET_FUNC( DbgUiRemoteBreakin );
-    GET_FUNC( KiRaiseUserExceptionDispatcher );
-    GET_FUNC( KiUserExceptionDispatcher );
-    GET_FUNC( KiUserApcDispatcher );
-    GET_FUNC( LdrInitializeThunk );
-    GET_FUNC( RtlUserThreadStart );
-    GET_FUNC( __wine_set_unix_funcs );
-#undef GET_FUNC
-#define SET_PTR(name,val) \
-    if ((ptr = (void *)find_named_export( ntdll_module, ntdll_exports, #name ))) *ptr = val; \
-    else ERR( "%s not found\n", #name )
-
-    SET_PTR( __wine_syscall_dispatcher, __wine_syscall_dispatcher );
-#ifdef __i386__
-    SET_PTR( __wine_ldt_copy, &__wine_ldt_copy );
-#endif
-#undef SET_PTR
-}
-
-
-static void *callback_module;
+        thunk_list = get_rva( nt, (DWORD)descr->FirstThunk );
+        if (descr->u.OriginalFirstThunk)
+            import_list = get_rva( nt, (DWORD)descr->u.OriginalFirstThunk );
+        else
+            import_list = thunk_list;
 
-/***********************************************************************
- *           load_builtin_callback
- *
- * Load a library in memory; callback function for wine_dll_register
- */
-static void load_builtin_callback( void *module, const char *filename )
-{
-    callback_module = module;
-}
-
-/***********************************************************************
- *           dlopen_dll
- */
-static NTSTATUS dlopen_dll( const char *so_name, void **ret_module )
-{
-    struct builtin_module *builtin;
-    void *module, *handle;
-    const IMAGE_NT_HEADERS *nt;
 
-    callback_module = (void *)1;
-    handle = dlopen( so_name, RTLD_NOW );
-    if (!handle)
-    {
-        WARN( "failed to load .so lib %s: %s\n", debugstr_a(so_name), dlerror() );
-        return STATUS_INVALID_IMAGE_FORMAT;
-    }
-    if (callback_module != (void *)1)  /* callback was called */
-    {
-        if (!callback_module) return STATUS_NO_MEMORY;
-        WARN( "got old-style builtin library %s, constructors won't work\n", debugstr_a(so_name) );
-        module = callback_module;
-        LIST_FOR_EACH_ENTRY( builtin, &builtin_modules, struct builtin_module, entry )
-            if (builtin->module == module) goto already_loaded;
-    }
-    else if ((nt = dlsym( handle, "__wine_spec_nt_header" )))
-    {
-        module = (HMODULE)((nt->OptionalHeader.ImageBase + 0xffff) & ~0xffff);
-        LIST_FOR_EACH_ENTRY( builtin, &builtin_modules, struct builtin_module, entry )
-            if (builtin->module == module) goto already_loaded;
-        if (map_so_dll( nt, module ))
+        while (import_list->u1.Ordinal)
         {
-            dlclose( handle );
-            return STATUS_NO_MEMORY;
-        }
-    }
-    else  /* already loaded .so */
-    {
-        WARN( "%s already loaded?\n", debugstr_a(so_name));
-        LIST_FOR_EACH_ENTRY( builtin, &builtin_modules, struct builtin_module, entry )
-            if (builtin->handle == handle) goto already_loaded;
-        return STATUS_INVALID_IMAGE_FORMAT;
-    }
-
-    if (add_builtin_module( module, handle, NULL ))
-    {
-        dlclose( handle );
-        return STATUS_NO_MEMORY;
-    }
-    virtual_create_builtin_view( module );
-    *ret_module = module;
-    return STATUS_SUCCESS;
-
-already_loaded:
-    *ret_module = builtin->module;
-    dlclose( handle );
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           load_so_dll
- */
-static NTSTATUS CDECL load_so_dll( UNICODE_STRING *nt_name, void **module )
-{
-    static const WCHAR soW[] = {'.','s','o',0};
-    char *unix_name;
-    NTSTATUS status;
-    DWORD len;
-
-    if (nt_to_unix_file_name( nt_name, &unix_name, FILE_OPEN )) return STATUS_DLL_NOT_FOUND;
-
-    /* remove .so extension from Windows name */
-    len = nt_name->Length / sizeof(WCHAR);
-    if (len > 3 && !wcsicmp( nt_name->Buffer + len - 3, soW )) nt_name->Length -= 3 * sizeof(WCHAR);
-
-    status = dlopen_dll( unix_name, module );
-    free( unix_name );
-    return status;
-}
-
-
-/* check if the library is the correct architecture */
-/* only returns false for a valid library of the wrong arch */
-static int check_library_arch( int fd )
-{
-#ifdef __APPLE__
-    struct  /* Mach-O header */
-    {
-        unsigned int magic;
-        unsigned int cputype;
-    } header;
-
-    if (read( fd, &header, sizeof(header) ) != sizeof(header)) return 1;
-    if (header.magic != 0xfeedface) return 1;
-    if (sizeof(void *) == sizeof(int)) return !(header.cputype >> 24);
-    else return (header.cputype >> 24) == 1; /* CPU_ARCH_ABI64 */
-#else
-    struct  /* ELF header */
-    {
-        unsigned char magic[4];
-        unsigned char class;
-        unsigned char data;
-        unsigned char version;
-    } header;
-
-    if (read( fd, &header, sizeof(header) ) != sizeof(header)) return 1;
-    if (memcmp( header.magic, "\177ELF", 4 )) return 1;
-    if (header.version != 1 /* EV_CURRENT */) return 1;
-#ifdef WORDS_BIGENDIAN
-    if (header.data != 2 /* ELFDATA2MSB */) return 1;
-#else
-    if (header.data != 1 /* ELFDATA2LSB */) return 1;
-#endif
-    if (sizeof(void *) == sizeof(int)) return header.class == 1; /* ELFCLASS32 */
-    else return header.class == 2; /* ELFCLASS64 */
-#endif
-}
-
-static inline char *prepend( char *buffer, const char *str, size_t len )
-{
-    return memcpy( buffer - len, str, len );
-}
-
-/***********************************************************************
- *	open_dll_file
- *
- * Open a file for a new dll. Helper for find_dll_file.
- */
-static NTSTATUS open_dll_file( const char *name, void **module, pe_image_info_t *image_info )
-{
-    struct builtin_module *builtin;
-    OBJECT_ATTRIBUTES attr = { sizeof(attr) };
-    LARGE_INTEGER size;
-    struct stat st;
-    SIZE_T len = 0;
-    NTSTATUS status;
-    HANDLE handle, mapping;
-
-    if ((status = open_unix_file( &handle, name, GENERIC_READ | SYNCHRONIZE, &attr, 0,
-                                  FILE_SHARE_READ | FILE_SHARE_DELETE, FILE_OPEN,
-                                  FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0 )))
-    {
-        if (status != STATUS_OBJECT_PATH_NOT_FOUND && status != STATUS_OBJECT_NAME_NOT_FOUND)
-        {
-            /* if the file exists but failed to open, report the error */
-            if (!stat( name, &st )) return status;
-        }
-        /* otherwise continue searching */
-        return STATUS_DLL_NOT_FOUND;
-    }
-
-    if (!stat( name, &st ))
-    {
-        LIST_FOR_EACH_ENTRY( builtin, &builtin_modules, struct builtin_module, entry )
-        {
-            if (builtin->id.dev == st.st_dev && builtin->id.ino == st.st_ino)
-            {
-                TRACE( "%s is the same file as existing module %p\n", debugstr_a(name),
-                       builtin->module );
-                NtClose( handle );
-                NtUnmapViewOfSection( NtCurrentProcess(), *module );
-                *module = builtin->module;
-                return STATUS_SUCCESS;
-            }
-        }
-    }
-    else memset( &st, 0, sizeof(st) );
-
-    size.QuadPart = 0;
-    status = NtCreateSection( &mapping, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY |
-                              SECTION_MAP_READ | SECTION_MAP_EXECUTE,
-                              NULL, &size, PAGE_EXECUTE_READ, SEC_IMAGE, handle );
-    NtClose( handle );
-    if (status) return status;
-
-    if (*module)
-    {
-        NtUnmapViewOfSection( NtCurrentProcess(), *module );
-        *module = NULL;
-    }
-    status = virtual_map_section( mapping, module, 0, 0, NULL, &len, 0, PAGE_EXECUTE_READ, image_info );
-    if (status == STATUS_IMAGE_NOT_AT_BASE) status = STATUS_SUCCESS;
-    NtClose( mapping );
-    if (status) return status;
-
-    /* ignore non-builtins */
-    if (!(image_info->image_flags & IMAGE_FLAGS_WineBuiltin))
-    {
-        WARN( "%s found in WINEDLLPATH but not a builtin, ignoring\n", debugstr_a(name) );
-        status = STATUS_DLL_NOT_FOUND;
-    }
-    else if (image_info->cpu != client_cpu)
-    {
-        TRACE( "%s is for CPU %u, continuing search\n", debugstr_a(name), image_info->cpu );
-        status = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
-    }
-
-    if (!status) status = add_builtin_module( *module, NULL, &st );
-
-    if (status)
-    {
-        NtUnmapViewOfSection( NtCurrentProcess(), *module );
-        *module = NULL;
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *           open_builtin_file
- */
-static NTSTATUS open_builtin_file( char *name, void **module, pe_image_info_t *image_info )
-{
-    NTSTATUS status;
-    int fd;
-
-    status = open_dll_file( name, module, image_info );
-    if (status != STATUS_DLL_NOT_FOUND) return status;
-
-    /* try .so file */
-
-    strcat( name, ".so" );
-    if ((fd = open( name, O_RDONLY )) != -1)
-    {
-        if (check_library_arch( fd ))
-        {
-            NtUnmapViewOfSection( NtCurrentProcess(), *module );
-            *module = NULL;
-            if (!dlopen_dll( name, module ))
+            if (IMAGE_SNAP_BY_ORDINAL( import_list->u1.Ordinal ))
             {
-                memset( image_info, 0, sizeof(*image_info) );
-                image_info->image_flags = IMAGE_FLAGS_WineBuiltin;
-                status = STATUS_SUCCESS;
+                int ordinal = IMAGE_ORDINAL( import_list->u1.Ordinal ) - ntdll_exports->Base;
+                thunk_list->u1.Function = find_ordinal_export( ntdll_module, ntdll_exports, ordinal );
+                if (!thunk_list->u1.Function) ERR( "ordinal %u not found\n", ordinal );
             }
-            else
+            else  /* import by name */
             {
-                ERR( "failed to load .so lib %s\n", debugstr_a(name) );
-                status = STATUS_PROCEDURE_NOT_FOUND;
+                IMAGE_IMPORT_BY_NAME *pe_name = get_rva( nt, import_list->u1.AddressOfData );
+                thunk_list->u1.Function = find_named_export( ntdll_module, ntdll_exports, pe_name );
+                if (!thunk_list->u1.Function) ERR( "%s not found\n", pe_name->Name );
             }
+            import_list++;
+            thunk_list++;
         }
-        else status = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
-        close( fd );
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *           load_builtin_dll
- */
-static NTSTATUS CDECL load_builtin_dll( const WCHAR *name, void **module, pe_image_info_t *image_info )
-{
-    unsigned int i, pos, len, namelen, maxlen = 0;
-    char *ptr, *file;
-    NTSTATUS status = STATUS_DLL_NOT_FOUND;
-    BOOL found_image = FALSE;
-
-    len = wcslen( name );
-    if (build_dir) maxlen = strlen(build_dir) + sizeof("/programs/") + len;
-    maxlen = max( maxlen, dll_path_maxlen + 1 ) + len + sizeof(".so");
-
-    if (!(file = malloc( maxlen ))) return STATUS_NO_MEMORY;
-
-    pos = maxlen - len - sizeof(".so");
-    /* we don't want to depend on the current codepage here */
-    for (i = 0; i < len; i++)
-    {
-        if (name[i] > 127) goto done;
-        file[pos + i] = (char)name[i];
-        if (file[pos + i] >= 'A' && file[pos + i] <= 'Z') file[pos + i] += 'a' - 'A';
-    }
-    file[--pos] = '/';
-
-    if (build_dir)
-    {
-        /* try as a dll */
-        ptr = file + pos;
-        namelen = len + 1;
-        file[pos + len + 1] = 0;
-        if (namelen > 4 && !memcmp( ptr + namelen - 4, ".dll", 4 )) namelen -= 4;
-        ptr = prepend( ptr, ptr, namelen );
-        ptr = prepend( ptr, "/dlls", sizeof("/dlls") - 1 );
-        ptr = prepend( ptr, build_dir, strlen(build_dir) );
-        status = open_builtin_file( ptr, module, image_info );
-        if (status != STATUS_DLL_NOT_FOUND) goto done;
-
-        /* now as a program */
-        ptr = file + pos;
-        namelen = len + 1;
-        file[pos + len + 1] = 0;
-        if (namelen > 4 && !memcmp( ptr + namelen - 4, ".exe", 4 )) namelen -= 4;
-        ptr = prepend( ptr, ptr, namelen );
-        ptr = prepend( ptr, "/programs", sizeof("/programs") - 1 );
-        ptr = prepend( ptr, build_dir, strlen(build_dir) );
-        status = open_builtin_file( ptr, module, image_info );
-        if (status != STATUS_DLL_NOT_FOUND) goto done;
-    }
-
-    for (i = 0; dll_paths[i]; i++)
-    {
-        file[pos + len + 1] = 0;
-        ptr = prepend( file + pos, dll_paths[i], strlen(dll_paths[i]) );
-        status = open_builtin_file( ptr, module, image_info );
-        if (status == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) found_image = TRUE;
-        else if (status != STATUS_DLL_NOT_FOUND) goto done;
-    }
-
-    if (found_image) status = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
-    WARN( "cannot find builtin library for %s\n", debugstr_w(name) );
-
-done:
-    free( file );
-    return status;
-}
-
-
-/***********************************************************************
- *           unload_builtin_dll
- */
-static NTSTATUS CDECL unload_builtin_dll( void *module )
-{
-    struct builtin_module *builtin;
-
-    LIST_FOR_EACH_ENTRY( builtin, &builtin_modules, struct builtin_module, entry )
-    {
-        if (builtin->module != module) continue;
-        list_remove( &builtin->entry );
-        if (builtin->handle) dlclose( builtin->handle );
-        free( builtin );
-        return STATUS_SUCCESS;
-    }
-    return STATUS_INVALID_PARAMETER;
-}
-
-
-#ifdef __FreeBSD__
-/* The PT_LOAD segments are sorted in increasing order, and the first
- * starts at the beginning of the ELF file. By parsing the file, we can
- * find that first PT_LOAD segment, from which we can find the base
- * address it wanted, and knowing mapbase where the binary was actually
- * loaded, use them to work out the relocbase offset. */
-static BOOL get_relocbase(caddr_t mapbase, caddr_t *relocbase)
-{
-    Elf_Half i;
-#ifdef _WIN64
-    const Elf64_Ehdr *elf_header = (Elf64_Ehdr*) mapbase;
-#else
-    const Elf32_Ehdr *elf_header = (Elf32_Ehdr*) mapbase;
-#endif
-    const Elf_Phdr *prog_header = (const Elf_Phdr *)(mapbase + elf_header->e_phoff);
-
-    for (i = 0; i < elf_header->e_phnum; i++)
-    {
-         if (prog_header->p_type == PT_LOAD)
-         {
-             caddr_t desired_base = (caddr_t)((prog_header->p_vaddr / prog_header->p_align) * prog_header->p_align);
-             *relocbase = (caddr_t) (mapbase - desired_base);
-             return TRUE;
-         }
-         prog_header++;
-    }
-    return FALSE;
-}
-#endif
-
-/*************************************************************************
- *              init_builtin_dll
- */
-static void CDECL init_builtin_dll( void *module )
-{
-#ifdef HAVE_DLINFO
-    struct builtin_module *builtin;
-    struct link_map *map;
-    void (*init_func)(int, char **, char **) = NULL;
-    void (**init_array)(int, char **, char **) = NULL;
-    ULONG_PTR i, init_arraysz = 0;
-#ifdef _WIN64
-    const Elf64_Dyn *dyn;
-#else
-    const Elf32_Dyn *dyn;
-#endif
-
-    LIST_FOR_EACH_ENTRY( builtin, &builtin_modules, struct builtin_module, entry )
-    {
-        if (builtin->module != module) continue;
-        if (!builtin->handle) break;
-        if (!dlinfo( builtin->handle, RTLD_DI_LINKMAP, &map )) goto found;
-        break;
-    }
-    return;
-
-found:
-    for (dyn = map->l_ld; dyn->d_tag; dyn++)
-    {
-        caddr_t relocbase = (caddr_t)map->l_addr;
 
-#ifdef __FreeBSD__
-        /* On older FreeBSD versions, l_addr was the absolute load address, now it's the relocation offset. */
-        if (!dlsym(RTLD_DEFAULT, "_rtld_version_laddr_offset"))
-            if (!get_relocbase(map->l_addr, &relocbase)) return;
-#endif
-        switch (dyn->d_tag)
-        {
-        case 0x60009990: init_array = (void *)(relocbase + dyn->d_un.d_val); break;
-        case 0x60009991: init_arraysz = dyn->d_un.d_val; break;
-        case 0x60009992: init_func = (void *)(relocbase + dyn->d_un.d_val); break;
-        }
+        descr++;
     }
-
-    TRACE( "%p: got init_func %p init_array %p %lu\n", module, init_func, init_array, init_arraysz );
-
-    if (init_func) init_func( main_argc, main_argv, main_envp );
-
-    if (init_array)
-        for (i = 0; i < init_arraysz / sizeof(*init_array); i++)
-            init_array[i]( main_argc, main_argv, main_envp );
-#endif
 }
 
-
 /***********************************************************************
  *           load_ntdll
  */
 static HMODULE load_ntdll(void)
 {
-    NTSTATUS status;
-    void *module;
-    int fd;
-    char *name = build_path( dll_dir, "ntdll.dll" );
-
-    if ((fd = open( name, O_RDONLY )) != -1)
-    {
-        struct stat st;
-        fstat( fd, &st );
-        if (!(status = virtual_map_ntdll( fd, &module )))
-            add_builtin_module( module, NULL, &st );
-        close( fd );
-    }
-    else
-    {
-        free( name );
-        name = build_path( dll_dir, "ntdll.dll.so" );
-        status = dlopen_dll( name, &module );
-    }
-    if (status) fatal_error( "failed to load %s error %x\n", name, status );
+    const IMAGE_NT_HEADERS *nt;
+    HMODULE module;
+    Dl_info info;
+    char *name;
+    void *handle;
+
+    name = build_path( dll_dir, "ntdll.dll.so" );
+    if (!dladdr( load_ntdll, &info )) fatal_error( "cannot get path to ntdll.so\n" );
+    name = malloc( strlen(info.dli_fname) + 5 );
+    strcpy( name, info.dli_fname );
+    strcpy( name + strlen(info.dli_fname) - 3, ".dll.so" );
+    if (!(handle = dlopen( name, RTLD_NOW ))) fatal_error( "failed to load %s: %s\n", name, dlerror() );
+    if (!(nt = dlsym( handle, "__wine_spec_nt_header" )))
+        fatal_error( "NT header not found in %s (too old?)\n", name );
+    dll_dir = realpath_dirname( name );
     free( name );
+    module = (HMODULE)((nt->OptionalHeader.ImageBase + 0xffff) & ~0xffff);
+    map_so_dll( nt, module );
     return module;
 }
 
 
-/***********************************************************************
- *           get_image_address
- */
-ULONG_PTR get_image_address(void)
-{
-#ifdef HAVE_GETAUXVAL
-    ULONG_PTR size, num, phdr_addr = getauxval( AT_PHDR );
-    ElfW(Phdr) *phdr;
-
-    if (!phdr_addr) return 0;
-    phdr = (ElfW(Phdr) *)phdr_addr;
-    size = getauxval( AT_PHENT );
-    num = getauxval( AT_PHNUM );
-    while (num--)
-    {
-        if (phdr->p_type == PT_PHDR) return phdr_addr - phdr->p_offset;
-        phdr = (ElfW(Phdr) *)((char *)phdr + size);
-    }
-#elif defined(__APPLE__) && defined(TASK_DYLD_INFO)
-    struct task_dyld_info dyld_info;
-    mach_msg_type_number_t size = TASK_DYLD_INFO_COUNT;
-
-    if (task_info(mach_task_self(), TASK_DYLD_INFO, (task_info_t)&dyld_info, &size) == KERN_SUCCESS)
-        return dyld_info.all_image_info_addr;
-#endif
-    return 0;
-}
-
-
-/* math function wrappers */
-static double CDECL ntdll_atan( double d )  { return atan( d ); }
-static double CDECL ntdll_ceil( double d )  { return ceil( d ); }
-static double CDECL ntdll_cos( double d )   { return cos( d ); }
-static double CDECL ntdll_fabs( double d )  { return fabs( d ); }
-static double CDECL ntdll_floor( double d ) { return floor( d ); }
-static double CDECL ntdll_log( double d )   { return log( d ); }
-static double CDECL ntdll_pow( double x, double y ) { return pow( x, y ); }
-static double CDECL ntdll_sin( double d )   { return sin( d ); }
-static double CDECL ntdll_sqrt( double d )  { return sqrt( d ); }
-static double CDECL ntdll_tan( double d )   { return tan( d ); }
-
-
 /***********************************************************************
  *           unix_funcs
  */
 static struct unix_funcs unix_funcs =
 {
-    NtCurrentTeb,
-    DbgUiIssueRemoteBreakin,
-    RtlGetSystemTimePrecise,
-    RtlWaitOnAddress,
-    RtlWakeAddressAll,
-    RtlWakeAddressSingle,
-    fast_RtlpWaitForCriticalSection,
-    fast_RtlpUnWaitCriticalSection,
-    fast_RtlDeleteCriticalSection,
-    fast_RtlTryAcquireSRWLockExclusive,
-    fast_RtlAcquireSRWLockExclusive,
-    fast_RtlTryAcquireSRWLockShared,
-    fast_RtlAcquireSRWLockShared,
-    fast_RtlReleaseSRWLockExclusive,
-    fast_RtlReleaseSRWLockShared,
-    fast_RtlSleepConditionVariableSRW,
-    fast_RtlSleepConditionVariableCS,
-    fast_RtlWakeConditionVariable,
-    ntdll_atan,
-    ntdll_ceil,
-    ntdll_cos,
-    ntdll_fabs,
-    ntdll_floor,
-    ntdll_log,
-    ntdll_pow,
-    ntdll_sin,
-    ntdll_sqrt,
-    ntdll_tan,
-    get_initial_environment,
-    get_startup_info,
-    get_dynamic_environment,
-    get_initial_console,
-    get_initial_directory,
-    get_unix_codepage_data,
-    get_locales,
+    get_main_args,
+    get_paths,
+    get_dll_path,
+    get_unix_codepage,
     get_version,
     get_build_id,
     get_host_version,
-    virtual_map_section,
-    virtual_locked_recvmsg,
-    virtual_release_address_space,
-    exec_process,
-    wine_server_call,
-    server_send_fd,
-    server_fd_to_handle,
-    server_handle_to_fd,
-    server_release_fd,
-    server_init_process_done,
-    wine_nt_to_unix_file_name,
-    wine_unix_to_nt_file_name,
-    set_show_dot_files,
-    load_so_dll,
-    load_builtin_dll,
-    unload_builtin_dll,
-    init_builtin_dll,
-    unwind_builtin_dll,
+    exec_wineloader,
+    start_server,
+    map_so_dll,
+    mmap_add_reserved_area,
+    mmap_remove_reserved_area,
+    mmap_is_in_reserved_area,
+    mmap_enum_reserved_areas,
+    dbg_init,
     __wine_dbg_get_channel_flags,
     __wine_dbg_strdup,
     __wine_dbg_output,
@@ -1431,28 +1004,6 @@ static struct unix_funcs unix_funcs =
 };
 
 
-/***********************************************************************
- *           start_main_thread
- */
-static void start_main_thread(void)
-{
-    BOOL suspend;
-    TEB *teb = virtual_alloc_first_teb();
-
-    signal_init_threading();
-    signal_alloc_thread( teb );
-    signal_init_thread( teb );
-    dbg_init();
-    server_init_process();
-    startup_info_size = server_init_thread( teb->Peb, &suspend );
-    virtual_map_user_shared_data();
-    init_cpu_info();
-    init_files();
-    NtCreateKeyedEvent( &keyed_event, GENERIC_READ | GENERIC_WRITE, NULL, 0 );
-    p__wine_set_unix_funcs( NTDLL_UNIXLIB_VERSION, &unix_funcs );
-}
-
-
 #ifdef __APPLE__
 struct apple_stack_info
 {
@@ -1462,7 +1013,7 @@ struct apple_stack_info
 
 static void *apple_wine_thread( void *arg )
 {
-    start_main_thread();
+    __wine_set_unix_funcs( NTDLL_UNIXLIB_VERSION, &unix_funcs );
     return NULL;
 }
 
@@ -1644,6 +1195,68 @@ static int pre_exec(void)
 #endif
 
 
+/***********************************************************************
+ *           set_process_name
+ *
+ * Change the process name in the ps output.
+ */
+static void set_process_name( int argc, char *argv[] )
+{
+    BOOL shift_strings;
+    char *p, *name;
+    int i;
+
+#ifdef HAVE_SETPROCTITLE
+    setproctitle("-%s", argv[1]);
+    shift_strings = FALSE;
+#else
+    p = argv[0];
+
+    shift_strings = (argc >= 2);
+    for (i = 1; i < argc; i++)
+    {
+        p += strlen(p) + 1;
+        if (p != argv[i])
+        {
+            shift_strings = FALSE;
+            break;
+        }
+    }
+#endif
+
+    if (shift_strings)
+    {
+        int offset = argv[1] - argv[0];
+        char *end = argv[argc-1] + strlen(argv[argc-1]) + 1;
+        memmove( argv[0], argv[1], end - argv[1] );
+        memset( end - offset, 0, offset );
+        for (i = 1; i < argc; i++)
+            argv[i-1] = argv[i] - offset;
+        argv[i-1] = NULL;
+    }
+    else
+    {
+        /* remove argv[0] */
+        memmove( argv, argv + 1, argc * sizeof(argv[0]) );
+    }
+
+    name = argv[0];
+    if ((p = strrchr( name, '\\' ))) name = p + 1;
+    if ((p = strrchr( name, '/' ))) name = p + 1;
+
+#if defined(HAVE_SETPROGNAME)
+    setprogname( name );
+#endif
+
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+    prctl( PR_SET_NAME, name );
+#endif  /* HAVE_PRCTL */
+}
+
+
 /***********************************************************************
  *           check_command_line
  *
@@ -1681,19 +1294,21 @@ static void check_command_line( int argc, char *argv[] )
  */
 void __wine_main( int argc, char *argv[], char *envp[] )
 {
+    HMODULE module;
+
     init_paths( argc, argv, envp );
 
     if (!getenv( "WINELOADERNOEXEC" ))  /* first time around */
     {
+        static char noexec[] = "WINELOADERNOEXEC=1";
+
+        putenv( noexec );
         check_command_line( argc, argv );
         if (pre_exec())
         {
-            static char noexec[] = "WINELOADERNOEXEC=1";
             char **new_argv = malloc( (argc + 2) * sizeof(*argv) );
-
             memcpy( new_argv + 1, argv, (argc + 1) * sizeof(*argv) );
-            putenv( noexec );
-            loader_exec( argv0, new_argv, client_cpu );
+            loader_exec( argv0, new_argv, is_win64 );
             fatal_error( "could not exec the wine loader\n" );
         }
     }
@@ -1707,14 +1322,53 @@ void __wine_main( int argc, char *argv[], char *envp[] )
 
     virtual_init();
 
-    ntdll_module = load_ntdll();
-    fixup_ntdll_imports( &__wine_spec_nt_header );
+    module = load_ntdll();
+    fixup_ntdll_imports( &__wine_spec_nt_header, module );
 
-    init_environment( argc, argv, envp );
-    wine_dll_set_callback( load_builtin_callback );
+    set_process_name( argc, argv );
+    init_unix_codepage();
 
 #ifdef __APPLE__
     apple_main_thread();
 #endif
-    start_main_thread();
+    __wine_set_unix_funcs( NTDLL_UNIXLIB_VERSION, &unix_funcs );
+}
+
+
+static int add_area( void *base, size_t size, void *arg )
+{
+    mmap_add_reserved_area( base, size );
+    return 0;
+}
+
+/***********************************************************************
+ *           __wine_init_unix_lib
+ *
+ * Lib entry point called by ntdll.dll.so if not yet initialized.
+ */
+NTSTATUS __cdecl __wine_init_unix_lib( HMODULE module, const void *ptr_in, void *ptr_out )
+{
+    const IMAGE_NT_HEADERS *nt = ptr_in;
+
+#ifdef __APPLE__
+    extern char **__wine_get_main_environment(void);
+    char **envp = __wine_get_main_environment();
+#else
+    char **envp = __wine_main_environ;
+#endif
+    init_paths( __wine_main_argc, __wine_main_argv, envp );
+
+    map_so_dll( nt, module );
+    fixup_ntdll_imports( &__wine_spec_nt_header, module );
+    set_process_name( __wine_main_argc, __wine_main_argv );
+    init_unix_codepage();
+    *(struct unix_funcs **)ptr_out = &unix_funcs;
+    wine_mmap_enum_reserved_areas( add_area, NULL, 0 );
+    return STATUS_SUCCESS;
+}
+
+BOOL WINAPI DECLSPEC_HIDDEN DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
+{
+    if (reason == DLL_PROCESS_ATTACH) LdrDisableThreadCalloutsForDll( inst );
+    return TRUE;
 }
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
deleted file mode 100644
index 37d0af1981..0000000000
--- a/dlls/ntdll/unix/process.c
+++ /dev/null
@@ -1,1668 +0,0 @@
-/*
- * NT process handling
- *
- * Copyright 1996-1998 Marcus Meissner
- * Copyright 2018, 2020 Alexandre Julliard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#ifdef HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef HAVE_SYS_TIME_H
-# include <sys/time.h>
-#endif
-#ifdef HAVE_SYS_TIMES_H
-# include <sys/times.h>
-#endif
-#include <sys/types.h>
-#ifdef HAVE_SYS_WAIT_H
-# include <sys/wait.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef __APPLE__
-# include <CoreFoundation/CoreFoundation.h>
-# include <pthread.h>
-#endif
-#ifdef HAVE_MACH_MACH_H
-# include <mach/mach.h>
-#endif
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winternl.h"
-#include "unix_private.h"
-#include "wine/exception.h"
-#include "wine/server.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(process);
-
-
-static ULONG execute_flags = MEM_EXECUTE_OPTION_DISABLE | (sizeof(void *) > sizeof(int) ?
-                                                           MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION |
-                                                           MEM_EXECUTE_OPTION_PERMANENT : 0);
-
-static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
-
-static const char * const cpu_names[] = { "x86", "x86_64", "PowerPC", "ARM", "ARM64" };
-
-static UINT process_error_mode;
-
-static char **build_argv( const UNICODE_STRING *cmdline, int reserved )
-{
-    char **argv, *arg, *src, *dst;
-    int argc, in_quotes = 0, bcount = 0, len = cmdline->Length / sizeof(WCHAR);
-
-    if (!(src = malloc( len * 3 + 1 ))) return NULL;
-    len = ntdll_wcstoumbs( cmdline->Buffer, len, src, len * 3, FALSE );
-    src[len++] = 0;
-
-    argc = reserved + 2 + len / 2;
-    argv = malloc( argc * sizeof(*argv) + len );
-    arg = dst = (char *)(argv + argc);
-    argc = reserved;
-    while (*src)
-    {
-        if ((*src == ' ' || *src == '\t') && !in_quotes)
-        {
-            /* skip the remaining spaces */
-            while (*src == ' ' || *src == '\t') src++;
-            if (!*src) break;
-            /* close the argument and copy it */
-            *dst++ = 0;
-            argv[argc++] = arg;
-            /* start with a new argument */
-            arg = dst;
-            bcount = 0;
-        }
-        else if (*src == '\\')
-        {
-            *dst++ = *src++;
-            bcount++;
-        }
-        else if (*src == '"')
-        {
-            if ((bcount & 1) == 0)
-            {
-                /* Preceded by an even number of '\', this is half that
-                 * number of '\', plus a '"' which we discard.
-                 */
-                dst -= bcount / 2;
-                src++;
-                if (in_quotes && *src == '"') *dst++ = *src++;
-                else in_quotes = !in_quotes;
-            }
-            else
-            {
-                /* Preceded by an odd number of '\', this is half that
-                 * number of '\' followed by a '"'
-                 */
-                dst -= bcount / 2 + 1;
-                *dst++ = *src++;
-            }
-            bcount = 0;
-        }
-        else  /* a regular character */
-        {
-            *dst++ = *src++;
-            bcount = 0;
-        }
-    }
-    *dst = 0;
-    argv[argc++] = arg;
-    argv[argc] = NULL;
-    return argv;
-}
-
-
-#ifdef __APPLE__
-/***********************************************************************
- *           terminate_main_thread
- *
- * On some versions of Mac OS X, the execve system call fails with
- * ENOTSUP if the process has multiple threads.  Wine is always multi-
- * threaded on Mac OS X because it specifically reserves the main thread
- * for use by the system frameworks (see apple_main_thread() in
- * libs/wine/loader.c).  So, when we need to exec without first forking,
- * we need to terminate the main thread first.  We do this by installing
- * a custom run loop source onto the main run loop and signaling it.
- * The source's "perform" callback is pthread_exit and it will be
- * executed on the main thread, terminating it.
- *
- * Returns TRUE if there's still hope the main thread has terminated or
- * will soon.  Return FALSE if we've given up.
- */
-static BOOL terminate_main_thread(void)
-{
-    static int delayms;
-
-    if (!delayms)
-    {
-        CFRunLoopSourceContext source_context = { 0 };
-        CFRunLoopSourceRef source;
-
-        source_context.perform = pthread_exit;
-        if (!(source = CFRunLoopSourceCreate( NULL, 0, &source_context )))
-            return FALSE;
-
-        CFRunLoopAddSource( CFRunLoopGetMain(), source, kCFRunLoopCommonModes );
-        CFRunLoopSourceSignal( source );
-        CFRunLoopWakeUp( CFRunLoopGetMain() );
-        CFRelease( source );
-
-        delayms = 20;
-    }
-
-    if (delayms > 1000)
-        return FALSE;
-
-    usleep(delayms * 1000);
-    delayms *= 2;
-
-    return TRUE;
-}
-#endif
-
-
-static inline const WCHAR *get_params_string( const RTL_USER_PROCESS_PARAMETERS *params,
-                                              const UNICODE_STRING *str )
-{
-    if (params->Flags & PROCESS_PARAMS_FLAG_NORMALIZED) return str->Buffer;
-    return (const WCHAR *)((const char *)params + (UINT_PTR)str->Buffer);
-}
-
-static inline DWORD append_string( void **ptr, const RTL_USER_PROCESS_PARAMETERS *params,
-                                   const UNICODE_STRING *str )
-{
-    const WCHAR *buffer = get_params_string( params, str );
-    memcpy( *ptr, buffer, str->Length );
-    *ptr = (WCHAR *)*ptr + str->Length / sizeof(WCHAR);
-    return str->Length;
-}
-
-/***********************************************************************
- *           create_startup_info
- */
-static startup_info_t *create_startup_info( const RTL_USER_PROCESS_PARAMETERS *params, DWORD *info_size )
-{
-    startup_info_t *info;
-    DWORD size;
-    void *ptr;
-
-    size = sizeof(*info);
-    size += params->CurrentDirectory.DosPath.Length;
-    size += params->DllPath.Length;
-    size += params->ImagePathName.Length;
-    size += params->CommandLine.Length;
-    size += params->WindowTitle.Length;
-    size += params->Desktop.Length;
-    size += params->ShellInfo.Length;
-    size += params->RuntimeInfo.Length;
-    size = (size + 1) & ~1;
-    *info_size = size;
-
-    if (!(info = calloc( size, 1 ))) return NULL;
-
-    info->debug_flags   = params->DebugFlags;
-    info->console_flags = params->ConsoleFlags;
-    info->console       = wine_server_obj_handle( params->ConsoleHandle );
-    info->hstdin        = wine_server_obj_handle( params->hStdInput );
-    info->hstdout       = wine_server_obj_handle( params->hStdOutput );
-    info->hstderr       = wine_server_obj_handle( params->hStdError );
-    info->x             = params->dwX;
-    info->y             = params->dwY;
-    info->xsize         = params->dwXSize;
-    info->ysize         = params->dwYSize;
-    info->xchars        = params->dwXCountChars;
-    info->ychars        = params->dwYCountChars;
-    info->attribute     = params->dwFillAttribute;
-    info->flags         = params->dwFlags;
-    info->show          = params->wShowWindow;
-
-    ptr = info + 1;
-    info->curdir_len = append_string( &ptr, params, &params->CurrentDirectory.DosPath );
-    info->dllpath_len = append_string( &ptr, params, &params->DllPath );
-    info->imagepath_len = append_string( &ptr, params, &params->ImagePathName );
-    info->cmdline_len = append_string( &ptr, params, &params->CommandLine );
-    info->title_len = append_string( &ptr, params, &params->WindowTitle );
-    info->desktop_len = append_string( &ptr, params, &params->Desktop );
-    info->shellinfo_len = append_string( &ptr, params, &params->ShellInfo );
-    info->runtime_len = append_string( &ptr, params, &params->RuntimeInfo );
-    return info;
-}
-
-
-/***************************************************************************
- *	is_builtin_path
- */
-static BOOL is_builtin_path( UNICODE_STRING *path, BOOL *is_64bit )
-{
-    static const WCHAR systemW[] = {'\\','?','?','\\','c',':','\\','w','i','n','d','o','w','s','\\',
-                                    's','y','s','t','e','m','3','2','\\'};
-    static const WCHAR wow64W[] = {'\\','?','?','\\','c',':','\\','w','i','n','d','o','w','s','\\',
-                                   's','y','s','w','o','w','6','4'};
-
-    *is_64bit = is_win64;
-    if (path->Length > sizeof(systemW) && !wcsnicmp( path->Buffer, systemW, ARRAY_SIZE(systemW) ))
-    {
-#ifndef _WIN64
-        if (NtCurrentTeb64() && NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR]) *is_64bit = TRUE;
-#endif
-        return TRUE;
-    }
-    if ((is_win64 || is_wow64) && path->Length > sizeof(wow64W) &&
-        !wcsnicmp( path->Buffer, wow64W, ARRAY_SIZE(wow64W) ))
-    {
-        *is_64bit = FALSE;
-        return TRUE;
-    }
-    return FALSE;
-}
-
-
-/***********************************************************************
- *           get_so_file_info
- */
-static BOOL get_so_file_info( HANDLE handle, pe_image_info_t *info )
-{
-    union
-    {
-        struct
-        {
-            unsigned char magic[4];
-            unsigned char class;
-            unsigned char data;
-            unsigned char version;
-            unsigned char ignored1[9];
-            unsigned short type;
-            unsigned short machine;
-            unsigned char ignored2[8];
-            unsigned int phoff;
-            unsigned char ignored3[12];
-            unsigned short phnum;
-        } elf;
-        struct
-        {
-            unsigned char magic[4];
-            unsigned char class;
-            unsigned char data;
-            unsigned char ignored1[10];
-            unsigned short type;
-            unsigned short machine;
-            unsigned char ignored2[12];
-            unsigned __int64 phoff;
-            unsigned char ignored3[16];
-            unsigned short phnum;
-        } elf64;
-        struct
-        {
-            unsigned int magic;
-            unsigned int cputype;
-            unsigned int cpusubtype;
-            unsigned int filetype;
-        } macho;
-        IMAGE_DOS_HEADER mz;
-    } header;
-
-    IO_STATUS_BLOCK io;
-    LARGE_INTEGER offset;
-
-    offset.QuadPart = 0;
-    if (NtReadFile( handle, 0, NULL, NULL, &io, &header, sizeof(header), &offset, 0 )) return FALSE;
-    if (io.Information != sizeof(header)) return FALSE;
-
-    if (!memcmp( header.elf.magic, "\177ELF", 4 ))
-    {
-        unsigned int type;
-        unsigned short phnum;
-
-        if (header.elf.version != 1 /* EV_CURRENT */) return FALSE;
-#ifdef WORDS_BIGENDIAN
-        if (header.elf.data != 2 /* ELFDATA2MSB */) return FALSE;
-#else
-        if (header.elf.data != 1 /* ELFDATA2LSB */) return FALSE;
-#endif
-        switch (header.elf.machine)
-        {
-        case 3:   info->cpu = CPU_x86; break;
-        case 40:  info->cpu = CPU_ARM; break;
-        case 62:  info->cpu = CPU_x86_64; break;
-        case 183: info->cpu = CPU_ARM64; break;
-        }
-        if (header.elf.type != 3 /* ET_DYN */) return FALSE;
-        if (header.elf.class == 2 /* ELFCLASS64 */)
-        {
-            offset.QuadPart = header.elf64.phoff;
-            phnum = header.elf64.phnum;
-        }
-        else
-        {
-            offset.QuadPart = header.elf.phoff;
-            phnum = header.elf.phnum;
-        }
-        while (phnum--)
-        {
-            if (NtReadFile( handle, 0, NULL, NULL, &io, &type, sizeof(type), &offset, 0 )) return FALSE;
-            if (io.Information < sizeof(type)) return FALSE;
-            if (type == 3 /* PT_INTERP */) return FALSE;
-            offset.QuadPart += (header.elf.class == 2) ? 56 : 32;
-        }
-        return TRUE;
-    }
-    else if (header.macho.magic == 0xfeedface || header.macho.magic == 0xfeedfacf)
-    {
-        switch (header.macho.cputype)
-        {
-        case 0x00000007: info->cpu = CPU_x86; break;
-        case 0x01000007: info->cpu = CPU_x86_64; break;
-        case 0x0000000c: info->cpu = CPU_ARM; break;
-        case 0x0100000c: info->cpu = CPU_ARM64; break;
-        }
-        if (header.macho.filetype == 8) return TRUE;
-    }
-    return FALSE;
-}
-
-
-/***********************************************************************
- *           get_pe_file_info
- */
-static NTSTATUS get_pe_file_info( UNICODE_STRING *path, HANDLE *handle, pe_image_info_t *info )
-{
-    NTSTATUS status;
-    HANDLE mapping;
-    OBJECT_ATTRIBUTES attr;
-    IO_STATUS_BLOCK io;
-
-    memset( info, 0, sizeof(*info) );
-    InitializeObjectAttributes( &attr, path, OBJ_CASE_INSENSITIVE, 0, 0 );
-    if ((status = NtOpenFile( handle, GENERIC_READ, &attr, &io,
-                              FILE_SHARE_READ | FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT )))
-    {
-        BOOL is_64bit;
-
-        if (is_builtin_path( path, &is_64bit ))
-        {
-            TRACE( "assuming %u-bit builtin for %s\n", is_64bit ? 64 : 32, debugstr_us(path));
-            /* assume current arch */
-#if defined(__i386__) || defined(__x86_64__)
-            info->cpu = is_64bit ? CPU_x86_64 : CPU_x86;
-#else
-            info->cpu = client_cpu;
-#endif
-            *handle = 0;
-            return STATUS_SUCCESS;
-        }
-        return status;
-    }
-
-    if (!(status = NtCreateSection( &mapping, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY |
-                                    SECTION_MAP_READ | SECTION_MAP_EXECUTE,
-                                    NULL, NULL, PAGE_EXECUTE_READ, SEC_IMAGE, *handle )))
-    {
-        SERVER_START_REQ( get_mapping_info )
-        {
-            req->handle = wine_server_obj_handle( mapping );
-            req->access = SECTION_QUERY;
-            wine_server_set_reply( req, info, sizeof(*info) );
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        NtClose( mapping );
-    }
-    else if (status == STATUS_INVALID_IMAGE_NOT_MZ)
-    {
-        if (get_so_file_info( *handle, info )) return STATUS_SUCCESS;
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *           get_env_size
- */
-static ULONG get_env_size( const RTL_USER_PROCESS_PARAMETERS *params, char **winedebug )
-{
-    WCHAR *ptr = params->Environment;
-
-    while (*ptr)
-    {
-        static const WCHAR WINEDEBUG[] = {'W','I','N','E','D','E','B','U','G','=',0};
-        if (!*winedebug && !wcsncmp( ptr, WINEDEBUG, ARRAY_SIZE( WINEDEBUG ) - 1 ))
-        {
-            DWORD len = wcslen(ptr) * 3 + 1;
-            if ((*winedebug = malloc( len )))
-                ntdll_wcstoumbs( ptr, wcslen(ptr) + 1, *winedebug, len, FALSE );
-        }
-        ptr += wcslen(ptr) + 1;
-    }
-    ptr++;
-    return (ptr - params->Environment) * sizeof(WCHAR);
-}
-
-
-/***********************************************************************
- *           get_unix_curdir
- */
-static int get_unix_curdir( const RTL_USER_PROCESS_PARAMETERS *params )
-{
-    static const WCHAR ntprefixW[] = {'\\','?','?','\\',0};
-    static const WCHAR uncprefixW[] = {'U','N','C','\\',0};
-    const UNICODE_STRING *curdir = &params->CurrentDirectory.DosPath;
-    const WCHAR *dir = curdir->Buffer;
-    UNICODE_STRING nt_name;
-    OBJECT_ATTRIBUTES attr;
-    IO_STATUS_BLOCK io;
-    NTSTATUS status;
-    HANDLE handle;
-    int fd = -1;
-
-    if (!(nt_name.Buffer = malloc( curdir->Length + 8 * sizeof(WCHAR) ))) return -1;
-
-    /* simplified version of RtlDosPathNameToNtPathName_U */
-    wcscpy( nt_name.Buffer, ntprefixW );
-    if (dir[0] == '\\' && dir[1] == '\\')
-    {
-        if ((dir[2] == '.' || dir[2] == '?') && dir[3] == '\\') dir += 4;
-        else
-        {
-            wcscat( nt_name.Buffer, uncprefixW );
-            dir += 2;
-        }
-    }
-    wcscat( nt_name.Buffer, dir );
-    nt_name.Length = wcslen( nt_name.Buffer ) * sizeof(WCHAR);
-
-    InitializeObjectAttributes( &attr, &nt_name, OBJ_CASE_INSENSITIVE, 0, NULL );
-    status = NtOpenFile( &handle, FILE_TRAVERSE | SYNCHRONIZE, &attr, &io,
-                         FILE_SHARE_READ | FILE_SHARE_WRITE,
-                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
-    free( nt_name.Buffer );
-    if (status) return -1;
-    server_handle_to_fd( handle, FILE_TRAVERSE, &fd, NULL );
-    NtClose( handle );
-    return fd;
-}
-
-
-/***********************************************************************
- *           set_stdio_fd
- */
-static void set_stdio_fd( int stdin_fd, int stdout_fd )
-{
-    int fd = -1;
-
-    if (stdin_fd == -1 || stdout_fd == -1)
-    {
-        fd = open( "/dev/null", O_RDWR );
-        if (stdin_fd == -1) stdin_fd = fd;
-        if (stdout_fd == -1) stdout_fd = fd;
-    }
-
-    dup2( stdin_fd, 0 );
-    dup2( stdout_fd, 1 );
-    if (fd != -1) close( fd );
-}
-
-
-/***********************************************************************
- *           spawn_process
- */
-static NTSTATUS spawn_process( const RTL_USER_PROCESS_PARAMETERS *params, int socketfd,
-                               int unixdir, char *winedebug, const pe_image_info_t *pe_info )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-    int stdin_fd = -1, stdout_fd = -1;
-    pid_t pid;
-    char **argv;
-
-    server_handle_to_fd( params->hStdInput, FILE_READ_DATA, &stdin_fd, NULL );
-    server_handle_to_fd( params->hStdOutput, FILE_WRITE_DATA, &stdout_fd, NULL );
-
-    if (!(pid = fork()))  /* child */
-    {
-        if (!(pid = fork()))  /* grandchild */
-        {
-            if (params->ConsoleFlags ||
-                params->ConsoleHandle == (HANDLE)1 /* KERNEL32_CONSOLE_ALLOC */ ||
-                (params->hStdInput == INVALID_HANDLE_VALUE && params->hStdOutput == INVALID_HANDLE_VALUE))
-            {
-                setsid();
-                set_stdio_fd( -1, -1 );  /* close stdin and stdout */
-            }
-            else set_stdio_fd( stdin_fd, stdout_fd );
-
-            if (stdin_fd != -1) close( stdin_fd );
-            if (stdout_fd != -1) close( stdout_fd );
-
-            if (winedebug) putenv( winedebug );
-            if (unixdir != -1)
-            {
-                fchdir( unixdir );
-                close( unixdir );
-            }
-            argv = build_argv( &params->CommandLine, 2 );
-
-            exec_wineloader( argv, socketfd, pe_info );
-            _exit(1);
-        }
-
-        _exit(pid == -1);
-    }
-
-    if (pid != -1)
-    {
-        /* reap child */
-        pid_t wret;
-        do {
-            wret = waitpid(pid, NULL, 0);
-        } while (wret < 0 && errno == EINTR);
-    }
-    else status = STATUS_NO_MEMORY;
-
-    if (stdin_fd != -1) close( stdin_fd );
-    if (stdout_fd != -1) close( stdout_fd );
-    return status;
-}
-
-
-/***********************************************************************
- *           exec_process
- */
-NTSTATUS CDECL exec_process( UNICODE_STRING *path, UNICODE_STRING *cmdline, NTSTATUS status )
-{
-    pe_image_info_t pe_info;
-    int unixdir, socketfd[2];
-    char **argv;
-    HANDLE handle;
-
-    if (startup_info_size) return status;  /* started from another Win32 process */
-
-    switch (status)
-    {
-    case STATUS_CONFLICTING_ADDRESSES:
-    case STATUS_NO_MEMORY:
-    case STATUS_INVALID_IMAGE_FORMAT:
-    case STATUS_INVALID_IMAGE_NOT_MZ:
-        if (getenv( "WINEPRELOADRESERVE" )) return status;
-        if ((status = get_pe_file_info( path, &handle, &pe_info ))) return status;
-        break;
-    case STATUS_INVALID_IMAGE_WIN_16:
-    case STATUS_INVALID_IMAGE_NE_FORMAT:
-    case STATUS_INVALID_IMAGE_PROTECT:
-        /* we'll start winevdm */
-        memset( &pe_info, 0, sizeof(pe_info) );
-        pe_info.cpu = CPU_x86;
-        break;
-    default:
-        return status;
-    }
-
-    unixdir = get_unix_curdir( NtCurrentTeb()->Peb->ProcessParameters );
-
-    if (socketpair( PF_UNIX, SOCK_STREAM, 0, socketfd ) == -1) return STATUS_TOO_MANY_OPENED_FILES;
-#ifdef SO_PASSCRED
-    else
-    {
-        int enable = 1;
-        setsockopt( socketfd[0], SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
-    }
-#endif
-    server_send_fd( socketfd[1] );
-    close( socketfd[1] );
-
-    SERVER_START_REQ( exec_process )
-    {
-        req->socket_fd = socketfd[1];
-        req->cpu       = pe_info.cpu;
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    if (!status)
-    {
-        if (!(argv = build_argv( cmdline, 2 ))) return STATUS_NO_MEMORY;
-        fchdir( unixdir );
-        do
-        {
-            status = exec_wineloader( argv, socketfd[0], &pe_info );
-        }
-#ifdef __APPLE__
-        while (errno == ENOTSUP && terminate_main_thread());
-#else
-        while (0);
-#endif
-        free( argv );
-    }
-    close( socketfd[0] );
-    return status;
-}
-
-
-/***********************************************************************
- *           fork_and_exec
- *
- * Fork and exec a new Unix binary, checking for errors.
- */
-static NTSTATUS fork_and_exec( UNICODE_STRING *path, int unixdir,
-                               const RTL_USER_PROCESS_PARAMETERS *params )
-{
-    pid_t pid;
-    int fd[2], stdin_fd = -1, stdout_fd = -1;
-    char **argv, **envp;
-    char *unix_name;
-    NTSTATUS status;
-
-    status = nt_to_unix_file_name( path, &unix_name, FILE_OPEN );
-    if (status) return status;
-
-#ifdef HAVE_PIPE2
-    if (pipe2( fd, O_CLOEXEC ) == -1)
-#endif
-    {
-        if (pipe(fd) == -1)
-        {
-            status = STATUS_TOO_MANY_OPENED_FILES;
-            goto done;
-        }
-        fcntl( fd[0], F_SETFD, FD_CLOEXEC );
-        fcntl( fd[1], F_SETFD, FD_CLOEXEC );
-    }
-
-    server_handle_to_fd( params->hStdInput, FILE_READ_DATA, &stdin_fd, NULL );
-    server_handle_to_fd( params->hStdOutput, FILE_WRITE_DATA, &stdout_fd, NULL );
-
-    if (!(pid = fork()))  /* child */
-    {
-        if (!(pid = fork()))  /* grandchild */
-        {
-            close( fd[0] );
-
-            if (params->ConsoleFlags ||
-                params->ConsoleHandle == (HANDLE)1 /* KERNEL32_CONSOLE_ALLOC */ ||
-                (params->hStdInput == INVALID_HANDLE_VALUE && params->hStdOutput == INVALID_HANDLE_VALUE))
-            {
-                setsid();
-                set_stdio_fd( -1, -1 );  /* close stdin and stdout */
-            }
-            else set_stdio_fd( stdin_fd, stdout_fd );
-
-            if (stdin_fd != -1) close( stdin_fd );
-            if (stdout_fd != -1) close( stdout_fd );
-
-            /* Reset signals that we previously set to SIG_IGN */
-            signal( SIGPIPE, SIG_DFL );
-
-            argv = build_argv( &params->CommandLine, 0 );
-            envp = build_envp( params->Environment );
-            if (unixdir != -1)
-            {
-                fchdir( unixdir );
-                close( unixdir );
-            }
-            execve( unix_name, argv, envp );
-        }
-
-        if (pid <= 0)  /* grandchild if exec failed or child if fork failed */
-        {
-            switch (errno)
-            {
-            case EPERM:
-            case EACCES: status = STATUS_ACCESS_DENIED; break;
-            case ENOENT: status = STATUS_OBJECT_NAME_NOT_FOUND; break;
-            case EMFILE:
-            case ENFILE: status = STATUS_TOO_MANY_OPENED_FILES; break;
-            case ENOEXEC:
-            case EINVAL: status = STATUS_INVALID_IMAGE_FORMAT; break;
-            default:     status = STATUS_NO_MEMORY; break;
-            }
-            write( fd[1], &status, sizeof(status) );
-            _exit(1);
-        }
-        _exit(0); /* child if fork succeeded */
-    }
-    close( fd[1] );
-
-    if (pid != -1)
-    {
-        /* reap child */
-        pid_t wret;
-        do {
-            wret = waitpid(pid, NULL, 0);
-        } while (wret < 0 && errno == EINTR);
-        read( fd[0], &status, sizeof(status) );  /* if we read something, exec or second fork failed */
-    }
-    else status = STATUS_NO_MEMORY;
-
-    close( fd[0] );
-    if (stdin_fd != -1) close( stdin_fd );
-    if (stdout_fd != -1) close( stdout_fd );
-done:
-    free( unix_name );
-    return status;
-}
-
-
-/**********************************************************************
- *           NtCreateUserProcess  (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateUserProcess( HANDLE *process_handle_ptr, HANDLE *thread_handle_ptr,
-                                     ACCESS_MASK process_access, ACCESS_MASK thread_access,
-                                     OBJECT_ATTRIBUTES *process_attr, OBJECT_ATTRIBUTES *thread_attr,
-                                     ULONG process_flags, ULONG thread_flags,
-                                     RTL_USER_PROCESS_PARAMETERS *params, PS_CREATE_INFO *info,
-                                     PS_ATTRIBUTE_LIST *attr )
-{
-    NTSTATUS status;
-    BOOL success = FALSE;
-    HANDLE file_handle, process_info = 0, process_handle = 0, thread_handle = 0;
-    struct object_attributes *objattr;
-    data_size_t attr_len;
-    char *winedebug = NULL;
-    startup_info_t *startup_info = NULL;
-    ULONG startup_info_size, env_size;
-    int unixdir, socketfd[2] = { -1, -1 };
-    pe_image_info_t pe_info;
-    CLIENT_ID id;
-    HANDLE parent = 0, debug = 0, token = 0;
-    UNICODE_STRING path = {0};
-    SIZE_T i, attr_count = (attr->TotalLength - sizeof(attr->TotalLength)) / sizeof(PS_ATTRIBUTE);
-
-    for (i = 0; i < attr_count; i++)
-    {
-        switch (attr->Attributes[i].Attribute)
-        {
-        case PS_ATTRIBUTE_PARENT_PROCESS:
-            parent = attr->Attributes[i].ValuePtr;
-            break;
-        case PS_ATTRIBUTE_DEBUG_PORT:
-            debug = attr->Attributes[i].ValuePtr;
-            break;
-        case PS_ATTRIBUTE_IMAGE_NAME:
-            path.Length = attr->Attributes[i].Size;
-            path.Buffer = attr->Attributes[i].ValuePtr;
-            break;
-        case PS_ATTRIBUTE_TOKEN:
-            token = attr->Attributes[i].ValuePtr;
-            break;
-        default:
-            if (attr->Attributes[i].Attribute & PS_ATTRIBUTE_INPUT)
-                FIXME( "unhandled input attribute %lx\n", attr->Attributes[i].Attribute );
-            break;
-        }
-    }
-
-    TRACE( "%s image %s cmdline %s parent %p\n", debugstr_us( &path ),
-           debugstr_us( &params->ImagePathName ), debugstr_us( &params->CommandLine ), parent );
-    if (debug) FIXME( "debug port %p not supported yet\n", debug );
-    if (token) FIXME( "token %p not supported yet\n", token );
-
-    unixdir = get_unix_curdir( params );
-
-    if ((status = get_pe_file_info( &path, &file_handle, &pe_info )))
-    {
-        if (status == STATUS_INVALID_IMAGE_NOT_MZ && !fork_and_exec( &path, unixdir, params ))
-        {
-            memset( info, 0, sizeof(*info) );
-            return STATUS_SUCCESS;
-        }
-        goto done;
-    }
-    if (!(startup_info = create_startup_info( params, &startup_info_size ))) goto done;
-    env_size = get_env_size( params, &winedebug );
-
-    if ((status = alloc_object_attributes( process_attr, &objattr, &attr_len ))) goto done;
-
-    /* create the socket for the new process */
-
-    if (socketpair( PF_UNIX, SOCK_STREAM, 0, socketfd ) == -1)
-    {
-        status = STATUS_TOO_MANY_OPENED_FILES;
-        free( objattr );
-        goto done;
-    }
-#ifdef SO_PASSCRED
-    else
-    {
-        int enable = 1;
-        setsockopt( socketfd[0], SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
-    }
-#endif
-
-    server_send_fd( socketfd[1] );
-    close( socketfd[1] );
-
-    /* create the process on the server side */
-
-    SERVER_START_REQ( new_process )
-    {
-        req->parent_process = wine_server_obj_handle( parent );
-        req->inherit_all    = !!(process_flags & PROCESS_CREATE_FLAGS_INHERIT_HANDLES);
-        req->create_flags   = params->DebugFlags; /* hack: creation flags stored in DebugFlags for now */
-        req->socket_fd      = socketfd[1];
-        req->exe_file       = wine_server_obj_handle( file_handle );
-        req->access         = process_access;
-        req->cpu            = pe_info.cpu;
-        req->info_size      = startup_info_size;
-        wine_server_add_data( req, objattr, attr_len );
-        wine_server_add_data( req, startup_info, startup_info_size );
-        wine_server_add_data( req, params->Environment, env_size );
-        if (!(status = wine_server_call( req )))
-        {
-            process_handle = wine_server_ptr_handle( reply->handle );
-            id.UniqueProcess = ULongToHandle( reply->pid );
-        }
-        process_info = wine_server_ptr_handle( reply->info );
-    }
-    SERVER_END_REQ;
-    free( objattr );
-
-    if (status)
-    {
-        switch (status)
-        {
-        case STATUS_INVALID_IMAGE_WIN_64:
-            ERR( "64-bit application %s not supported in 32-bit prefix\n", debugstr_us(&path) );
-            break;
-        case STATUS_INVALID_IMAGE_FORMAT:
-            ERR( "%s not supported on this installation (%s binary)\n",
-                 debugstr_us(&path), cpu_names[pe_info.cpu] );
-            break;
-        }
-        goto done;
-    }
-
-    if ((status = alloc_object_attributes( thread_attr, &objattr, &attr_len ))) goto done;
-
-    SERVER_START_REQ( new_thread )
-    {
-        req->process    = wine_server_obj_handle( process_handle );
-        req->access     = thread_access;
-        req->suspend    = !!(thread_flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED);
-        req->request_fd = -1;
-        wine_server_add_data( req, objattr, attr_len );
-        if (!(status = wine_server_call( req )))
-        {
-            thread_handle = wine_server_ptr_handle( reply->handle );
-            id.UniqueThread = ULongToHandle( reply->tid );
-        }
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    if (status) goto done;
-
-    /* create the child process */
-
-    if ((status = spawn_process( params, socketfd[0], unixdir, winedebug, &pe_info ))) goto done;
-
-    close( socketfd[0] );
-    socketfd[0] = -1;
-
-    /* wait for the new process info to be ready */
-
-    NtWaitForSingleObject( process_info, FALSE, NULL );
-    SERVER_START_REQ( get_new_process_info )
-    {
-        req->info = wine_server_obj_handle( process_info );
-        wine_server_call( req );
-        success = reply->success;
-        status = reply->exit_code;
-    }
-    SERVER_END_REQ;
-
-    if (!success)
-    {
-        if (!status) status = STATUS_INTERNAL_ERROR;
-        goto done;
-    }
-
-    TRACE( "%s pid %04x tid %04x handles %p/%p\n", debugstr_us(&path),
-           HandleToULong(id.UniqueProcess), HandleToULong(id.UniqueThread),
-           process_handle, thread_handle );
-
-    /* update output attributes */
-
-    for (i = 0; i < attr_count; i++)
-    {
-        switch (attr->Attributes[i].Attribute)
-        {
-        case PS_ATTRIBUTE_CLIENT_ID:
-        {
-            SIZE_T size = min( attr->Attributes[i].Size, sizeof(id) );
-            memcpy( attr->Attributes[i].ValuePtr, &id, size );
-            if (attr->Attributes[i].ReturnLength) *attr->Attributes[i].ReturnLength = size;
-            break;
-        }
-        case PS_ATTRIBUTE_IMAGE_INFO:
-        {
-            SECTION_IMAGE_INFORMATION info;
-            SIZE_T size = min( attr->Attributes[i].Size, sizeof(info) );
-            virtual_fill_image_information( &pe_info, &info );
-            memcpy( attr->Attributes[i].ValuePtr, &info, size );
-            if (attr->Attributes[i].ReturnLength) *attr->Attributes[i].ReturnLength = size;
-            break;
-        }
-        case PS_ATTRIBUTE_TEB_ADDRESS:
-        default:
-            if (!(attr->Attributes[i].Attribute & PS_ATTRIBUTE_INPUT))
-                FIXME( "unhandled output attribute %lx\n", attr->Attributes[i].Attribute );
-            break;
-        }
-    }
-    *process_handle_ptr = process_handle;
-    *thread_handle_ptr = thread_handle;
-    process_handle = thread_handle = 0;
-    status = STATUS_SUCCESS;
-
-done:
-    if (file_handle) NtClose( file_handle );
-    if (process_info) NtClose( process_info );
-    if (process_handle) NtClose( process_handle );
-    if (thread_handle) NtClose( thread_handle );
-    if (socketfd[0] != -1) close( socketfd[0] );
-    if (unixdir != -1) close( unixdir );
-    free( startup_info );
-    free( winedebug );
-    return status;
-}
-
-
-/******************************************************************************
- *              NtTerminateProcess  (NTDLL.@)
- */
-NTSTATUS WINAPI NtTerminateProcess( HANDLE handle, LONG exit_code )
-{
-    static BOOL clean_exit;
-    NTSTATUS ret;
-    BOOL self;
-
-    SERVER_START_REQ( terminate_process )
-    {
-        req->handle    = wine_server_obj_handle( handle );
-        req->exit_code = exit_code;
-        ret = wine_server_call( req );
-        self = reply->self;
-    }
-    SERVER_END_REQ;
-    if (self)
-    {
-        if (!handle) clean_exit = TRUE;
-        else if (clean_exit) exit_process( exit_code );
-        else abort_process( exit_code );
-    }
-    return ret;
-}
-
-
-#if defined(HAVE_MACH_MACH_H)
-
-void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid )
-{
-#if defined(MACH_TASK_BASIC_INFO)
-    struct mach_task_basic_info info;
-
-    if (unix_pid != -1) return; /* FIXME: Retrieve information for other processes. */
-
-    mach_msg_type_number_t infoCount = MACH_TASK_BASIC_INFO_COUNT;
-    if(task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &infoCount) == KERN_SUCCESS)
-    {
-        pvmi->VirtualSize = info.resident_size + info.virtual_size;
-        pvmi->PagefileUsage = info.virtual_size;
-        pvmi->WorkingSetSize = info.resident_size;
-        pvmi->PeakWorkingSetSize = info.resident_size_max;
-    }
-#endif
-}
-
-#elif defined(linux)
-
-void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid )
-{
-    FILE *f;
-    char line[256], path[26];
-    unsigned long value;
-
-    if (unix_pid == -1)
-        strcpy( path, "/proc/self/status" );
-    else
-        sprintf( path, "/proc/%u/status", unix_pid);
-    f = fopen( path, "r" );
-    if (!f) return;
-
-    while (fgets(line, sizeof(line), f))
-    {
-        if (sscanf(line, "VmPeak: %lu", &value))
-            pvmi->PeakVirtualSize = (ULONG64)value * 1024;
-        else if (sscanf(line, "VmSize: %lu", &value))
-            pvmi->VirtualSize = (ULONG64)value * 1024;
-        else if (sscanf(line, "VmHWM: %lu", &value))
-            pvmi->PeakWorkingSetSize = (ULONG64)value * 1024;
-        else if (sscanf(line, "VmRSS: %lu", &value))
-            pvmi->WorkingSetSize = (ULONG64)value * 1024;
-        else if (sscanf(line, "RssAnon: %lu", &value))
-            pvmi->PagefileUsage += (ULONG64)value * 1024;
-        else if (sscanf(line, "VmSwap: %lu", &value))
-            pvmi->PagefileUsage += (ULONG64)value * 1024;
-    }
-    pvmi->PeakPagefileUsage = pvmi->PagefileUsage;
-
-    fclose(f);
-}
-
-#else
-
-void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid )
-{
-    /* FIXME : real data */
-}
-
-#endif
-
-#define UNIMPLEMENTED_INFO_CLASS(c) \
-    case c: \
-        FIXME( "(process=%p) Unimplemented information class: " #c "\n", handle); \
-        ret = STATUS_INVALID_INFO_CLASS; \
-        break
-
-/**********************************************************************
- *           NtQueryInformationProcess  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class, void *info,
-                                           ULONG size, ULONG *ret_len )
-{
-    NTSTATUS ret = STATUS_SUCCESS;
-    ULONG len = 0;
-
-    TRACE( "(%p,0x%08x,%p,0x%08x,%p)\n", handle, class, info, size, ret_len );
-
-    switch (class)
-    {
-    UNIMPLEMENTED_INFO_CLASS(ProcessQuotaLimits);
-    UNIMPLEMENTED_INFO_CLASS(ProcessBasePriority);
-    UNIMPLEMENTED_INFO_CLASS(ProcessRaisePriority);
-    UNIMPLEMENTED_INFO_CLASS(ProcessExceptionPort);
-    UNIMPLEMENTED_INFO_CLASS(ProcessAccessToken);
-    UNIMPLEMENTED_INFO_CLASS(ProcessLdtInformation);
-    UNIMPLEMENTED_INFO_CLASS(ProcessLdtSize);
-    UNIMPLEMENTED_INFO_CLASS(ProcessIoPortHandlers);
-    UNIMPLEMENTED_INFO_CLASS(ProcessPooledUsageAndLimits);
-    UNIMPLEMENTED_INFO_CLASS(ProcessWorkingSetWatch);
-    UNIMPLEMENTED_INFO_CLASS(ProcessUserModeIOPL);
-    UNIMPLEMENTED_INFO_CLASS(ProcessEnableAlignmentFaultFixup);
-    UNIMPLEMENTED_INFO_CLASS(ProcessWx86Information);
-    UNIMPLEMENTED_INFO_CLASS(ProcessPriorityBoost);
-    UNIMPLEMENTED_INFO_CLASS(ProcessDeviceMap);
-    UNIMPLEMENTED_INFO_CLASS(ProcessSessionInformation);
-    UNIMPLEMENTED_INFO_CLASS(ProcessForegroundInformation);
-    UNIMPLEMENTED_INFO_CLASS(ProcessLUIDDeviceMapsEnabled);
-    UNIMPLEMENTED_INFO_CLASS(ProcessBreakOnTermination);
-    UNIMPLEMENTED_INFO_CLASS(ProcessHandleTracing);
-
-    case ProcessBasicInformation:
-        {
-            PROCESS_BASIC_INFORMATION pbi;
-            const ULONG_PTR affinity_mask = get_system_affinity_mask();
-
-            if (size >= sizeof(PROCESS_BASIC_INFORMATION))
-            {
-                if (!info) ret = STATUS_ACCESS_VIOLATION;
-                else
-                {
-                    SERVER_START_REQ(get_process_info)
-                    {
-                        req->handle = wine_server_obj_handle( handle );
-                        if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
-                        {
-                            pbi.ExitStatus = reply->exit_code;
-                            pbi.PebBaseAddress = wine_server_get_ptr( reply->peb );
-                            pbi.AffinityMask = reply->affinity & affinity_mask;
-                            pbi.BasePriority = reply->priority;
-                            pbi.UniqueProcessId = reply->pid;
-                            pbi.InheritedFromUniqueProcessId = reply->ppid;
-                        }
-                    }
-                    SERVER_END_REQ;
-
-                    memcpy( info, &pbi, sizeof(PROCESS_BASIC_INFORMATION) );
-                    len = sizeof(PROCESS_BASIC_INFORMATION);
-                }
-                if (size > sizeof(PROCESS_BASIC_INFORMATION)) ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-            else
-            {
-                len = sizeof(PROCESS_BASIC_INFORMATION);
-                ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-        }
-        break;
-
-    case ProcessIoCounters:
-        {
-            IO_COUNTERS pii;
-
-            if (size >= sizeof(IO_COUNTERS))
-            {
-                if (!info) ret = STATUS_ACCESS_VIOLATION;
-                else if (!handle) ret = STATUS_INVALID_HANDLE;
-                else
-                {
-                    /* FIXME : real data */
-                    memset(&pii, 0 , sizeof(IO_COUNTERS));
-                    memcpy(info, &pii, sizeof(IO_COUNTERS));
-                    len = sizeof(IO_COUNTERS);
-                }
-                if (size > sizeof(IO_COUNTERS)) ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-            else
-            {
-                len = sizeof(IO_COUNTERS);
-                ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-        }
-        break;
-
-    case ProcessVmCounters:
-        {
-            VM_COUNTERS_EX pvmi;
-
-            /* older Windows versions don't have the PrivateUsage field */
-            if (size >= sizeof(VM_COUNTERS))
-            {
-                if (!info) ret = STATUS_ACCESS_VIOLATION;
-                else
-                {
-                    memset(&pvmi, 0, sizeof(pvmi));
-                    if (handle == GetCurrentProcess()) fill_vm_counters( &pvmi, -1 );
-                    else
-                    {
-                        SERVER_START_REQ(get_process_vm_counters)
-                        {
-                            req->handle = wine_server_obj_handle( handle );
-                            if (!(ret = wine_server_call( req )))
-                            {
-                                pvmi.PeakVirtualSize = reply->peak_virtual_size;
-                                pvmi.VirtualSize = reply->virtual_size;
-                                pvmi.PeakWorkingSetSize = reply->peak_working_set_size;
-                                pvmi.WorkingSetSize = reply->working_set_size;
-                                pvmi.PagefileUsage = reply->pagefile_usage;
-                                pvmi.PeakPagefileUsage = reply->peak_pagefile_usage;
-                            }
-                        }
-                        SERVER_END_REQ;
-                        if (ret) break;
-                    }
-                    if (size >= sizeof(VM_COUNTERS_EX))
-                        pvmi.PrivateUsage = pvmi.PagefileUsage;
-                    len = size;
-                    if (len != sizeof(VM_COUNTERS)) len = sizeof(VM_COUNTERS_EX);
-                    memcpy(info, &pvmi, min(size, sizeof(pvmi)));
-                }
-                if (size != sizeof(VM_COUNTERS) && size != sizeof(VM_COUNTERS_EX))
-                    ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-            else
-            {
-                len = sizeof(pvmi);
-                ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-        }
-        break;
-
-    case ProcessTimes:
-        {
-            KERNEL_USER_TIMES pti = {{{0}}};
-
-            if (size >= sizeof(KERNEL_USER_TIMES))
-            {
-                if (!info) ret = STATUS_ACCESS_VIOLATION;
-                else if (!handle) ret = STATUS_INVALID_HANDLE;
-                else
-                {
-                    long ticks = sysconf(_SC_CLK_TCK);
-                    struct tms tms;
-
-                    /* FIXME: user/kernel times only work for current process */
-                    if (ticks && times( &tms ) != -1)
-                    {
-                        pti.UserTime.QuadPart = (ULONGLONG)tms.tms_utime * 10000000 / ticks;
-                        pti.KernelTime.QuadPart = (ULONGLONG)tms.tms_stime * 10000000 / ticks;
-                    }
-
-                    SERVER_START_REQ(get_process_info)
-                    {
-                        req->handle = wine_server_obj_handle( handle );
-                        if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
-                        {
-                            pti.CreateTime.QuadPart = reply->start_time;
-                            pti.ExitTime.QuadPart = reply->end_time;
-                        }
-                    }
-                    SERVER_END_REQ;
-
-                    memcpy(info, &pti, sizeof(KERNEL_USER_TIMES));
-                    len = sizeof(KERNEL_USER_TIMES);
-                }
-                if (size > sizeof(KERNEL_USER_TIMES)) ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-            else
-            {
-                len = sizeof(KERNEL_USER_TIMES);
-                ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-        }
-        break;
-
-    case ProcessDebugPort:
-        len = sizeof(DWORD_PTR);
-        if (size == len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else
-            {
-                SERVER_START_REQ(get_process_info)
-                {
-                    req->handle = wine_server_obj_handle( handle );
-                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
-                    {
-                        *(DWORD_PTR *)info = reply->debugger_present ? ~(DWORD_PTR)0 : 0;
-                    }
-                }
-                SERVER_END_REQ;
-            }
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case ProcessDebugFlags:
-        len = sizeof(DWORD);
-        if (size == len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else
-            {
-                SERVER_START_REQ(get_process_info)
-                {
-                    req->handle = wine_server_obj_handle( handle );
-                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
-                    {
-                        *(DWORD *)info = reply->debug_children;
-                    }
-                }
-                SERVER_END_REQ;
-            }
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case ProcessDefaultHardErrorMode:
-        len = sizeof(process_error_mode);
-        if (size == len) memcpy(info, &process_error_mode, len);
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case ProcessDebugObjectHandle:
-        /* "These are not the debuggers you are looking for." *
-         * set it to 0 aka "no debugger" to satisfy copy protections */
-        len = sizeof(HANDLE);
-        if (size == len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else if (!handle) ret = STATUS_INVALID_HANDLE;
-            else
-            {
-                memset(info, 0, size);
-                ret = STATUS_PORT_NOT_SET;
-            }
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case ProcessHandleCount:
-        if (size >= 4)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else if (!handle) ret = STATUS_INVALID_HANDLE;
-            else
-            {
-                memset(info, 0, 4);
-                len = 4;
-            }
-            if (size > 4) ret = STATUS_INFO_LENGTH_MISMATCH;
-        }
-        else
-        {
-            len = 4;
-            ret = STATUS_INFO_LENGTH_MISMATCH;
-        }
-        break;
-
-    case ProcessAffinityMask:
-        len = sizeof(ULONG_PTR);
-        if (size == len)
-        {
-            const ULONG_PTR system_mask = get_system_affinity_mask();
-
-            SERVER_START_REQ(get_process_info)
-            {
-                req->handle = wine_server_obj_handle( handle );
-                if (!(ret = wine_server_call( req )))
-                    *(ULONG_PTR *)info = reply->affinity & system_mask;
-            }
-            SERVER_END_REQ;
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case ProcessWow64Information:
-        len = sizeof(ULONG_PTR);
-        if (size != len) ret = STATUS_INFO_LENGTH_MISMATCH;
-        else if (!info) ret = STATUS_ACCESS_VIOLATION;
-        else if (!handle) ret = STATUS_INVALID_HANDLE;
-        else
-        {
-            ULONG_PTR val = 0;
-
-            if (handle == GetCurrentProcess()) val = is_wow64;
-            else if (server_cpus & ((1 << CPU_x86_64) | (1 << CPU_ARM64)))
-            {
-                SERVER_START_REQ( get_process_info )
-                {
-                    req->handle = wine_server_obj_handle( handle );
-                    if (!(ret = wine_server_call( req )))
-                        val = (reply->cpu != CPU_x86_64 && reply->cpu != CPU_ARM64);
-                }
-                SERVER_END_REQ;
-            }
-            *(ULONG_PTR *)info = val;
-        }
-        break;
-
-    case ProcessImageFileName:
-        /* FIXME: Should return a device path */
-    case ProcessImageFileNameWin32:
-        SERVER_START_REQ(get_dll_info)
-        {
-            UNICODE_STRING *image_file_name_str = info;
-
-            req->handle = wine_server_obj_handle( handle );
-            req->base_address = 0; /* main module */
-            wine_server_set_reply( req, image_file_name_str ? image_file_name_str + 1 : NULL,
-                                   size > sizeof(UNICODE_STRING) ? size - sizeof(UNICODE_STRING) : 0 );
-            ret = wine_server_call( req );
-            if (ret == STATUS_BUFFER_TOO_SMALL) ret = STATUS_INFO_LENGTH_MISMATCH;
-
-            len = sizeof(UNICODE_STRING) + reply->filename_len;
-            if (ret == STATUS_SUCCESS)
-            {
-                image_file_name_str->MaximumLength = image_file_name_str->Length = reply->filename_len;
-                image_file_name_str->Buffer = (PWSTR)(image_file_name_str + 1);
-            }
-        }
-        SERVER_END_REQ;
-        break;
-
-    case ProcessExecuteFlags:
-        len = sizeof(ULONG);
-        if (size == len) *(ULONG *)info = execute_flags;
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case ProcessPriorityClass:
-        len = sizeof(PROCESS_PRIORITY_CLASS);
-        if (size == len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else
-            {
-                PROCESS_PRIORITY_CLASS *priority = info;
-
-                SERVER_START_REQ(get_process_info)
-                {
-                    req->handle = wine_server_obj_handle( handle );
-                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
-                    {
-                        priority->PriorityClass = reply->priority;
-                        /* FIXME: Not yet supported by the wineserver */
-                        priority->Foreground = FALSE;
-                    }
-                }
-                SERVER_END_REQ;
-            }
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case ProcessCookie:
-        FIXME( "ProcessCookie (%p,%p,0x%08x,%p) stub\n", handle, info, size, ret_len );
-        if (handle == NtCurrentProcess())
-        {
-            len = sizeof(ULONG);
-            if (size == len) *(ULONG *)info = 0;
-            else ret = STATUS_INFO_LENGTH_MISMATCH;
-        }
-        else ret = STATUS_INVALID_PARAMETER;
-        break;
-
-    case ProcessImageInformation:
-        len = sizeof(SECTION_IMAGE_INFORMATION);
-        if (size == len)
-        {
-            if (info)
-            {
-                pe_image_info_t pe_info;
-
-                SERVER_START_REQ( get_process_info )
-                {
-                    req->handle = wine_server_obj_handle( handle );
-                    wine_server_set_reply( req, &pe_info, sizeof(pe_info) );
-                    if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
-                        virtual_fill_image_information( &pe_info, info );
-                }
-                SERVER_END_REQ;
-            }
-            else ret = STATUS_ACCESS_VIOLATION;
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    default:
-        FIXME("(%p,info_class=%d,%p,0x%08x,%p) Unknown information class\n",
-              handle, class, info, size, ret_len );
-        ret = STATUS_INVALID_INFO_CLASS;
-        break;
-    }
-
-    if (ret_len) *ret_len = len;
-    return ret;
-}
-
-
-/**********************************************************************
- *           NtSetInformationProcess  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetInformationProcess( HANDLE handle, PROCESSINFOCLASS class, void *info, ULONG size )
-{
-    NTSTATUS ret = STATUS_SUCCESS;
-
-    switch (class)
-    {
-    case ProcessDefaultHardErrorMode:
-        if (size != sizeof(UINT)) return STATUS_INVALID_PARAMETER;
-        process_error_mode = *(UINT *)info;
-        break;
-
-    case ProcessAffinityMask:
-    {
-        const ULONG_PTR system_mask = get_system_affinity_mask();
-
-        if (size != sizeof(DWORD_PTR)) return STATUS_INVALID_PARAMETER;
-        if (*(PDWORD_PTR)info & ~system_mask)
-            return STATUS_INVALID_PARAMETER;
-        if (!*(PDWORD_PTR)info)
-            return STATUS_INVALID_PARAMETER;
-        SERVER_START_REQ( set_process_info )
-        {
-            req->handle   = wine_server_obj_handle( handle );
-            req->affinity = *(PDWORD_PTR)info;
-            req->mask     = SET_PROCESS_INFO_AFFINITY;
-            ret = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        break;
-    }
-    case ProcessPriorityClass:
-        if (size != sizeof(PROCESS_PRIORITY_CLASS)) return STATUS_INVALID_PARAMETER;
-        else
-        {
-            PROCESS_PRIORITY_CLASS* ppc = info;
-
-            SERVER_START_REQ( set_process_info )
-            {
-                req->handle   = wine_server_obj_handle( handle );
-                /* FIXME Foreground isn't used */
-                req->priority = ppc->PriorityClass;
-                req->mask     = SET_PROCESS_INFO_PRIORITY;
-                ret = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-        }
-        break;
-
-    case ProcessExecuteFlags:
-        if (is_win64 || size != sizeof(ULONG)) return STATUS_INVALID_PARAMETER;
-        if (execute_flags & MEM_EXECUTE_OPTION_PERMANENT) return STATUS_ACCESS_DENIED;
-        else
-        {
-            BOOL enable;
-            switch (*(ULONG *)info & (MEM_EXECUTE_OPTION_ENABLE|MEM_EXECUTE_OPTION_DISABLE))
-            {
-            case MEM_EXECUTE_OPTION_ENABLE:
-                enable = TRUE;
-                break;
-            case MEM_EXECUTE_OPTION_DISABLE:
-                enable = FALSE;
-                break;
-            default:
-                return STATUS_INVALID_PARAMETER;
-            }
-            execute_flags = *(ULONG *)info;
-            virtual_set_force_exec( enable );
-        }
-        break;
-
-    case ProcessThreadStackAllocation:
-    {
-        void *addr = NULL;
-        SIZE_T reserve;
-        PROCESS_STACK_ALLOCATION_INFORMATION *stack = info;
-        if (size == sizeof(PROCESS_STACK_ALLOCATION_INFORMATION_EX))
-            stack = &((PROCESS_STACK_ALLOCATION_INFORMATION_EX *)info)->AllocInfo;
-        else if (size != sizeof(*stack)) return STATUS_INFO_LENGTH_MISMATCH;
-
-        reserve = stack->ReserveSize;
-        ret = NtAllocateVirtualMemory( GetCurrentProcess(), &addr, stack->ZeroBits, &reserve,
-                                       MEM_RESERVE, PAGE_READWRITE );
-        if (!ret)
-        {
-#ifdef VALGRIND_STACK_REGISTER
-            VALGRIND_STACK_REGISTER( addr, (char *)addr + reserve );
-#endif
-            stack->StackBase = addr;
-        }
-        break;
-    }
-
-    default:
-        FIXME( "(%p,0x%08x,%p,0x%08x) stub\n", handle, class, info, size );
-        ret = STATUS_NOT_IMPLEMENTED;
-        break;
-    }
-    return ret;
-}
-
-
-/**********************************************************************
- *           NtOpenProcess  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenProcess( HANDLE *handle, ACCESS_MASK access,
-                               const OBJECT_ATTRIBUTES *attr, const CLIENT_ID *id )
-{
-    NTSTATUS status;
-
-    SERVER_START_REQ( open_process )
-    {
-        req->pid        = HandleToULong( id->UniqueProcess );
-        req->access     = access;
-        req->attributes = attr ? attr->Attributes : 0;
-        status = wine_server_call( req );
-        if (!status) *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/**********************************************************************
- *           NtSuspendProcess  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSuspendProcess( HANDLE handle )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( suspend_process )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**********************************************************************
- *           NtResumeProcess  (NTDLL.@)
- */
-NTSTATUS WINAPI NtResumeProcess( HANDLE handle )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( resume_process )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
diff --git a/dlls/ntdll/unix/registry.c b/dlls/ntdll/unix/registry.c
deleted file mode 100644
index f94c8ff98e..0000000000
--- a/dlls/ntdll/unix/registry.c
+++ /dev/null
@@ -1,778 +0,0 @@
-/*
- * Registry functions
- *
- * Copyright 1999 Juergen Schmied
- * Copyright 2000 Alexandre Julliard
- * Copyright 2005 Ivan Leo Puoti, Laurent Pinchart
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- *
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include <stdarg.h>
-#include <string.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(reg);
-
-/* maximum length of a value name in bytes (without terminating null) */
-#define MAX_VALUE_LENGTH (16383 * sizeof(WCHAR))
-
-
-/******************************************************************************
- *              NtCreateKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateKey( HANDLE *key, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                             ULONG index, const UNICODE_STRING *class, ULONG options, ULONG *dispos )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if (!key || !attr) return STATUS_ACCESS_VIOLATION;
-    if (attr->Length > sizeof(OBJECT_ATTRIBUTES)) return STATUS_INVALID_PARAMETER;
-
-    TRACE( "(%p,%s,%s,%x,%x,%p)\n", attr->RootDirectory, debugstr_us(attr->ObjectName),
-           debugstr_us(class), options, access, key );
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_key )
-    {
-        req->access     = access;
-        req->options    = options;
-        wine_server_add_data( req, objattr, len );
-        if (class) wine_server_add_data( req, class->Buffer, class->Length );
-        ret = wine_server_call( req );
-        *key = wine_server_ptr_handle( reply->hkey );
-        if (dispos && !ret) *dispos = reply->created ? REG_CREATED_NEW_KEY : REG_OPENED_EXISTING_KEY;
-    }
-    SERVER_END_REQ;
-
-    TRACE( "<- %p\n", *key );
-    free( objattr );
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtCreateKeyTransacted  (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateKeyTransacted( HANDLE *key, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                                       ULONG index, const UNICODE_STRING *class, ULONG options,
-                                       HANDLE transacted, ULONG *dispos )
-{
-    FIXME( "(%p,%s,%s,%x,%x,%p,%p)\n", attr->RootDirectory, debugstr_us(attr->ObjectName),
-           debugstr_us(class), options, access, transacted, key );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtOpenKeyEx  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenKeyEx( HANDLE *key, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, ULONG options )
-{
-    NTSTATUS ret;
-
-    if (!key || !attr || !attr->ObjectName) return STATUS_ACCESS_VIOLATION;
-    if (attr->Length != sizeof(*attr)) return STATUS_INVALID_PARAMETER;
-    if (attr->ObjectName->Length & 1) return STATUS_OBJECT_NAME_INVALID;
-
-    TRACE( "(%p,%s,%x,%p)\n", attr->RootDirectory, debugstr_us(attr->ObjectName), access, key );
-
-    if (options & ~REG_OPTION_OPEN_LINK) FIXME( "options %x not implemented\n", options );
-
-    SERVER_START_REQ( open_key )
-    {
-        req->parent     = wine_server_obj_handle( attr->RootDirectory );
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *key = wine_server_ptr_handle( reply->hkey );
-    }
-    SERVER_END_REQ;
-    TRACE("<- %p\n", *key);
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtOpenKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenKey( HANDLE *key, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    return NtOpenKeyEx( key, access, attr, 0 );
-}
-
-
-/******************************************************************************
- *              NtOpenKeyTransactedEx  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenKeyTransactedEx( HANDLE *key, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                                       ULONG options, HANDLE transaction )
-{
-    FIXME( "(%p %x %p %x %p)\n", key, access, attr, options, transaction );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtOpenKeyTransacted  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenKeyTransacted( HANDLE *key, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                                     HANDLE transaction )
-{
-    return NtOpenKeyTransactedEx( key, access, attr, 0, transaction );
-}
-
-
-/******************************************************************************
- *              NtDeleteKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtDeleteKey( HANDLE key )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p)\n", key );
-
-    SERVER_START_REQ( delete_key )
-    {
-        req->hkey = wine_server_obj_handle( key );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtRenameKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtRenameKey( HANDLE handle, UNICODE_STRING *name )
-{
-    FIXME( "(%p %s)\n", handle, debugstr_us(name) );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *     enumerate_key
- *
- * Implementation of NtQueryKey and NtEnumerateKey
- */
-static NTSTATUS enumerate_key( HANDLE handle, int index, KEY_INFORMATION_CLASS info_class,
-                               void *info, DWORD length, DWORD *result_len )
-
-{
-    NTSTATUS ret;
-    void *data_ptr;
-    size_t fixed_size;
-
-    switch (info_class)
-    {
-    case KeyBasicInformation:  data_ptr = ((KEY_BASIC_INFORMATION *)info)->Name; break;
-    case KeyFullInformation:   data_ptr = ((KEY_FULL_INFORMATION *)info)->Class; break;
-    case KeyNodeInformation:   data_ptr = ((KEY_NODE_INFORMATION *)info)->Name;  break;
-    case KeyNameInformation:   data_ptr = ((KEY_NAME_INFORMATION *)info)->Name;  break;
-    case KeyCachedInformation: data_ptr = ((KEY_CACHED_INFORMATION *)info)+1;    break;
-    default:
-        FIXME( "Information class %d not implemented\n", info_class );
-        return STATUS_INVALID_PARAMETER;
-    }
-    fixed_size = (char *)data_ptr - (char *)info;
-
-    SERVER_START_REQ( enum_key )
-    {
-        req->hkey       = wine_server_obj_handle( handle );
-        req->index      = index;
-        req->info_class = info_class;
-        if (length > fixed_size) wine_server_set_reply( req, data_ptr, length - fixed_size );
-        if (!(ret = wine_server_call( req )))
-        {
-            switch (info_class)
-            {
-            case KeyBasicInformation:
-            {
-                KEY_BASIC_INFORMATION keyinfo;
-                fixed_size = (char *)keyinfo.Name - (char *)&keyinfo;
-                keyinfo.LastWriteTime.QuadPart = reply->modif;
-                keyinfo.TitleIndex = 0;
-                keyinfo.NameLength = reply->namelen;
-                memcpy( info, &keyinfo, min( length, fixed_size ) );
-            break;
-            }
-
-            case KeyFullInformation:
-            {
-                KEY_FULL_INFORMATION keyinfo;
-                fixed_size = (char *)keyinfo.Class - (char *)&keyinfo;
-                keyinfo.LastWriteTime.QuadPart = reply->modif;
-                keyinfo.TitleIndex = 0;
-                keyinfo.ClassLength = wine_server_reply_size(reply);
-                keyinfo.ClassOffset = keyinfo.ClassLength ? fixed_size : -1;
-                keyinfo.SubKeys = reply->subkeys;
-                keyinfo.MaxNameLen = reply->max_subkey;
-                keyinfo.MaxClassLen = reply->max_class;
-                keyinfo.Values = reply->values;
-                keyinfo.MaxValueNameLen = reply->max_value;
-                keyinfo.MaxValueDataLen = reply->max_data;
-                memcpy( info, &keyinfo, min( length, fixed_size ) );
-                break;
-            }
-
-            case KeyNodeInformation:
-            {
-                KEY_NODE_INFORMATION keyinfo;
-                fixed_size = (char *)keyinfo.Name - (char *)&keyinfo;
-                keyinfo.LastWriteTime.QuadPart = reply->modif;
-                keyinfo.TitleIndex = 0;
-                if (reply->namelen < wine_server_reply_size(reply))
-                {
-                    keyinfo.ClassLength = wine_server_reply_size(reply) - reply->namelen;
-                    keyinfo.ClassOffset = fixed_size + reply->namelen;
-                }
-                else
-                {
-                    keyinfo.ClassLength = 0;
-                    keyinfo.ClassOffset = -1;
-                }
-                keyinfo.NameLength = reply->namelen;
-                memcpy( info, &keyinfo, min( length, fixed_size ) );
-                break;
-            }
-
-            case KeyNameInformation:
-            {
-                KEY_NAME_INFORMATION keyinfo;
-                fixed_size = (char *)keyinfo.Name - (char *)&keyinfo;
-                keyinfo.NameLength = reply->namelen;
-                memcpy( info, &keyinfo, min( length, fixed_size ) );
-                break;
-            }
-
-            case KeyCachedInformation:
-            {
-                KEY_CACHED_INFORMATION keyinfo;
-                fixed_size = sizeof(keyinfo);
-                keyinfo.LastWriteTime.QuadPart = reply->modif;
-                keyinfo.TitleIndex = 0;
-                keyinfo.SubKeys = reply->subkeys;
-                keyinfo.MaxNameLen = reply->max_subkey;
-                keyinfo.Values = reply->values;
-                keyinfo.MaxValueNameLen = reply->max_value;
-                keyinfo.MaxValueDataLen = reply->max_data;
-                keyinfo.NameLength = reply->namelen;
-                memcpy( info, &keyinfo, min( length, fixed_size ) );
-                break;
-            }
-
-            default:
-                break;
-            }
-            *result_len = fixed_size + reply->total;
-            if (length < *result_len) ret = STATUS_BUFFER_OVERFLOW;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtEnumerateKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtEnumerateKey( HANDLE handle, ULONG index, KEY_INFORMATION_CLASS info_class,
-                                void *info, DWORD length, DWORD *result_len )
-{
-    /* -1 means query key, so avoid it here */
-    if (index == (ULONG)-1) return STATUS_NO_MORE_ENTRIES;
-    return enumerate_key( handle, index, info_class, info, length, result_len );
-}
-
-
-/******************************************************************************
- *              NtQueryKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryKey( HANDLE handle, KEY_INFORMATION_CLASS info_class,
-                            void *info, DWORD length, DWORD *result_len )
-{
-    return enumerate_key( handle, -1, info_class, info, length, result_len );
-}
-
-
-/******************************************************************************
- *              NtSetInformationKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetInformationKey( HANDLE key, int class, void *info, ULONG length )
-{
-    FIXME( "(%p,0x%08x,%p,0x%08x) stub\n", key, class, info, length );
-    return STATUS_SUCCESS;
-}
-
-
-/* fill the key value info structure for a specific info class */
-static void copy_key_value_info( KEY_VALUE_INFORMATION_CLASS info_class, void *info,
-                                 DWORD length, int type, int name_len, int data_len )
-{
-    switch (info_class)
-    {
-    case KeyValueBasicInformation:
-    {
-        KEY_VALUE_BASIC_INFORMATION keyinfo;
-        keyinfo.TitleIndex = 0;
-        keyinfo.Type       = type;
-        keyinfo.NameLength = name_len;
-        length = min( length, (char *)keyinfo.Name - (char *)&keyinfo );
-        memcpy( info, &keyinfo, length );
-        break;
-    }
-
-    case KeyValueFullInformation:
-    {
-        KEY_VALUE_FULL_INFORMATION keyinfo;
-        keyinfo.TitleIndex = 0;
-        keyinfo.Type       = type;
-        keyinfo.DataOffset = (char *)keyinfo.Name - (char *)&keyinfo + name_len;
-        keyinfo.DataLength = data_len;
-        keyinfo.NameLength = name_len;
-        length = min( length, (char *)keyinfo.Name - (char *)&keyinfo );
-        memcpy( info, &keyinfo, length );
-        break;
-    }
-
-    case KeyValuePartialInformation:
-    {
-        KEY_VALUE_PARTIAL_INFORMATION keyinfo;
-        keyinfo.TitleIndex = 0;
-        keyinfo.Type       = type;
-        keyinfo.DataLength = data_len;
-        length = min( length, (char *)keyinfo.Data - (char *)&keyinfo );
-        memcpy( info, &keyinfo, length );
-        break;
-    }
-
-    default:
-        break;
-    }
-}
-
-
-/******************************************************************************
- *              NtEnumerateValueKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtEnumerateValueKey( HANDLE handle, ULONG index, KEY_VALUE_INFORMATION_CLASS info_class,
-                                     void *info, DWORD length, DWORD *result_len )
-{
-    NTSTATUS ret;
-    void *ptr;
-    size_t fixed_size;
-
-    TRACE( "(%p,%u,%d,%p,%d)\n", handle, index, info_class, info, length );
-
-    /* compute the length we want to retrieve */
-    switch (info_class)
-    {
-    case KeyValueBasicInformation:   ptr = ((KEY_VALUE_BASIC_INFORMATION *)info)->Name; break;
-    case KeyValueFullInformation:    ptr = ((KEY_VALUE_FULL_INFORMATION *)info)->Name; break;
-    case KeyValuePartialInformation: ptr = ((KEY_VALUE_PARTIAL_INFORMATION *)info)->Data; break;
-    default:
-        FIXME( "Information class %d not implemented\n", info_class );
-        return STATUS_INVALID_PARAMETER;
-    }
-    fixed_size = (char *)ptr - (char *)info;
-
-    SERVER_START_REQ( enum_key_value )
-    {
-        req->hkey       = wine_server_obj_handle( handle );
-        req->index      = index;
-        req->info_class = info_class;
-        if (length > fixed_size) wine_server_set_reply( req, ptr, length - fixed_size );
-        if (!(ret = wine_server_call( req )))
-        {
-            copy_key_value_info( info_class, info, length, reply->type, reply->namelen,
-                                 wine_server_reply_size(reply) - reply->namelen );
-            *result_len = fixed_size + reply->total;
-            if (length < *result_len) ret = STATUS_BUFFER_OVERFLOW;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtQueryValueKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryValueKey( HANDLE handle, const UNICODE_STRING *name,
-                                 KEY_VALUE_INFORMATION_CLASS info_class,
-                                 void *info, DWORD length, DWORD *result_len )
-{
-    NTSTATUS ret;
-    UCHAR *data_ptr;
-    unsigned int fixed_size, min_size;
-
-    TRACE( "(%p,%s,%d,%p,%d)\n", handle, debugstr_us(name), info_class, info, length );
-
-    if (name->Length > MAX_VALUE_LENGTH) return STATUS_OBJECT_NAME_NOT_FOUND;
-
-    /* compute the length we want to retrieve */
-    switch(info_class)
-    {
-    case KeyValueBasicInformation:
-    {
-        KEY_VALUE_BASIC_INFORMATION *basic_info = info;
-        min_size = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name);
-        fixed_size = min_size + name->Length;
-        if (min_size < length)
-            memcpy(basic_info->Name, name->Buffer, min(length - min_size, name->Length));
-        data_ptr = NULL;
-        break;
-    }
-
-    case KeyValueFullInformation:
-    {
-        KEY_VALUE_FULL_INFORMATION *full_info = info;
-        min_size = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name);
-        fixed_size = min_size + name->Length;
-        if (min_size < length)
-            memcpy(full_info->Name, name->Buffer, min(length - min_size, name->Length));
-        data_ptr = (UCHAR *)full_info->Name + name->Length;
-        break;
-    }
-
-    case KeyValuePartialInformation:
-        min_size = fixed_size = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
-        data_ptr = ((KEY_VALUE_PARTIAL_INFORMATION *)info)->Data;
-        break;
-
-    default:
-        FIXME( "Information class %d not implemented\n", info_class );
-        return STATUS_INVALID_PARAMETER;
-    }
-
-    SERVER_START_REQ( get_key_value )
-    {
-        req->hkey = wine_server_obj_handle( handle );
-        wine_server_add_data( req, name->Buffer, name->Length );
-        if (length > fixed_size && data_ptr) wine_server_set_reply( req, data_ptr, length - fixed_size );
-        if (!(ret = wine_server_call( req )))
-        {
-            copy_key_value_info( info_class, info, length, reply->type,
-                                 name->Length, reply->total );
-            *result_len = fixed_size + (info_class == KeyValueBasicInformation ? 0 : reply->total);
-            if (length < min_size) ret = STATUS_BUFFER_TOO_SMALL;
-            else if (length < *result_len) ret = STATUS_BUFFER_OVERFLOW;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtQueryMultipleValueKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryMultipleValueKey( HANDLE key, KEY_MULTIPLE_VALUE_INFORMATION *info,
-                                         ULONG count, void *buffer, ULONG length, ULONG *retlen )
-{
-    FIXME( "(%p,%p,0x%08x,%p,0x%08x,%p) stub!\n", key, info, count, buffer, length, retlen );
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtSetValueKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetValueKey( HANDLE key, const UNICODE_STRING *name, ULONG index,
-                               ULONG type, const void *data, ULONG count )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p,%s,%d,%p,%d)\n", key, debugstr_us(name), type, data, count );
-
-    if (name->Length > MAX_VALUE_LENGTH) return STATUS_INVALID_PARAMETER;
-
-    SERVER_START_REQ( set_key_value )
-    {
-        req->hkey    = wine_server_obj_handle( key );
-        req->type    = type;
-        req->namelen = name->Length;
-        wine_server_add_data( req, name->Buffer, name->Length );
-        wine_server_add_data( req, data, count );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtDeleteValueKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtDeleteValueKey( HANDLE key, const UNICODE_STRING *name )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p,%s)\n", key, debugstr_us(name) );
-
-    if (name->Length > MAX_VALUE_LENGTH) return STATUS_OBJECT_NAME_NOT_FOUND;
-
-    SERVER_START_REQ( delete_key_value )
-    {
-        req->hkey = wine_server_obj_handle( key );
-        wine_server_add_data( req, name->Buffer, name->Length );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtNotifyChangeMultipleKeys  (NTDLL.@)
- */
-NTSTATUS WINAPI NtNotifyChangeMultipleKeys( HANDLE key, ULONG count, OBJECT_ATTRIBUTES *attr,
-                                            HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
-                                            IO_STATUS_BLOCK *io, ULONG filter, BOOLEAN subtree,
-                                            void *buffer, ULONG length, BOOLEAN async )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p,%u,%p,%p,%p,%p,%p,0x%08x, 0x%08x,%p,0x%08x,0x%08x)\n",
-           key, count, attr, event, apc, apc_context, io, filter, async, buffer, length, subtree );
-
-    if (count || attr || apc || apc_context || buffer || length)
-        FIXME( "Unimplemented optional parameter\n" );
-
-    if (!async)
-    {
-        OBJECT_ATTRIBUTES attr;
-        InitializeObjectAttributes( &attr, NULL, 0, NULL, NULL );
-        ret = NtCreateEvent( &event, EVENT_ALL_ACCESS, &attr, SynchronizationEvent, FALSE );
-        if (ret) return ret;
-    }
-
-    SERVER_START_REQ( set_registry_notification )
-    {
-        req->hkey    = wine_server_obj_handle( key );
-        req->event   = wine_server_obj_handle( event );
-        req->subtree = subtree;
-        req->filter  = filter;
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    if (!async)
-    {
-        if (ret == STATUS_PENDING) ret = NtWaitForSingleObject( event, FALSE, NULL );
-        NtClose( event );
-    }
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtNotifyChangeKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtNotifyChangeKey( HANDLE key, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
-                                   IO_STATUS_BLOCK *io, ULONG filter, BOOLEAN subtree,
-                                   void *buffer, ULONG length, BOOLEAN async )
-{
-    return NtNotifyChangeMultipleKeys( key, 0, NULL, event, apc, apc_context,
-                                       io, filter, subtree, buffer, length, async );
-}
-
-
-/******************************************************************************
- *              NtFlushKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtFlushKey( HANDLE key )
-{
-    NTSTATUS ret;
-
-    TRACE( "key=%p\n", key );
-
-    SERVER_START_REQ( flush_key )
-    {
-	req->hkey = wine_server_obj_handle( key );
-	ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtLoadKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtLoadKey( const OBJECT_ATTRIBUTES *attr, OBJECT_ATTRIBUTES *file )
-{
-    NTSTATUS ret;
-    HANDLE key;
-    IO_STATUS_BLOCK io;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    TRACE("(%p,%p)\n", attr, file);
-
-    ret = NtCreateFile( &key, GENERIC_READ | SYNCHRONIZE, file, &io, NULL, FILE_ATTRIBUTE_NORMAL, 0,
-                        FILE_OPEN, 0, NULL, 0);
-    if (ret) return ret;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( load_registry )
-    {
-        req->file = wine_server_obj_handle( key );
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    NtClose( key );
-    free( objattr );
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtLoadKey2  (NTDLL.@)
- */
-NTSTATUS WINAPI NtLoadKey2( const OBJECT_ATTRIBUTES *attr, OBJECT_ATTRIBUTES *file, ULONG flags )
-{
-    FIXME( "(%p,%p,0x%08x) semi-stub: ignoring flags\n", attr, file, flags );
-    return NtLoadKey( attr, file );
-}
-
-
-/******************************************************************************
- *              NtUnloadKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtUnloadKey( OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p)\n", attr );
-
-    SERVER_START_REQ( unload_registry )
-    {
-        req->hkey = wine_server_obj_handle( attr->RootDirectory );
-        ret = wine_server_call(req);
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtSaveKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSaveKey( HANDLE key, HANDLE file )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p,%p)\n", key, file );
-
-    SERVER_START_REQ( save_registry )
-    {
-        req->hkey = wine_server_obj_handle( key );
-        req->file = wine_server_obj_handle( file );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtRestoreKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtRestoreKey( HANDLE key, HANDLE file, ULONG flags )
-{
-    FIXME( "(%p,%p,0x%08x) stub\n", key, file, flags );
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtReplaceKey  (NTDLL.@)
- */
-NTSTATUS WINAPI NtReplaceKey( OBJECT_ATTRIBUTES *attr, HANDLE key, OBJECT_ATTRIBUTES *replace )
-{
-    FIXME( "(%s,%p,%s),stub!\n", debugstr_us(attr->ObjectName), key, debugstr_us(replace->ObjectName) );
-    return STATUS_SUCCESS;
-}
-
-/******************************************************************************
- *              NtQueryLicenseValue  (NTDLL.@)
- *
- * NOTES
- *  On Windows all license properties are stored in a single key, but
- *  unless there is some app which explicitly depends on that, there is
- *  no good reason to reproduce that.
- */
-NTSTATUS WINAPI NtQueryLicenseValue( const UNICODE_STRING *name, ULONG *type,
-                                     void *data, ULONG length, ULONG *retlen )
-{
-    static const WCHAR nameW[] = {'M','a','c','h','i','n','e','\\',
-                                  'S','o','f','t','w','a','r','e','\\',
-                                  'W','i','n','e','\\','L','i','c','e','n','s','e',
-                                  'I','n','f','o','r','m','a','t','i','o','n',0};
-    UNICODE_STRING keyW = { sizeof(nameW) - sizeof(WCHAR), sizeof(nameW), (WCHAR *)nameW };
-    KEY_VALUE_PARTIAL_INFORMATION *info;
-    NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
-    DWORD info_length, count;
-    OBJECT_ATTRIBUTES attr;
-    HANDLE key;
-
-    if (!name || !name->Buffer || !name->Length || !retlen) return STATUS_INVALID_PARAMETER;
-
-    info_length = FIELD_OFFSET( KEY_VALUE_PARTIAL_INFORMATION, Data ) + length;
-    if (!(info = malloc( info_length ))) return STATUS_NO_MEMORY;
-
-    InitializeObjectAttributes( &attr, &keyW, 0, 0, NULL );
-
-    /* @@ Wine registry key: HKLM\Software\Wine\LicenseInformation */
-    if (!NtOpenKey( &key, KEY_READ, &attr ))
-    {
-        status = NtQueryValueKey( key, name, KeyValuePartialInformation, info, info_length, &count );
-        if (!status || status == STATUS_BUFFER_OVERFLOW)
-        {
-            if (type) *type = info->Type;
-            *retlen = info->DataLength;
-            if (status == STATUS_BUFFER_OVERFLOW)
-                status = STATUS_BUFFER_TOO_SMALL;
-            else
-                memcpy( data, info->Data, info->DataLength );
-        }
-        NtClose( key );
-    }
-
-    if (status == STATUS_OBJECT_NAME_NOT_FOUND)
-        FIXME( "License key %s not found\n", debugstr_w(name->Buffer) );
-
-    free( info );
-    return status;
-}
diff --git a/dlls/ntdll/unix/security.c b/dlls/ntdll/unix/security.c
deleted file mode 100644
index daecc5e059..0000000000
--- a/dlls/ntdll/unix/security.c
+++ /dev/null
@@ -1,832 +0,0 @@
-/*
- * Security functions
- *
- * Copyright 1996-1998 Marcus Meissner
- * Copyright 2003 CodeWeavers Inc. (Ulrich Czekalla)
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
-
-
-/***********************************************************************
- *             NtOpenProcessToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenProcessToken( HANDLE process, DWORD access, HANDLE *handle )
-{
-    return NtOpenProcessTokenEx( process, access, 0, handle );
-}
-
-
-/***********************************************************************
- *             NtOpenProcessTokenEx  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenProcessTokenEx( HANDLE process, DWORD access, DWORD attributes, HANDLE *handle )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p,0x%08x,0x%08x,%p)\n", process, access, attributes, handle );
-
-    SERVER_START_REQ( open_token )
-    {
-        req->handle     = wine_server_obj_handle( process );
-        req->access     = access;
-        req->attributes = attributes;
-        req->flags      = 0;
-        ret = wine_server_call( req );
-        if (!ret) *handle = wine_server_ptr_handle( reply->token );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/***********************************************************************
- *             NtOpenThreadToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenThreadToken( HANDLE thread, DWORD access, BOOLEAN self, HANDLE *handle )
-{
-    return NtOpenThreadTokenEx( thread, access, self, 0, handle );
-}
-
-
-/***********************************************************************
- *             NtOpenThreadTokenEx  (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenThreadTokenEx( HANDLE thread, DWORD access, BOOLEAN self, DWORD attributes,
-                                     HANDLE *handle )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p,0x%08x,%u,0x%08x,%p)\n", thread, access, self, attributes, handle );
-
-    SERVER_START_REQ( open_token )
-    {
-        req->handle     = wine_server_obj_handle( thread );
-        req->access     = access;
-        req->attributes = attributes;
-        req->flags      = OPEN_TOKEN_THREAD;
-        if (self) req->flags |= OPEN_TOKEN_AS_SELF;
-        ret = wine_server_call( req );
-        if (!ret) *handle = wine_server_ptr_handle( reply->token );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/***********************************************************************
- *             NtDuplicateToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtDuplicateToken( HANDLE token, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
-                                  SECURITY_IMPERSONATION_LEVEL level, TOKEN_TYPE type, HANDLE *handle )
-{
-    NTSTATUS status;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
-
-    if (attr && attr->SecurityQualityOfService)
-    {
-        SECURITY_QUALITY_OF_SERVICE *qos = attr->SecurityQualityOfService;
-        TRACE( "ObjectAttributes->SecurityQualityOfService = {%d, %d, %d, %s}\n",
-               qos->Length, qos->ImpersonationLevel, qos->ContextTrackingMode,
-               qos->EffectiveOnly ? "TRUE" : "FALSE");
-        level = qos->ImpersonationLevel;
-    }
-
-    SERVER_START_REQ( duplicate_token )
-    {
-        req->handle              = wine_server_obj_handle( token );
-        req->access              = access;
-        req->primary             = (type == TokenPrimary);
-        req->impersonation_level = level;
-        wine_server_add_data( req, objattr, len );
-        status = wine_server_call( req );
-        if (!status) *handle = wine_server_ptr_handle( reply->new_handle );
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtQueryInformationToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryInformationToken( HANDLE token, TOKEN_INFORMATION_CLASS class,
-                                         void *info, ULONG length, ULONG *retlen )
-{
-    static const ULONG info_len [] =
-    {
-        0,
-        0,    /* TokenUser */
-        0,    /* TokenGroups */
-        0,    /* TokenPrivileges */
-        0,    /* TokenOwner */
-        0,    /* TokenPrimaryGroup */
-        0,    /* TokenDefaultDacl */
-        sizeof(TOKEN_SOURCE), /* TokenSource */
-        sizeof(TOKEN_TYPE),  /* TokenType */
-        sizeof(SECURITY_IMPERSONATION_LEVEL), /* TokenImpersonationLevel */
-        sizeof(TOKEN_STATISTICS), /* TokenStatistics */
-        0,    /* TokenRestrictedSids */
-        sizeof(DWORD), /* TokenSessionId */
-        0,    /* TokenGroupsAndPrivileges */
-        0,    /* TokenSessionReference */
-        0,    /* TokenSandBoxInert */
-        0,    /* TokenAuditPolicy */
-        0,    /* TokenOrigin */
-        sizeof(TOKEN_ELEVATION_TYPE), /* TokenElevationType */
-        0,    /* TokenLinkedToken */
-        sizeof(TOKEN_ELEVATION), /* TokenElevation */
-        0,    /* TokenHasRestrictions */
-        0,    /* TokenAccessInformation */
-        0,    /* TokenVirtualizationAllowed */
-        sizeof(DWORD), /* TokenVirtualizationEnabled */
-        sizeof(TOKEN_MANDATORY_LABEL) + sizeof(SID), /* TokenIntegrityLevel [sizeof(SID) includes one SubAuthority] */
-        0,    /* TokenUIAccess */
-        0,    /* TokenMandatoryPolicy */
-        0,    /* TokenLogonSid */
-        sizeof(DWORD), /* TokenIsAppContainer */
-        0,    /* TokenCapabilities */
-        sizeof(TOKEN_APPCONTAINER_INFORMATION) + sizeof(SID), /* TokenAppContainerSid */
-        0,    /* TokenAppContainerNumber */
-        0,    /* TokenUserClaimAttributes*/
-        0,    /* TokenDeviceClaimAttributes */
-        0,    /* TokenRestrictedUserClaimAttributes */
-        0,    /* TokenRestrictedDeviceClaimAttributes */
-        0,    /* TokenDeviceGroups */
-        0,    /* TokenRestrictedDeviceGroups */
-        0,    /* TokenSecurityAttributes */
-        0,    /* TokenIsRestricted */
-        0     /* TokenProcessTrustLevel */
-    };
-
-    ULONG len = 0;
-    NTSTATUS status = STATUS_SUCCESS;
-
-    TRACE( "(%p,%d,%p,%d,%p)\n", token, class, info, length, retlen );
-
-    if (class < MaxTokenInfoClass) len = info_len[class];
-    if (retlen) *retlen = len;
-    if (length < len) return STATUS_BUFFER_TOO_SMALL;
-
-    switch (class)
-    {
-    case TokenUser:
-        SERVER_START_REQ( get_token_sid )
-        {
-            TOKEN_USER *tuser = info;
-            PSID sid = tuser + 1;
-            DWORD sid_len = length < sizeof(TOKEN_USER) ? 0 : length - sizeof(TOKEN_USER);
-
-            req->handle = wine_server_obj_handle( token );
-            req->which_sid = class;
-            wine_server_set_reply( req, sid, sid_len );
-            status = wine_server_call( req );
-            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_USER);
-            if (status == STATUS_SUCCESS)
-            {
-                tuser->User.Sid = sid;
-                tuser->User.Attributes = 0;
-            }
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenGroups:
-    {
-        /* reply buffer is always shorter than output one */
-        void *buffer = malloc( length );
-
-        SERVER_START_REQ( get_token_groups )
-        {
-            TOKEN_GROUPS *groups = info;
-
-            req->handle = wine_server_obj_handle( token );
-            wine_server_set_reply( req, buffer, length );
-            status = wine_server_call( req );
-            if (status == STATUS_BUFFER_TOO_SMALL)
-            {
-                if (retlen) *retlen = reply->user_len;
-            }
-            else if (status == STATUS_SUCCESS)
-            {
-                struct token_groups *tg = buffer;
-                unsigned int *attr = (unsigned int *)(tg + 1);
-                ULONG i;
-                const int non_sid_portion = (sizeof(struct token_groups) + tg->count * sizeof(unsigned int));
-                SID *sids = (SID *)((char *)info + FIELD_OFFSET( TOKEN_GROUPS, Groups[tg->count] ));
-
-                if (retlen) *retlen = reply->user_len;
-
-                groups->GroupCount = tg->count;
-                memcpy( sids, (char *)buffer + non_sid_portion,
-                        reply->user_len - offsetof( TOKEN_GROUPS, Groups[tg->count] ));
-
-                for (i = 0; i < tg->count; i++)
-                {
-                    groups->Groups[i].Attributes = attr[i];
-                    groups->Groups[i].Sid = sids;
-                    sids = (SID *)((char *)sids + offsetof( SID, SubAuthority[sids->SubAuthorityCount] ));
-                }
-             }
-             else if (retlen) *retlen = 0;
-        }
-        SERVER_END_REQ;
-        free( buffer );
-        break;
-    }
-
-    case TokenPrimaryGroup:
-        SERVER_START_REQ( get_token_sid )
-        {
-            TOKEN_PRIMARY_GROUP *tgroup = info;
-            PSID sid = tgroup + 1;
-            DWORD sid_len = length < sizeof(TOKEN_PRIMARY_GROUP) ? 0 : length - sizeof(TOKEN_PRIMARY_GROUP);
-
-            req->handle = wine_server_obj_handle( token );
-            req->which_sid = class;
-            wine_server_set_reply( req, sid, sid_len );
-            status = wine_server_call( req );
-            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_PRIMARY_GROUP);
-            if (status == STATUS_SUCCESS) tgroup->PrimaryGroup = sid;
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenPrivileges:
-        SERVER_START_REQ( get_token_privileges )
-        {
-            TOKEN_PRIVILEGES *tpriv = info;
-            req->handle = wine_server_obj_handle( token );
-            if (tpriv && length > FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ))
-                wine_server_set_reply( req, tpriv->Privileges, length - FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ) );
-            status = wine_server_call( req );
-            if (retlen) *retlen = FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ) + reply->len;
-            if (tpriv) tpriv->PrivilegeCount = reply->len / sizeof(LUID_AND_ATTRIBUTES);
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenOwner:
-        SERVER_START_REQ( get_token_sid )
-        {
-            TOKEN_OWNER *towner = info;
-            PSID sid = towner + 1;
-            DWORD sid_len = length < sizeof(TOKEN_OWNER) ? 0 : length - sizeof(TOKEN_OWNER);
-
-            req->handle = wine_server_obj_handle( token );
-            req->which_sid = class;
-            wine_server_set_reply( req, sid, sid_len );
-            status = wine_server_call( req );
-            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_OWNER);
-            if (status == STATUS_SUCCESS) towner->Owner = sid;
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenImpersonationLevel:
-        SERVER_START_REQ( get_token_impersonation_level )
-        {
-            SECURITY_IMPERSONATION_LEVEL *level = info;
-            req->handle = wine_server_obj_handle( token );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS) *level = reply->impersonation_level;
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenStatistics:
-        SERVER_START_REQ( get_token_statistics )
-        {
-            TOKEN_STATISTICS *statistics = info;
-            req->handle = wine_server_obj_handle( token );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                statistics->TokenId.LowPart  = reply->token_id.low_part;
-                statistics->TokenId.HighPart = reply->token_id.high_part;
-                statistics->AuthenticationId.LowPart  = 0; /* FIXME */
-                statistics->AuthenticationId.HighPart = 0; /* FIXME */
-                statistics->ExpirationTime.u.HighPart = 0x7fffffff;
-                statistics->ExpirationTime.u.LowPart  = 0xffffffff;
-                statistics->TokenType = reply->primary ? TokenPrimary : TokenImpersonation;
-                statistics->ImpersonationLevel = reply->impersonation_level;
-
-                /* kernel information not relevant to us */
-                statistics->DynamicCharged = 0;
-                statistics->DynamicAvailable = 0;
-
-                statistics->GroupCount = reply->group_count;
-                statistics->PrivilegeCount = reply->privilege_count;
-                statistics->ModifiedId.LowPart  = reply->modified_id.low_part;
-                statistics->ModifiedId.HighPart = reply->modified_id.high_part;
-            }
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenType:
-        SERVER_START_REQ( get_token_statistics )
-        {
-            TOKEN_TYPE *type = info;
-            req->handle = wine_server_obj_handle( token );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS) *type = reply->primary ? TokenPrimary : TokenImpersonation;
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenDefaultDacl:
-        SERVER_START_REQ( get_token_default_dacl )
-        {
-            TOKEN_DEFAULT_DACL *default_dacl = info;
-            ACL *acl = (ACL *)(default_dacl + 1);
-            DWORD acl_len = length < sizeof(TOKEN_DEFAULT_DACL) ? 0 : length - sizeof(TOKEN_DEFAULT_DACL);
-
-            req->handle = wine_server_obj_handle( token );
-            wine_server_set_reply( req, acl, acl_len );
-            status = wine_server_call( req );
-            if (retlen) *retlen = reply->acl_len + sizeof(TOKEN_DEFAULT_DACL);
-            if (status == STATUS_SUCCESS)
-            {
-                if (reply->acl_len)
-                    default_dacl->DefaultDacl = acl;
-                else
-                    default_dacl->DefaultDacl = NULL;
-            }
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenElevationType:
-        {
-            TOKEN_ELEVATION_TYPE *type = info;
-            FIXME("QueryInformationToken( ..., TokenElevationType, ...) semi-stub\n");
-            *type = TokenElevationTypeFull;
-        }
-        break;
-
-    case TokenElevation:
-        {
-            TOKEN_ELEVATION *elevation = info;
-            FIXME("QueryInformationToken( ..., TokenElevation, ...) semi-stub\n");
-            elevation->TokenIsElevated = TRUE;
-        }
-        break;
-
-    case TokenSessionId:
-        {
-            *(DWORD *)info = 0;
-            FIXME("QueryInformationToken( ..., TokenSessionId, ...) semi-stub\n");
-        }
-        break;
-
-    case TokenVirtualizationEnabled:
-        {
-            *(DWORD *)info = 0;
-            TRACE("QueryInformationToken( ..., TokenVirtualizationEnabled, ...) semi-stub\n");
-        }
-        break;
-
-    case TokenIntegrityLevel:
-        {
-            /* report always "S-1-16-12288" (high mandatory level) for now */
-            static const SID high_level = {SID_REVISION, 1, {SECURITY_MANDATORY_LABEL_AUTHORITY},
-                                                            {SECURITY_MANDATORY_HIGH_RID}};
-
-            TOKEN_MANDATORY_LABEL *tml = info;
-            PSID psid = tml + 1;
-
-            tml->Label.Sid = psid;
-            tml->Label.Attributes = SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED;
-            memcpy( psid, &high_level, sizeof(SID) );
-        }
-        break;
-
-    case TokenAppContainerSid:
-        {
-            TOKEN_APPCONTAINER_INFORMATION *container = info;
-            FIXME("QueryInformationToken( ..., TokenAppContainerSid, ...) semi-stub\n");
-            container->TokenAppContainer = NULL;
-        }
-        break;
-
-    case TokenIsAppContainer:
-        {
-            TRACE("TokenIsAppContainer semi-stub\n");
-            *(DWORD *)info = 0;
-            break;
-        }
-
-    case TokenLogonSid:
-        SERVER_START_REQ( get_token_sid )
-        {
-            TOKEN_GROUPS * groups = info;
-            PSID sid = groups + 1;
-            DWORD sid_len = length < sizeof(TOKEN_GROUPS) ? 0 : length - sizeof(TOKEN_GROUPS);
-
-            req->handle = wine_server_obj_handle( token );
-            req->which_sid = class;
-            wine_server_set_reply( req, sid, sid_len );
-            status = wine_server_call( req );
-            if (retlen) *retlen = reply->sid_len + sizeof(TOKEN_GROUPS);
-            if (status == STATUS_SUCCESS)
-            {
-                groups->GroupCount = 1;
-                groups->Groups[0].Sid = sid;
-                groups->Groups[0].Attributes = 0;
-            }
-        }
-        SERVER_END_REQ;
-        break;
-
-    default:
-        ERR( "Unhandled token information class %u\n", class );
-        return STATUS_NOT_IMPLEMENTED;
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *             NtSetInformationToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetInformationToken( HANDLE token, TOKEN_INFORMATION_CLASS class,
-                                       void *info, ULONG length )
-{
-    NTSTATUS ret = STATUS_NOT_IMPLEMENTED;
-
-    TRACE( "%p %d %p %u\n", token, class, info, length );
-
-    switch (class)
-    {
-    case TokenDefaultDacl:
-        if (length < sizeof(TOKEN_DEFAULT_DACL))
-        {
-            ret = STATUS_INFO_LENGTH_MISMATCH;
-            break;
-        }
-        if (!info)
-        {
-            ret = STATUS_ACCESS_VIOLATION;
-            break;
-        }
-        SERVER_START_REQ( set_token_default_dacl )
-        {
-            ACL *acl = ((TOKEN_DEFAULT_DACL *)info)->DefaultDacl;
-            WORD size;
-
-            if (acl) size = acl->AclSize;
-            else size = 0;
-            req->handle = wine_server_obj_handle( token );
-            wine_server_add_data( req, acl, size );
-            ret = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        break;
-
-    case TokenSessionId:
-        if (length < sizeof(DWORD))
-        {
-            ret = STATUS_INFO_LENGTH_MISMATCH;
-            break;
-        }
-        if (!info)
-        {
-            ret = STATUS_ACCESS_VIOLATION;
-            break;
-        }
-        FIXME("TokenSessionId stub!\n");
-        ret = STATUS_SUCCESS;
-        break;
-
-    case TokenIntegrityLevel:
-        FIXME( "TokenIntegrityLevel stub!\n" );
-        ret = STATUS_SUCCESS;
-        break;
-
-    default:
-        FIXME( "unimplemented class %u\n", class );
-        break;
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *             NtCreateLowBoxToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateLowBoxToken( HANDLE *token_handle, HANDLE token, ACCESS_MASK access,
-                                     OBJECT_ATTRIBUTES *attr, SID *sid, ULONG count,
-                                     SID_AND_ATTRIBUTES *capabilities, ULONG handle_count, HANDLE *handle )
-{
-    FIXME("(%p, %p, %x, %p, %p, %u, %p, %u, %p): stub\n",
-          token_handle, token, access, attr, sid, count, capabilities, handle_count, handle );
-
-    /* we need to return a NULL handle since later it will be passed to NtClose and that must not fail */
-    *token_handle = NULL;
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *             NtAdjustGroupsToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtAdjustGroupsToken( HANDLE token, BOOLEAN reset, TOKEN_GROUPS *groups,
-                                     ULONG length, TOKEN_GROUPS *prev, ULONG *retlen )
-{
-    FIXME( "%p %d %p %u %p %p\n", token, reset, groups, length, prev, retlen );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtAdjustPrivilegesToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtAdjustPrivilegesToken( HANDLE token, BOOLEAN disable, TOKEN_PRIVILEGES *privs,
-                                         DWORD length, TOKEN_PRIVILEGES *prev, DWORD *retlen )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p,0x%08x,%p,0x%08x,%p,%p)\n", token, disable, privs, length, prev, retlen );
-
-    SERVER_START_REQ( adjust_token_privileges )
-    {
-        req->handle = wine_server_obj_handle( token );
-        req->disable_all = disable;
-        req->get_modified_state = (prev != NULL);
-        if (!disable)
-            wine_server_add_data( req, privs->Privileges,
-                                  privs->PrivilegeCount * sizeof(privs->Privileges[0]) );
-        if (prev && length >= FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ))
-            wine_server_set_reply( req, prev->Privileges,
-                                   length - FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges ) );
-        ret = wine_server_call( req );
-        if (prev)
-        {
-            if (retlen) *retlen = reply->len + FIELD_OFFSET( TOKEN_PRIVILEGES, Privileges );
-            prev->PrivilegeCount = reply->len / sizeof(LUID_AND_ATTRIBUTES);
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/***********************************************************************
- *             NtPrivilegeCheck  (NTDLL.@)
- */
-NTSTATUS WINAPI NtPrivilegeCheck( HANDLE token, PRIVILEGE_SET *privs, BOOLEAN *res )
-{
-    NTSTATUS status;
-
-    SERVER_START_REQ( check_token_privileges )
-    {
-        req->handle = wine_server_obj_handle( token );
-        req->all_required = (privs->Control & PRIVILEGE_SET_ALL_NECESSARY) != 0;
-        wine_server_add_data( req, privs->Privilege, privs->PrivilegeCount * sizeof(privs->Privilege[0]) );
-        wine_server_set_reply( req, privs->Privilege, privs->PrivilegeCount * sizeof(privs->Privilege[0]) );
-        status = wine_server_call( req );
-        if (status == STATUS_SUCCESS) *res = reply->has_privileges != 0;
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtImpersonateAnonymousToken  (NTDLL.@)
- */
-NTSTATUS WINAPI NtImpersonateAnonymousToken( HANDLE thread )
-{
-    FIXME( "(%p): stub\n", thread );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtAccessCheck  (NTDLL.@)
- */
-NTSTATUS WINAPI NtAccessCheck( PSECURITY_DESCRIPTOR descr, HANDLE token, ACCESS_MASK access,
-                               GENERIC_MAPPING *mapping, PRIVILEGE_SET *privs, ULONG *retlen,
-                               ULONG *access_granted, NTSTATUS *access_status)
-{
-    struct object_attributes *objattr;
-    data_size_t len;
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-
-    TRACE( "(%p, %p, %08x, %p, %p, %p, %p, %p)\n",
-           descr, token, access, mapping, privs, retlen, access_granted, access_status );
-
-    if (!privs || !retlen) return STATUS_ACCESS_VIOLATION;
-
-    /* reuse the object attribute SD marshalling */
-    InitializeObjectAttributes( &attr, NULL, 0, 0, descr );
-    if ((status = alloc_object_attributes( &attr, &objattr, &len ))) return status;
-
-    SERVER_START_REQ( access_check )
-    {
-        req->handle = wine_server_obj_handle( token );
-        req->desired_access = access;
-        req->mapping_read = mapping->GenericRead;
-        req->mapping_write = mapping->GenericWrite;
-        req->mapping_execute = mapping->GenericExecute;
-        req->mapping_all = mapping->GenericAll;
-        wine_server_add_data( req, objattr + 1, objattr->sd_len );
-        wine_server_set_reply( req, privs->Privilege, *retlen - offsetof( PRIVILEGE_SET, Privilege ) );
-
-        status = wine_server_call( req );
-
-        *retlen = offsetof( PRIVILEGE_SET, Privilege ) + reply->privileges_len;
-        privs->PrivilegeCount = reply->privileges_len / sizeof(LUID_AND_ATTRIBUTES);
-        if (status == STATUS_SUCCESS)
-        {
-            *access_status = reply->access_status;
-            *access_granted = reply->access_granted;
-        }
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtAccessCheckAndAuditAlarm  (NTDLL.@)
- */
-NTSTATUS WINAPI NtAccessCheckAndAuditAlarm( UNICODE_STRING *subsystem, HANDLE handle,
-                                            UNICODE_STRING *typename, UNICODE_STRING *objectname,
-                                            PSECURITY_DESCRIPTOR descr, ACCESS_MASK access,
-                                            GENERIC_MAPPING *mapping, BOOLEAN creation,
-                                            ACCESS_MASK *access_granted, BOOLEAN *access_status,
-                                            BOOLEAN *onclose )
-{
-    FIXME( "(%s, %p, %s, %p, 0x%08x, %p, %d, %p, %p, %p), stub\n",
-           debugstr_us(subsystem), handle, debugstr_us(typename), descr, access,
-           mapping, creation, access_granted, access_status, onclose );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtQuerySecurityObject  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySecurityObject( HANDLE handle, SECURITY_INFORMATION info,
-                                       PSECURITY_DESCRIPTOR descr, ULONG length, ULONG *retlen )
-{
-    SECURITY_DESCRIPTOR_RELATIVE *psd = descr;
-    NTSTATUS status;
-    void *buffer;
-    unsigned int buffer_size = 512;
-
-    TRACE( "(%p,0x%08x,%p,0x%08x,%p)\n", handle, info, descr, length, retlen );
-
-    for (;;)
-    {
-        if (!(buffer = malloc( buffer_size ))) return STATUS_NO_MEMORY;
-
-        SERVER_START_REQ( get_security_object )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->security_info = info;
-            wine_server_set_reply( req, buffer, buffer_size );
-            status = wine_server_call( req );
-            buffer_size = reply->sd_len;
-        }
-        SERVER_END_REQ;
-
-        if (status == STATUS_BUFFER_TOO_SMALL)
-        {
-            free( buffer );
-            continue;
-        }
-        if (status == STATUS_SUCCESS)
-        {
-            struct security_descriptor *sd = buffer;
-
-            if (!buffer_size) memset( sd, 0, sizeof(*sd) );
-            *retlen = sizeof(*psd) + sd->owner_len + sd->group_len + sd->sacl_len + sd->dacl_len;
-            if (length >= *retlen)
-            {
-                DWORD len = sizeof(*psd);
-                memset( psd, 0, len );
-                psd->Revision = SECURITY_DESCRIPTOR_REVISION;
-                psd->Control = sd->control | SE_SELF_RELATIVE;
-                if (sd->owner_len) { psd->Owner = len; len += sd->owner_len; }
-                if (sd->group_len) { psd->Group = len; len += sd->group_len; }
-                if (sd->sacl_len) { psd->Sacl = len; len += sd->sacl_len; }
-                if (sd->dacl_len) { psd->Dacl = len; len += sd->dacl_len; }
-                /* owner, group, sacl and dacl are the same type as in the server
-                 * and in the same order so we copy the memory in one block */
-                memcpy( psd + 1, sd + 1, len - sizeof(*psd) );
-            }
-            else status = STATUS_BUFFER_TOO_SMALL;
-        }
-        free( buffer );
-        return status;
-    }
-}
-
-
-/***********************************************************************
- *             NtSetSecurityObject  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetSecurityObject( HANDLE handle, SECURITY_INFORMATION info, PSECURITY_DESCRIPTOR descr )
-{
-    struct object_attributes *objattr;
-    struct security_descriptor *sd;
-    data_size_t len;
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-
-    TRACE( "%p 0x%08x %p\n", handle, info, descr );
-
-    if (!descr) return STATUS_ACCESS_VIOLATION;
-
-    /* reuse the object attribute SD marshalling */
-    InitializeObjectAttributes( &attr, NULL, 0, 0, descr );
-    if ((status = alloc_object_attributes( &attr, &objattr, &len ))) return status;
-    sd = (struct security_descriptor *)(objattr + 1);
-    if (info & OWNER_SECURITY_INFORMATION && !sd->owner_len) return STATUS_INVALID_SECURITY_DESCR;
-    if (info & GROUP_SECURITY_INFORMATION && !sd->group_len) return STATUS_INVALID_SECURITY_DESCR;
-    if (info & (SACL_SECURITY_INFORMATION | LABEL_SECURITY_INFORMATION)) sd->control |= SE_SACL_PRESENT;
-    if (info & DACL_SECURITY_INFORMATION) sd->control |= SE_DACL_PRESENT;
-
-    SERVER_START_REQ( set_security_object )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->security_info = info;
-        wine_server_add_data( req, sd, objattr->sd_len );
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtAllocateLocallyUniqueId  (NTDLL.@)
- */
-NTSTATUS WINAPI NtAllocateLocallyUniqueId( LUID *luid )
-{
-    NTSTATUS status;
-
-    TRACE( "%p\n", luid );
-
-    if (!luid) return STATUS_ACCESS_VIOLATION;
-
-    SERVER_START_REQ( allocate_locally_unique_id )
-    {
-        status = wine_server_call( req );
-        if (!status)
-        {
-            luid->LowPart = reply->luid.low_part;
-            luid->HighPart = reply->luid.high_part;
-        }
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtAllocateUuids  (NTDLL.@)
- */
-NTSTATUS WINAPI NtAllocateUuids( ULARGE_INTEGER *time, ULONG *delta, ULONG *sequence, UCHAR *seed )
-{
-    FIXME( "(%p,%p,%p,%p), stub.\n", time, delta, sequence, seed );
-    return STATUS_SUCCESS;
-}
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
deleted file mode 100644
index d867a7fb46..0000000000
--- a/dlls/ntdll/unix/server.c
+++ /dev/null
@@ -1,1656 +0,0 @@
-/*
- * Wine server communication
- *
- * Copyright (C) 1998 Alexandre Julliard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#ifdef HAVE_LWP_H
-#include <lwp.h>
-#endif
-#ifdef HAVE_PTHREAD_NP_H
-# include <pthread_np.h>
-#endif
-#ifdef HAVE_PWD_H
-# include <pwd.h>
-#endif
-#include <signal.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/types.h>
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-#ifdef HAVE_SYS_WAIT_H
-#include <sys/wait.h>
-#endif
-#ifdef HAVE_SYS_UN_H
-#include <sys/un.h>
-#endif
-#ifdef HAVE_SYS_MMAN_H
-#include <sys/mman.h>
-#endif
-#ifdef HAVE_SYS_PRCTL_H
-# include <sys/prctl.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef HAVE_SYS_SYSCALL_H
-# include <sys/syscall.h>
-#endif
-#ifdef HAVE_SYS_UIO_H
-#include <sys/uio.h>
-#endif
-#ifdef HAVE_SYS_THR_H
-#include <sys/thr.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef __APPLE__
-#include <crt_externs.h>
-#include <spawn.h>
-#ifndef _POSIX_SPAWN_DISABLE_ASLR
-#define _POSIX_SPAWN_DISABLE_ASLR 0x0100
-#endif
-#endif
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winnt.h"
-#include "wine/library.h"
-#include "wine/server.h"
-#include "wine/debug.h"
-#include "unix_private.h"
-#include "ddk/wdm.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(server);
-
-#ifndef MSG_CMSG_CLOEXEC
-#define MSG_CMSG_CLOEXEC 0
-#endif
-
-#define SOCKETNAME "socket"        /* name of the socket file */
-#define LOCKNAME   "lock"          /* name of the lock file */
-
-static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
-
-static const char *server_dir;
-
-unsigned int server_cpus = 0;
-BOOL is_wow64 = FALSE;
-
-timeout_t server_start_time = 0;  /* time of server startup */
-
-sigset_t server_block_set;  /* signals to block during server calls */
-static int fd_socket = -1;  /* socket to exchange file descriptors with the server */
-static pid_t server_pid;
-static pthread_mutex_t fd_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-/* atomically exchange a 64-bit value */
-static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
-{
-#ifdef _WIN64
-    return (LONG64)InterlockedExchangePointer( (void **)dest, (void *)val );
-#else
-    LONG64 tmp = *dest;
-    while (InterlockedCompareExchange64( dest, val, tmp ) != tmp) tmp = *dest;
-    return tmp;
-#endif
-}
-
-#ifdef __GNUC__
-static void fatal_error( const char *err, ... ) __attribute__((noreturn, format(printf,1,2)));
-static void fatal_perror( const char *err, ... ) __attribute__((noreturn, format(printf,1,2)));
-static void server_connect_error( const char *serverdir ) __attribute__((noreturn));
-#endif
-
-/* die on a fatal error; use only during initialization */
-static void fatal_error( const char *err, ... )
-{
-    va_list args;
-
-    va_start( args, err );
-    fprintf( stderr, "wine: " );
-    vfprintf( stderr, err, args );
-    va_end( args );
-    exit(1);
-}
-
-/* die on a fatal error; use only during initialization */
-static void fatal_perror( const char *err, ... )
-{
-    va_list args;
-
-    va_start( args, err );
-    fprintf( stderr, "wine: " );
-    vfprintf( stderr, err, args );
-    perror( " " );
-    va_end( args );
-    exit(1);
-}
-
-/***********************************************************************
- *           server_protocol_error
- */
-static DECLSPEC_NORETURN void server_protocol_error( const char *err, ... )
-{
-    va_list args;
-
-    va_start( args, err );
-    fprintf( stderr, "wine client error:%x: ", GetCurrentThreadId() );
-    vfprintf( stderr, err, args );
-    va_end( args );
-    abort_thread(1);
-}
-
-
-/***********************************************************************
- *           server_protocol_perror
- */
-static DECLSPEC_NORETURN void server_protocol_perror( const char *err )
-{
-    fprintf( stderr, "wine client error:%x: ", GetCurrentThreadId() );
-    perror( err );
-    abort_thread(1);
-}
-
-
-/***********************************************************************
- *           send_request
- *
- * Send a request to the server.
- */
-static unsigned int send_request( const struct __server_request_info *req )
-{
-    unsigned int i;
-    int ret;
-
-    if (!req->u.req.request_header.request_size)
-    {
-        if ((ret = write( ntdll_get_thread_data()->request_fd, &req->u.req,
-                          sizeof(req->u.req) )) == sizeof(req->u.req)) return STATUS_SUCCESS;
-
-    }
-    else
-    {
-        struct iovec vec[__SERVER_MAX_DATA+1];
-
-        vec[0].iov_base = (void *)&req->u.req;
-        vec[0].iov_len = sizeof(req->u.req);
-        for (i = 0; i < req->data_count; i++)
-        {
-            vec[i+1].iov_base = (void *)req->data[i].ptr;
-            vec[i+1].iov_len = req->data[i].size;
-        }
-        if ((ret = writev( ntdll_get_thread_data()->request_fd, vec, i+1 )) ==
-            req->u.req.request_header.request_size + sizeof(req->u.req)) return STATUS_SUCCESS;
-    }
-
-    if (ret >= 0) server_protocol_error( "partial write %d\n", ret );
-    if (errno == EPIPE) abort_thread(0);
-    if (errno == EFAULT) return STATUS_ACCESS_VIOLATION;
-    server_protocol_perror( "write" );
-}
-
-
-/***********************************************************************
- *           read_reply_data
- *
- * Read data from the reply buffer; helper for wait_reply.
- */
-static void read_reply_data( void *buffer, size_t size )
-{
-    int ret;
-
-    for (;;)
-    {
-        if ((ret = read( ntdll_get_thread_data()->reply_fd, buffer, size )) > 0)
-        {
-            if (!(size -= ret)) return;
-            buffer = (char *)buffer + ret;
-            continue;
-        }
-        if (!ret) break;
-        if (errno == EINTR) continue;
-        if (errno == EPIPE) break;
-        server_protocol_perror("read");
-    }
-    /* the server closed the connection; time to die... */
-    abort_thread(0);
-}
-
-
-/***********************************************************************
- *           wait_reply
- *
- * Wait for a reply from the server.
- */
-static inline unsigned int wait_reply( struct __server_request_info *req )
-{
-    read_reply_data( &req->u.reply, sizeof(req->u.reply) );
-    if (req->u.reply.reply_header.reply_size)
-        read_reply_data( req->reply_data, req->u.reply.reply_header.reply_size );
-    return req->u.reply.reply_header.error;
-}
-
-
-/***********************************************************************
- *           server_call_unlocked
- */
-unsigned int server_call_unlocked( void *req_ptr )
-{
-    struct __server_request_info * const req = req_ptr;
-    unsigned int ret;
-
-    if ((ret = send_request( req ))) return ret;
-    return wait_reply( req );
-}
-
-
-/***********************************************************************
- *           wine_server_call
- *
- * Perform a server call.
- */
-unsigned int CDECL wine_server_call( void *req_ptr )
-{
-    sigset_t old_set;
-    unsigned int ret;
-
-    pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
-    ret = server_call_unlocked( req_ptr );
-    pthread_sigmask( SIG_SETMASK, &old_set, NULL );
-    return ret;
-}
-
-
-/***********************************************************************
- *           server_enter_uninterrupted_section
- */
-void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset )
-{
-    pthread_sigmask( SIG_BLOCK, &server_block_set, sigset );
-    pthread_mutex_lock( mutex );
-}
-
-
-/***********************************************************************
- *           server_leave_uninterrupted_section
- */
-void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset )
-{
-    pthread_mutex_unlock( mutex );
-    pthread_sigmask( SIG_SETMASK, sigset, NULL );
-}
-
-
-/***********************************************************************
- *              wait_select_reply
- *
- * Wait for a reply on the waiting pipe of the current thread.
- */
-static int wait_select_reply( void *cookie )
-{
-    int signaled;
-    struct wake_up_reply reply;
-    for (;;)
-    {
-        int ret;
-        ret = read( ntdll_get_thread_data()->wait_fd[0], &reply, sizeof(reply) );
-        if (ret == sizeof(reply))
-        {
-            if (!reply.cookie) abort_thread( reply.signaled );  /* thread got killed */
-            if (wine_server_get_ptr(reply.cookie) == cookie) return reply.signaled;
-            /* we stole another reply, wait for the real one */
-            signaled = wait_select_reply( cookie );
-            /* and now put the wrong one back in the pipe */
-            for (;;)
-            {
-                ret = write( ntdll_get_thread_data()->wait_fd[1], &reply, sizeof(reply) );
-                if (ret == sizeof(reply)) break;
-                if (ret >= 0) server_protocol_error( "partial wakeup write %d\n", ret );
-                if (errno == EINTR) continue;
-                server_protocol_perror("wakeup write");
-            }
-            return signaled;
-        }
-        if (ret >= 0) server_protocol_error( "partial wakeup read %d\n", ret );
-        if (errno == EINTR) continue;
-        server_protocol_perror("wakeup read");
-    }
-}
-
-
-static void invoke_apc( CONTEXT *context, const user_apc_t *apc )
-{
-    switch( apc->type )
-    {
-    case APC_USER:
-        call_user_apc( context, apc->user.args[0], apc->user.args[1], apc->user.args[2],
-                       wine_server_get_ptr( apc->user.func ));
-        break;
-    case APC_TIMER:
-        call_user_apc( context, (ULONG_PTR)wine_server_get_ptr( apc->user.args[1] ),
-                       (DWORD)apc->timer.time, (DWORD)(apc->timer.time >> 32),
-                       wine_server_get_ptr( apc->user.func ));
-        break;
-    default:
-        server_protocol_error( "get_apc_request: bad type %d\n", apc->type );
-        break;
-    }
-}
-
-/***********************************************************************
- *              invoke_apc
- *
- * Invoke a single APC.
- *
- */
-static void invoke_system_apc( const apc_call_t *call, apc_result_t *result )
-{
-    SIZE_T size, bits;
-    void *addr;
-
-    memset( result, 0, sizeof(*result) );
-
-    switch (call->type)
-    {
-    case APC_NONE:
-        break;
-    case APC_ASYNC_IO:
-    {
-        IO_STATUS_BLOCK *iosb = wine_server_get_ptr( call->async_io.sb );
-        NTSTATUS (**user)(void *, IO_STATUS_BLOCK *, NTSTATUS) = wine_server_get_ptr( call->async_io.user );
-        result->type = call->type;
-        result->async_io.status = (*user)( user, iosb, call->async_io.status );
-        if (result->async_io.status != STATUS_PENDING)
-            result->async_io.total = iosb->Information;
-        break;
-    }
-    case APC_VIRTUAL_ALLOC:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->virtual_alloc.addr );
-        size = call->virtual_alloc.size;
-        bits = call->virtual_alloc.zero_bits;
-        if ((ULONG_PTR)addr == call->virtual_alloc.addr && size == call->virtual_alloc.size &&
-            bits == call->virtual_alloc.zero_bits)
-        {
-            result->virtual_alloc.status = NtAllocateVirtualMemory( NtCurrentProcess(), &addr, bits, &size,
-                                                                    call->virtual_alloc.op_type,
-                                                                    call->virtual_alloc.prot );
-            result->virtual_alloc.addr = wine_server_client_ptr( addr );
-            result->virtual_alloc.size = size;
-        }
-        else result->virtual_alloc.status = STATUS_WORKING_SET_LIMIT_RANGE;
-        break;
-    case APC_VIRTUAL_FREE:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->virtual_free.addr );
-        size = call->virtual_free.size;
-        if ((ULONG_PTR)addr == call->virtual_free.addr && size == call->virtual_free.size)
-        {
-            result->virtual_free.status = NtFreeVirtualMemory( NtCurrentProcess(), &addr, &size,
-                                                               call->virtual_free.op_type );
-            result->virtual_free.addr = wine_server_client_ptr( addr );
-            result->virtual_free.size = size;
-        }
-        else result->virtual_free.status = STATUS_INVALID_PARAMETER;
-        break;
-    case APC_VIRTUAL_QUERY:
-    {
-        MEMORY_BASIC_INFORMATION info;
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->virtual_query.addr );
-        if ((ULONG_PTR)addr == call->virtual_query.addr)
-            result->virtual_query.status = NtQueryVirtualMemory( NtCurrentProcess(),
-                                                                 addr, MemoryBasicInformation, &info,
-                                                                 sizeof(info), NULL );
-        else
-            result->virtual_query.status = STATUS_WORKING_SET_LIMIT_RANGE;
-
-        if (result->virtual_query.status == STATUS_SUCCESS)
-        {
-            result->virtual_query.base       = wine_server_client_ptr( info.BaseAddress );
-            result->virtual_query.alloc_base = wine_server_client_ptr( info.AllocationBase );
-            result->virtual_query.size       = info.RegionSize;
-            result->virtual_query.prot       = info.Protect;
-            result->virtual_query.alloc_prot = info.AllocationProtect;
-            result->virtual_query.state      = info.State >> 12;
-            result->virtual_query.alloc_type = info.Type >> 16;
-        }
-        break;
-    }
-    case APC_VIRTUAL_PROTECT:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->virtual_protect.addr );
-        size = call->virtual_protect.size;
-        if ((ULONG_PTR)addr == call->virtual_protect.addr && size == call->virtual_protect.size)
-        {
-            result->virtual_protect.status = NtProtectVirtualMemory( NtCurrentProcess(), &addr, &size,
-                                                                     call->virtual_protect.prot,
-                                                                     &result->virtual_protect.prot );
-            result->virtual_protect.addr = wine_server_client_ptr( addr );
-            result->virtual_protect.size = size;
-        }
-        else result->virtual_protect.status = STATUS_INVALID_PARAMETER;
-        break;
-    case APC_VIRTUAL_FLUSH:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->virtual_flush.addr );
-        size = call->virtual_flush.size;
-        if ((ULONG_PTR)addr == call->virtual_flush.addr && size == call->virtual_flush.size)
-        {
-            result->virtual_flush.status = NtFlushVirtualMemory( NtCurrentProcess(),
-                                                                 (const void **)&addr, &size, 0 );
-            result->virtual_flush.addr = wine_server_client_ptr( addr );
-            result->virtual_flush.size = size;
-        }
-        else result->virtual_flush.status = STATUS_INVALID_PARAMETER;
-        break;
-    case APC_VIRTUAL_LOCK:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->virtual_lock.addr );
-        size = call->virtual_lock.size;
-        if ((ULONG_PTR)addr == call->virtual_lock.addr && size == call->virtual_lock.size)
-        {
-            result->virtual_lock.status = NtLockVirtualMemory( NtCurrentProcess(), &addr, &size, 0 );
-            result->virtual_lock.addr = wine_server_client_ptr( addr );
-            result->virtual_lock.size = size;
-        }
-        else result->virtual_lock.status = STATUS_INVALID_PARAMETER;
-        break;
-    case APC_VIRTUAL_UNLOCK:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->virtual_unlock.addr );
-        size = call->virtual_unlock.size;
-        if ((ULONG_PTR)addr == call->virtual_unlock.addr && size == call->virtual_unlock.size)
-        {
-            result->virtual_unlock.status = NtUnlockVirtualMemory( NtCurrentProcess(), &addr, &size, 0 );
-            result->virtual_unlock.addr = wine_server_client_ptr( addr );
-            result->virtual_unlock.size = size;
-        }
-        else result->virtual_unlock.status = STATUS_INVALID_PARAMETER;
-        break;
-    case APC_MAP_VIEW:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->map_view.addr );
-        size = call->map_view.size;
-        bits = call->map_view.zero_bits;
-        if ((ULONG_PTR)addr == call->map_view.addr && size == call->map_view.size &&
-            bits == call->map_view.zero_bits)
-        {
-            LARGE_INTEGER offset;
-            offset.QuadPart = call->map_view.offset;
-            result->map_view.status = NtMapViewOfSection( wine_server_ptr_handle(call->map_view.handle),
-                                                          NtCurrentProcess(),
-                                                          &addr, bits, 0, &offset, &size, 0,
-                                                          call->map_view.alloc_type, call->map_view.prot );
-            result->map_view.addr = wine_server_client_ptr( addr );
-            result->map_view.size = size;
-        }
-        else result->map_view.status = STATUS_INVALID_PARAMETER;
-        NtClose( wine_server_ptr_handle(call->map_view.handle) );
-        break;
-    case APC_UNMAP_VIEW:
-        result->type = call->type;
-        addr = wine_server_get_ptr( call->unmap_view.addr );
-        if ((ULONG_PTR)addr == call->unmap_view.addr)
-            result->unmap_view.status = NtUnmapViewOfSection( NtCurrentProcess(), addr );
-        else
-            result->unmap_view.status = STATUS_INVALID_PARAMETER;
-        break;
-    case APC_CREATE_THREAD:
-    {
-        ULONG_PTR buffer[offsetof( PS_ATTRIBUTE_LIST, Attributes[2] ) / sizeof(ULONG_PTR)];
-        PS_ATTRIBUTE_LIST *attr = (PS_ATTRIBUTE_LIST *)buffer;
-        CLIENT_ID id;
-        HANDLE handle;
-        TEB *teb;
-        SIZE_T reserve = call->create_thread.reserve;
-        SIZE_T commit = call->create_thread.commit;
-        void *func = wine_server_get_ptr( call->create_thread.func );
-        void *arg  = wine_server_get_ptr( call->create_thread.arg );
-
-        result->type = call->type;
-        if (reserve == call->create_thread.reserve && commit == call->create_thread.commit &&
-            (ULONG_PTR)func == call->create_thread.func && (ULONG_PTR)arg == call->create_thread.arg)
-        {
-            attr->TotalLength = sizeof(buffer);
-            attr->Attributes[0].Attribute    = PS_ATTRIBUTE_CLIENT_ID;
-            attr->Attributes[0].Size         = sizeof(id);
-            attr->Attributes[0].ValuePtr     = &id;
-            attr->Attributes[0].ReturnLength = NULL;
-            attr->Attributes[1].Attribute    = PS_ATTRIBUTE_TEB_ADDRESS;
-            attr->Attributes[1].Size         = sizeof(teb);
-            attr->Attributes[1].ValuePtr     = &teb;
-            attr->Attributes[1].ReturnLength = NULL;
-            result->create_thread.status = NtCreateThreadEx( &handle, THREAD_ALL_ACCESS, NULL,
-                                                             NtCurrentProcess(), func, arg,
-                                                             call->create_thread.flags, 0,
-                                                             commit, reserve, attr );
-            result->create_thread.handle = wine_server_obj_handle( handle );
-            result->create_thread.pid = HandleToULong(id.UniqueProcess);
-            result->create_thread.tid = HandleToULong(id.UniqueThread);
-            result->create_thread.teb = wine_server_client_ptr( teb );
-        }
-        else result->create_thread.status = STATUS_INVALID_PARAMETER;
-        break;
-    }
-    case APC_BREAK_PROCESS:
-    {
-        HANDLE handle;
-
-        result->type = APC_BREAK_PROCESS;
-        result->break_process.status = NtCreateThreadEx( &handle, THREAD_ALL_ACCESS, NULL,
-                                                         NtCurrentProcess(), pDbgUiRemoteBreakin, NULL,
-                                                         0, 0, 0, 0, NULL );
-        if (!result->break_process.status) NtClose( handle );
-        break;
-    }
-    default:
-        server_protocol_error( "get_apc_request: bad type %d\n", call->type );
-        break;
-    }
-}
-
-
-/***********************************************************************
- *              server_select
- */
-unsigned int server_select( const select_op_t *select_op, data_size_t size, UINT flags,
-                            timeout_t abs_timeout, CONTEXT *context, pthread_mutex_t *mutex,
-                            user_apc_t *user_apc )
-{
-    unsigned int ret;
-    int cookie;
-    obj_handle_t apc_handle = 0;
-    context_t server_context;
-    BOOL suspend_context = FALSE;
-    apc_call_t call;
-    apc_result_t result;
-    sigset_t old_set;
-
-    memset( &result, 0, sizeof(result) );
-    if (context)
-    {
-        suspend_context = TRUE;
-        context_to_server( &server_context, context );
-    }
-
-    do
-    {
-        pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
-        for (;;)
-        {
-            SERVER_START_REQ( select )
-            {
-                req->flags    = flags;
-                req->cookie   = wine_server_client_ptr( &cookie );
-                req->prev_apc = apc_handle;
-                req->timeout  = abs_timeout;
-                req->size     = size;
-                wine_server_add_data( req, &result, sizeof(result) );
-                wine_server_add_data( req, select_op, size );
-                if (suspend_context)
-                {
-                    wine_server_add_data( req, &server_context, sizeof(server_context) );
-                    suspend_context = FALSE; /* server owns the context now */
-                }
-                if (context) wine_server_set_reply( req, &server_context, sizeof(server_context) );
-                ret = server_call_unlocked( req );
-                apc_handle  = reply->apc_handle;
-                call        = reply->call;
-                if (wine_server_reply_size( reply ))
-                {
-                    DWORD context_flags = context->ContextFlags; /* unchanged registers are still available */
-                    context_from_server( context, &server_context );
-                    context->ContextFlags |= context_flags;
-                }
-            }
-            SERVER_END_REQ;
-
-            if (ret != STATUS_KERNEL_APC) break;
-            invoke_system_apc( &call, &result );
-
-            /* don't signal multiple times */
-            if (size >= sizeof(select_op->signal_and_wait) && select_op->op == SELECT_SIGNAL_AND_WAIT)
-                size = offsetof( select_op_t, signal_and_wait.signal );
-        }
-        pthread_sigmask( SIG_SETMASK, &old_set, NULL );
-        if (mutex)
-        {
-            pthread_mutex_unlock( mutex );
-            mutex = NULL;
-        }
-        if (ret != STATUS_PENDING) break;
-
-        ret = wait_select_reply( &cookie );
-    }
-    while (ret == STATUS_USER_APC || ret == STATUS_KERNEL_APC);
-
-    if (ret == STATUS_USER_APC) *user_apc = call.user;
-    return ret;
-}
-
-
-/***********************************************************************
- *              server_wait
- */
-unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT flags,
-                          const LARGE_INTEGER *timeout )
-{
-    timeout_t abs_timeout = timeout ? timeout->QuadPart : TIMEOUT_INFINITE;
-    unsigned int ret;
-    user_apc_t apc;
-
-    if (abs_timeout < 0)
-    {
-        LARGE_INTEGER now;
-
-        NtQueryPerformanceCounter( &now, NULL );
-        abs_timeout -= now.QuadPart;
-    }
-
-    ret = server_select( select_op, size, flags, abs_timeout, NULL, NULL, &apc );
-    if (ret == STATUS_USER_APC) invoke_apc( NULL, &apc );
-
-    /* A test on Windows 2000 shows that Windows always yields during
-       a wait, but a wait that is hit by an event gets a priority
-       boost as well.  This seems to model that behavior the closest.  */
-    if (ret == STATUS_TIMEOUT) NtYieldExecution();
-    return ret;
-}
-
-
-/***********************************************************************
- *              NtContinue  (NTDLL.@)
- */
-NTSTATUS WINAPI NtContinue( CONTEXT *context, BOOLEAN alertable )
-{
-    user_apc_t apc;
-    NTSTATUS status;
-
-    status = server_select( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, 0, NULL, NULL, &apc );
-    if (status == STATUS_USER_APC) invoke_apc( context, &apc );
-    return NtSetContextThread( GetCurrentThread(), context );
-}
-
-
-/***********************************************************************
- *           server_queue_process_apc
- */
-unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call, apc_result_t *result )
-{
-    for (;;)
-    {
-        unsigned int ret;
-        HANDLE handle = 0;
-        BOOL self = FALSE;
-
-        SERVER_START_REQ( queue_apc )
-        {
-            req->handle = wine_server_obj_handle( process );
-            req->call = *call;
-            if (!(ret = wine_server_call( req )))
-            {
-                handle = wine_server_ptr_handle( reply->handle );
-                self = reply->self;
-            }
-        }
-        SERVER_END_REQ;
-        if (ret != STATUS_SUCCESS) return ret;
-
-        if (self)
-        {
-            invoke_system_apc( call, result );
-        }
-        else
-        {
-            NtWaitForSingleObject( handle, FALSE, NULL );
-
-            SERVER_START_REQ( get_apc_result )
-            {
-                req->handle = wine_server_obj_handle( handle );
-                if (!(ret = wine_server_call( req ))) *result = reply->result;
-            }
-            SERVER_END_REQ;
-
-            if (!ret && result->type == APC_NONE) continue;  /* APC didn't run, try again */
-        }
-        return ret;
-    }
-}
-
-
-/***********************************************************************
- *           server_send_fd
- *
- * Send a file descriptor to the server.
- */
-void CDECL server_send_fd( int fd )
-{
-    struct send_fd data;
-    struct msghdr msghdr;
-    struct iovec vec;
-    int ret;
-
-#ifdef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS
-    msghdr.msg_accrights    = (void *)&fd;
-    msghdr.msg_accrightslen = sizeof(fd);
-#else  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
-    char cmsg_buffer[256];
-    struct cmsghdr *cmsg;
-    msghdr.msg_control    = cmsg_buffer;
-    msghdr.msg_controllen = sizeof(cmsg_buffer);
-    msghdr.msg_flags      = 0;
-    cmsg = CMSG_FIRSTHDR( &msghdr );
-    cmsg->cmsg_len   = CMSG_LEN( sizeof(fd) );
-    cmsg->cmsg_level = SOL_SOCKET;
-    cmsg->cmsg_type  = SCM_RIGHTS;
-    *(int *)CMSG_DATA(cmsg) = fd;
-    msghdr.msg_controllen = cmsg->cmsg_len;
-#endif  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
-
-    msghdr.msg_name    = NULL;
-    msghdr.msg_namelen = 0;
-    msghdr.msg_iov     = &vec;
-    msghdr.msg_iovlen  = 1;
-
-    vec.iov_base = (void *)&data;
-    vec.iov_len  = sizeof(data);
-
-    data.tid = GetCurrentThreadId();
-    data.fd  = fd;
-
-    for (;;)
-    {
-        if ((ret = sendmsg( fd_socket, &msghdr, 0 )) == sizeof(data)) return;
-        if (ret >= 0) server_protocol_error( "partial write %d\n", ret );
-        if (errno == EINTR) continue;
-        if (errno == EPIPE) abort_thread(0);
-        server_protocol_perror( "sendmsg" );
-    }
-}
-
-
-/***********************************************************************
- *           receive_fd
- *
- * Receive a file descriptor passed from the server.
- */
-static int receive_fd( obj_handle_t *handle )
-{
-    struct iovec vec;
-    struct msghdr msghdr;
-    int ret, fd = -1;
-
-#ifdef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS
-    msghdr.msg_accrights    = (void *)&fd;
-    msghdr.msg_accrightslen = sizeof(fd);
-#else  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
-    char cmsg_buffer[256];
-    msghdr.msg_control    = cmsg_buffer;
-    msghdr.msg_controllen = sizeof(cmsg_buffer);
-    msghdr.msg_flags      = 0;
-#endif  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
-
-    msghdr.msg_name    = NULL;
-    msghdr.msg_namelen = 0;
-    msghdr.msg_iov     = &vec;
-    msghdr.msg_iovlen  = 1;
-    vec.iov_base = (void *)handle;
-    vec.iov_len  = sizeof(*handle);
-
-    for (;;)
-    {
-        if ((ret = recvmsg( fd_socket, &msghdr, MSG_CMSG_CLOEXEC )) > 0)
-        {
-#ifndef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS
-            struct cmsghdr *cmsg;
-            for (cmsg = CMSG_FIRSTHDR( &msghdr ); cmsg; cmsg = CMSG_NXTHDR( &msghdr, cmsg ))
-            {
-                if (cmsg->cmsg_level != SOL_SOCKET) continue;
-                if (cmsg->cmsg_type == SCM_RIGHTS) fd = *(int *)CMSG_DATA(cmsg);
-#ifdef SCM_CREDENTIALS
-                else if (cmsg->cmsg_type == SCM_CREDENTIALS)
-                {
-                    struct ucred *ucred = (struct ucred *)CMSG_DATA(cmsg);
-                    server_pid = ucred->pid;
-                }
-#endif
-            }
-#endif  /* HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
-            if (fd != -1) fcntl( fd, F_SETFD, FD_CLOEXEC ); /* in case MSG_CMSG_CLOEXEC is not supported */
-            return fd;
-        }
-        if (!ret) break;
-        if (errno == EINTR) continue;
-        if (errno == EPIPE) break;
-        server_protocol_perror("recvmsg");
-    }
-    /* the server closed the connection; time to die... */
-    abort_thread(0);
-}
-
-
-/***********************************************************************/
-/* fd cache support */
-
-union fd_cache_entry
-{
-    LONG64 data;
-    struct
-    {
-        int fd;
-        enum server_fd_type type : 5;
-        unsigned int        access : 3;
-        unsigned int        options : 24;
-    } s;
-};
-
-C_ASSERT( sizeof(union fd_cache_entry) == sizeof(LONG64) );
-
-#define FD_CACHE_BLOCK_SIZE  (65536 / sizeof(union fd_cache_entry))
-#define FD_CACHE_ENTRIES     128
-
-static union fd_cache_entry *fd_cache[FD_CACHE_ENTRIES];
-static union fd_cache_entry fd_cache_initial_block[FD_CACHE_BLOCK_SIZE];
-
-static inline unsigned int handle_to_index( HANDLE handle, unsigned int *entry )
-{
-    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
-    *entry = idx / FD_CACHE_BLOCK_SIZE;
-    return idx % FD_CACHE_BLOCK_SIZE;
-}
-
-
-/***********************************************************************
- *           add_fd_to_cache
- *
- * Caller must hold fd_cache_mutex.
- */
-static BOOL add_fd_to_cache( HANDLE handle, int fd, enum server_fd_type type,
-                            unsigned int access, unsigned int options )
-{
-    unsigned int entry, idx = handle_to_index( handle, &entry );
-    union fd_cache_entry cache;
-
-    if (entry >= FD_CACHE_ENTRIES)
-    {
-        FIXME( "too many allocated handles, not caching %p\n", handle );
-        return FALSE;
-    }
-
-    if (!fd_cache[entry])  /* do we need to allocate a new block of entries? */
-    {
-        if (!entry) fd_cache[0] = fd_cache_initial_block;
-        else
-        {
-            void *ptr = wine_anon_mmap( NULL, FD_CACHE_BLOCK_SIZE * sizeof(union fd_cache_entry),
-                                        PROT_READ | PROT_WRITE, 0 );
-            if (ptr == MAP_FAILED) return FALSE;
-            fd_cache[entry] = ptr;
-        }
-    }
-
-    /* store fd+1 so that 0 can be used as the unset value */
-    cache.s.fd = fd + 1;
-    cache.s.type = type;
-    cache.s.access = access;
-    cache.s.options = options;
-    cache.data = interlocked_xchg64( &fd_cache[entry][idx].data, cache.data );
-    assert( !cache.s.fd );
-    return TRUE;
-}
-
-
-/***********************************************************************
- *           get_cached_fd
- */
-static inline NTSTATUS get_cached_fd( HANDLE handle, int *fd, enum server_fd_type *type,
-                                      unsigned int *access, unsigned int *options )
-{
-    unsigned int entry, idx = handle_to_index( handle, &entry );
-    union fd_cache_entry cache;
-
-    if (entry >= FD_CACHE_ENTRIES || !fd_cache[entry]) return STATUS_INVALID_HANDLE;
-
-    cache.data = InterlockedCompareExchange64( &fd_cache[entry][idx].data, 0, 0 );
-    if (!cache.data) return STATUS_INVALID_HANDLE;
-
-    /* if fd type is invalid, fd stores an error value */
-    if (cache.s.type == FD_TYPE_INVALID) return cache.s.fd - 1;
-
-    *fd = cache.s.fd - 1;
-    if (type) *type = cache.s.type;
-    if (access) *access = cache.s.access;
-    if (options) *options = cache.s.options;
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           remove_fd_from_cache
- */
-static int remove_fd_from_cache( HANDLE handle )
-{
-    unsigned int entry, idx = handle_to_index( handle, &entry );
-    int fd = -1;
-
-    if (entry < FD_CACHE_ENTRIES && fd_cache[entry])
-    {
-        union fd_cache_entry cache;
-        cache.data = interlocked_xchg64( &fd_cache[entry][idx].data, 0 );
-        if (cache.s.type != FD_TYPE_INVALID) fd = cache.s.fd - 1;
-    }
-
-    return fd;
-}
-
-
-/***********************************************************************
- *           server_get_unix_fd
- *
- * The returned unix_fd should be closed iff needs_close is non-zero.
- */
-int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
-                        int *needs_close, enum server_fd_type *type, unsigned int *options )
-{
-    sigset_t sigset;
-    obj_handle_t fd_handle;
-    int ret, fd = -1;
-    unsigned int access = 0;
-
-    *unix_fd = -1;
-    *needs_close = 0;
-    wanted_access &= FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA;
-
-    ret = get_cached_fd( handle, &fd, type, &access, options );
-    if (ret != STATUS_INVALID_HANDLE) goto done;
-
-    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-    ret = get_cached_fd( handle, &fd, type, &access, options );
-    if (ret == STATUS_INVALID_HANDLE)
-    {
-        SERVER_START_REQ( get_handle_fd )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (!(ret = wine_server_call( req )))
-            {
-                if (type) *type = reply->type;
-                if (options) *options = reply->options;
-                access = reply->access;
-                if ((fd = receive_fd( &fd_handle )) != -1)
-                {
-                    assert( wine_server_ptr_handle(fd_handle) == handle );
-                    *needs_close = (!reply->cacheable ||
-                                    !add_fd_to_cache( handle, fd, reply->type,
-                                                      reply->access, reply->options ));
-                }
-                else ret = STATUS_TOO_MANY_OPENED_FILES;
-            }
-            else if (reply->cacheable)
-            {
-                add_fd_to_cache( handle, ret, FD_TYPE_INVALID, 0, 0 );
-            }
-        }
-        SERVER_END_REQ;
-    }
-    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-done:
-    if (!ret && ((access & wanted_access) != wanted_access))
-    {
-        ret = STATUS_ACCESS_DENIED;
-        if (*needs_close) close( fd );
-    }
-    if (!ret) *unix_fd = fd;
-    return ret;
-}
-
-
-/***********************************************************************
- *           server_fd_to_handle
- */
-NTSTATUS CDECL server_fd_to_handle( int fd, unsigned int access, unsigned int attributes, HANDLE *handle )
-{
-    NTSTATUS ret;
-
-    *handle = 0;
-    server_send_fd( fd );
-
-    SERVER_START_REQ( alloc_file_handle )
-    {
-        req->access     = access;
-        req->attributes = attributes;
-        req->fd         = fd;
-        if (!(ret = wine_server_call( req ))) *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/***********************************************************************
- *           server_handle_to_fd
- *
- * Retrieve the file descriptor corresponding to a file handle.
- */
-NTSTATUS CDECL server_handle_to_fd( HANDLE handle, unsigned int access, int *unix_fd,
-                                    unsigned int *options )
-{
-    int needs_close;
-    NTSTATUS ret = server_get_unix_fd( handle, access, unix_fd, &needs_close, NULL, options );
-
-    if (!ret && !needs_close)
-    {
-        if ((*unix_fd = dup(*unix_fd)) == -1) ret = STATUS_TOO_MANY_OPENED_FILES;
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *           server_release_fd
- */
-void CDECL server_release_fd( HANDLE handle, int unix_fd )
-{
-    close( unix_fd );
-}
-
-
-/***********************************************************************
- *           server_pipe
- *
- * Create a pipe for communicating with the server.
- */
-int server_pipe( int fd[2] )
-{
-    int ret;
-#ifdef HAVE_PIPE2
-    static BOOL have_pipe2 = TRUE;
-
-    if (have_pipe2)
-    {
-        if (!(ret = pipe2( fd, O_CLOEXEC ))) return ret;
-        if (errno == ENOSYS || errno == EINVAL) have_pipe2 = FALSE;  /* don't try again */
-    }
-#endif
-    if (!(ret = pipe( fd )))
-    {
-        fcntl( fd[0], F_SETFD, FD_CLOEXEC );
-        fcntl( fd[1], F_SETFD, FD_CLOEXEC );
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *           init_server_dir
- */
-static const char *init_server_dir( dev_t dev, ino_t ino )
-{
-    char *p, *dir;
-    size_t len = sizeof("/server-") + 2 * sizeof(dev) + 2 * sizeof(ino) + 2;
-
-#ifdef __ANDROID__  /* there's no /tmp dir on Android */
-    len += strlen( config_dir ) + sizeof("/.wineserver");
-    dir = malloc( len );
-    strcpy( dir, config_dir );
-    strcat( dir, "/.wineserver/server-" );
-#else
-    len += sizeof("/tmp/.wine-") + 12;
-    dir = malloc( len );
-    sprintf( dir, "/tmp/.wine-%u/server-", getuid() );
-#endif
-    p = dir + strlen( dir );
-    if (dev != (unsigned long)dev)
-        p += sprintf( p, "%lx%08lx-", (unsigned long)((unsigned long long)dev >> 32), (unsigned long)dev );
-    else
-        p += sprintf( p, "%lx-", (unsigned long)dev );
-
-    if (ino != (unsigned long)ino)
-        sprintf( p, "%lx%08lx", (unsigned long)((unsigned long long)ino >> 32), (unsigned long)ino );
-    else
-        sprintf( p, "%lx", (unsigned long)ino );
-    return dir;
-}
-
-
-/***********************************************************************
- *           setup_config_dir
- *
- * Setup the wine configuration dir.
- */
-static int setup_config_dir(void)
-{
-    char *p;
-    struct stat st;
-    int fd_cwd = open( ".", O_RDONLY );
-
-    if (chdir( config_dir ) == -1)
-    {
-        if (errno != ENOENT) fatal_perror( "cannot use directory %s", config_dir );
-        if ((p = strrchr( config_dir, '/' )) && p != config_dir)
-        {
-            while (p > config_dir + 1 && p[-1] == '/') p--;
-            *p = 0;
-            if (!stat( config_dir, &st ) && st.st_uid != getuid())
-                fatal_error( "'%s' is not owned by you, refusing to create a configuration directory there\n",
-                             config_dir );
-            *p = '/';
-        }
-        mkdir( config_dir, 0777 );
-        if (chdir( config_dir ) == -1) fatal_perror( "chdir to %s", config_dir );
-        MESSAGE( "wine: created the configuration directory '%s'\n", config_dir );
-    }
-
-    if (stat( ".", &st ) == -1) fatal_perror( "stat %s", config_dir );
-    if (st.st_uid != getuid()) fatal_error( "'%s' is not owned by you\n", config_dir );
-
-    server_dir = init_server_dir( st.st_dev, st.st_ino );
-
-    if (!mkdir( "dosdevices", 0777 ))
-    {
-        mkdir( "drive_c", 0777 );
-        symlink( "../drive_c", "dosdevices/c:" );
-        symlink( "/", "dosdevices/z:" );
-    }
-    else if (errno != EEXIST) fatal_perror( "cannot create %s/dosdevices", config_dir );
-
-    if (fd_cwd == -1) fd_cwd = open( "dosdevices/c:", O_RDONLY );
-    fcntl( fd_cwd, F_SETFD, FD_CLOEXEC );
-    return fd_cwd;
-}
-
-
-/***********************************************************************
- *           server_connect_error
- *
- * Try to display a meaningful explanation of why we couldn't connect
- * to the server.
- */
-static void server_connect_error( const char *serverdir )
-{
-    int fd;
-    struct flock fl;
-
-    if ((fd = open( LOCKNAME, O_WRONLY )) == -1)
-        fatal_error( "for some mysterious reason, the wine server never started.\n" );
-
-    fl.l_type   = F_WRLCK;
-    fl.l_whence = SEEK_SET;
-    fl.l_start  = 0;
-    fl.l_len    = 1;
-    if (fcntl( fd, F_GETLK, &fl ) != -1)
-    {
-        if (fl.l_type == F_WRLCK)  /* the file is locked */
-            fatal_error( "a wine server seems to be running, but I cannot connect to it.\n"
-                         "   You probably need to kill that process (it might be pid %d).\n",
-                         (int)fl.l_pid );
-        fatal_error( "for some mysterious reason, the wine server failed to run.\n" );
-    }
-    fatal_error( "the file system of '%s' doesn't support locks,\n"
-          "   and there is a 'socket' file in that directory that prevents wine from starting.\n"
-          "   You should make sure no wine server is running, remove that file and try again.\n",
-                 serverdir );
-}
-
-
-/***********************************************************************
- *           server_connect
- *
- * Attempt to connect to an existing server socket.
- * We need to be in the server directory already.
- */
-static int server_connect(void)
-{
-    struct sockaddr_un addr;
-    struct stat st;
-    int s, slen, retry, fd_cwd;
-
-    fd_cwd = setup_config_dir();
-
-    /* chdir to the server directory */
-    if (chdir( server_dir ) == -1)
-    {
-        if (errno != ENOENT) fatal_perror( "chdir to %s", server_dir );
-        start_server( TRACE_ON(server) );
-        if (chdir( server_dir ) == -1) fatal_perror( "chdir to %s", server_dir );
-    }
-
-    /* make sure we are at the right place */
-    if (stat( ".", &st ) == -1) fatal_perror( "stat %s", server_dir );
-    if (st.st_uid != getuid()) fatal_error( "'%s' is not owned by you\n", server_dir );
-    if (st.st_mode & 077) fatal_error( "'%s' must not be accessible by other users\n", server_dir );
-
-    for (retry = 0; retry < 6; retry++)
-    {
-        /* if not the first try, wait a bit to leave the previous server time to exit */
-        if (retry)
-        {
-            usleep( 100000 * retry * retry );
-            start_server( TRACE_ON(server) );
-            if (lstat( SOCKETNAME, &st ) == -1) continue;  /* still no socket, wait a bit more */
-        }
-        else if (lstat( SOCKETNAME, &st ) == -1) /* check for an already existing socket */
-        {
-            if (errno != ENOENT) fatal_perror( "lstat %s/%s", server_dir, SOCKETNAME );
-            start_server( TRACE_ON(server) );
-            if (lstat( SOCKETNAME, &st ) == -1) continue;  /* still no socket, wait a bit more */
-        }
-
-        /* make sure the socket is sane (ISFIFO needed for Solaris) */
-        if (!S_ISSOCK(st.st_mode) && !S_ISFIFO(st.st_mode))
-            fatal_error( "'%s/%s' is not a socket\n", server_dir, SOCKETNAME );
-        if (st.st_uid != getuid())
-            fatal_error( "'%s/%s' is not owned by you\n", server_dir, SOCKETNAME );
-
-        /* try to connect to it */
-        addr.sun_family = AF_UNIX;
-        strcpy( addr.sun_path, SOCKETNAME );
-        slen = sizeof(addr) - sizeof(addr.sun_path) + strlen(addr.sun_path) + 1;
-#ifdef HAVE_STRUCT_SOCKADDR_UN_SUN_LEN
-        addr.sun_len = slen;
-#endif
-        if ((s = socket( AF_UNIX, SOCK_STREAM, 0 )) == -1) fatal_perror( "socket" );
-#ifdef SO_PASSCRED
-        else
-        {
-            int enable = 1;
-            setsockopt( s, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
-        }
-#endif
-        if (connect( s, (struct sockaddr *)&addr, slen ) != -1)
-        {
-            /* switch back to the starting directory */
-            if (fd_cwd != -1)
-            {
-                fchdir( fd_cwd );
-                close( fd_cwd );
-            }
-            fcntl( s, F_SETFD, FD_CLOEXEC );
-            return s;
-        }
-        close( s );
-    }
-    server_connect_error( server_dir );
-}
-
-
-#ifdef __APPLE__
-#include <mach/mach.h>
-#include <mach/mach_error.h>
-#include <servers/bootstrap.h>
-
-/* send our task port to the server */
-static void send_server_task_port(void)
-{
-    mach_port_t bootstrap_port, wineserver_port;
-    kern_return_t kret;
-
-    struct {
-        mach_msg_header_t           header;
-        mach_msg_body_t             body;
-        mach_msg_port_descriptor_t  task_port;
-    } msg;
-
-    if (task_get_bootstrap_port(mach_task_self(), &bootstrap_port) != KERN_SUCCESS) return;
-
-    if (!server_dir)
-    {
-        struct stat st;
-        stat( config_dir, &st );
-        server_dir = init_server_dir( st.st_dev, st.st_ino );
-    }
-    kret = bootstrap_look_up(bootstrap_port, server_dir, &wineserver_port);
-    if (kret != KERN_SUCCESS)
-        fatal_error( "cannot find the server port: 0x%08x\n", kret );
-
-    mach_port_deallocate(mach_task_self(), bootstrap_port);
-
-    msg.header.msgh_bits        = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
-    msg.header.msgh_size        = sizeof(msg);
-    msg.header.msgh_remote_port = wineserver_port;
-    msg.header.msgh_local_port  = MACH_PORT_NULL;
-
-    msg.body.msgh_descriptor_count  = 1;
-    msg.task_port.name              = mach_task_self();
-    msg.task_port.disposition       = MACH_MSG_TYPE_COPY_SEND;
-    msg.task_port.type              = MACH_MSG_PORT_DESCRIPTOR;
-
-    kret = mach_msg_send(&msg.header);
-    if (kret != KERN_SUCCESS)
-        server_protocol_error( "mach_msg_send failed: 0x%08x\n", kret );
-
-    mach_port_deallocate(mach_task_self(), wineserver_port);
-}
-#endif  /* __APPLE__ */
-
-
-/***********************************************************************
- *           get_unix_tid
- *
- * Retrieve the Unix tid to use on the server side for the current thread.
- */
-static int get_unix_tid(void)
-{
-    int ret = -1;
-#ifdef HAVE_PTHREAD_GETTHREADID_NP
-    ret = pthread_getthreadid_np();
-#elif defined(linux)
-    ret = syscall( __NR_gettid );
-#elif defined(__sun)
-    ret = pthread_self();
-#elif defined(__APPLE__)
-    ret = mach_thread_self();
-    mach_port_deallocate(mach_task_self(), ret);
-#elif defined(__NetBSD__)
-    ret = _lwp_self();
-#elif defined(__FreeBSD__)
-    long lwpid;
-    thr_self( &lwpid );
-    ret = lwpid;
-#elif defined(__DragonFly__)
-    ret = lwp_gettid();
-#endif
-    return ret;
-}
-
-
-/***********************************************************************
- *           server_init_process
- *
- * Start the server and create the initial socket pair.
- */
-void server_init_process(void)
-{
-    obj_handle_t version;
-    const char *env_socket = getenv( "WINESERVERSOCKET" );
-
-    server_pid = -1;
-    if (env_socket)
-    {
-        fd_socket = atoi( env_socket );
-        if (fcntl( fd_socket, F_SETFD, FD_CLOEXEC ) == -1)
-            fatal_perror( "Bad server socket %d", fd_socket );
-        unsetenv( "WINESERVERSOCKET" );
-    }
-    else
-    {
-        const char *arch = getenv( "WINEARCH" );
-
-        if (arch && strcmp( arch, "win32" ) && strcmp( arch, "win64" ))
-            fatal_error( "WINEARCH set to invalid value '%s', it must be either win32 or win64.\n", arch );
-
-        fd_socket = server_connect();
-    }
-
-    /* setup the signal mask */
-    sigemptyset( &server_block_set );
-    sigaddset( &server_block_set, SIGALRM );
-    sigaddset( &server_block_set, SIGIO );
-    sigaddset( &server_block_set, SIGINT );
-    sigaddset( &server_block_set, SIGHUP );
-    sigaddset( &server_block_set, SIGUSR1 );
-    sigaddset( &server_block_set, SIGUSR2 );
-    sigaddset( &server_block_set, SIGCHLD );
-    pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
-
-    /* receive the first thread request fd on the main socket */
-    ntdll_get_thread_data()->request_fd = receive_fd( &version );
-
-#ifdef SO_PASSCRED
-    /* now that we hopefully received the server_pid, disable SO_PASSCRED */
-    {
-        int enable = 0;
-        setsockopt( fd_socket, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
-    }
-#endif
-
-    if (version != SERVER_PROTOCOL_VERSION)
-        server_protocol_error( "version mismatch %d/%d.\n"
-                               "Your %s binary was not upgraded correctly,\n"
-                               "or you have an older one somewhere in your PATH.\n"
-                               "Or maybe the wrong wineserver is still running?\n",
-                               version, SERVER_PROTOCOL_VERSION,
-                               (version > SERVER_PROTOCOL_VERSION) ? "wine" : "wineserver" );
-#if defined(__linux__) && defined(HAVE_PRCTL)
-    /* work around Ubuntu's ptrace breakage */
-    if (server_pid != -1) prctl( 0x59616d61 /* PR_SET_PTRACER */, server_pid );
-#endif
-}
-
-
-/***********************************************************************
- *           server_init_process_done
- */
-void CDECL server_init_process_done( void *relay )
-{
-    PEB *peb = NtCurrentTeb()->Peb;
-    IMAGE_NT_HEADERS *nt = get_exe_nt_header();
-    void *entry = (char *)peb->ImageBaseAddress + nt->OptionalHeader.AddressOfEntryPoint;
-    NTSTATUS status;
-    int suspend;
-
-#ifdef __APPLE__
-    send_server_task_port();
-#endif
-    if (nt->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) virtual_set_large_address_space();
-
-    /* Install signal handlers; this cannot be done earlier, since we cannot
-     * send exceptions to the debugger before the create process event that
-     * is sent by init_process_done */
-    signal_init_process();
-
-    /* Signal the parent process to continue */
-    SERVER_START_REQ( init_process_done )
-    {
-        req->module   = wine_server_client_ptr( peb->ImageBaseAddress );
-#ifdef __i386__
-        req->ldt_copy = wine_server_client_ptr( &__wine_ldt_copy );
-#endif
-        req->entry    = wine_server_client_ptr( entry );
-        req->gui      = (nt->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_WINDOWS_CUI);
-        status = wine_server_call( req );
-        suspend = reply->suspend;
-    }
-    SERVER_END_REQ;
-
-    assert( !status );
-    signal_start_thread( entry, peb, suspend, relay, NtCurrentTeb() );
-}
-
-
-/***********************************************************************
- *           server_init_thread
- *
- * Send an init thread request.
- */
-size_t server_init_thread( void *entry_point, BOOL *suspend )
-{
-    static const char *cpu_names[] = { "x86", "x86_64", "PowerPC", "ARM", "ARM64" };
-    const char *arch = getenv( "WINEARCH" );
-    int ret;
-    int reply_pipe[2];
-    struct sigaction sig_act;
-    stack_t ss;
-    size_t info_size;
-
-    /* ignore SIGPIPE so that we get an EPIPE error instead  */
-    sig_act.sa_handler = SIG_IGN;
-    sig_act.sa_flags   = 0;
-    sigemptyset( &sig_act.sa_mask );
-    sigaction( SIGPIPE, &sig_act, NULL );
-
-    ss.ss_sp    = get_signal_stack();
-    ss.ss_size  = signal_stack_size;
-    ss.ss_flags = 0;
-    sigaltstack( &ss, NULL );
-
-    /* create the server->client communication pipes */
-    if (server_pipe( reply_pipe ) == -1) server_protocol_perror( "pipe" );
-    if (server_pipe( ntdll_get_thread_data()->wait_fd ) == -1) server_protocol_perror( "pipe" );
-    server_send_fd( reply_pipe[1] );
-    server_send_fd( ntdll_get_thread_data()->wait_fd[1] );
-    ntdll_get_thread_data()->reply_fd = reply_pipe[0];
-    close( reply_pipe[1] );
-
-    SERVER_START_REQ( init_thread )
-    {
-        req->unix_pid    = getpid();
-        req->unix_tid    = get_unix_tid();
-        req->teb         = wine_server_client_ptr( NtCurrentTeb() );
-        req->entry       = wine_server_client_ptr( entry_point );
-        req->reply_fd    = reply_pipe[1];
-        req->wait_fd     = ntdll_get_thread_data()->wait_fd[1];
-        req->debug_level = (TRACE_ON(server) != 0);
-        req->cpu         = client_cpu;
-        ret = wine_server_call( req );
-        NtCurrentTeb()->ClientId.UniqueProcess = ULongToHandle(reply->pid);
-        NtCurrentTeb()->ClientId.UniqueThread  = ULongToHandle(reply->tid);
-        info_size         = reply->info_size;
-        server_start_time = reply->server_start;
-        server_cpus       = reply->all_cpus;
-        *suspend          = reply->suspend;
-    }
-    SERVER_END_REQ;
-
-#ifndef _WIN64
-    is_wow64 = (server_cpus & ((1 << CPU_x86_64) | (1 << CPU_ARM64))) != 0;
-    if (is_wow64)
-    {
-        TEB64 *teb64 = (TEB64 *)((char *)NtCurrentTeb() - teb_offset);
-
-        NtCurrentTeb()->GdiBatchCount = PtrToUlong( teb64 );
-        NtCurrentTeb()->WowTebOffset  = -teb_offset;
-        teb64->ClientId.UniqueProcess = PtrToUlong( NtCurrentTeb()->ClientId.UniqueProcess );
-        teb64->ClientId.UniqueThread  = PtrToUlong( NtCurrentTeb()->ClientId.UniqueThread );
-    }
-#endif
-
-    switch (ret)
-    {
-    case STATUS_SUCCESS:
-        if (arch)
-        {
-            if (!strcmp( arch, "win32" ) && (is_win64 || is_wow64))
-                fatal_error( "WINEARCH set to win32 but '%s' is a 64-bit installation.\n", config_dir );
-            if (!strcmp( arch, "win64" ) && !is_win64 && !is_wow64)
-                fatal_error( "WINEARCH set to win64 but '%s' is a 32-bit installation.\n", config_dir );
-        }
-        return info_size;
-    case STATUS_INVALID_IMAGE_WIN_64:
-        fatal_error( "'%s' is a 32-bit installation, it cannot support 64-bit applications.\n", config_dir );
-    case STATUS_NOT_SUPPORTED:
-        fatal_error( "'%s' is a 64-bit installation, it cannot be used with a 32-bit wineserver.\n", config_dir );
-    case STATUS_INVALID_IMAGE_FORMAT:
-        fatal_error( "wineserver doesn't support the %s architecture\n", cpu_names[client_cpu] );
-    default:
-        server_protocol_error( "init_thread failed with status %x\n", ret );
-    }
-}
-
-
-/***********************************************************************
- *           DbgUiIssueRemoteBreakin
- */
-NTSTATUS WINAPI DbgUiIssueRemoteBreakin( HANDLE process )
-{
-    apc_call_t call;
-    apc_result_t result;
-    NTSTATUS status;
-
-    memset( &call, 0, sizeof(call) );
-    call.type = APC_BREAK_PROCESS;
-    status = server_queue_process_apc( process, &call, &result );
-    if (status) return status;
-    return result.break_process.status;
-}
-
-
-/******************************************************************************
- *           NtDuplicateObject
- */
-NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE dest_process, HANDLE *dest,
-                                   ACCESS_MASK access, ULONG attributes, ULONG options )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( dup_handle )
-    {
-        req->src_process = wine_server_obj_handle( source_process );
-        req->src_handle  = wine_server_obj_handle( source );
-        req->dst_process = wine_server_obj_handle( dest_process );
-        req->access      = access;
-        req->attributes  = attributes;
-        req->options     = options;
-        if (!(ret = wine_server_call( req )))
-        {
-            if (dest) *dest = wine_server_ptr_handle( reply->handle );
-            if (reply->closed && reply->self)
-            {
-                int fd = remove_fd_from_cache( source );
-                if (fd != -1) close( fd );
-            }
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *           NtClose
- */
-NTSTATUS WINAPI NtClose( HANDLE handle )
-{
-    HANDLE port;
-    NTSTATUS ret;
-    int fd = remove_fd_from_cache( handle );
-
-    SERVER_START_REQ( close_handle )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    if (fd != -1) close( fd );
-
-    if (ret != STATUS_INVALID_HANDLE || !handle) return ret;
-    if (!NtCurrentTeb()->Peb->BeingDebugged) return ret;
-    if (!NtQueryInformationProcess( NtCurrentProcess(), ProcessDebugPort, &port, sizeof(port), NULL) && port)
-    {
-        NtCurrentTeb()->ExceptionCode = ret;
-        call_raise_user_exception_dispatcher( pKiRaiseUserExceptionDispatcher );
-    }
-    return ret;
-}
diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
deleted file mode 100644
index e619dbd975..0000000000
--- a/dlls/ntdll/unix/signal_arm.c
+++ /dev/null
@@ -1,988 +0,0 @@
-/*
- * ARM signal handling routines
- *
- * Copyright 2002 Marcus Meissner, SuSE Linux AG
- * Copyright 2010-2013, 2015 André Hentschel
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#ifdef __arm__
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdio.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef HAVE_SYS_PARAM_H
-# include <sys/param.h>
-#endif
-#ifdef HAVE_SYSCALL_H
-# include <syscall.h>
-#else
-# ifdef HAVE_SYS_SYSCALL_H
-#  include <sys/syscall.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SIGNAL_H
-# include <sys/signal.h>
-#endif
-#ifdef HAVE_SYS_UCONTEXT_H
-# include <sys/ucontext.h>
-#endif
-
-#define NONAMELESSUNION
-#define NONAMELESSSTRUCT
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winnt.h"
-#include "winternl.h"
-#include "wine/exception.h"
-#include "wine/asm.h"
-#include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(seh);
-
-static pthread_key_t teb_key;
-
-
-/***********************************************************************
- * signal context platform-specific definitions
- */
-#ifdef linux
-
-#if defined(__ANDROID__) && !defined(HAVE_SYS_UCONTEXT_H)
-typedef struct ucontext
-{
-    unsigned long uc_flags;
-    struct ucontext *uc_link;
-    stack_t uc_stack;
-    struct sigcontext uc_mcontext;
-    sigset_t uc_sigmask;
-    unsigned long uc_regspace[128] __attribute__((__aligned__(8)));
-} ucontext_t;
-#endif
-
-/* All Registers access - only for local access */
-# define REG_sig(reg_name, context) ((context)->uc_mcontext.reg_name)
-# define REGn_sig(reg_num, context) ((context)->uc_mcontext.arm_r##reg_num)
-
-/* Special Registers access  */
-# define SP_sig(context)            REG_sig(arm_sp, context)    /* Stack pointer */
-# define LR_sig(context)            REG_sig(arm_lr, context)    /* Link register */
-# define PC_sig(context)            REG_sig(arm_pc, context)    /* Program counter */
-# define CPSR_sig(context)          REG_sig(arm_cpsr, context)  /* Current State Register */
-# define IP_sig(context)            REG_sig(arm_ip, context)    /* Intra-Procedure-call scratch register */
-# define FP_sig(context)            REG_sig(arm_fp, context)    /* Frame pointer */
-
-/* Exceptions */
-# define ERROR_sig(context)         REG_sig(error_code, context)
-# define TRAP_sig(context)          REG_sig(trap_no, context)
-
-struct extended_ctx
-{
-    unsigned long magic;
-    unsigned long size;
-};
-
-struct vfp_sigframe
-{
-    struct extended_ctx ctx;
-    unsigned long long fpregs[32];
-    unsigned long fpscr;
-};
-
-static void *get_extended_sigcontext( const ucontext_t *sigcontext, unsigned int magic )
-{
-    struct extended_ctx *ctx = (struct extended_ctx *)sigcontext->uc_regspace;
-    while ((char *)ctx < (char *)(sigcontext + 1) && ctx->magic && ctx->size)
-    {
-        if (ctx->magic == magic) return ctx;
-        ctx = (struct extended_ctx *)((char *)ctx + ctx->size);
-    }
-    return NULL;
-}
-
-static void save_fpu( CONTEXT *context, const ucontext_t *sigcontext )
-{
-    struct vfp_sigframe *frame = get_extended_sigcontext( sigcontext, 0x56465001 );
-
-    if (!frame) return;
-    memcpy( context->u.D, frame->fpregs, sizeof(context->u.D) );
-    context->Fpscr = frame->fpscr;
-}
-
-static void restore_fpu( const CONTEXT *context, ucontext_t *sigcontext )
-{
-    struct vfp_sigframe *frame = get_extended_sigcontext( sigcontext, 0x56465001 );
-
-    if (!frame) return;
-    memcpy( frame->fpregs, context->u.D, sizeof(context->u.D) );
-    frame->fpscr = context->Fpscr;
-}
-
-#elif defined(__FreeBSD__)
-
-/* All Registers access - only for local access */
-# define REGn_sig(reg_num, context) ((context)->uc_mcontext.__gregs[reg_num])
-
-/* Special Registers access  */
-# define SP_sig(context)            REGn_sig(_REG_SP, context)    /* Stack pointer */
-# define LR_sig(context)            REGn_sig(_REG_LR, context)    /* Link register */
-# define PC_sig(context)            REGn_sig(_REG_PC, context)    /* Program counter */
-# define CPSR_sig(context)          REGn_sig(_REG_CPSR, context)  /* Current State Register */
-# define IP_sig(context)            REGn_sig(_REG_R12, context)   /* Intra-Procedure-call scratch register */
-# define FP_sig(context)            REGn_sig(_REG_FP, context)    /* Frame pointer */
-
-static void save_fpu( CONTEXT *context, const ucontext_t *sigcontext ) { }
-static void restore_fpu( const CONTEXT *context, ucontext_t *sigcontext ) { }
-
-#endif /* linux */
-
-enum arm_trap_code
-{
-    TRAP_ARM_UNKNOWN    = -1,  /* Unknown fault (TRAP_sig not defined) */
-    TRAP_ARM_PRIVINFLT  =  6,  /* Invalid opcode exception */
-    TRAP_ARM_PAGEFLT    = 14,  /* Page fault */
-    TRAP_ARM_ALIGNFLT   = 17,  /* Alignment check exception */
-};
-
-struct syscall_frame
-{
-    struct syscall_frame *prev_frame;
-    DWORD                 cpsr;
-    DWORD                 r5;
-    DWORD                 r6;
-    DWORD                 r7;
-    DWORD                 r8;
-    DWORD                 r9;
-    DWORD                 r10;
-    DWORD                 r11;
-    DWORD                 thunk_addr;
-    DWORD                 r4;
-    DWORD                 ret_addr;
-};
-
-struct arm_thread_data
-{
-    void                 *exit_frame;    /* 1d4 exit frame pointer */
-    struct syscall_frame *syscall_frame; /* 1d8 frame pointer on syscall entry */
-};
-
-C_ASSERT( sizeof(struct arm_thread_data) <= sizeof(((struct ntdll_thread_data *)0)->cpu_data) );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct arm_thread_data, exit_frame ) == 0x1d4 );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct arm_thread_data, syscall_frame ) == 0x1d8 );
-
-static inline struct arm_thread_data *arm_thread_data(void)
-{
-    return (struct arm_thread_data *)ntdll_get_thread_data()->cpu_data;
-}
-
-
-/***********************************************************************
- *           unwind_builtin_dll
- */
-NTSTATUS CDECL unwind_builtin_dll( ULONG type, struct _DISPATCHER_CONTEXT *dispatch, CONTEXT *context )
-{
-    return STATUS_UNSUCCESSFUL;
-}
-
-
-/***********************************************************************
- *           get_trap_code
- *
- * Get the trap code for a signal.
- */
-static inline enum arm_trap_code get_trap_code( int signal, const ucontext_t *sigcontext )
-{
-#ifdef TRAP_sig
-    enum arm_trap_code trap = TRAP_sig(sigcontext);
-    if (trap)
-        return trap;
-#endif
-
-    switch (signal)
-    {
-    case SIGILL:
-        return TRAP_ARM_PRIVINFLT;
-    case SIGSEGV:
-        return TRAP_ARM_PAGEFLT;
-    case SIGBUS:
-        return TRAP_ARM_ALIGNFLT;
-    default:
-        return TRAP_ARM_UNKNOWN;
-    }
-}
-
-
-/***********************************************************************
- *           get_error_code
- *
- * Get the error code for a signal.
- */
-static inline WORD get_error_code( const ucontext_t *sigcontext )
-{
-#ifdef ERROR_sig
-    return ERROR_sig(sigcontext);
-#else
-    return 0;
-#endif
-}
-
-
-/***********************************************************************
- *           save_context
- *
- * Set the register values from a sigcontext.
- */
-static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
-{
-#define C(x) context->R##x = REGn_sig(x,sigcontext)
-    /* Save normal registers */
-    C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
-#undef C
-
-    context->ContextFlags = CONTEXT_FULL;
-    context->Sp   = SP_sig(sigcontext);   /* Stack pointer */
-    context->Lr   = LR_sig(sigcontext);   /* Link register */
-    context->Pc   = PC_sig(sigcontext);   /* Program Counter */
-    context->Cpsr = CPSR_sig(sigcontext); /* Current State Register */
-    context->R11  = FP_sig(sigcontext);   /* Frame pointer */
-    context->R12  = IP_sig(sigcontext);   /* Intra-Procedure-call scratch register */
-    save_fpu( context, sigcontext );
-}
-
-
-/***********************************************************************
- *           restore_context
- *
- * Build a sigcontext from the register values.
- */
-static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
-{
-#define C(x)  REGn_sig(x,sigcontext) = context->R##x
-    /* Restore normal registers */
-    C(0); C(1); C(2); C(3); C(4); C(5); C(6); C(7); C(8); C(9); C(10);
-#undef C
-
-    SP_sig(sigcontext)   = context->Sp;   /* Stack pointer */
-    LR_sig(sigcontext)   = context->Lr;   /* Link register */
-    PC_sig(sigcontext)   = context->Pc;   /* Program Counter */
-    CPSR_sig(sigcontext) = context->Cpsr; /* Current State Register */
-    FP_sig(sigcontext)   = context->R11;  /* Frame pointer */
-    IP_sig(sigcontext)   = context->R12;  /* Intra-Procedure-call scratch register */
-    restore_fpu( context, sigcontext );
-}
-
-
-/***********************************************************************
- *           set_cpu_context
- *
- * Set the new CPU context.
- */
-void DECLSPEC_HIDDEN set_cpu_context( const CONTEXT *context );
-__ASM_GLOBAL_FUNC( set_cpu_context,
-                   ".arm\n\t"
-                   "ldr r2, [r0, #0x44]\n\t"  /* context->Cpsr */
-                   "tst r2, #0x20\n\t"        /* thumb? */
-                   "ldr r1, [r0, #0x40]\n\t"  /* context->Pc */
-                   "orrne r1, r1, #1\n\t"     /* Adjust PC according to thumb */
-                   "biceq r1, r1, #1\n\t"     /* Adjust PC according to arm */
-                   "msr CPSR_f, r2\n\t"
-                   "ldr lr, [r0, #0x3c]\n\t"  /* context->Lr */
-                   "ldr sp, [r0, #0x38]\n\t"  /* context->Sp */
-                   "push {r1}\n\t"
-                   "ldmib r0, {r0-r12}\n\t"   /* context->R0..R12 */
-                   "pop {pc}" )
-
-
-/***********************************************************************
- *           get_server_context_flags
- *
- * Convert CPU-specific flags to generic server flags
- */
-static unsigned int get_server_context_flags( DWORD flags )
-{
-    unsigned int ret = 0;
-
-    flags &= ~CONTEXT_ARM;  /* get rid of CPU id */
-    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
-    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
-    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
-    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
-    return ret;
-}
-
-
-/***********************************************************************
- *           context_to_server
- *
- * Convert a register context to the server format.
- */
-NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
-{
-    DWORD i, flags = from->ContextFlags & ~CONTEXT_ARM;  /* get rid of CPU id */
-
-    memset( to, 0, sizeof(*to) );
-    to->cpu = CPU_ARM;
-
-    if (flags & CONTEXT_CONTROL)
-    {
-        to->flags |= SERVER_CTX_CONTROL;
-        to->ctl.arm_regs.sp   = from->Sp;
-        to->ctl.arm_regs.lr   = from->Lr;
-        to->ctl.arm_regs.pc   = from->Pc;
-        to->ctl.arm_regs.cpsr = from->Cpsr;
-    }
-    if (flags & CONTEXT_INTEGER)
-    {
-        to->flags |= SERVER_CTX_INTEGER;
-        to->integer.arm_regs.r[0]  = from->R0;
-        to->integer.arm_regs.r[1]  = from->R1;
-        to->integer.arm_regs.r[2]  = from->R2;
-        to->integer.arm_regs.r[3]  = from->R3;
-        to->integer.arm_regs.r[4]  = from->R4;
-        to->integer.arm_regs.r[5]  = from->R5;
-        to->integer.arm_regs.r[6]  = from->R6;
-        to->integer.arm_regs.r[7]  = from->R7;
-        to->integer.arm_regs.r[8]  = from->R8;
-        to->integer.arm_regs.r[9]  = from->R9;
-        to->integer.arm_regs.r[10] = from->R10;
-        to->integer.arm_regs.r[11] = from->R11;
-        to->integer.arm_regs.r[12] = from->R12;
-    }
-    if (flags & CONTEXT_FLOATING_POINT)
-    {
-        to->flags |= SERVER_CTX_FLOATING_POINT;
-        for (i = 0; i < 32; i++) to->fp.arm_regs.d[i] = from->u.D[i];
-        to->fp.arm_regs.fpscr = from->Fpscr;
-    }
-    if (flags & CONTEXT_DEBUG_REGISTERS)
-    {
-        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
-        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->debug.arm_regs.bvr[i] = from->Bvr[i];
-        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->debug.arm_regs.bcr[i] = from->Bcr[i];
-        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->debug.arm_regs.wvr[i] = from->Wvr[i];
-        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->debug.arm_regs.wcr[i] = from->Wcr[i];
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           context_from_server
- *
- * Convert a register context from the server format.
- */
-NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
-{
-    DWORD i;
-
-    if (from->cpu != CPU_ARM) return STATUS_INVALID_PARAMETER;
-
-    to->ContextFlags = CONTEXT_ARM;
-    if (from->flags & SERVER_CTX_CONTROL)
-    {
-        to->ContextFlags |= CONTEXT_CONTROL;
-        to->Sp   = from->ctl.arm_regs.sp;
-        to->Lr   = from->ctl.arm_regs.lr;
-        to->Pc   = from->ctl.arm_regs.pc;
-        to->Cpsr = from->ctl.arm_regs.cpsr;
-    }
-    if (from->flags & SERVER_CTX_INTEGER)
-    {
-        to->ContextFlags |= CONTEXT_INTEGER;
-        to->R0  = from->integer.arm_regs.r[0];
-        to->R1  = from->integer.arm_regs.r[1];
-        to->R2  = from->integer.arm_regs.r[2];
-        to->R3  = from->integer.arm_regs.r[3];
-        to->R4  = from->integer.arm_regs.r[4];
-        to->R5  = from->integer.arm_regs.r[5];
-        to->R6  = from->integer.arm_regs.r[6];
-        to->R7  = from->integer.arm_regs.r[7];
-        to->R8  = from->integer.arm_regs.r[8];
-        to->R9  = from->integer.arm_regs.r[9];
-        to->R10 = from->integer.arm_regs.r[10];
-        to->R11 = from->integer.arm_regs.r[11];
-        to->R12 = from->integer.arm_regs.r[12];
-    }
-    if (from->flags & SERVER_CTX_FLOATING_POINT)
-    {
-        to->ContextFlags |= CONTEXT_FLOATING_POINT;
-        for (i = 0; i < 32; i++) to->u.D[i] = from->fp.arm_regs.d[i];
-        to->Fpscr = from->fp.arm_regs.fpscr;
-    }
-    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
-    {
-        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
-        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->Bvr[i] = from->debug.arm_regs.bvr[i];
-        for (i = 0; i < ARM_MAX_BREAKPOINTS; i++) to->Bcr[i] = from->debug.arm_regs.bcr[i];
-        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->Wvr[i] = from->debug.arm_regs.wvr[i];
-        for (i = 0; i < ARM_MAX_WATCHPOINTS; i++) to->Wcr[i] = from->debug.arm_regs.wcr[i];
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *              NtSetContextThread  (NTDLL.@)
- *              ZwSetContextThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
-{
-    NTSTATUS ret;
-    BOOL self;
-    context_t server_context;
-
-    context_to_server( &server_context, context );
-    ret = set_thread_context( handle, &server_context, &self );
-    if (self && ret == STATUS_SUCCESS) set_cpu_context( context );
-    return ret;
-}
-
-
-/***********************************************************************
- *              NtGetContextThread  (NTDLL.@)
- *              ZwGetContextThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
-{
-    NTSTATUS ret;
-    struct syscall_frame *frame = arm_thread_data()->syscall_frame;
-    DWORD needed_flags = context->ContextFlags & ~CONTEXT_ARM;
-    BOOL self = (handle == GetCurrentThread());
-
-    if (!self)
-    {
-        context_t server_context;
-        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
-
-        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
-        if ((ret = context_from_server( context, &server_context ))) return ret;
-        needed_flags &= ~context->ContextFlags;
-    }
-
-    if (self)
-    {
-        if (needed_flags & CONTEXT_INTEGER)
-        {
-            context->R0  = 0;
-            context->R1  = 0;
-            context->R2  = 0;
-            context->R3  = 0;
-            context->R4  = frame->r4;
-            context->R5  = frame->r5;
-            context->R6  = frame->r6;
-            context->R7  = frame->r7;
-            context->R8  = frame->r8;
-            context->R9  = frame->r9;
-            context->R10 = frame->r10;
-            context->R11 = frame->r11;
-            context->R12 = 0;
-            context->ContextFlags |= CONTEXT_INTEGER;
-        }
-        if (needed_flags & CONTEXT_CONTROL)
-        {
-            context->Sp   = (DWORD)&frame->r4;
-            context->Lr   = frame->thunk_addr;
-            context->Pc   = frame->thunk_addr;
-            context->Cpsr = frame->cpsr;
-            context->ContextFlags |= CONTEXT_CONTROL;
-        }
-        if (needed_flags & CONTEXT_FLOATING_POINT) FIXME( "floating point not implemented\n" );
-    }
-    return STATUS_SUCCESS;
-}
-
-
-extern void raise_func_trampoline_thumb( EXCEPTION_RECORD *rec, CONTEXT *context, void *func );
-__ASM_GLOBAL_FUNC( raise_func_trampoline_thumb,
-                   ".thumb\n\t"
-                   "bx r2\n\t"
-                   "bkpt\n\t"
-                   ".arm")
-
-extern void raise_func_trampoline_arm( EXCEPTION_RECORD *rec, CONTEXT *context, void *func );
-__ASM_GLOBAL_FUNC( raise_func_trampoline_arm,
-                   ".arm\n\t"
-                   "bx r2\n\t"
-                   "bkpt")
-
-/***********************************************************************
- *           setup_exception
- *
- * Modify the signal context to call the exception raise function.
- */
-static void setup_exception( ucontext_t *sigcontext, EXCEPTION_RECORD *rec )
-{
-    struct
-    {
-        CONTEXT          context;
-        EXCEPTION_RECORD rec;
-    } *stack;
-
-    void *stack_ptr = (void *)(SP_sig(sigcontext) & ~3);
-    CONTEXT context;
-    NTSTATUS status;
-
-    rec->ExceptionAddress = (void *)PC_sig(sigcontext);
-    save_context( &context, sigcontext );
-    if (rec->ExceptionCode == EXCEPTION_BREAKPOINT) context.Pc += 4;
-
-    status = send_debug_event( rec, &context, TRUE );
-    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
-    {
-        restore_context( &context, sigcontext );
-        return;
-    }
-
-    stack = virtual_setup_exception( stack_ptr, sizeof(*stack), rec );
-    stack->rec = *rec;
-    stack->context = context;
-
-    /* now modify the sigcontext to return to the raise function */
-    SP_sig(sigcontext) = (DWORD)stack;
-    if (CPSR_sig(sigcontext) & 0x20)
-        PC_sig(sigcontext) = (DWORD)raise_func_trampoline_thumb;
-    else
-        PC_sig(sigcontext) = (DWORD)raise_func_trampoline_arm;
-    REGn_sig(0, sigcontext) = (DWORD)&stack->rec;  /* first arg for KiUserExceptionDispatcher */
-    REGn_sig(1, sigcontext) = (DWORD)&stack->context; /* second arg for KiUserExceptionDispatcher */
-    REGn_sig(2, sigcontext) = (DWORD)pKiUserExceptionDispatcher;
-}
-
-
-/***********************************************************************
- *           call_user_apc
- */
-void WINAPI call_user_apc( CONTEXT *context_ptr, ULONG_PTR ctx, ULONG_PTR arg1,
-                           ULONG_PTR arg2, PNTAPCFUNC func )
-{
-    CONTEXT context;
-
-    if (!context_ptr)
-    {
-        context.ContextFlags = CONTEXT_FULL;
-        NtGetContextThread( GetCurrentThread(), &context );
-        context.R0 = STATUS_USER_APC;
-        context_ptr = &context;
-    }
-    pKiUserApcDispatcher( context_ptr, ctx, arg1, arg2, func );
-}
-
-
-/***********************************************************************
- *           call_raise_user_exception_dispatcher
- */
-__ASM_GLOBAL_FUNC( call_raise_user_exception_dispatcher,
-                   "mov r2, r0\n\t"  /* dispatcher */
-                   "b " __ASM_NAME("call_user_exception_dispatcher") )
-
-
-/***********************************************************************
- *           call_user_exception_dispatcher
- */
-__ASM_GLOBAL_FUNC( call_user_exception_dispatcher,
-                   "mov r4, r0\n\t"
-                   "mov r5, r1\n\t"
-                   "mov r6, r2\n\t"
-                   "bl " __ASM_NAME("NtCurrentTeb") "\n\t"
-                   "add r7, r0, #0x1d8\n\t"  /* arm_thread_data()->syscall_frame */
-                   "mov r0, r4\n\t"
-                   "mov r1, r5\n\t"
-                   "mov r2, r6\n\t"
-                   "ldr r3, [r7]\n\t"
-                   "ldr r4, [r3]\n\t"        /* frame->prev_frame */
-                   "str r4, [r7]\n\t"
-                   "add r3, r3, #8\n\t"
-                   "ldm r3, {r5-r11}\n\t"
-                   "ldr r4, [r3, #32]\n\t"
-                   "ldr lr, [r3, #36]\n\t"
-                   "add sp, r3, #40\n\t"
-                   "bx r2" )
-
-
-/**********************************************************************
- *		segv_handler
- *
- * Handler for SIGSEGV and related errors.
- */
-static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-    ucontext_t *context = sigcontext;
-
-    switch (get_trap_code(signal, context))
-    {
-    case TRAP_ARM_PRIVINFLT:   /* Invalid opcode exception */
-        rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
-        break;
-    case TRAP_ARM_PAGEFLT:  /* Page fault */
-        rec.NumberParameters = 2;
-        rec.ExceptionInformation[0] = (get_error_code(context) & 0x800) != 0;
-        rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
-        rec.ExceptionCode = virtual_handle_fault( siginfo->si_addr, rec.ExceptionInformation[0],
-                                                  (void *)SP_sig(context) );
-        if (!rec.ExceptionCode) return;
-        break;
-    case TRAP_ARM_ALIGNFLT:  /* Alignment check exception */
-        rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
-        break;
-    case TRAP_ARM_UNKNOWN:   /* Unknown fault code */
-        rec.ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
-        rec.NumberParameters = 2;
-        rec.ExceptionInformation[0] = 0;
-        rec.ExceptionInformation[1] = 0xffffffff;
-        break;
-    default:
-        ERR("Got unexpected trap %d\n", get_trap_code(signal, context));
-        rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
-        break;
-    }
-    setup_exception( context, &rec );
-}
-
-
-/**********************************************************************
- *		trap_handler
- *
- * Handler for SIGTRAP.
- */
-static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-
-    switch (siginfo->si_code)
-    {
-    case TRAP_TRACE:
-        rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
-        break;
-    case TRAP_BRKPT:
-    default:
-        rec.ExceptionCode = EXCEPTION_BREAKPOINT;
-        rec.NumberParameters = 1;
-        break;
-    }
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		fpe_handler
- *
- * Handler for SIGFPE.
- */
-static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-
-    switch (siginfo->si_code & 0xffff )
-    {
-#ifdef FPE_FLTSUB
-    case FPE_FLTSUB:
-        rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
-        break;
-#endif
-#ifdef FPE_INTDIV
-    case FPE_INTDIV:
-        rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
-        break;
-#endif
-#ifdef FPE_INTOVF
-    case FPE_INTOVF:
-        rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
-        break;
-#endif
-#ifdef FPE_FLTDIV
-    case FPE_FLTDIV:
-        rec.ExceptionCode = EXCEPTION_FLT_DIVIDE_BY_ZERO;
-        break;
-#endif
-#ifdef FPE_FLTOVF
-    case FPE_FLTOVF:
-        rec.ExceptionCode = EXCEPTION_FLT_OVERFLOW;
-        break;
-#endif
-#ifdef FPE_FLTUND
-    case FPE_FLTUND:
-        rec.ExceptionCode = EXCEPTION_FLT_UNDERFLOW;
-        break;
-#endif
-#ifdef FPE_FLTRES
-    case FPE_FLTRES:
-        rec.ExceptionCode = EXCEPTION_FLT_INEXACT_RESULT;
-        break;
-#endif
-#ifdef FPE_FLTINV
-    case FPE_FLTINV:
-#endif
-    default:
-        rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
-        break;
-    }
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		int_handler
- *
- * Handler for SIGINT.
- */
-static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { CONTROL_C_EXIT };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		abrt_handler
- *
- * Handler for SIGABRT.
- */
-static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { EXCEPTION_WINE_ASSERTION, EH_NONCONTINUABLE };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		quit_handler
- *
- * Handler for SIGQUIT.
- */
-static void quit_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    abort_thread(0);
-}
-
-
-/**********************************************************************
- *		usr1_handler
- *
- * Handler for SIGUSR1, used to signal a thread that it got suspended.
- */
-static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    CONTEXT context;
-
-    save_context( &context, sigcontext );
-    wait_suspend( &context );
-    restore_context( &context, sigcontext );
-}
-
-
-/**********************************************************************
- *           get_thread_ldt_entry
- */
-NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *           NtSetLdtEntries   (NTDLL.@)
- *           ZwSetLdtEntries   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/**********************************************************************
- *             signal_init_threading
- */
-void signal_init_threading(void)
-{
-    pthread_key_create( &teb_key, NULL );
-}
-
-
-/**********************************************************************
- *             signal_alloc_thread
- */
-NTSTATUS signal_alloc_thread( TEB *teb )
-{
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *             signal_free_thread
- */
-void signal_free_thread( TEB *teb )
-{
-}
-
-
-/**********************************************************************
- *		signal_init_thread
- */
-void signal_init_thread( TEB *teb )
-{
-#if defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_8A__)
-    /* Win32/ARM applications expect the TEB pointer to be in the TPIDRURW register. */
-    __asm__ __volatile__( "mcr p15, 0, %0, c13, c0, 2" : : "r" (teb) );
-#endif
-    pthread_setspecific( teb_key, teb );
-}
-
-
-/**********************************************************************
- *		signal_init_process
- */
-void signal_init_process(void)
-{
-    struct sigaction sig_act;
-
-    sig_act.sa_mask = server_block_set;
-    sig_act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
-
-    sig_act.sa_sigaction = int_handler;
-    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = fpe_handler;
-    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = abrt_handler;
-    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = quit_handler;
-    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = trap_handler;
-    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = segv_handler;
-    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
-    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
-    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
-    return;
-
- error:
-    perror("sigaction");
-    exit(1);
-}
-
-
-/***********************************************************************
- *           init_thread_context
- */
-static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
-{
-    context->R0 = (DWORD)entry;
-    context->R1 = (DWORD)arg;
-    context->Sp = (DWORD)NtCurrentTeb()->Tib.StackBase;
-    context->Pc = (DWORD)relay;
-}
-
-
-/***********************************************************************
- *           attach_thread
- */
-PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
-                                        BOOL suspend, void *relay )
-{
-    CONTEXT *ctx;
-
-    if (suspend)
-    {
-        CONTEXT context = { CONTEXT_ALL };
-
-        init_thread_context( &context, entry, arg, relay );
-        wait_suspend( &context );
-        ctx = (CONTEXT *)((ULONG_PTR)context.Sp & ~15) - 1;
-        *ctx = context;
-    }
-    else
-    {
-        ctx = (CONTEXT *)NtCurrentTeb()->Tib.StackBase - 1;
-        init_thread_context( ctx, entry, arg, relay );
-    }
-    pthread_sigmask( SIG_UNBLOCK, &server_block_set, NULL );
-    ctx->ContextFlags = CONTEXT_FULL;
-    pLdrInitializeThunk( ctx, (void **)&ctx->R0, 0, 0 );
-    return ctx;
-}
-
-
-/***********************************************************************
- *           signal_start_thread
- */
-__ASM_GLOBAL_FUNC( signal_start_thread,
-                   ".arm\n\t"
-                   "push {r4-r12,lr}\n\t"
-                   /* store exit frame */
-                   "ldr r4, [sp, #40]\n\t"    /* teb */
-                   "str sp, [r4, #0x1d4]\n\t" /* teb->GdiTebBatch */
-                   /* switch to thread stack */
-                   "ldr r4, [r4, #4]\n\t"     /* teb->Tib.StackBase */
-                   "sub sp, r4, #0x1000\n\t"
-                   /* attach dlls */
-                   "bl " __ASM_NAME("attach_thread") "\n\t"
-                   "mov sp, r0\n\t"
-                   /* clear the stack */
-                   "and r0, #~0xff0\n\t"  /* round down to page size */
-                   "bl " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
-                   /* switch to the initial context */
-                   "mov r1, #1\n\t"
-                   "mov r0, sp\n\t"
-                   "b " __ASM_NAME("NtContinue") )
-
-
-extern void DECLSPEC_NORETURN call_thread_exit_func( int status, void (*func)(int), TEB *teb );
-__ASM_GLOBAL_FUNC( call_thread_exit_func,
-                   ".arm\n\t"
-                   "ldr r3, [r2, #0x1d4]\n\t"  /* teb->GdiTebBatch */
-                   "mov ip, #0\n\t"
-                   "str ip, [r2, #0x1d4]\n\t"
-                   "cmp r3, ip\n\t"
-                   "movne sp, r3\n\t"
-                   "blx r1" )
-
-/***********************************************************************
- *           signal_exit_thread
- */
-void signal_exit_thread( int status, void (*func)(int) )
-{
-    call_thread_exit_func( status, func, NtCurrentTeb() );
-}
-
-
-/**********************************************************************
- *           NtCurrentTeb   (NTDLL.@)
- */
-TEB * WINAPI NtCurrentTeb(void)
-{
-    return pthread_getspecific( teb_key );
-}
-
-#endif  /* __arm__ */
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
deleted file mode 100644
index d5ced2172a..0000000000
--- a/dlls/ntdll/unix/signal_arm64.c
+++ /dev/null
@@ -1,1034 +0,0 @@
-/*
- * ARM64 signal handling routines
- *
- * Copyright 2010-2013 André Hentschel
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#ifdef __aarch64__
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdio.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef HAVE_SYS_PARAM_H
-# include <sys/param.h>
-#endif
-#ifdef HAVE_SYSCALL_H
-# include <syscall.h>
-#else
-# ifdef HAVE_SYS_SYSCALL_H
-#  include <sys/syscall.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SIGNAL_H
-# include <sys/signal.h>
-#endif
-#ifdef HAVE_SYS_UCONTEXT_H
-# include <sys/ucontext.h>
-#endif
-#ifdef HAVE_LIBUNWIND
-# define UNW_LOCAL_ONLY
-# include <libunwind.h>
-#endif
-
-#define NONAMELESSUNION
-#define NONAMELESSSTRUCT
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winnt.h"
-#include "winternl.h"
-#include "wine/exception.h"
-#include "wine/asm.h"
-#include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(seh);
-
-/***********************************************************************
- * signal context platform-specific definitions
- */
-#ifdef linux
-
-/* All Registers access - only for local access */
-# define REG_sig(reg_name, context) ((context)->uc_mcontext.reg_name)
-# define REGn_sig(reg_num, context) ((context)->uc_mcontext.regs[reg_num])
-
-/* Special Registers access  */
-# define SP_sig(context)            REG_sig(sp, context)    /* Stack pointer */
-# define PC_sig(context)            REG_sig(pc, context)    /* Program counter */
-# define PSTATE_sig(context)        REG_sig(pstate, context) /* Current State Register */
-# define FP_sig(context)            REGn_sig(29, context)    /* Frame pointer */
-# define LR_sig(context)            REGn_sig(30, context)    /* Link Register */
-
-static struct _aarch64_ctx *get_extended_sigcontext( ucontext_t *sigcontext, unsigned int magic )
-{
-    struct _aarch64_ctx *ctx = (struct _aarch64_ctx *)sigcontext->uc_mcontext.__reserved;
-    while ((char *)ctx < (char *)(&sigcontext->uc_mcontext + 1) && ctx->magic && ctx->size)
-    {
-        if (ctx->magic == magic) return ctx;
-        ctx = (struct _aarch64_ctx *)((char *)ctx + ctx->size);
-    }
-    return NULL;
-}
-
-static struct fpsimd_context *get_fpsimd_context( ucontext_t *sigcontext )
-{
-    return (struct fpsimd_context *)get_extended_sigcontext( sigcontext, FPSIMD_MAGIC );
-}
-
-static DWORD64 get_fault_esr( ucontext_t *sigcontext )
-{
-    struct esr_context *esr = (struct esr_context *)get_extended_sigcontext( sigcontext, ESR_MAGIC );
-    if (esr) return esr->esr;
-    return 0;
-}
-
-#endif /* linux */
-
-static pthread_key_t teb_key;
-
-struct syscall_frame
-{
-    ULONG64 x29;
-    ULONG64 thunk_addr;
-    ULONG64 x0, x1, x2, x3, x4, x5, x6, x7, x8;
-    struct syscall_frame *prev_frame;
-    ULONG64 x19, x20, x21, x22, x23, x24, x25, x26, x27, x28;
-    ULONG64 thunk_x29;
-    ULONG64 ret_addr;
-};
-
-struct arm64_thread_data
-{
-    void                 *exit_frame;    /* 02f0 exit frame pointer */
-    struct syscall_frame *syscall_frame; /* 02f8 frame pointer on syscall entry */
-    CONTEXT              *context;       /* 0300 context to set with SIGUSR2 */
-};
-
-C_ASSERT( sizeof(struct arm64_thread_data) <= sizeof(((struct ntdll_thread_data *)0)->cpu_data) );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct arm64_thread_data, exit_frame ) == 0x2f0 );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct arm64_thread_data, syscall_frame ) == 0x2f8 );
-
-static inline struct arm64_thread_data *arm64_thread_data(void)
-{
-    return (struct arm64_thread_data *)ntdll_get_thread_data()->cpu_data;
-}
-
-
-/***********************************************************************
- *           unwind_builtin_dll
- *
- * Equivalent of RtlVirtualUnwind for builtin modules.
- */
-NTSTATUS CDECL unwind_builtin_dll( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEXT *context )
-{
-#ifdef HAVE_LIBUNWIND
-    ULONG_PTR ip = context->Pc;
-    unw_context_t unw_context;
-    unw_cursor_t cursor;
-    unw_proc_info_t info;
-    int rc;
-
-    memcpy( unw_context.uc_mcontext.regs, context->u.X, sizeof(context->u.X) );
-    unw_context.uc_mcontext.sp = context->Sp;
-    unw_context.uc_mcontext.pc = context->Pc;
-
-    rc = unw_init_local( &cursor, &unw_context );
-    if (rc != UNW_ESUCCESS)
-    {
-        WARN( "setup failed: %d\n", rc );
-        return STATUS_INVALID_DISPOSITION;
-    }
-    rc = unw_get_proc_info( &cursor, &info );
-    if (rc != UNW_ESUCCESS && rc != -UNW_ENOINFO)
-    {
-        WARN( "failed to get info: %d\n", rc );
-        return STATUS_INVALID_DISPOSITION;
-    }
-    if (rc == -UNW_ENOINFO || ip < info.start_ip || ip > info.end_ip)
-    {
-        TRACE( "no info found for %lx ip %lx-%lx, assuming leaf function\n",
-               ip, info.start_ip, info.end_ip );
-        dispatch->LanguageHandler = NULL;
-        dispatch->EstablisherFrame = context->Sp;
-        context->Pc = context->u.s.Lr;
-        context->Sp = context->Sp + sizeof(ULONG64);
-        context->ContextFlags |= CONTEXT_UNWOUND_TO_CALL;
-        return STATUS_SUCCESS;
-    }
-
-    TRACE( "ip %#lx function %#lx-%#lx personality %#lx lsda %#lx fde %#lx\n",
-           ip, (unsigned long)info.start_ip, (unsigned long)info.end_ip, (unsigned long)info.handler,
-           (unsigned long)info.lsda, (unsigned long)info.unwind_info );
-
-    rc = unw_step( &cursor );
-    if (rc < 0)
-    {
-        WARN( "failed to unwind: %d %d\n", rc, UNW_ENOINFO );
-        return STATUS_INVALID_DISPOSITION;
-    }
-
-    dispatch->LanguageHandler  = (void *)info.handler;
-    dispatch->HandlerData      = (void *)info.lsda;
-    dispatch->EstablisherFrame = context->Sp;
-    unw_get_reg( &cursor, UNW_AARCH64_X0,  (unw_word_t *)&context->u.s.X0 );
-    unw_get_reg( &cursor, UNW_AARCH64_X1,  (unw_word_t *)&context->u.s.X1 );
-    unw_get_reg( &cursor, UNW_AARCH64_X2,  (unw_word_t *)&context->u.s.X2 );
-    unw_get_reg( &cursor, UNW_AARCH64_X3,  (unw_word_t *)&context->u.s.X3 );
-    unw_get_reg( &cursor, UNW_AARCH64_X4,  (unw_word_t *)&context->u.s.X4 );
-    unw_get_reg( &cursor, UNW_AARCH64_X5,  (unw_word_t *)&context->u.s.X5 );
-    unw_get_reg( &cursor, UNW_AARCH64_X6,  (unw_word_t *)&context->u.s.X6 );
-    unw_get_reg( &cursor, UNW_AARCH64_X7,  (unw_word_t *)&context->u.s.X7 );
-    unw_get_reg( &cursor, UNW_AARCH64_X8,  (unw_word_t *)&context->u.s.X8 );
-    unw_get_reg( &cursor, UNW_AARCH64_X9,  (unw_word_t *)&context->u.s.X9 );
-    unw_get_reg( &cursor, UNW_AARCH64_X10, (unw_word_t *)&context->u.s.X10 );
-    unw_get_reg( &cursor, UNW_AARCH64_X11, (unw_word_t *)&context->u.s.X11 );
-    unw_get_reg( &cursor, UNW_AARCH64_X12, (unw_word_t *)&context->u.s.X12 );
-    unw_get_reg( &cursor, UNW_AARCH64_X13, (unw_word_t *)&context->u.s.X13 );
-    unw_get_reg( &cursor, UNW_AARCH64_X14, (unw_word_t *)&context->u.s.X14 );
-    unw_get_reg( &cursor, UNW_AARCH64_X15, (unw_word_t *)&context->u.s.X15 );
-    unw_get_reg( &cursor, UNW_AARCH64_X16, (unw_word_t *)&context->u.s.X16 );
-    unw_get_reg( &cursor, UNW_AARCH64_X17, (unw_word_t *)&context->u.s.X17 );
-    unw_get_reg( &cursor, UNW_AARCH64_X18, (unw_word_t *)&context->u.s.X18 );
-    unw_get_reg( &cursor, UNW_AARCH64_X19, (unw_word_t *)&context->u.s.X19 );
-    unw_get_reg( &cursor, UNW_AARCH64_X20, (unw_word_t *)&context->u.s.X20 );
-    unw_get_reg( &cursor, UNW_AARCH64_X21, (unw_word_t *)&context->u.s.X21 );
-    unw_get_reg( &cursor, UNW_AARCH64_X22, (unw_word_t *)&context->u.s.X22 );
-    unw_get_reg( &cursor, UNW_AARCH64_X23, (unw_word_t *)&context->u.s.X23 );
-    unw_get_reg( &cursor, UNW_AARCH64_X24, (unw_word_t *)&context->u.s.X24 );
-    unw_get_reg( &cursor, UNW_AARCH64_X25, (unw_word_t *)&context->u.s.X25 );
-    unw_get_reg( &cursor, UNW_AARCH64_X26, (unw_word_t *)&context->u.s.X26 );
-    unw_get_reg( &cursor, UNW_AARCH64_X27, (unw_word_t *)&context->u.s.X27 );
-    unw_get_reg( &cursor, UNW_AARCH64_X28, (unw_word_t *)&context->u.s.X28 );
-    unw_get_reg( &cursor, UNW_AARCH64_X29, (unw_word_t *)&context->u.s.Fp );
-    unw_get_reg( &cursor, UNW_AARCH64_X30, (unw_word_t *)&context->u.s.Lr );
-    unw_get_reg( &cursor, UNW_AARCH64_SP,  (unw_word_t *)&context->Sp );
-    context->Pc = context->u.s.Lr;
-    context->ContextFlags |= CONTEXT_UNWOUND_TO_CALL;
-
-    TRACE( "next function pc=%016lx%s\n", context->Pc, rc ? "" : " (last frame)" );
-    TRACE("  x0=%016lx  x1=%016lx  x2=%016lx  x3=%016lx\n",
-          context->u.s.X0, context->u.s.X1, context->u.s.X2, context->u.s.X3 );
-    TRACE("  x4=%016lx  x5=%016lx  x6=%016lx  x7=%016lx\n",
-          context->u.s.X4, context->u.s.X5, context->u.s.X6, context->u.s.X7 );
-    TRACE("  x8=%016lx  x9=%016lx x10=%016lx x11=%016lx\n",
-          context->u.s.X8, context->u.s.X9, context->u.s.X10, context->u.s.X11 );
-    TRACE(" x12=%016lx x13=%016lx x14=%016lx x15=%016lx\n",
-          context->u.s.X12, context->u.s.X13, context->u.s.X14, context->u.s.X15 );
-    TRACE(" x16=%016lx x17=%016lx x18=%016lx x19=%016lx\n",
-          context->u.s.X16, context->u.s.X17, context->u.s.X18, context->u.s.X19 );
-    TRACE(" x20=%016lx x21=%016lx x22=%016lx x23=%016lx\n",
-          context->u.s.X20, context->u.s.X21, context->u.s.X22, context->u.s.X23 );
-    TRACE(" x24=%016lx x25=%016lx x26=%016lx x27=%016lx\n",
-          context->u.s.X24, context->u.s.X25, context->u.s.X26, context->u.s.X27 );
-    TRACE(" x28=%016lx  fp=%016lx  lr=%016lx  sp=%016lx\n",
-          context->u.s.X28, context->u.s.Fp, context->u.s.Lr, context->Sp );
-    return STATUS_SUCCESS;
-#else
-    return STATUS_INVALID_DISPOSITION;
-#endif
-}
-
-
-/***********************************************************************
- *           save_context
- *
- * Set the register values from a sigcontext.
- */
-static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
-{
-    DWORD i;
-
-    context->ContextFlags = CONTEXT_FULL;
-    context->u.s.Fp = FP_sig(sigcontext);     /* Frame pointer */
-    context->u.s.Lr = LR_sig(sigcontext);     /* Link register */
-    context->Sp     = SP_sig(sigcontext);     /* Stack pointer */
-    context->Pc     = PC_sig(sigcontext);     /* Program Counter */
-    context->Cpsr   = PSTATE_sig(sigcontext); /* Current State Register */
-    for (i = 0; i <= 28; i++) context->u.X[i] = REGn_sig( i, sigcontext );
-}
-
-
-/***********************************************************************
- *           restore_context
- *
- * Build a sigcontext from the register values.
- */
-static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
-{
-    DWORD i;
-
-    FP_sig(sigcontext)     = context->u.s.Fp; /* Frame pointer */
-    LR_sig(sigcontext)     = context->u.s.Lr; /* Link register */
-    SP_sig(sigcontext)     = context->Sp;     /* Stack pointer */
-    PC_sig(sigcontext)     = context->Pc;     /* Program Counter */
-    PSTATE_sig(sigcontext) = context->Cpsr;   /* Current State Register */
-    for (i = 0; i <= 28; i++) REGn_sig( i, sigcontext ) = context->u.X[i];
-}
-
-
-/***********************************************************************
- *           save_fpu
- *
- * Set the FPU context from a sigcontext.
- */
-static void save_fpu( CONTEXT *context, ucontext_t *sigcontext )
-{
-    struct fpsimd_context *fp = get_fpsimd_context( sigcontext );
-
-    if (!fp) return;
-    context->ContextFlags |= CONTEXT_FLOATING_POINT;
-    context->Fpcr = fp->fpcr;
-    context->Fpsr = fp->fpsr;
-    memcpy( context->V, fp->vregs, sizeof(context->V) );
-}
-
-
-/***********************************************************************
- *           restore_fpu
- *
- * Restore the FPU context to a sigcontext.
- */
-static void restore_fpu( CONTEXT *context, ucontext_t *sigcontext )
-{
-    struct fpsimd_context *fp = get_fpsimd_context( sigcontext );
-
-    if (!fp) return;
-    fp->fpcr = context->Fpcr;
-    fp->fpsr = context->Fpsr;
-    memcpy( fp->vregs, context->V, sizeof(fp->vregs) );
-}
-
-
-/***********************************************************************
- *           get_server_context_flags
- *
- * Convert CPU-specific flags to generic server flags
- */
-static unsigned int get_server_context_flags( DWORD flags )
-{
-    unsigned int ret = 0;
-
-    flags &= ~CONTEXT_ARM64;  /* get rid of CPU id */
-    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
-    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
-    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
-    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
-    return ret;
-}
-
-
-/***********************************************************************
- *           context_to_server
- *
- * Convert a register context to the server format.
- */
-NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
-{
-    DWORD i, flags = from->ContextFlags & ~CONTEXT_ARM64;  /* get rid of CPU id */
-
-    memset( to, 0, sizeof(*to) );
-    to->cpu = CPU_ARM64;
-
-    if (flags & CONTEXT_CONTROL)
-    {
-        to->flags |= SERVER_CTX_CONTROL;
-        to->integer.arm64_regs.x[29] = from->u.s.Fp;
-        to->integer.arm64_regs.x[30] = from->u.s.Lr;
-        to->ctl.arm64_regs.sp     = from->Sp;
-        to->ctl.arm64_regs.pc     = from->Pc;
-        to->ctl.arm64_regs.pstate = from->Cpsr;
-    }
-    if (flags & CONTEXT_INTEGER)
-    {
-        to->flags |= SERVER_CTX_INTEGER;
-        for (i = 0; i <= 28; i++) to->integer.arm64_regs.x[i] = from->u.X[i];
-    }
-    if (flags & CONTEXT_FLOATING_POINT)
-    {
-        to->flags |= SERVER_CTX_FLOATING_POINT;
-        for (i = 0; i < 32; i++)
-        {
-            to->fp.arm64_regs.q[i].low = from->V[i].s.Low;
-            to->fp.arm64_regs.q[i].high = from->V[i].s.High;
-        }
-        to->fp.arm64_regs.fpcr = from->Fpcr;
-        to->fp.arm64_regs.fpsr = from->Fpsr;
-    }
-    if (flags & CONTEXT_DEBUG_REGISTERS)
-    {
-        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
-        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->debug.arm64_regs.bcr[i] = from->Bcr[i];
-        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->debug.arm64_regs.bvr[i] = from->Bvr[i];
-        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->debug.arm64_regs.wcr[i] = from->Wcr[i];
-        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->debug.arm64_regs.wvr[i] = from->Wvr[i];
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           context_from_server
- *
- * Convert a register context from the server format.
- */
-NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
-{
-    DWORD i;
-
-    if (from->cpu != CPU_ARM64) return STATUS_INVALID_PARAMETER;
-
-    to->ContextFlags = CONTEXT_ARM64;
-    if (from->flags & SERVER_CTX_CONTROL)
-    {
-        to->ContextFlags |= CONTEXT_CONTROL;
-        to->u.s.Fp = from->integer.arm64_regs.x[29];
-        to->u.s.Lr = from->integer.arm64_regs.x[30];
-        to->Sp     = from->ctl.arm64_regs.sp;
-        to->Pc     = from->ctl.arm64_regs.pc;
-        to->Cpsr   = from->ctl.arm64_regs.pstate;
-    }
-    if (from->flags & SERVER_CTX_INTEGER)
-    {
-        to->ContextFlags |= CONTEXT_INTEGER;
-        for (i = 0; i <= 28; i++) to->u.X[i] = from->integer.arm64_regs.x[i];
-    }
-    if (from->flags & SERVER_CTX_FLOATING_POINT)
-    {
-        to->ContextFlags |= CONTEXT_FLOATING_POINT;
-        for (i = 0; i < 32; i++)
-        {
-            to->V[i].s.Low = from->fp.arm64_regs.q[i].low;
-            to->V[i].s.High = from->fp.arm64_regs.q[i].high;
-        }
-        to->Fpcr = from->fp.arm64_regs.fpcr;
-        to->Fpsr = from->fp.arm64_regs.fpsr;
-    }
-    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
-    {
-        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
-        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->Bcr[i] = from->debug.arm64_regs.bcr[i];
-        for (i = 0; i < ARM64_MAX_BREAKPOINTS; i++) to->Bvr[i] = from->debug.arm64_regs.bvr[i];
-        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->Wcr[i] = from->debug.arm64_regs.wcr[i];
-        for (i = 0; i < ARM64_MAX_WATCHPOINTS; i++) to->Wvr[i] = from->debug.arm64_regs.wvr[i];
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *              NtSetContextThread  (NTDLL.@)
- *              ZwSetContextThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
-{
-    NTSTATUS ret = STATUS_SUCCESS;
-    BOOL self = (handle == GetCurrentThread());
-
-    if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_ARM64))) self = FALSE;
-
-    if (!self)
-    {
-        context_t server_context;
-        context_to_server( &server_context, context );
-        ret = set_thread_context( handle, &server_context, &self );
-    }
-    if (self && ret == STATUS_SUCCESS)
-    {
-        InterlockedExchangePointer( (void **)&arm64_thread_data()->context, (void *)context );
-        raise( SIGUSR2 );
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *              NtGetContextThread  (NTDLL.@)
- *              ZwGetContextThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
-{
-    NTSTATUS ret;
-    struct syscall_frame *frame = arm64_thread_data()->syscall_frame;
-    DWORD needed_flags = context->ContextFlags & ~CONTEXT_ARM64;
-    BOOL self = (handle == GetCurrentThread());
-
-    if (!self)
-    {
-        context_t server_context;
-        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
-
-        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
-        if ((ret = context_from_server( context, &server_context ))) return ret;
-        needed_flags &= ~context->ContextFlags;
-    }
-
-    if (self)
-    {
-        if (needed_flags & CONTEXT_INTEGER)
-        {
-            memset( context->u.X, 0, sizeof(context->u.X[0]) * 18 );
-            context->u.X[18] = (DWORD64)NtCurrentTeb();
-            memcpy( context->u.X + 19, &frame->x19, sizeof(context->u.X[0]) * 10 );
-            context->ContextFlags |= CONTEXT_INTEGER;
-        }
-        if (needed_flags & CONTEXT_CONTROL)
-        {
-            context->u.s.Fp  = frame->x29;
-            context->u.s.Lr  = frame->ret_addr;
-            context->Sp      = (ULONG64)&frame->thunk_x29;
-            context->Pc      = frame->thunk_addr;
-            context->Cpsr    = 0;
-            context->ContextFlags |= CONTEXT_CONTROL;
-        }
-        if (needed_flags & CONTEXT_FLOATING_POINT) FIXME( "floating point not supported\n" );
-        if (needed_flags & CONTEXT_DEBUG_REGISTERS) FIXME( "debug registers not supported\n" );
-    }
-    return STATUS_SUCCESS;
-}
-
-
-extern void raise_func_trampoline( EXCEPTION_RECORD *rec, CONTEXT *context, void *dispatcher, void *sp );
-__ASM_GLOBAL_FUNC( raise_func_trampoline,
-                   __ASM_CFI(".cfi_signal_frame\n\t")
-                   "stp x29, x30, [sp, #-0x20]!\n\t"
-                   __ASM_CFI(".cfi_def_cfa_offset 32\n\t")
-                   __ASM_CFI(".cfi_offset 29, -32\n\t")
-                   __ASM_CFI(".cfi_offset 30, -24\n\t")
-                   "mov x29, sp\n\t"
-                   __ASM_CFI(".cfi_def_cfa_register 29\n\t")
-                   "str x3, [sp, 0x10]\n\t"
-                   __ASM_CFI(".cfi_remember_state\n\t")
-                   __ASM_CFI(".cfi_escape 0x0f,0x03,0x8d,0x10,0x06\n\t") /* CFA */
-                   __ASM_CFI(".cfi_escape 0x10,0x1d,0x02,0x8d,0x00\n\t") /* x29 */
-                   __ASM_CFI(".cfi_escape 0x10,0x1e,0x02,0x8d,0x08\n\t") /* x30 */
-                   "blr x2\n\t"
-                   __ASM_CFI(".cfi_restore_state\n\t")
-                   "brk #1")
-
-/***********************************************************************
- *           setup_exception
- *
- * Modify the signal context to call the exception raise function.
- */
-static void setup_exception( ucontext_t *sigcontext, EXCEPTION_RECORD *rec )
-{
-    struct
-    {
-        CONTEXT           context;
-        EXCEPTION_RECORD  rec;
-        void             *redzone[3];
-    } *stack;
-
-    void *stack_ptr = (void *)(SP_sig(sigcontext) & ~15);
-    CONTEXT context;
-    NTSTATUS status;
-
-    rec->ExceptionAddress = (void *)PC_sig(sigcontext);
-    save_context( &context, sigcontext );
-    save_fpu( &context, sigcontext );
-    if (rec->ExceptionCode == EXCEPTION_BREAKPOINT) context.Pc += 4;
-
-    status = send_debug_event( rec, &context, TRUE );
-    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
-    {
-        restore_context( &context, sigcontext );
-        return;
-    }
-
-    stack = virtual_setup_exception( stack_ptr, (sizeof(*stack) + 15) & ~15, rec );
-    stack->rec = *rec;
-    stack->context = context;
-
-    REGn_sig(3, sigcontext) = SP_sig(sigcontext); /* original stack pointer, fourth arg for raise_func_trampoline */
-    SP_sig(sigcontext) = (ULONG_PTR)stack;
-    LR_sig(sigcontext) = PC_sig(sigcontext);
-    PC_sig(sigcontext) = (ULONG_PTR)raise_func_trampoline;
-    REGn_sig(0, sigcontext) = (ULONG_PTR)&stack->rec;  /* first arg for KiUserExceptionDispatcher */
-    REGn_sig(1, sigcontext) = (ULONG_PTR)&stack->context; /* second arg for KiUserExceptionDispatcher */
-    REGn_sig(2, sigcontext) = (ULONG_PTR)pKiUserExceptionDispatcher; /* dispatcher arg for raise_func_trampoline */
-    REGn_sig(18, sigcontext) = (ULONG_PTR)NtCurrentTeb();
-}
-
-
-/***********************************************************************
- *           call_user_apc
- */
-void WINAPI call_user_apc( CONTEXT *context_ptr, ULONG_PTR ctx, ULONG_PTR arg1,
-                           ULONG_PTR arg2, PNTAPCFUNC func )
-{
-    CONTEXT context;
-
-    if (!context_ptr)
-    {
-        context.ContextFlags = CONTEXT_FULL;
-        NtGetContextThread( GetCurrentThread(), &context );
-        context.u.s.X0 = STATUS_USER_APC;
-        context_ptr = &context;
-    }
-    pKiUserApcDispatcher( context_ptr, ctx, arg1, arg2, func );
-}
-
-
-/***********************************************************************
- *           call_raise_user_exception_dispatcher
- */
-__ASM_GLOBAL_FUNC( call_raise_user_exception_dispatcher,
-                   "mov x2, x0\n\t"  /* dispatcher */
-                   "b " __ASM_NAME("call_user_exception_dispatcher") )
-
-
-/***********************************************************************
- *           call_user_exception_dispatcher
- */
-__ASM_GLOBAL_FUNC( call_user_exception_dispatcher,
-                   "mov x19, x0\n\t"
-                   "mov x20, x1\n\t"
-                   "mov x21, x2\n\t"
-                   "bl " __ASM_NAME("NtCurrentTeb") "\n\t"
-                   "add x4, x0, #0x2f8\n\t"        /* arm64_thread_data()->syscall_frame */
-                   "ldr x5, [x4]\n\t"
-                   "ldr x6, [x5, #88]\n\t"         /* frame->prev_frame */
-                   "str x6, [x4]\n\t"
-                   "mov x0, x19\n\t"
-                   "mov x1, x20\n\t"
-                   "mov x2, x21\n\t"
-                   "ldp x19, x20, [x5, #96]\n\t"   /* frame->x19,x20 */
-                   "ldp x21, x22, [x5, #112]\n\t"  /* frame->x21,x22 */
-                   "ldp x23, x24, [x5, #128]\n\t"  /* frame->x23,x24 */
-                   "ldp x25, x26, [x5, #144]\n\t"  /* frame->x25,x26 */
-                   "ldp x27, x28, [x5, #160]\n\t"  /* frame->x27,x28 */
-                   "ldp x29, x30, [x5, #176]\n\t"  /* frame->thunk_x29,ret_addr */
-                   "add sp, x5, #192\n\t"
-                   "br x2" )
-
-
-/**********************************************************************
- *		segv_handler
- *
- * Handler for SIGSEGV.
- */
-static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-    ucontext_t *context = sigcontext;
-
-    rec.NumberParameters = 2;
-    rec.ExceptionInformation[0] = (get_fault_esr( context ) & 0x40) != 0;
-    rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
-    rec.ExceptionCode = virtual_handle_fault( siginfo->si_addr, rec.ExceptionInformation[0],
-                                              (void *)SP_sig(context) );
-    if (!rec.ExceptionCode) return;
-    setup_exception( context, &rec );
-}
-
-
-/**********************************************************************
- *		ill_handler
- *
- * Handler for SIGILL.
- */
-static void ill_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { EXCEPTION_ILLEGAL_INSTRUCTION };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		bus_handler
- *
- * Handler for SIGBUS.
- */
-static void bus_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { EXCEPTION_DATATYPE_MISALIGNMENT };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		trap_handler
- *
- * Handler for SIGTRAP.
- */
-static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-
-    switch (siginfo->si_code)
-    {
-    case TRAP_TRACE:
-        rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
-        break;
-    case TRAP_BRKPT:
-    default:
-        rec.ExceptionCode = EXCEPTION_BREAKPOINT;
-        rec.NumberParameters = 1;
-        break;
-    }
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		fpe_handler
- *
- * Handler for SIGFPE.
- */
-static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-
-    switch (siginfo->si_code & 0xffff )
-    {
-#ifdef FPE_FLTSUB
-    case FPE_FLTSUB:
-        rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
-        break;
-#endif
-#ifdef FPE_INTDIV
-    case FPE_INTDIV:
-        rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
-        break;
-#endif
-#ifdef FPE_INTOVF
-    case FPE_INTOVF:
-        rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
-        break;
-#endif
-#ifdef FPE_FLTDIV
-    case FPE_FLTDIV:
-        rec.ExceptionCode = EXCEPTION_FLT_DIVIDE_BY_ZERO;
-        break;
-#endif
-#ifdef FPE_FLTOVF
-    case FPE_FLTOVF:
-        rec.ExceptionCode = EXCEPTION_FLT_OVERFLOW;
-        break;
-#endif
-#ifdef FPE_FLTUND
-    case FPE_FLTUND:
-        rec.ExceptionCode = EXCEPTION_FLT_UNDERFLOW;
-        break;
-#endif
-#ifdef FPE_FLTRES
-    case FPE_FLTRES:
-        rec.ExceptionCode = EXCEPTION_FLT_INEXACT_RESULT;
-        break;
-#endif
-#ifdef FPE_FLTINV
-    case FPE_FLTINV:
-#endif
-    default:
-        rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
-        break;
-    }
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		int_handler
- *
- * Handler for SIGINT.
- */
-static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { CONTROL_C_EXIT };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		abrt_handler
- *
- * Handler for SIGABRT.
- */
-static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { EXCEPTION_WINE_ASSERTION, EH_NONCONTINUABLE };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		quit_handler
- *
- * Handler for SIGQUIT.
- */
-static void quit_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    abort_thread(0);
-}
-
-
-/**********************************************************************
- *		usr1_handler
- *
- * Handler for SIGUSR1, used to signal a thread that it got suspended.
- */
-static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    CONTEXT context;
-
-    save_context( &context, sigcontext );
-    wait_suspend( &context );
-    restore_context( &context, sigcontext );
-}
-
-
-/**********************************************************************
- *		usr2_handler
- *
- * Handler for SIGUSR2, used to set a thread context.
- */
-static void usr2_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    CONTEXT *context = InterlockedExchangePointer( (void **)&arm64_thread_data()->context, NULL );
-    if (!context) return;
-    if ((context->ContextFlags & ~CONTEXT_ARM64) & CONTEXT_FLOATING_POINT)
-        restore_fpu( context, sigcontext );
-    restore_context( context, sigcontext );
-}
-
-
-/**********************************************************************
- *           get_thread_ldt_entry
- */
-NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *           NtSetLdtEntries   (NTDLL.@)
- *           ZwSetLdtEntries   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/**********************************************************************
- *             signal_init_threading
- */
-void signal_init_threading(void)
-{
-    pthread_key_create( &teb_key, NULL );
-}
-
-
-/**********************************************************************
- *             signal_alloc_thread
- */
-NTSTATUS signal_alloc_thread( TEB *teb )
-{
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *             signal_free_thread
- */
-void signal_free_thread( TEB *teb )
-{
-}
-
-
-/**********************************************************************
- *		signal_init_thread
- */
-void signal_init_thread( TEB *teb )
-{
-    /* Win64/ARM applications expect the TEB pointer to be in the x18 platform register. */
-    __asm__ __volatile__( "mov x18, %0" : : "r" (teb) );
-
-    pthread_setspecific( teb_key, teb );
-}
-
-
-/**********************************************************************
- *		signal_init_process
- */
-void signal_init_process(void)
-{
-    struct sigaction sig_act;
-
-    sig_act.sa_mask = server_block_set;
-    sig_act.sa_flags = SA_SIGINFO | SA_RESTART | SA_ONSTACK;
-
-    sig_act.sa_sigaction = int_handler;
-    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = fpe_handler;
-    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = abrt_handler;
-    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = quit_handler;
-    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr2_handler;
-    if (sigaction( SIGUSR2, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = trap_handler;
-    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = segv_handler;
-    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = ill_handler;
-    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = bus_handler;
-    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
-    return;
-
- error:
-    perror("sigaction");
-    exit(1);
-}
-
-/***********************************************************************
- *           init_thread_context
- */
-static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
-{
-    context->u.s.X0  = (DWORD64)entry;
-    context->u.s.X1  = (DWORD64)arg;
-    context->u.s.X18 = (DWORD64)NtCurrentTeb();
-    context->Sp      = (DWORD64)NtCurrentTeb()->Tib.StackBase;
-    context->Pc      = (DWORD64)relay;
-}
-
-
-/***********************************************************************
- *           attach_thread
- */
-PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
-                                        BOOL suspend, void *relay )
-{
-    CONTEXT *ctx;
-
-    if (suspend)
-    {
-        CONTEXT context = { CONTEXT_ALL };
-
-        init_thread_context( &context, entry, arg, relay );
-        wait_suspend( &context );
-        ctx = (CONTEXT *)((ULONG_PTR)context.Sp & ~15) - 1;
-        *ctx = context;
-    }
-    else
-    {
-        ctx = (CONTEXT *)NtCurrentTeb()->Tib.StackBase - 1;
-        init_thread_context( ctx, entry, arg, relay );
-    }
-    pthread_sigmask( SIG_UNBLOCK, &server_block_set, NULL );
-    ctx->ContextFlags = CONTEXT_FULL;
-    pLdrInitializeThunk( ctx, (void **)&ctx->u.s.X0, 0, 0 );
-    return ctx;
-}
-
-
-/***********************************************************************
- *           signal_start_thread
- */
-__ASM_GLOBAL_FUNC( signal_start_thread,
-                   "stp x29, x30, [sp,#-16]!\n\t"
-                   "mov x18, x4\n\t"             /* teb */
-                   /* store exit frame */
-                   "mov x29, sp\n\t"
-                   "str x29, [x4, #0x2f0]\n\t"  /* arm64_thread_data()->exit_frame */
-                   /* switch to thread stack */
-                   "ldr x5, [x4, #8]\n\t"       /* teb->Tib.StackBase */
-                   "sub sp, x5, #0x1000\n\t"
-                   /* attach dlls */
-                   "bl " __ASM_NAME("attach_thread") "\n\t"
-                   "mov sp, x0\n\t"
-                   /* clear the stack */
-                   "and x0, x0, #~0xfff\n\t"  /* round down to page size */
-                   "bl " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
-                   /* switch to the initial context */
-                   "mov x0, sp\n\t"
-                   "ldp q0, q1, [x0, #0x110]\n\t"      /* context->V[0,1] */
-                   "ldp q2, q3, [x0, #0x130]\n\t"      /* context->V[2,3] */
-                   "ldp q4, q5, [x0, #0x150]\n\t"      /* context->V[4,5] */
-                   "ldp q6, q7, [x0, #0x170]\n\t"      /* context->V[6,7] */
-                   "ldp q8, q9, [x0, #0x190]\n\t"      /* context->V[8,9] */
-                   "ldp q10, q11, [x0, #0x1b0]\n\t"    /* context->V[10,11] */
-                   "ldp q12, q13, [x0, #0x1d0]\n\t"    /* context->V[12,13] */
-                   "ldp q14, q15, [x0, #0x1f0]\n\t"    /* context->V[14,15] */
-                   "ldp q16, q17, [x0, #0x210]\n\t"    /* context->V[16,17] */
-                   "ldp q18, q19, [x0, #0x230]\n\t"    /* context->V[18,19] */
-                   "ldp q20, q21, [x0, #0x250]\n\t"    /* context->V[20,21] */
-                   "ldp q22, q23, [x0, #0x270]\n\t"    /* context->V[22,23] */
-                   "ldp q24, q25, [x0, #0x290]\n\t"    /* context->V[24,25] */
-                   "ldp q26, q27, [x0, #0x2b0]\n\t"    /* context->V[26,27] */
-                   "ldp q28, q29, [x0, #0x2d0]\n\t"    /* context->V[28,29] */
-                   "ldp q30, q31, [x0, #0x2f0]\n\t"    /* context->V[30,31] */
-                   "ldr w1, [x0, #0x310]\n\t"          /* context->Fpcr */
-                   "msr fpcr, x1\n\t"
-                   "ldr w1, [x0, #0x314]\n\t"          /* context->Fpsr */
-                   "msr fpsr, x1\n\t"
-                   "mov x1, #1\n\t"
-                   "b " __ASM_NAME("NtContinue") )
-
-
-extern void DECLSPEC_NORETURN call_thread_exit_func( int status, void (*func)(int), TEB *teb );
-__ASM_GLOBAL_FUNC( call_thread_exit_func,
-                   "stp x29, x30, [sp,#-16]!\n\t"
-                   "ldr x3, [x2, #0x2f0]\n\t"  /* arm64_thread_data()->exit_frame */
-                   "str xzr, [x2, #0x2f0]\n\t"
-                   "cbz x3, 1f\n\t"
-                   "mov sp, x3\n"
-                   "1:\tldp x29, x30, [sp], #16\n\t"
-                   "br x1" )
-
-/***********************************************************************
- *           signal_exit_thread
- */
-void signal_exit_thread( int status, void (*func)(int) )
-{
-    call_thread_exit_func( status, func, NtCurrentTeb() );
-}
-
-
-/**********************************************************************
- *           NtCurrentTeb   (NTDLL.@)
- */
-TEB * WINAPI NtCurrentTeb(void)
-{
-    return pthread_getspecific( teb_key );
-}
-
-#endif  /* __aarch64__ */
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
deleted file mode 100644
index 39c154ebbc..0000000000
--- a/dlls/ntdll/unix/signal_i386.c
+++ /dev/null
@@ -1,2338 +0,0 @@
-/*
- * i386 signal handling routines
- *
- * Copyright 1999 Alexandre Julliard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#ifdef __i386__
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <errno.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef HAVE_SYS_PARAM_H
-# include <sys/param.h>
-#endif
-#ifdef HAVE_SYSCALL_H
-# include <syscall.h>
-#else
-# ifdef HAVE_SYS_SYSCALL_H
-#  include <sys/syscall.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SIGNAL_H
-# include <sys/signal.h>
-#endif
-#ifdef HAVE_SYS_UCONTEXT_H
-# include <sys/ucontext.h>
-#endif
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "wine/asm.h"
-#include "wine/exception.h"
-#include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(seh);
-
-#undef ERR  /* Solaris needs to define this */
-
-/* not defined for x86, so copy the x86_64 definition */
-typedef struct DECLSPEC_ALIGN(16) _M128A
-{
-    ULONGLONG Low;
-    LONGLONG High;
-} M128A;
-
-typedef struct
-{
-    WORD ControlWord;
-    WORD StatusWord;
-    BYTE TagWord;
-    BYTE Reserved1;
-    WORD ErrorOpcode;
-    DWORD ErrorOffset;
-    WORD ErrorSelector;
-    WORD Reserved2;
-    DWORD DataOffset;
-    WORD DataSelector;
-    WORD Reserved3;
-    DWORD MxCsr;
-    DWORD MxCsr_Mask;
-    M128A FloatRegisters[8];
-    M128A XmmRegisters[16];
-    BYTE Reserved4[96];
-} XMM_SAVE_AREA32;
-
-/***********************************************************************
- * signal context platform-specific definitions
- */
-
-#ifdef __linux__
-
-#ifndef HAVE_SYS_UCONTEXT_H
-
-enum
-{
-    REG_GS, REG_FS, REG_ES, REG_DS, REG_EDI, REG_ESI, REG_EBP, REG_ESP,
-    REG_EBX, REG_EDX, REG_ECX, REG_EAX, REG_TRAPNO, REG_ERR, REG_EIP,
-    REG_CS, REG_EFL, REG_UESP, REG_SS, NGREG
-};
-
-typedef int greg_t;
-typedef greg_t gregset_t[NGREG];
-
-struct _libc_fpreg
-{
-    unsigned short significand[4];
-    unsigned short exponent;
-};
-
-struct _libc_fpstate
-{
-    unsigned long cw;
-    unsigned long sw;
-    unsigned long tag;
-    unsigned long ipoff;
-    unsigned long cssel;
-    unsigned long dataoff;
-    unsigned long datasel;
-    struct _libc_fpreg _st[8];
-    unsigned long status;
-};
-
-typedef struct _libc_fpstate* fpregset_t;
-
-typedef struct
-{
-    gregset_t     gregs;
-    fpregset_t    fpregs;
-    unsigned long oldmask;
-    unsigned long cr2;
-} mcontext_t;
-
-typedef struct ucontext
-{
-    unsigned long     uc_flags;
-    struct ucontext  *uc_link;
-    stack_t           uc_stack;
-    mcontext_t        uc_mcontext;
-    sigset_t          uc_sigmask;
-} ucontext_t;
-#endif /* HAVE_SYS_UCONTEXT_H */
-
-#define EAX_sig(context)     ((context)->uc_mcontext.gregs[REG_EAX])
-#define EBX_sig(context)     ((context)->uc_mcontext.gregs[REG_EBX])
-#define ECX_sig(context)     ((context)->uc_mcontext.gregs[REG_ECX])
-#define EDX_sig(context)     ((context)->uc_mcontext.gregs[REG_EDX])
-#define ESI_sig(context)     ((context)->uc_mcontext.gregs[REG_ESI])
-#define EDI_sig(context)     ((context)->uc_mcontext.gregs[REG_EDI])
-#define EBP_sig(context)     ((context)->uc_mcontext.gregs[REG_EBP])
-#define ESP_sig(context)     ((context)->uc_mcontext.gregs[REG_ESP])
-
-#define CS_sig(context)      ((context)->uc_mcontext.gregs[REG_CS])
-#define DS_sig(context)      ((context)->uc_mcontext.gregs[REG_DS])
-#define ES_sig(context)      ((context)->uc_mcontext.gregs[REG_ES])
-#define SS_sig(context)      ((context)->uc_mcontext.gregs[REG_SS])
-#define FS_sig(context)      ((context)->uc_mcontext.gregs[REG_FS])
-#define GS_sig(context)      ((context)->uc_mcontext.gregs[REG_GS])
-
-#define EFL_sig(context)     ((context)->uc_mcontext.gregs[REG_EFL])
-#define EIP_sig(context)     ((context)->uc_mcontext.gregs[REG_EIP])
-#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[REG_TRAPNO])
-#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[REG_ERR])
-
-#define FPU_sig(context)     ((FLOATING_SAVE_AREA*)((context)->uc_mcontext.fpregs))
-#define FPUX_sig(context)    (FPU_sig(context) && !((context)->uc_mcontext.fpregs->status >> 16) ? (XMM_SAVE_AREA32 *)(FPU_sig(context) + 1) : NULL)
-
-#ifdef __ANDROID__
-/* custom signal restorer since we may have unmapped the one in vdso, and bionic doesn't check for that */
-void rt_sigreturn(void);
-__ASM_GLOBAL_FUNC( rt_sigreturn,
-                   "movl $173,%eax\n\t"  /* NR_rt_sigreturn */
-                   "int $0x80" );
-#endif
-
-struct modify_ldt_s
-{
-    unsigned int  entry_number;
-    void         *base_addr;
-    unsigned int  limit;
-    unsigned int  seg_32bit : 1;
-    unsigned int  contents : 2;
-    unsigned int  read_exec_only : 1;
-    unsigned int  limit_in_pages : 1;
-    unsigned int  seg_not_present : 1;
-    unsigned int  usable : 1;
-    unsigned int  garbage : 25;
-};
-
-static inline int modify_ldt( int func, struct modify_ldt_s *ptr, unsigned long count )
-{
-    return syscall( 123 /* SYS_modify_ldt */, func, ptr, count );
-}
-
-static inline int set_thread_area( struct modify_ldt_s *ptr )
-{
-    return syscall( 243 /* SYS_set_thread_area */, ptr );
-}
-
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
-
-#include <machine/trap.h>
-#include <machine/segments.h>
-#include <machine/sysarch.h>
-
-#define EAX_sig(context)     ((context)->uc_mcontext.mc_eax)
-#define EBX_sig(context)     ((context)->uc_mcontext.mc_ebx)
-#define ECX_sig(context)     ((context)->uc_mcontext.mc_ecx)
-#define EDX_sig(context)     ((context)->uc_mcontext.mc_edx)
-#define ESI_sig(context)     ((context)->uc_mcontext.mc_esi)
-#define EDI_sig(context)     ((context)->uc_mcontext.mc_edi)
-#define EBP_sig(context)     ((context)->uc_mcontext.mc_ebp)
-
-#define CS_sig(context)      ((context)->uc_mcontext.mc_cs)
-#define DS_sig(context)      ((context)->uc_mcontext.mc_ds)
-#define ES_sig(context)      ((context)->uc_mcontext.mc_es)
-#define FS_sig(context)      ((context)->uc_mcontext.mc_fs)
-#define GS_sig(context)      ((context)->uc_mcontext.mc_gs)
-#define SS_sig(context)      ((context)->uc_mcontext.mc_ss)
-
-#define TRAP_sig(context)    ((context)->uc_mcontext.mc_trapno)
-#define ERROR_sig(context)   ((context)->uc_mcontext.mc_err)
-#define EFL_sig(context)     ((context)->uc_mcontext.mc_eflags)
-
-#define EIP_sig(context)     ((context)->uc_mcontext.mc_eip)
-#define ESP_sig(context)     ((context)->uc_mcontext.mc_esp)
-
-#define FPU_sig(context)     NULL  /* FIXME */
-#define FPUX_sig(context)    NULL  /* FIXME */
-
-#elif defined (__OpenBSD__)
-
-#include <machine/segments.h>
-#include <machine/sysarch.h>
-
-#define EAX_sig(context)     ((context)->sc_eax)
-#define EBX_sig(context)     ((context)->sc_ebx)
-#define ECX_sig(context)     ((context)->sc_ecx)
-#define EDX_sig(context)     ((context)->sc_edx)
-#define ESI_sig(context)     ((context)->sc_esi)
-#define EDI_sig(context)     ((context)->sc_edi)
-#define EBP_sig(context)     ((context)->sc_ebp)
-
-#define CS_sig(context)      ((context)->sc_cs)
-#define DS_sig(context)      ((context)->sc_ds)
-#define ES_sig(context)      ((context)->sc_es)
-#define FS_sig(context)      ((context)->sc_fs)
-#define GS_sig(context)      ((context)->sc_gs)
-#define SS_sig(context)      ((context)->sc_ss)
-
-#define TRAP_sig(context)    ((context)->sc_trapno)
-#define ERROR_sig(context)   ((context)->sc_err)
-#define EFL_sig(context)     ((context)->sc_eflags)
-
-#define EIP_sig(context)     ((context)->sc_eip)
-#define ESP_sig(context)     ((context)->sc_esp)
-
-#define FPU_sig(context)     NULL  /* FIXME */
-#define FPUX_sig(context)    NULL  /* FIXME */
-
-#define T_MCHK T_MACHK
-#define T_XMMFLT T_XFTRAP
-
-#elif defined(__svr4__) || defined(_SCO_DS) || defined(__sun)
-
-#if defined(_SCO_DS) || defined(__sun)
-#include <sys/regset.h>
-#endif
-
-#ifdef _SCO_DS
-#define gregs regs
-#endif
-
-#define EAX_sig(context)     ((context)->uc_mcontext.gregs[EAX])
-#define EBX_sig(context)     ((context)->uc_mcontext.gregs[EBX])
-#define ECX_sig(context)     ((context)->uc_mcontext.gregs[ECX])
-#define EDX_sig(context)     ((context)->uc_mcontext.gregs[EDX])
-#define ESI_sig(context)     ((context)->uc_mcontext.gregs[ESI])
-#define EDI_sig(context)     ((context)->uc_mcontext.gregs[EDI])
-#define EBP_sig(context)     ((context)->uc_mcontext.gregs[EBP])
-
-#define CS_sig(context)      ((context)->uc_mcontext.gregs[CS])
-#define DS_sig(context)      ((context)->uc_mcontext.gregs[DS])
-#define ES_sig(context)      ((context)->uc_mcontext.gregs[ES])
-#define SS_sig(context)      ((context)->uc_mcontext.gregs[SS])
-
-#define FS_sig(context)      ((context)->uc_mcontext.gregs[FS])
-#define GS_sig(context)      ((context)->uc_mcontext.gregs[GS])
-
-#define EFL_sig(context)     ((context)->uc_mcontext.gregs[EFL])
-
-#define EIP_sig(context)     ((context)->uc_mcontext.gregs[EIP])
-#ifdef UESP
-#define ESP_sig(context)     ((context)->uc_mcontext.gregs[UESP])
-#elif defined(R_ESP)
-#define ESP_sig(context)     ((context)->uc_mcontext.gregs[R_ESP])
-#else
-#define ESP_sig(context)     ((context)->uc_mcontext.gregs[ESP])
-#endif
-#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[ERR])
-#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[TRAPNO])
-
-#define FPU_sig(context)     NULL  /* FIXME */
-#define FPUX_sig(context)    NULL  /* FIXME */
-
-#elif defined (__APPLE__)
-
-#include <i386/user_ldt.h>
-
-/* work around silly renaming of struct members in OS X 10.5 */
-#if __DARWIN_UNIX03 && defined(_STRUCT_X86_EXCEPTION_STATE32)
-#define EAX_sig(context)     ((context)->uc_mcontext->__ss.__eax)
-#define EBX_sig(context)     ((context)->uc_mcontext->__ss.__ebx)
-#define ECX_sig(context)     ((context)->uc_mcontext->__ss.__ecx)
-#define EDX_sig(context)     ((context)->uc_mcontext->__ss.__edx)
-#define ESI_sig(context)     ((context)->uc_mcontext->__ss.__esi)
-#define EDI_sig(context)     ((context)->uc_mcontext->__ss.__edi)
-#define EBP_sig(context)     ((context)->uc_mcontext->__ss.__ebp)
-#define CS_sig(context)      ((context)->uc_mcontext->__ss.__cs)
-#define DS_sig(context)      ((context)->uc_mcontext->__ss.__ds)
-#define ES_sig(context)      ((context)->uc_mcontext->__ss.__es)
-#define FS_sig(context)      ((context)->uc_mcontext->__ss.__fs)
-#define GS_sig(context)      ((context)->uc_mcontext->__ss.__gs)
-#define SS_sig(context)      ((context)->uc_mcontext->__ss.__ss)
-#define EFL_sig(context)     ((context)->uc_mcontext->__ss.__eflags)
-#define EIP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__eip))
-#define ESP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__esp))
-#define TRAP_sig(context)    ((context)->uc_mcontext->__es.__trapno)
-#define ERROR_sig(context)   ((context)->uc_mcontext->__es.__err)
-#define FPU_sig(context)     NULL
-#define FPUX_sig(context)    ((XMM_SAVE_AREA32 *)&(context)->uc_mcontext->__fs.__fpu_fcw)
-#else
-#define EAX_sig(context)     ((context)->uc_mcontext->ss.eax)
-#define EBX_sig(context)     ((context)->uc_mcontext->ss.ebx)
-#define ECX_sig(context)     ((context)->uc_mcontext->ss.ecx)
-#define EDX_sig(context)     ((context)->uc_mcontext->ss.edx)
-#define ESI_sig(context)     ((context)->uc_mcontext->ss.esi)
-#define EDI_sig(context)     ((context)->uc_mcontext->ss.edi)
-#define EBP_sig(context)     ((context)->uc_mcontext->ss.ebp)
-#define CS_sig(context)      ((context)->uc_mcontext->ss.cs)
-#define DS_sig(context)      ((context)->uc_mcontext->ss.ds)
-#define ES_sig(context)      ((context)->uc_mcontext->ss.es)
-#define FS_sig(context)      ((context)->uc_mcontext->ss.fs)
-#define GS_sig(context)      ((context)->uc_mcontext->ss.gs)
-#define SS_sig(context)      ((context)->uc_mcontext->ss.ss)
-#define EFL_sig(context)     ((context)->uc_mcontext->ss.eflags)
-#define EIP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->ss.eip))
-#define ESP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->ss.esp))
-#define TRAP_sig(context)    ((context)->uc_mcontext->es.trapno)
-#define ERROR_sig(context)   ((context)->uc_mcontext->es.err)
-#define FPU_sig(context)     NULL
-#define FPUX_sig(context)    ((XMM_SAVE_AREA32 *)&(context)->uc_mcontext->fs.fpu_fcw)
-#endif
-
-#elif defined(__NetBSD__)
-
-#include <machine/segments.h>
-#include <machine/sysarch.h>
-
-#define EAX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EAX])
-#define EBX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EBX])
-#define ECX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_ECX])
-#define EDX_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EDX])
-#define ESI_sig(context)       ((context)->uc_mcontext.__gregs[_REG_ESI])
-#define EDI_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EDI])
-#define EBP_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EBP])
-#define ESP_sig(context)       _UC_MACHINE_SP(context)
-
-#define CS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_CS])
-#define DS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_DS])
-#define ES_sig(context)        ((context)->uc_mcontext.__gregs[_REG_ES])
-#define SS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_SS])
-#define FS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_FS])
-#define GS_sig(context)        ((context)->uc_mcontext.__gregs[_REG_GS])
-
-#define EFL_sig(context)       ((context)->uc_mcontext.__gregs[_REG_EFL])
-#define EIP_sig(context)       _UC_MACHINE_PC(context)
-#define TRAP_sig(context)      ((context)->uc_mcontext.__gregs[_REG_TRAPNO])
-#define ERROR_sig(context)     ((context)->uc_mcontext.__gregs[_REG_ERR])
-
-#define FPU_sig(context)     NULL
-#define FPUX_sig(context)    ((XMM_SAVE_AREA32 *)&((context)->uc_mcontext.__fpregs))
-
-#define T_MCHK T_MCA
-#define T_XMMFLT T_XMM
-
-#elif defined(__GNU__)
-
-#include <mach/i386/mach_i386.h>
-#include <mach/mach_traps.h>
-
-#define EAX_sig(context)     ((context)->uc_mcontext.gregs[REG_EAX])
-#define EBX_sig(context)     ((context)->uc_mcontext.gregs[REG_EBX])
-#define ECX_sig(context)     ((context)->uc_mcontext.gregs[REG_ECX])
-#define EDX_sig(context)     ((context)->uc_mcontext.gregs[REG_EDX])
-#define ESI_sig(context)     ((context)->uc_mcontext.gregs[REG_ESI])
-#define EDI_sig(context)     ((context)->uc_mcontext.gregs[REG_EDI])
-#define EBP_sig(context)     ((context)->uc_mcontext.gregs[REG_EBP])
-#define ESP_sig(context)     ((context)->uc_mcontext.gregs[REG_ESP])
-
-#define CS_sig(context)      ((context)->uc_mcontext.gregs[REG_CS])
-#define DS_sig(context)      ((context)->uc_mcontext.gregs[REG_DS])
-#define ES_sig(context)      ((context)->uc_mcontext.gregs[REG_ES])
-#define SS_sig(context)      ((context)->uc_mcontext.gregs[REG_SS])
-#define FS_sig(context)      ((context)->uc_mcontext.gregs[REG_FS])
-#define GS_sig(context)      ((context)->uc_mcontext.gregs[REG_GS])
-
-#define EFL_sig(context)     ((context)->uc_mcontext.gregs[REG_EFL])
-#define EIP_sig(context)     ((context)->uc_mcontext.gregs[REG_EIP])
-#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[REG_TRAPNO])
-#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[REG_ERR])
-
-#define FPU_sig(context)     ((FLOATING_SAVE_AREA *)&(context)->uc_mcontext.fpregs.fp_reg_set.fpchip_state)
-#define FPUX_sig(context)    NULL
-
-#else
-#error You must define the signal context functions for your platform
-#endif /* linux */
-
-static ULONG first_ldt_entry = 32;
-
-enum i386_trap_code
-{
-#if defined(__FreeBSD__) || defined (__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
-    TRAP_x86_DIVIDE     = T_DIVIDE,     /* Division by zero exception */
-    TRAP_x86_TRCTRAP    = T_TRCTRAP,    /* Single-step exception */
-    TRAP_x86_NMI        = T_NMI,        /* NMI interrupt */
-    TRAP_x86_BPTFLT     = T_BPTFLT,     /* Breakpoint exception */
-    TRAP_x86_OFLOW      = T_OFLOW,      /* Overflow exception */
-    TRAP_x86_BOUND      = T_BOUND,      /* Bound range exception */
-    TRAP_x86_PRIVINFLT  = T_PRIVINFLT,  /* Invalid opcode exception */
-    TRAP_x86_DNA        = T_DNA,        /* Device not available exception */
-    TRAP_x86_DOUBLEFLT  = T_DOUBLEFLT,  /* Double fault exception */
-    TRAP_x86_FPOPFLT    = T_FPOPFLT,    /* Coprocessor segment overrun */
-    TRAP_x86_TSSFLT     = T_TSSFLT,     /* Invalid TSS exception */
-    TRAP_x86_SEGNPFLT   = T_SEGNPFLT,   /* Segment not present exception */
-    TRAP_x86_STKFLT     = T_STKFLT,     /* Stack fault */
-    TRAP_x86_PROTFLT    = T_PROTFLT,    /* General protection fault */
-    TRAP_x86_PAGEFLT    = T_PAGEFLT,    /* Page fault */
-    TRAP_x86_ARITHTRAP  = T_ARITHTRAP,  /* Floating point exception */
-    TRAP_x86_ALIGNFLT   = T_ALIGNFLT,   /* Alignment check exception */
-    TRAP_x86_MCHK       = T_MCHK,       /* Machine check exception */
-    TRAP_x86_CACHEFLT   = T_XMMFLT      /* Cache flush exception */
-#else
-    TRAP_x86_DIVIDE     = 0,   /* Division by zero exception */
-    TRAP_x86_TRCTRAP    = 1,   /* Single-step exception */
-    TRAP_x86_NMI        = 2,   /* NMI interrupt */
-    TRAP_x86_BPTFLT     = 3,   /* Breakpoint exception */
-    TRAP_x86_OFLOW      = 4,   /* Overflow exception */
-    TRAP_x86_BOUND      = 5,   /* Bound range exception */
-    TRAP_x86_PRIVINFLT  = 6,   /* Invalid opcode exception */
-    TRAP_x86_DNA        = 7,   /* Device not available exception */
-    TRAP_x86_DOUBLEFLT  = 8,   /* Double fault exception */
-    TRAP_x86_FPOPFLT    = 9,   /* Coprocessor segment overrun */
-    TRAP_x86_TSSFLT     = 10,  /* Invalid TSS exception */
-    TRAP_x86_SEGNPFLT   = 11,  /* Segment not present exception */
-    TRAP_x86_STKFLT     = 12,  /* Stack fault */
-    TRAP_x86_PROTFLT    = 13,  /* General protection fault */
-    TRAP_x86_PAGEFLT    = 14,  /* Page fault */
-    TRAP_x86_ARITHTRAP  = 16,  /* Floating point exception */
-    TRAP_x86_ALIGNFLT   = 17,  /* Alignment check exception */
-    TRAP_x86_MCHK       = 18,  /* Machine check exception */
-    TRAP_x86_CACHEFLT   = 19   /* SIMD exception (via SIGFPE) if CPU is SSE capable
-                                  otherwise Cache flush exception (via SIGSEV) */
-#endif
-};
-
-struct syscall_frame
-{
-    struct syscall_frame *prev_frame;
-    DWORD                 edi;
-    DWORD                 esi;
-    DWORD                 ebx;
-    DWORD                 ebp;
-    DWORD                 thunk_addr;
-    DWORD                 ret_addr;
-};
-
-struct x86_thread_data
-{
-    DWORD              fs;            /* 1d4 TEB selector */
-    DWORD              gs;            /* 1d8 libc selector; update winebuild if you move this! */
-    DWORD              dr0;           /* 1dc debug registers */
-    DWORD              dr1;           /* 1e0 */
-    DWORD              dr2;           /* 1e4 */
-    DWORD              dr3;           /* 1e8 */
-    DWORD              dr6;           /* 1ec */
-    DWORD              dr7;           /* 1f0 */
-    void              *exit_frame;    /* 1f4 exit frame pointer */
-    struct syscall_frame *syscall_frame; /* 1f8 frame pointer on syscall entry */
-};
-
-C_ASSERT( sizeof(struct x86_thread_data) <= sizeof(((struct ntdll_thread_data *)0)->cpu_data) );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct x86_thread_data, gs ) == 0x1d8 );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct x86_thread_data, exit_frame ) == 0x1f4 );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct x86_thread_data, syscall_frame ) == 0x1f8 );
-
-static inline struct x86_thread_data *x86_thread_data(void)
-{
-    return (struct x86_thread_data *)ntdll_get_thread_data()->cpu_data;
-}
-
-static inline WORD get_cs(void) { WORD res; __asm__( "movw %%cs,%0" : "=r" (res) ); return res; }
-static inline WORD get_ds(void) { WORD res; __asm__( "movw %%ds,%0" : "=r" (res) ); return res; }
-static inline WORD get_fs(void) { WORD res; __asm__( "movw %%fs,%0" : "=r" (res) ); return res; }
-static inline WORD get_gs(void) { WORD res; __asm__( "movw %%gs,%0" : "=r" (res) ); return res; }
-static inline void set_fs( WORD val ) { __asm__( "mov %0,%%fs" :: "r" (val)); }
-static inline void set_gs( WORD val ) { __asm__( "mov %0,%%gs" :: "r" (val)); }
-
-
-/***********************************************************************
- *           unwind_builtin_dll
- */
-NTSTATUS CDECL unwind_builtin_dll( ULONG type, struct _DISPATCHER_CONTEXT *dispatch, CONTEXT *context )
-{
-    return STATUS_UNSUCCESSFUL;
-}
-
-
-/***********************************************************************
- *           is_gdt_sel
- */
-static inline int is_gdt_sel( WORD sel )
-{
-    return !(sel & 4);
-}
-
-
-/***********************************************************************
- *           ldt_is_system
- */
-static inline int ldt_is_system( WORD sel )
-{
-    return is_gdt_sel( sel ) || ((sel >> 3) < first_ldt_entry);
-}
-
-
-/***********************************************************************
- *           get_current_teb
- *
- * Get the current teb based on the stack pointer.
- */
-static inline TEB *get_current_teb(void)
-{
-    unsigned long esp;
-    __asm__("movl %%esp,%0" : "=g" (esp) );
-    return (TEB *)((esp & ~signal_stack_mask) + teb_offset);
-}
-
-
-#ifdef __sun
-
-/* We have to workaround two Solaris breakages:
- * - Solaris doesn't restore %ds and %es before calling the signal handler so exceptions in 16-bit
- *   code crash badly.
- * - Solaris inserts a libc trampoline to call our handler, but the trampoline expects that registers
- *   are setup correctly. So we need to insert our own trampoline below the libc trampoline to set %gs.
- */
-
-extern int sigaction_syscall( int sig, const struct sigaction *new, struct sigaction *old );
-__ASM_GLOBAL_FUNC( sigaction_syscall,
-                  "movl $0x62,%eax\n\t"
-                  "int $0x91\n\t"
-                  "ret" )
-
-/* assume the same libc handler is used for all signals */
-static void (*libc_sigacthandler)( int signal, siginfo_t *siginfo, void *context );
-
-static void wine_sigacthandler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    struct x86_thread_data *thread_data;
-
-    __asm__ __volatile__("mov %ss,%ax; mov %ax,%ds; mov %ax,%es");
-
-    thread_data = (struct x86_thread_data *)get_current_teb()->GdiTebBatch;
-    set_fs( thread_data->fs );
-    set_gs( thread_data->gs );
-
-    libc_sigacthandler( signal, siginfo, sigcontext );
-}
-
-static int solaris_sigaction( int sig, const struct sigaction *new, struct sigaction *old )
-{
-    struct sigaction real_act;
-
-    if (sigaction( sig, new, old ) == -1) return -1;
-
-    /* retrieve the real handler and flags with a direct syscall */
-    sigaction_syscall( sig, NULL, &real_act );
-    libc_sigacthandler = real_act.sa_sigaction;
-    real_act.sa_sigaction = wine_sigacthandler;
-    sigaction_syscall( sig, &real_act, NULL );
-    return 0;
-}
-#define sigaction(sig,new,old) solaris_sigaction(sig,new,old)
-
-#endif
-
-extern void clear_alignment_flag(void);
-__ASM_GLOBAL_FUNC( clear_alignment_flag,
-                   "pushfl\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
-                   "andl $~0x40000,(%esp)\n\t"
-                   "popfl\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset -4\n\t")
-                   "ret" )
-
-
-/***********************************************************************
- *           init_handler
- *
- * Handler initialization when the full context is not needed.
- * Return the stack pointer to use for pushing the exception data.
- */
-static inline void *init_handler( const ucontext_t *sigcontext )
-{
-    TEB *teb = get_current_teb();
-
-    clear_alignment_flag();
-
-#ifndef __sun  /* see above for Solaris handling */
-    {
-        struct x86_thread_data *thread_data = (struct x86_thread_data *)&teb->GdiTebBatch;
-        set_fs( thread_data->fs );
-        set_gs( thread_data->gs );
-    }
-#endif
-
-    if (!ldt_is_system(CS_sig(sigcontext)) || !ldt_is_system(SS_sig(sigcontext)))  /* 16-bit mode */
-    {
-        /*
-         * Win16 or DOS protected mode. Note that during switch
-         * from 16-bit mode to linear mode, CS may be set to system
-         * segment before FS is restored. Fortunately, in this case
-         * SS is still non-system segment. This is why both CS and SS
-         * are checked.
-         */
-        return teb->WOW32Reserved;
-    }
-    return (void *)(ESP_sig(sigcontext) & ~3);
-}
-
-
-/***********************************************************************
- *           save_fpu
- *
- * Save the thread FPU context.
- */
-static inline void save_fpu( CONTEXT *context )
-{
-    struct
-    {
-        DWORD ControlWord;
-        DWORD StatusWord;
-        DWORD TagWord;
-        DWORD ErrorOffset;
-        DWORD ErrorSelector;
-        DWORD DataOffset;
-        DWORD DataSelector;
-    }
-    float_status;
-
-    context->ContextFlags |= CONTEXT_FLOATING_POINT;
-    __asm__ __volatile__( "fnsave %0; fwait" : "=m" (context->FloatSave) );
-
-    /* Reset unmasked exceptions status to avoid firing an exception. */
-    memcpy(&float_status, &context->FloatSave, sizeof(float_status));
-    float_status.StatusWord &= float_status.ControlWord | 0xffffff80;
-
-    __asm__ __volatile__( "fldenv %0" : : "m" (float_status) );
-}
-
-
-/***********************************************************************
- *           save_fpux
- *
- * Save the thread FPU extended context.
- */
-static inline void save_fpux( CONTEXT *context )
-{
-    /* we have to enforce alignment by hand */
-    char buffer[sizeof(XMM_SAVE_AREA32) + 16];
-    XMM_SAVE_AREA32 *state = (XMM_SAVE_AREA32 *)(((ULONG_PTR)buffer + 15) & ~15);
-
-    context->ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
-    __asm__ __volatile__( "fxsave %0" : "=m" (*state) );
-    memcpy( context->ExtendedRegisters, state, sizeof(*state) );
-}
-
-
-/***********************************************************************
- *           restore_fpu
- *
- * Restore the FPU context to a sigcontext.
- */
-static inline void restore_fpu( const CONTEXT *context )
-{
-    FLOATING_SAVE_AREA float_status = context->FloatSave;
-    /* reset the current interrupt status */
-    float_status.StatusWord &= float_status.ControlWord | 0xffffff80;
-    __asm__ __volatile__( "frstor %0; fwait" : : "m" (float_status) );
-}
-
-
-/***********************************************************************
- *           restore_fpux
- *
- * Restore the FPU extended context to a sigcontext.
- */
-static inline void restore_fpux( const CONTEXT *context )
-{
-    /* we have to enforce alignment by hand */
-    char buffer[sizeof(XMM_SAVE_AREA32) + 16];
-    XMM_SAVE_AREA32 *state = (XMM_SAVE_AREA32 *)(((ULONG_PTR)buffer + 15) & ~15);
-
-    memcpy( state, context->ExtendedRegisters, sizeof(*state) );
-    /* reset the current interrupt status */
-    state->StatusWord &= state->ControlWord | 0xff80;
-    __asm__ __volatile__( "fxrstor %0" : : "m" (*state) );
-}
-
-
-/***********************************************************************
- *           fpux_to_fpu
- *
- * Build a standard FPU context from an extended one.
- */
-static void fpux_to_fpu( FLOATING_SAVE_AREA *fpu, const XMM_SAVE_AREA32 *fpux )
-{
-    unsigned int i, tag, stack_top;
-
-    fpu->ControlWord   = fpux->ControlWord | 0xffff0000;
-    fpu->StatusWord    = fpux->StatusWord | 0xffff0000;
-    fpu->ErrorOffset   = fpux->ErrorOffset;
-    fpu->ErrorSelector = fpux->ErrorSelector | (fpux->ErrorOpcode << 16);
-    fpu->DataOffset    = fpux->DataOffset;
-    fpu->DataSelector  = fpux->DataSelector;
-    fpu->Cr0NpxState   = fpux->StatusWord | 0xffff0000;
-
-    stack_top = (fpux->StatusWord >> 11) & 7;
-    fpu->TagWord = 0xffff0000;
-    for (i = 0; i < 8; i++)
-    {
-        memcpy( &fpu->RegisterArea[10 * i], &fpux->FloatRegisters[i], 10 );
-        if (!(fpux->TagWord & (1 << i))) tag = 3;  /* empty */
-        else
-        {
-            const M128A *reg = &fpux->FloatRegisters[(i - stack_top) & 7];
-            if ((reg->High & 0x7fff) == 0x7fff)  /* exponent all ones */
-            {
-                tag = 2;  /* special */
-            }
-            else if (!(reg->High & 0x7fff))  /* exponent all zeroes */
-            {
-                if (reg->Low) tag = 2;  /* special */
-                else tag = 1;  /* zero */
-            }
-            else
-            {
-                if (reg->Low >> 63) tag = 0;  /* valid */
-                else tag = 2;  /* special */
-            }
-        }
-        fpu->TagWord |= tag << (2 * i);
-    }
-}
-
-
-/***********************************************************************
- *           save_context
- *
- * Build a context structure from the signal info.
- */
-static inline void save_context( CONTEXT *context, const ucontext_t *sigcontext )
-{
-    FLOATING_SAVE_AREA *fpu = FPU_sig(sigcontext);
-    XMM_SAVE_AREA32 *fpux = FPUX_sig(sigcontext);
-
-    memset(context, 0, sizeof(*context));
-    context->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
-    context->Eax          = EAX_sig(sigcontext);
-    context->Ebx          = EBX_sig(sigcontext);
-    context->Ecx          = ECX_sig(sigcontext);
-    context->Edx          = EDX_sig(sigcontext);
-    context->Esi          = ESI_sig(sigcontext);
-    context->Edi          = EDI_sig(sigcontext);
-    context->Ebp          = EBP_sig(sigcontext);
-    context->EFlags       = EFL_sig(sigcontext);
-    context->Eip          = EIP_sig(sigcontext);
-    context->Esp          = ESP_sig(sigcontext);
-    context->SegCs        = LOWORD(CS_sig(sigcontext));
-    context->SegDs        = LOWORD(DS_sig(sigcontext));
-    context->SegEs        = LOWORD(ES_sig(sigcontext));
-    context->SegFs        = LOWORD(FS_sig(sigcontext));
-    context->SegGs        = LOWORD(GS_sig(sigcontext));
-    context->SegSs        = LOWORD(SS_sig(sigcontext));
-    context->Dr0          = x86_thread_data()->dr0;
-    context->Dr1          = x86_thread_data()->dr1;
-    context->Dr2          = x86_thread_data()->dr2;
-    context->Dr3          = x86_thread_data()->dr3;
-    context->Dr6          = x86_thread_data()->dr6;
-    context->Dr7          = x86_thread_data()->dr7;
-
-    if (fpu)
-    {
-        context->ContextFlags |= CONTEXT_FLOATING_POINT;
-        context->FloatSave = *fpu;
-    }
-    if (fpux)
-    {
-        context->ContextFlags |= CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;
-        memcpy( context->ExtendedRegisters, fpux, sizeof(*fpux) );
-        if (!fpu) fpux_to_fpu( &context->FloatSave, fpux );
-    }
-    if (!fpu && !fpux) save_fpu( context );
-}
-
-
-/***********************************************************************
- *           restore_context
- *
- * Restore the signal info from the context.
- */
-static inline void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
-{
-    FLOATING_SAVE_AREA *fpu = FPU_sig(sigcontext);
-    XMM_SAVE_AREA32 *fpux = FPUX_sig(sigcontext);
-
-    x86_thread_data()->dr0 = context->Dr0;
-    x86_thread_data()->dr1 = context->Dr1;
-    x86_thread_data()->dr2 = context->Dr2;
-    x86_thread_data()->dr3 = context->Dr3;
-    x86_thread_data()->dr6 = context->Dr6;
-    x86_thread_data()->dr7 = context->Dr7;
-    EAX_sig(sigcontext) = context->Eax;
-    EBX_sig(sigcontext) = context->Ebx;
-    ECX_sig(sigcontext) = context->Ecx;
-    EDX_sig(sigcontext) = context->Edx;
-    ESI_sig(sigcontext) = context->Esi;
-    EDI_sig(sigcontext) = context->Edi;
-    EBP_sig(sigcontext) = context->Ebp;
-    EFL_sig(sigcontext) = context->EFlags;
-    EIP_sig(sigcontext) = context->Eip;
-    ESP_sig(sigcontext) = context->Esp;
-    CS_sig(sigcontext)  = context->SegCs;
-    DS_sig(sigcontext)  = context->SegDs;
-    ES_sig(sigcontext)  = context->SegEs;
-    FS_sig(sigcontext)  = context->SegFs;
-    GS_sig(sigcontext)  = context->SegGs;
-    SS_sig(sigcontext)  = context->SegSs;
-
-    if (fpu) *fpu = context->FloatSave;
-    if (fpux) memcpy( fpux, context->ExtendedRegisters, sizeof(*fpux) );
-    if (!fpu && !fpux) restore_fpu( context );
-}
-
-
-/***********************************************************************
- *           set_full_cpu_context
- *
- * Set the new CPU context.
- */
-extern void set_full_cpu_context( const CONTEXT *context );
-__ASM_GLOBAL_FUNC( set_full_cpu_context,
-                   "movl 4(%esp),%ecx\n\t"
-                   "movw 0x8c(%ecx),%gs\n\t"  /* SegGs */
-                   "movw 0x90(%ecx),%fs\n\t"  /* SegFs */
-                   "movw 0x94(%ecx),%es\n\t"  /* SegEs */
-                   "movl 0x9c(%ecx),%edi\n\t" /* Edi */
-                   "movl 0xa0(%ecx),%esi\n\t" /* Esi */
-                   "movl 0xa4(%ecx),%ebx\n\t" /* Ebx */
-                   "movl 0xb4(%ecx),%ebp\n\t" /* Ebp */
-                   "movw %ss,%ax\n\t"
-                   "cmpw 0xc8(%ecx),%ax\n\t"  /* SegSs */
-                   "jne 1f\n\t"
-                   /* As soon as we have switched stacks the context structure could
-                    * be invalid (when signal handlers are executed for example). Copy
-                    * values on the target stack before changing ESP. */
-                   "movl 0xc4(%ecx),%eax\n\t" /* Esp */
-                   "leal -4*4(%eax),%eax\n\t"
-                   "movl 0xc0(%ecx),%edx\n\t" /* EFlags */
-                   "movl %edx,3*4(%eax)\n\t"
-                   "movl 0xbc(%ecx),%edx\n\t" /* SegCs */
-                   "movl %edx,2*4(%eax)\n\t"
-                   "movl 0xb8(%ecx),%edx\n\t" /* Eip */
-                   "movl %edx,1*4(%eax)\n\t"
-                   "movl 0xb0(%ecx),%edx\n\t" /* Eax */
-                   "movl %edx,0*4(%eax)\n\t"
-                   "pushl 0x98(%ecx)\n\t"     /* SegDs */
-                   "movl 0xa8(%ecx),%edx\n\t" /* Edx */
-                   "movl 0xac(%ecx),%ecx\n\t" /* Ecx */
-                   "popl %ds\n\t"
-                   "movl %eax,%esp\n\t"
-                   "popl %eax\n\t"
-                   "iret\n"
-                   /* Restore the context when the stack segment changes. We can't use
-                    * the same code as above because we do not know if the stack segment
-                    * is 16 or 32 bit, and 'movl' will throw an exception when we try to
-                    * access memory above the limit. */
-                   "1:\n\t"
-                   "movl 0xa8(%ecx),%edx\n\t" /* Edx */
-                   "movl 0xb0(%ecx),%eax\n\t" /* Eax */
-                   "movw 0xc8(%ecx),%ss\n\t"  /* SegSs */
-                   "movl 0xc4(%ecx),%esp\n\t" /* Esp */
-                   "pushl 0xc0(%ecx)\n\t"     /* EFlags */
-                   "pushl 0xbc(%ecx)\n\t"     /* SegCs */
-                   "pushl 0xb8(%ecx)\n\t"     /* Eip */
-                   "pushl 0x98(%ecx)\n\t"     /* SegDs */
-                   "movl 0xac(%ecx),%ecx\n\t" /* Ecx */
-                   "popl %ds\n\t"
-                   "iret" )
-
-
-/***********************************************************************
- *           get_server_context_flags
- *
- * Convert CPU-specific flags to generic server flags
- */
-static unsigned int get_server_context_flags( DWORD flags )
-{
-    unsigned int ret = 0;
-
-    flags &= ~CONTEXT_i386;  /* get rid of CPU id */
-    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
-    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
-    if (flags & CONTEXT_SEGMENTS) ret |= SERVER_CTX_SEGMENTS;
-    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
-    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
-    if (flags & CONTEXT_EXTENDED_REGISTERS) ret |= SERVER_CTX_EXTENDED_REGISTERS;
-    return ret;
-}
-
-
-/***********************************************************************
- *           context_to_server
- *
- * Convert a register context to the server format.
- */
-NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
-{
-    DWORD flags = from->ContextFlags & ~CONTEXT_i386;  /* get rid of CPU id */
-
-    memset( to, 0, sizeof(*to) );
-    to->cpu = CPU_x86;
-
-    if (flags & CONTEXT_CONTROL)
-    {
-        to->flags |= SERVER_CTX_CONTROL;
-        to->ctl.i386_regs.ebp    = from->Ebp;
-        to->ctl.i386_regs.esp    = from->Esp;
-        to->ctl.i386_regs.eip    = from->Eip;
-        to->ctl.i386_regs.cs     = from->SegCs;
-        to->ctl.i386_regs.ss     = from->SegSs;
-        to->ctl.i386_regs.eflags = from->EFlags;
-    }
-    if (flags & CONTEXT_INTEGER)
-    {
-        to->flags |= SERVER_CTX_INTEGER;
-        to->integer.i386_regs.eax = from->Eax;
-        to->integer.i386_regs.ebx = from->Ebx;
-        to->integer.i386_regs.ecx = from->Ecx;
-        to->integer.i386_regs.edx = from->Edx;
-        to->integer.i386_regs.esi = from->Esi;
-        to->integer.i386_regs.edi = from->Edi;
-    }
-    if (flags & CONTEXT_SEGMENTS)
-    {
-        to->flags |= SERVER_CTX_SEGMENTS;
-        to->seg.i386_regs.ds = from->SegDs;
-        to->seg.i386_regs.es = from->SegEs;
-        to->seg.i386_regs.fs = from->SegFs;
-        to->seg.i386_regs.gs = from->SegGs;
-    }
-    if (flags & CONTEXT_FLOATING_POINT)
-    {
-        to->flags |= SERVER_CTX_FLOATING_POINT;
-        to->fp.i386_regs.ctrl     = from->FloatSave.ControlWord;
-        to->fp.i386_regs.status   = from->FloatSave.StatusWord;
-        to->fp.i386_regs.tag      = from->FloatSave.TagWord;
-        to->fp.i386_regs.err_off  = from->FloatSave.ErrorOffset;
-        to->fp.i386_regs.err_sel  = from->FloatSave.ErrorSelector;
-        to->fp.i386_regs.data_off = from->FloatSave.DataOffset;
-        to->fp.i386_regs.data_sel = from->FloatSave.DataSelector;
-        to->fp.i386_regs.cr0npx   = from->FloatSave.Cr0NpxState;
-        memcpy( to->fp.i386_regs.regs, from->FloatSave.RegisterArea, sizeof(to->fp.i386_regs.regs) );
-    }
-    if (flags & CONTEXT_DEBUG_REGISTERS)
-    {
-        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
-        to->debug.i386_regs.dr0 = from->Dr0;
-        to->debug.i386_regs.dr1 = from->Dr1;
-        to->debug.i386_regs.dr2 = from->Dr2;
-        to->debug.i386_regs.dr3 = from->Dr3;
-        to->debug.i386_regs.dr6 = from->Dr6;
-        to->debug.i386_regs.dr7 = from->Dr7;
-    }
-    if (flags & CONTEXT_EXTENDED_REGISTERS)
-    {
-        to->flags |= SERVER_CTX_EXTENDED_REGISTERS;
-        memcpy( to->ext.i386_regs, from->ExtendedRegisters, sizeof(to->ext.i386_regs) );
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           context_from_server
- *
- * Convert a register context from the server format.
- */
-NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
-{
-    if (from->cpu != CPU_x86) return STATUS_INVALID_PARAMETER;
-
-    to->ContextFlags = CONTEXT_i386;
-    if (from->flags & SERVER_CTX_CONTROL)
-    {
-        to->ContextFlags |= CONTEXT_CONTROL;
-        to->Ebp    = from->ctl.i386_regs.ebp;
-        to->Esp    = from->ctl.i386_regs.esp;
-        to->Eip    = from->ctl.i386_regs.eip;
-        to->SegCs  = from->ctl.i386_regs.cs;
-        to->SegSs  = from->ctl.i386_regs.ss;
-        to->EFlags = from->ctl.i386_regs.eflags;
-    }
-    if (from->flags & SERVER_CTX_INTEGER)
-    {
-        to->ContextFlags |= CONTEXT_INTEGER;
-        to->Eax = from->integer.i386_regs.eax;
-        to->Ebx = from->integer.i386_regs.ebx;
-        to->Ecx = from->integer.i386_regs.ecx;
-        to->Edx = from->integer.i386_regs.edx;
-        to->Esi = from->integer.i386_regs.esi;
-        to->Edi = from->integer.i386_regs.edi;
-    }
-    if (from->flags & SERVER_CTX_SEGMENTS)
-    {
-        to->ContextFlags |= CONTEXT_SEGMENTS;
-        to->SegDs = from->seg.i386_regs.ds;
-        to->SegEs = from->seg.i386_regs.es;
-        to->SegFs = from->seg.i386_regs.fs;
-        to->SegGs = from->seg.i386_regs.gs;
-    }
-    if (from->flags & SERVER_CTX_FLOATING_POINT)
-    {
-        to->ContextFlags |= CONTEXT_FLOATING_POINT;
-        to->FloatSave.ControlWord   = from->fp.i386_regs.ctrl;
-        to->FloatSave.StatusWord    = from->fp.i386_regs.status;
-        to->FloatSave.TagWord       = from->fp.i386_regs.tag;
-        to->FloatSave.ErrorOffset   = from->fp.i386_regs.err_off;
-        to->FloatSave.ErrorSelector = from->fp.i386_regs.err_sel;
-        to->FloatSave.DataOffset    = from->fp.i386_regs.data_off;
-        to->FloatSave.DataSelector  = from->fp.i386_regs.data_sel;
-        to->FloatSave.Cr0NpxState   = from->fp.i386_regs.cr0npx;
-        memcpy( to->FloatSave.RegisterArea, from->fp.i386_regs.regs, sizeof(to->FloatSave.RegisterArea) );
-    }
-    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
-    {
-        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
-        to->Dr0 = from->debug.i386_regs.dr0;
-        to->Dr1 = from->debug.i386_regs.dr1;
-        to->Dr2 = from->debug.i386_regs.dr2;
-        to->Dr3 = from->debug.i386_regs.dr3;
-        to->Dr6 = from->debug.i386_regs.dr6;
-        to->Dr7 = from->debug.i386_regs.dr7;
-    }
-    if (from->flags & SERVER_CTX_EXTENDED_REGISTERS)
-    {
-        to->ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
-        memcpy( to->ExtendedRegisters, from->ext.i386_regs, sizeof(to->ExtendedRegisters) );
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *              NtSetContextThread  (NTDLL.@)
- *              ZwSetContextThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
-{
-    NTSTATUS ret = STATUS_SUCCESS;
-    DWORD flags = context->ContextFlags & ~CONTEXT_i386;
-    BOOL self = (handle == GetCurrentThread());
-
-    /* debug registers require a server call */
-    if (self && (flags & CONTEXT_DEBUG_REGISTERS))
-        self = (x86_thread_data()->dr0 == context->Dr0 &&
-                x86_thread_data()->dr1 == context->Dr1 &&
-                x86_thread_data()->dr2 == context->Dr2 &&
-                x86_thread_data()->dr3 == context->Dr3 &&
-                x86_thread_data()->dr6 == context->Dr6 &&
-                x86_thread_data()->dr7 == context->Dr7);
-
-    if (!self)
-    {
-        context_t server_context;
-        context_to_server( &server_context, context );
-        ret = set_thread_context( handle, &server_context, &self );
-        if (ret || !self) return ret;
-        if (flags & CONTEXT_DEBUG_REGISTERS)
-        {
-            x86_thread_data()->dr0 = context->Dr0;
-            x86_thread_data()->dr1 = context->Dr1;
-            x86_thread_data()->dr2 = context->Dr2;
-            x86_thread_data()->dr3 = context->Dr3;
-            x86_thread_data()->dr6 = context->Dr6;
-            x86_thread_data()->dr7 = context->Dr7;
-        }
-    }
-
-    if (flags & CONTEXT_EXTENDED_REGISTERS) restore_fpux( context );
-    else if (flags & CONTEXT_FLOATING_POINT) restore_fpu( context );
-
-    if (flags & CONTEXT_FULL)
-    {
-        if (!(flags & CONTEXT_CONTROL))
-            FIXME( "setting partial context (%x) not supported\n", flags );
-        else if (flags & CONTEXT_SEGMENTS)
-            set_full_cpu_context( context );
-        else
-        {
-            CONTEXT newcontext = *context;
-            newcontext.SegDs = get_ds();
-            newcontext.SegEs = get_ds();
-            newcontext.SegFs = get_fs();
-            newcontext.SegGs = get_gs();
-            set_full_cpu_context( &newcontext );
-        }
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *              NtGetContextThread  (NTDLL.@)
- *              ZwGetContextThread  (NTDLL.@)
- *
- * Note: we use a small assembly wrapper to save the necessary registers
- *       in case we are fetching the context of the current thread.
- */
-NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
-{
-    NTSTATUS ret;
-    struct syscall_frame *frame = x86_thread_data()->syscall_frame;
-    DWORD needed_flags = context->ContextFlags & ~CONTEXT_i386;
-    BOOL self = (handle == GetCurrentThread());
-
-    /* debug registers require a server call */
-    if (needed_flags & CONTEXT_DEBUG_REGISTERS) self = FALSE;
-
-    if (!self)
-    {
-        context_t server_context;
-        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
-
-        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
-        if ((ret = context_from_server( context, &server_context ))) return ret;
-        needed_flags &= ~context->ContextFlags;
-    }
-
-    if (self)
-    {
-        if (needed_flags & CONTEXT_INTEGER)
-        {
-            context->Eax = 0;
-            context->Ebx = frame->ebx;
-            context->Ecx = 0;
-            context->Edx = 0;
-            context->Esi = frame->esi;
-            context->Edi = frame->edi;
-            context->ContextFlags |= CONTEXT_INTEGER;
-        }
-        if (needed_flags & CONTEXT_CONTROL)
-        {
-            context->Esp    = (DWORD)&frame->ret_addr;
-            context->Ebp    = frame->ebp;
-            context->Eip    = frame->thunk_addr;
-            context->EFlags = 0x202;
-            context->SegCs  = get_cs();
-            context->SegSs  = get_ds();
-            context->ContextFlags |= CONTEXT_CONTROL;
-        }
-        if (needed_flags & CONTEXT_SEGMENTS)
-        {
-            context->SegDs = get_ds();
-            context->SegEs = get_ds();
-            context->SegFs = get_fs();
-            context->SegGs = get_gs();
-            context->ContextFlags |= CONTEXT_SEGMENTS;
-        }
-        if (needed_flags & CONTEXT_FLOATING_POINT) save_fpu( context );
-        if (needed_flags & CONTEXT_EXTENDED_REGISTERS) save_fpux( context );
-        /* FIXME: xstate */
-        /* update the cached version of the debug registers */
-        if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
-        {
-            x86_thread_data()->dr0 = context->Dr0;
-            x86_thread_data()->dr1 = context->Dr1;
-            x86_thread_data()->dr2 = context->Dr2;
-            x86_thread_data()->dr3 = context->Dr3;
-            x86_thread_data()->dr6 = context->Dr6;
-            x86_thread_data()->dr7 = context->Dr7;
-        }
-    }
-
-    if (context->ContextFlags & (CONTEXT_INTEGER & ~CONTEXT_i386))
-        TRACE( "%p: eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n", handle,
-               context->Eax, context->Ebx, context->Ecx, context->Edx, context->Esi, context->Edi );
-    if (context->ContextFlags & (CONTEXT_CONTROL & ~CONTEXT_i386))
-        TRACE( "%p: ebp=%08x esp=%08x eip=%08x cs=%04x ss=%04x flags=%08x\n", handle,
-               context->Ebp, context->Esp, context->Eip, context->SegCs, context->SegSs, context->EFlags );
-    if (context->ContextFlags & (CONTEXT_SEGMENTS & ~CONTEXT_i386))
-        TRACE( "%p: ds=%04x es=%04x fs=%04x gs=%04x\n", handle,
-               context->SegDs, context->SegEs, context->SegFs, context->SegGs );
-    if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
-        TRACE( "%p: dr0=%08x dr1=%08x dr2=%08x dr3=%08x dr6=%08x dr7=%08x\n", handle,
-               context->Dr0, context->Dr1, context->Dr2, context->Dr3, context->Dr6, context->Dr7 );
-
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           is_privileged_instr
- *
- * Check if the fault location is a privileged instruction.
- * Based on the instruction emulation code in dlls/kernel/instr.c.
- */
-static inline DWORD is_privileged_instr( CONTEXT *context )
-{
-    BYTE instr[16];
-    unsigned int i, len, prefix_count = 0;
-
-    if (!ldt_is_system( context->SegCs )) return 0;
-    len = virtual_uninterrupted_read_memory( (BYTE *)context->Eip, instr, sizeof(instr) );
-
-    for (i = 0; i < len; i++) switch (instr[i])
-    {
-    /* instruction prefixes */
-    case 0x2e:  /* %cs: */
-    case 0x36:  /* %ss: */
-    case 0x3e:  /* %ds: */
-    case 0x26:  /* %es: */
-    case 0x64:  /* %fs: */
-    case 0x65:  /* %gs: */
-    case 0x66:  /* opcode size */
-    case 0x67:  /* addr size */
-    case 0xf0:  /* lock */
-    case 0xf2:  /* repne */
-    case 0xf3:  /* repe */
-        if (++prefix_count >= 15) return EXCEPTION_ILLEGAL_INSTRUCTION;
-        continue;
-
-    case 0x0f: /* extended instruction */
-        if (i == len - 1) return 0;
-        switch(instr[i + 1])
-        {
-        case 0x20: /* mov crX, reg */
-        case 0x21: /* mov drX, reg */
-        case 0x22: /* mov reg, crX */
-        case 0x23: /* mov reg drX */
-            return EXCEPTION_PRIV_INSTRUCTION;
-        }
-        return 0;
-    case 0x6c: /* insb (%dx) */
-    case 0x6d: /* insl (%dx) */
-    case 0x6e: /* outsb (%dx) */
-    case 0x6f: /* outsl (%dx) */
-    case 0xcd: /* int $xx */
-    case 0xe4: /* inb al,XX */
-    case 0xe5: /* in (e)ax,XX */
-    case 0xe6: /* outb XX,al */
-    case 0xe7: /* out XX,(e)ax */
-    case 0xec: /* inb (%dx),%al */
-    case 0xed: /* inl (%dx),%eax */
-    case 0xee: /* outb %al,(%dx) */
-    case 0xef: /* outl %eax,(%dx) */
-    case 0xf4: /* hlt */
-    case 0xfa: /* cli */
-    case 0xfb: /* sti */
-        return EXCEPTION_PRIV_INSTRUCTION;
-    default:
-        return 0;
-    }
-    return 0;
-}
-
-
-/***********************************************************************
- *           check_invalid_gs
- *
- * Check for fault caused by invalid %gs value (some copy protection schemes mess with it).
- */
-static inline BOOL check_invalid_gs( ucontext_t *sigcontext, CONTEXT *context )
-{
-    unsigned int prefix_count = 0;
-    const BYTE *instr = (BYTE *)context->Eip;
-    WORD system_gs = x86_thread_data()->gs;
-
-    if (context->SegGs == system_gs) return FALSE;
-    if (!ldt_is_system( context->SegCs )) return FALSE;
-    /* only handle faults in system libraries */
-    if (virtual_is_valid_code_address( instr, 1 )) return FALSE;
-
-    for (;;) switch(*instr)
-    {
-    /* instruction prefixes */
-    case 0x2e:  /* %cs: */
-    case 0x36:  /* %ss: */
-    case 0x3e:  /* %ds: */
-    case 0x26:  /* %es: */
-    case 0x64:  /* %fs: */
-    case 0x66:  /* opcode size */
-    case 0x67:  /* addr size */
-    case 0xf0:  /* lock */
-    case 0xf2:  /* repne */
-    case 0xf3:  /* repe */
-        if (++prefix_count >= 15) return FALSE;
-        instr++;
-        continue;
-    case 0x65:  /* %gs: */
-        TRACE( "%04x/%04x at %p, fixing up\n", context->SegGs, system_gs, instr );
-        GS_sig(sigcontext) = system_gs;
-        return TRUE;
-    default:
-        return FALSE;
-    }
-}
-
-
-#include "pshpack1.h"
-union atl_thunk
-{
-    struct
-    {
-        DWORD movl;  /* movl this,4(%esp) */
-        DWORD this;
-        BYTE  jmp;   /* jmp func */
-        int   func;
-    } t1;
-    struct
-    {
-        BYTE  movl;  /* movl this,ecx */
-        DWORD this;
-        BYTE  jmp;   /* jmp func */
-        int   func;
-    } t2;
-    struct
-    {
-        BYTE  movl1; /* movl this,edx */
-        DWORD this;
-        BYTE  movl2; /* movl func,ecx */
-        DWORD func;
-        WORD  jmp;   /* jmp ecx */
-    } t3;
-    struct
-    {
-        BYTE  movl1; /* movl this,ecx */
-        DWORD this;
-        BYTE  movl2; /* movl func,eax */
-        DWORD func;
-        WORD  jmp;   /* jmp eax */
-    } t4;
-    struct
-    {
-        DWORD inst1; /* pop ecx
-                      * pop eax
-                      * push ecx
-                      * jmp 4(%eax) */
-        WORD  inst2;
-    } t5;
-};
-#include "poppack.h"
-
-/**********************************************************************
- *		check_atl_thunk
- *
- * Check if code destination is an ATL thunk, and emulate it if so.
- */
-static BOOL check_atl_thunk( ucontext_t *sigcontext, EXCEPTION_RECORD *rec, CONTEXT *context )
-{
-    const union atl_thunk *thunk = (const union atl_thunk *)rec->ExceptionInformation[1];
-    union atl_thunk thunk_copy;
-    SIZE_T thunk_len;
-
-    thunk_len = virtual_uninterrupted_read_memory( thunk, &thunk_copy, sizeof(*thunk) );
-    if (!thunk_len) return FALSE;
-
-    if (thunk_len >= sizeof(thunk_copy.t1) && thunk_copy.t1.movl == 0x042444c7 &&
-                                              thunk_copy.t1.jmp == 0xe9)
-    {
-        if (!virtual_uninterrupted_write_memory( (DWORD *)context->Esp + 1,
-                                                 &thunk_copy.t1.this, sizeof(DWORD) ))
-        {
-            EIP_sig(sigcontext) = (DWORD_PTR)(&thunk->t1.func + 1) + thunk_copy.t1.func;
-            TRACE( "emulating ATL thunk type 1 at %p, func=%08x arg=%08x\n",
-                   thunk, EIP_sig(sigcontext), thunk_copy.t1.this );
-            return TRUE;
-        }
-    }
-    else if (thunk_len >= sizeof(thunk_copy.t2) && thunk_copy.t2.movl == 0xb9 &&
-                                                   thunk_copy.t2.jmp == 0xe9)
-    {
-        ECX_sig(sigcontext) = thunk_copy.t2.this;
-        EIP_sig(sigcontext) = (DWORD_PTR)(&thunk->t2.func + 1) + thunk_copy.t2.func;
-        TRACE( "emulating ATL thunk type 2 at %p, func=%08x ecx=%08x\n",
-               thunk, EIP_sig(sigcontext), ECX_sig(sigcontext) );
-        return TRUE;
-    }
-    else if (thunk_len >= sizeof(thunk_copy.t3) && thunk_copy.t3.movl1 == 0xba &&
-                                                   thunk_copy.t3.movl2 == 0xb9 &&
-                                                   thunk_copy.t3.jmp == 0xe1ff)
-    {
-        EDX_sig(sigcontext) = thunk_copy.t3.this;
-        ECX_sig(sigcontext) = thunk_copy.t3.func;
-        EIP_sig(sigcontext) = thunk_copy.t3.func;
-        TRACE( "emulating ATL thunk type 3 at %p, func=%08x ecx=%08x edx=%08x\n",
-               thunk, EIP_sig(sigcontext), ECX_sig(sigcontext), EDX_sig(sigcontext) );
-        return TRUE;
-    }
-    else if (thunk_len >= sizeof(thunk_copy.t4) && thunk_copy.t4.movl1 == 0xb9 &&
-                                                   thunk_copy.t4.movl2 == 0xb8 &&
-                                                   thunk_copy.t4.jmp == 0xe0ff)
-    {
-        ECX_sig(sigcontext) = thunk_copy.t4.this;
-        EAX_sig(sigcontext) = thunk_copy.t4.func;
-        EIP_sig(sigcontext) = thunk_copy.t4.func;
-        TRACE( "emulating ATL thunk type 4 at %p, func=%08x eax=%08x ecx=%08x\n",
-               thunk, EIP_sig(sigcontext), EAX_sig(sigcontext), ECX_sig(sigcontext) );
-        return TRUE;
-    }
-    else if (thunk_len >= sizeof(thunk_copy.t5) && thunk_copy.t5.inst1 == 0xff515859 &&
-                                                   thunk_copy.t5.inst2 == 0x0460)
-    {
-        DWORD func, sp[2];
-        if (virtual_uninterrupted_read_memory( (DWORD *)context->Esp, sp, sizeof(sp) ) == sizeof(sp) &&
-            virtual_uninterrupted_read_memory( (DWORD *)sp[1] + 1, &func, sizeof(DWORD) ) == sizeof(DWORD) &&
-            !virtual_uninterrupted_write_memory( (DWORD *)context->Esp + 1, &sp[0], sizeof(sp[0]) ))
-        {
-            ECX_sig(sigcontext) = sp[0];
-            EAX_sig(sigcontext) = sp[1];
-            ESP_sig(sigcontext) += sizeof(DWORD);
-            EIP_sig(sigcontext) = func;
-            TRACE( "emulating ATL thunk type 5 at %p, func=%08x eax=%08x ecx=%08x esp=%08x\n",
-                   thunk, EIP_sig(sigcontext), EAX_sig(sigcontext),
-                   ECX_sig(sigcontext), ESP_sig(sigcontext) );
-            return TRUE;
-        }
-    }
-
-    return FALSE;
-}
-
-
-/***********************************************************************
- *           setup_exception_record
- *
- * Setup the exception record and context on the thread stack.
- */
-static void *setup_exception_record( ucontext_t *sigcontext, EXCEPTION_RECORD *rec, CONTEXT *context )
-{
-    void *stack = init_handler( sigcontext );
-
-    rec->ExceptionAddress = (void *)EIP_sig( sigcontext );
-    save_context( context, sigcontext );
-    return stack;
-}
-
-
-/***********************************************************************
- *           setup_raise_exception
- *
- * Change context to setup a call to a raise exception function.
- */
-static void setup_raise_exception( ucontext_t *sigcontext, void *stack_ptr,
-                                   EXCEPTION_RECORD *rec, CONTEXT *context )
-{
-    struct
-    {
-        EXCEPTION_RECORD *rec_ptr;       /* first arg for KiUserExceptionDispatcher */
-        CONTEXT          *context_ptr;   /* second arg for KiUserExceptionDispatcher */
-        CONTEXT           context;
-        EXCEPTION_RECORD  rec;
-        DWORD             ebp;
-        DWORD             eip;
-    } *stack;
-
-    NTSTATUS status = send_debug_event( rec, context, TRUE );
-
-    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
-    {
-        restore_context( context, sigcontext );
-        return;
-    }
-
-    /* fix up instruction pointer in context for EXCEPTION_BREAKPOINT */
-    if (rec->ExceptionCode == EXCEPTION_BREAKPOINT) context->Eip--;
-
-    stack = virtual_setup_exception( stack_ptr, sizeof(*stack), rec );
-    stack->rec          = *rec;
-    stack->context      = *context;
-    stack->rec_ptr      = &stack->rec;
-    stack->context_ptr  = &stack->context;
-    ESP_sig(sigcontext) = (DWORD)stack;
-    EIP_sig(sigcontext) = (DWORD)pKiUserExceptionDispatcher;
-    /* clear single-step, direction, and align check flag */
-    EFL_sig(sigcontext) &= ~(0x100|0x400|0x40000);
-    CS_sig(sigcontext)  = get_cs();
-    DS_sig(sigcontext)  = get_ds();
-    ES_sig(sigcontext)  = get_ds();
-    FS_sig(sigcontext)  = get_fs();
-    GS_sig(sigcontext)  = get_gs();
-    SS_sig(sigcontext)  = get_ds();
-}
-
-
-/***********************************************************************
- *           setup_exception
- *
- * Do the full setup to raise an exception from an exception record.
- */
-static void setup_exception( ucontext_t *sigcontext, EXCEPTION_RECORD *rec )
-{
-    CONTEXT context;
-    void *stack = setup_exception_record( sigcontext, rec, &context );
-    setup_raise_exception( sigcontext, stack, rec, &context );
-}
-
-
-/***********************************************************************
- *           call_user_apc
- */
-void WINAPI call_user_apc( CONTEXT *context_ptr, ULONG_PTR ctx, ULONG_PTR arg1,
-                           ULONG_PTR arg2, PNTAPCFUNC func )
-{
-    CONTEXT context;
-
-    if (!context_ptr)
-    {
-        context.ContextFlags = CONTEXT_FULL;
-        NtGetContextThread( GetCurrentThread(), &context );
-        context.Eax = STATUS_USER_APC;
-        context_ptr = &context;
-    }
-    pKiUserApcDispatcher( context_ptr, ctx, arg1, arg2, func );
-}
-
-
-/***********************************************************************
- *           call_raise_user_exception_dispatcher
- */
-__ASM_GLOBAL_FUNC( call_raise_user_exception_dispatcher,
-                   "movl %fs:0x1f8,%eax\n\t"  /* x86_thread_data()->syscall_frame */
-                   "pushl (%eax)\n\t"         /* frame->prev_frame */
-                   "popl %fs:0x1f8\n\t"
-                   "movl 4(%eax),%edi\n\t"    /* frame->edi */
-                   "movl 8(%eax),%esi\n\t"    /* frame->esi */
-                   "movl 12(%eax),%ebx\n\t"   /* frame->ebx */
-                   "movl 16(%eax),%ebp\n\t"   /* frame->ebp */
-                   "movl 4(%esp),%edx\n\t"    /* dispatcher */
-                   "leal 24(%eax),%esp\n\t"
-                   "jmp *%edx" )
-
-
-/***********************************************************************
- *           call_user_exception_dispatcher
- */
-__ASM_GLOBAL_FUNC( call_user_exception_dispatcher,
-                   "movl 4(%esp),%edx\n\t"        /* rec */
-                   "movl 8(%esp),%ecx\n\t"        /* context */
-                   "cmpl $0x80000003,(%edx)\n\t"  /* rec->ExceptionCode */
-                   "jne 1f\n\t"
-                   "decl 0xb8(%ecx)\n"            /* context->Eip */
-                   "1:\tmovl %fs:0x1f8,%eax\n\t"  /* x86_thread_data()->syscall_frame */
-                   "pushl (%eax)\n\t"             /* frame->prev_frame */
-                   "popl %fs:0x1f8\n\t"
-                   "movl 4(%eax),%edi\n\t"        /* frame->edi */
-                   "movl 8(%eax),%esi\n\t"        /* frame->esi */
-                   "movl 12(%eax),%ebx\n\t"       /* frame->ebx */
-                   "movl 16(%eax),%ebp\n\t"       /* frame->ebp */
-                   "movl %edx,16(%eax)\n\t"
-                   "movl %ecx,20(%eax)\n\t"
-                   "movl 12(%esp),%edx\n\t"       /* dispatcher */
-                   "leal 16(%eax),%esp\n\t"
-                   "jmp *%edx" )
-
-/**********************************************************************
- *		get_fpu_code
- *
- * Get the FPU exception code from the FPU status.
- */
-static inline DWORD get_fpu_code( const CONTEXT *context )
-{
-    DWORD status = context->FloatSave.StatusWord & ~(context->FloatSave.ControlWord & 0x3f);
-
-    if (status & 0x01)  /* IE */
-    {
-        if (status & 0x40)  /* SF */
-            return EXCEPTION_FLT_STACK_CHECK;
-        else
-            return EXCEPTION_FLT_INVALID_OPERATION;
-    }
-    if (status & 0x02) return EXCEPTION_FLT_DENORMAL_OPERAND;  /* DE flag */
-    if (status & 0x04) return EXCEPTION_FLT_DIVIDE_BY_ZERO;    /* ZE flag */
-    if (status & 0x08) return EXCEPTION_FLT_OVERFLOW;          /* OE flag */
-    if (status & 0x10) return EXCEPTION_FLT_UNDERFLOW;         /* UE flag */
-    if (status & 0x20) return EXCEPTION_FLT_INEXACT_RESULT;    /* PE flag */
-    return EXCEPTION_FLT_INVALID_OPERATION;  /* generic error */
-}
-
-
-/***********************************************************************
- *           handle_interrupt
- *
- * Handle an interrupt.
- */
-static BOOL handle_interrupt( unsigned int interrupt, ucontext_t *sigcontext, void *stack,
-                              EXCEPTION_RECORD *rec, CONTEXT *context )
-{
-    switch(interrupt)
-    {
-    case 0x2d:
-        if (!is_wow64)
-        {
-            /* On Wow64, the upper DWORD of Rax contains garbage, and the debug
-             * service is usually not recognized when called from usermode. */
-            switch (context->Eax)
-            {
-                case 1: /* BREAKPOINT_PRINT */
-                case 3: /* BREAKPOINT_LOAD_SYMBOLS */
-                case 4: /* BREAKPOINT_UNLOAD_SYMBOLS */
-                case 5: /* BREAKPOINT_COMMAND_STRING (>= Win2003) */
-                    EIP_sig(sigcontext) += 3;
-                    return TRUE;
-            }
-        }
-        context->Eip += 3;
-        rec->ExceptionCode = EXCEPTION_BREAKPOINT;
-        rec->ExceptionAddress = (void *)context->Eip;
-        rec->NumberParameters = is_wow64 ? 1 : 3;
-        rec->ExceptionInformation[0] = context->Eax;
-        rec->ExceptionInformation[1] = context->Ecx;
-        rec->ExceptionInformation[2] = context->Edx;
-        setup_raise_exception( sigcontext, stack, rec, context );
-        return TRUE;
-    default:
-        return FALSE;
-    }
-}
-
-
-/**********************************************************************
- *		segv_handler
- *
- * Handler for SIGSEGV and related errors.
- */
-static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-    CONTEXT context;
-    ucontext_t *ucontext = sigcontext;
-    void *stack = setup_exception_record( sigcontext, &rec, &context );
-
-    switch (TRAP_sig(ucontext))
-    {
-    case TRAP_x86_OFLOW:   /* Overflow exception */
-        rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
-        break;
-    case TRAP_x86_BOUND:   /* Bound range exception */
-        rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
-        break;
-    case TRAP_x86_PRIVINFLT:   /* Invalid opcode exception */
-        rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
-        break;
-    case TRAP_x86_STKFLT:  /* Stack fault */
-        rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
-        break;
-    case TRAP_x86_SEGNPFLT:  /* Segment not present exception */
-    case TRAP_x86_PROTFLT:   /* General protection fault */
-        {
-            WORD err = ERROR_sig(ucontext);
-            if (!err && (rec.ExceptionCode = is_privileged_instr( &context ))) break;
-            if ((err & 7) == 2 && handle_interrupt( err >> 3, ucontext, stack, &rec, &context )) return;
-            rec.ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
-            rec.NumberParameters = 2;
-            rec.ExceptionInformation[0] = 0;
-            /* if error contains a LDT selector, use that as fault address */
-            if ((err & 7) == 4 && !ldt_is_system( err | 7 )) rec.ExceptionInformation[1] = err & ~7;
-            else
-            {
-                rec.ExceptionInformation[1] = 0xffffffff;
-                if (check_invalid_gs( ucontext, &context )) return;
-            }
-        }
-        break;
-    case TRAP_x86_PAGEFLT:  /* Page fault */
-        rec.NumberParameters = 2;
-        rec.ExceptionInformation[0] = (ERROR_sig(ucontext) >> 1) & 0x09;
-        rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
-        rec.ExceptionCode = virtual_handle_fault( siginfo->si_addr, rec.ExceptionInformation[0], stack );
-        if (!rec.ExceptionCode) return;
-        if (rec.ExceptionCode == EXCEPTION_ACCESS_VIOLATION &&
-            rec.ExceptionInformation[0] == EXCEPTION_EXECUTE_FAULT)
-        {
-            ULONG flags;
-            NtQueryInformationProcess( GetCurrentProcess(), ProcessExecuteFlags,
-                                       &flags, sizeof(flags), NULL );
-            if (!(flags & MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION) &&
-                check_atl_thunk( ucontext, &rec, &context ))
-                return;
-
-            /* send EXCEPTION_EXECUTE_FAULT only if data execution prevention is enabled */
-            if (!(flags & MEM_EXECUTE_OPTION_DISABLE)) rec.ExceptionInformation[0] = EXCEPTION_READ_FAULT;
-        }
-        break;
-    case TRAP_x86_ALIGNFLT:  /* Alignment check exception */
-        /* FIXME: pass through exception handler first? */
-        if (context.EFlags & 0x00040000)
-        {
-            EFL_sig(ucontext) &= ~0x00040000;  /* disable AC flag */
-            return;
-        }
-        rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
-        break;
-    default:
-        WINE_ERR( "Got unexpected trap %d\n", TRAP_sig(ucontext) );
-        /* fall through */
-    case TRAP_x86_NMI:       /* NMI interrupt */
-    case TRAP_x86_DNA:       /* Device not available exception */
-    case TRAP_x86_DOUBLEFLT: /* Double fault exception */
-    case TRAP_x86_TSSFLT:    /* Invalid TSS exception */
-    case TRAP_x86_MCHK:      /* Machine check exception */
-    case TRAP_x86_CACHEFLT:  /* Cache flush exception */
-        rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
-        break;
-    }
-    setup_raise_exception( ucontext, stack, &rec, &context );
-}
-
-
-/**********************************************************************
- *		trap_handler
- *
- * Handler for SIGTRAP.
- */
-static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-    CONTEXT context;
-    ucontext_t *ucontext = sigcontext;
-    void *stack = setup_exception_record( sigcontext, &rec, &context );
-
-    switch (TRAP_sig(ucontext))
-    {
-    case TRAP_x86_TRCTRAP:  /* Single-step exception */
-        rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
-        /* when single stepping can't tell whether this is a hw bp or a
-         * single step interrupt. try to avoid as much overhead as possible
-         * and only do a server call if there is any hw bp enabled. */
-        if (!(context.EFlags & 0x100) || (context.Dr7 & 0xff))
-        {
-            /* (possible) hardware breakpoint, fetch the debug registers */
-            DWORD saved_flags = context.ContextFlags;
-            context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
-            NtGetContextThread( GetCurrentThread(), &context );
-            context.ContextFlags |= saved_flags;  /* restore flags */
-        }
-        context.EFlags &= ~0x100;  /* clear single-step flag */
-        break;
-    case TRAP_x86_BPTFLT:   /* Breakpoint exception */
-        rec.ExceptionAddress = (char *)rec.ExceptionAddress - 1;  /* back up over the int3 instruction */
-        /* fall through */
-    default:
-        rec.ExceptionCode = EXCEPTION_BREAKPOINT;
-        rec.NumberParameters = is_wow64 ? 1 : 3;
-        rec.ExceptionInformation[0] = 0;
-        rec.ExceptionInformation[1] = 0; /* FIXME */
-        rec.ExceptionInformation[2] = 0; /* FIXME */
-        break;
-    }
-    setup_raise_exception( sigcontext, stack, &rec, &context );
-}
-
-
-/**********************************************************************
- *		fpe_handler
- *
- * Handler for SIGFPE.
- */
-static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-    CONTEXT context;
-    ucontext_t *ucontext = sigcontext;
-    void *stack = setup_exception_record( sigcontext, &rec, &context );
-
-    switch (TRAP_sig(ucontext))
-    {
-    case TRAP_x86_DIVIDE:   /* Division by zero exception */
-        rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
-        break;
-    case TRAP_x86_FPOPFLT:   /* Coprocessor segment overrun */
-        rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
-        break;
-    case TRAP_x86_ARITHTRAP:  /* Floating point exception */
-        rec.ExceptionCode = get_fpu_code( &context );
-        rec.ExceptionAddress = (void *)context.FloatSave.ErrorOffset;
-        break;
-    case TRAP_x86_CACHEFLT:  /* SIMD exception */
-        /* TODO:
-         * Behaviour only tested for divide-by-zero exceptions
-         * Check for other SIMD exceptions as well */
-        if(siginfo->si_code != FPE_FLTDIV && siginfo->si_code != FPE_FLTINV)
-            FIXME("untested SIMD exception: %#x. Might not work correctly\n",
-                  siginfo->si_code);
-
-        rec.ExceptionCode = STATUS_FLOAT_MULTIPLE_TRAPS;
-        rec.NumberParameters = 1;
-        /* no idea what meaning is actually behind this but that's what native does */
-        rec.ExceptionInformation[0] = 0;
-        break;
-    default:
-        WINE_ERR( "Got unexpected trap %d\n", TRAP_sig(ucontext) );
-        rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
-        break;
-    }
-    setup_raise_exception( sigcontext, stack, &rec, &context );
-}
-
-
-/**********************************************************************
- *		int_handler
- *
- * Handler for SIGINT.
- */
-static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { CONTROL_C_EXIT };
-
-    setup_exception( sigcontext, &rec );
-}
-
-/**********************************************************************
- *		abrt_handler
- *
- * Handler for SIGABRT.
- */
-static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { EXCEPTION_WINE_ASSERTION, EH_NONCONTINUABLE };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		quit_handler
- *
- * Handler for SIGQUIT.
- */
-static void quit_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    init_handler( sigcontext );
-    abort_thread(0);
-}
-
-
-/**********************************************************************
- *		usr1_handler
- *
- * Handler for SIGUSR1, used to signal a thread that it got suspended.
- */
-static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    CONTEXT context;
-
-    init_handler( sigcontext );
-    save_context( &context, sigcontext );
-    wait_suspend( &context );
-    restore_context( &context, sigcontext );
-}
-
-
-/***********************************************************************
- *           LDT support
- */
-
-#define LDT_SIZE 8192
-
-#define LDT_FLAGS_DATA      0x13  /* Data segment */
-#define LDT_FLAGS_CODE      0x1b  /* Code segment */
-#define LDT_FLAGS_32BIT     0x40  /* Segment is 32-bit (code or stack) */
-#define LDT_FLAGS_ALLOCATED 0x80  /* Segment is allocated */
-
-struct ldt_copy
-{
-    void         *base[LDT_SIZE];
-    unsigned int  limit[LDT_SIZE];
-    unsigned char flags[LDT_SIZE];
-} __wine_ldt_copy;
-
-static WORD gdt_fs_sel;
-static pthread_mutex_t ldt_mutex = PTHREAD_MUTEX_INITIALIZER;
-static const LDT_ENTRY null_entry;
-
-static inline void *ldt_get_base( LDT_ENTRY ent )
-{
-    return (void *)(ent.BaseLow |
-                    (ULONG_PTR)ent.HighWord.Bits.BaseMid << 16 |
-                    (ULONG_PTR)ent.HighWord.Bits.BaseHi << 24);
-}
-
-static inline unsigned int ldt_get_limit( LDT_ENTRY ent )
-{
-    unsigned int limit = ent.LimitLow | (ent.HighWord.Bits.LimitHi << 16);
-    if (ent.HighWord.Bits.Granularity) limit = (limit << 12) | 0xfff;
-    return limit;
-}
-
-static LDT_ENTRY ldt_make_entry( void *base, unsigned int limit, unsigned char flags )
-{
-    LDT_ENTRY entry;
-
-    entry.BaseLow                   = (WORD)(ULONG_PTR)base;
-    entry.HighWord.Bits.BaseMid     = (BYTE)((ULONG_PTR)base >> 16);
-    entry.HighWord.Bits.BaseHi      = (BYTE)((ULONG_PTR)base >> 24);
-    if ((entry.HighWord.Bits.Granularity = (limit >= 0x100000))) limit >>= 12;
-    entry.LimitLow                  = (WORD)limit;
-    entry.HighWord.Bits.LimitHi     = limit >> 16;
-    entry.HighWord.Bits.Dpl         = 3;
-    entry.HighWord.Bits.Pres        = 1;
-    entry.HighWord.Bits.Type        = flags;
-    entry.HighWord.Bits.Sys         = 0;
-    entry.HighWord.Bits.Reserved_0  = 0;
-    entry.HighWord.Bits.Default_Big = (flags & LDT_FLAGS_32BIT) != 0;
-    return entry;
-}
-
-static void ldt_set_entry( WORD sel, LDT_ENTRY entry )
-{
-    int index = sel >> 3;
-
-#ifdef linux
-    struct modify_ldt_s ldt_info = { index };
-
-    ldt_info.base_addr       = ldt_get_base( entry );
-    ldt_info.limit           = entry.LimitLow | (entry.HighWord.Bits.LimitHi << 16);
-    ldt_info.seg_32bit       = entry.HighWord.Bits.Default_Big;
-    ldt_info.contents        = (entry.HighWord.Bits.Type >> 2) & 3;
-    ldt_info.read_exec_only  = !(entry.HighWord.Bits.Type & 2);
-    ldt_info.limit_in_pages  = entry.HighWord.Bits.Granularity;
-    ldt_info.seg_not_present = !entry.HighWord.Bits.Pres;
-    ldt_info.usable          = entry.HighWord.Bits.Sys;
-    if (modify_ldt( 0x11, &ldt_info, sizeof(ldt_info) ) < 0) perror( "modify_ldt" );
-#elif defined(__NetBSD__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__)
-    /* The kernel will only let us set LDTs with user priority level */
-    if (entry.HighWord.Bits.Pres && entry.HighWord.Bits.Dpl != 3) entry.HighWord.Bits.Dpl = 3;
-    if (i386_set_ldt(index, (union descriptor *)&entry, 1) < 0)
-    {
-        perror("i386_set_ldt");
-        fprintf( stderr, "Did you reconfigure the kernel with \"options USER_LDT\"?\n" );
-        exit(1);
-    }
-#elif defined(__svr4__) || defined(_SCO_DS)
-    struct ssd ldt_mod;
-
-    ldt_mod.sel  = sel;
-    ldt_mod.bo   = (unsigned long)ldt_get_base( entry );
-    ldt_mod.ls   = entry.LimitLow | (entry.HighWord.Bits.LimitHi << 16);
-    ldt_mod.acc1 = entry.HighWord.Bytes.Flags1;
-    ldt_mod.acc2 = entry.HighWord.Bytes.Flags2 >> 4;
-    if (sysi86(SI86DSCR, &ldt_mod) == -1) perror("sysi86");
-#elif defined(__APPLE__)
-    if (i386_set_ldt(index, (union ldt_entry *)&entry, 1) < 0) perror("i386_set_ldt");
-#elif defined(__GNU__)
-    if (i386_set_ldt(mach_thread_self(), sel, (descriptor_list_t)&entry, 1) != KERN_SUCCESS)
-        perror("i386_set_ldt");
-#else
-    fprintf( stderr, "No LDT support on this platform\n" );
-    exit(1);
-#endif
-
-    __wine_ldt_copy.base[index]  = ldt_get_base( entry );
-    __wine_ldt_copy.limit[index] = ldt_get_limit( entry );
-    __wine_ldt_copy.flags[index] = (entry.HighWord.Bits.Type |
-                                    (entry.HighWord.Bits.Default_Big ? LDT_FLAGS_32BIT : 0) |
-                                    LDT_FLAGS_ALLOCATED);
-}
-
-static void ldt_set_fs( WORD sel, TEB *teb )
-{
-    if (sel == gdt_fs_sel)
-    {
-#ifdef __linux__
-        struct modify_ldt_s ldt_info = { sel >> 3 };
-
-        ldt_info.base_addr = teb;
-        ldt_info.limit     = page_size - 1;
-        ldt_info.seg_32bit = 1;
-        if (set_thread_area( &ldt_info ) < 0) perror( "set_thread_area" );
-#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__) || defined(__DragonFly__)
-        i386_set_fsbase( teb );
-#endif
-    }
-    set_fs( sel );
-}
-
-
-/**********************************************************************
- *           get_thread_ldt_entry
- */
-NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
-{
-    THREAD_DESCRIPTOR_INFORMATION *info = data;
-    NTSTATUS status = STATUS_SUCCESS;
-
-    if (len < sizeof(*info)) return STATUS_INFO_LENGTH_MISMATCH;
-    if (info->Selector >> 16) return STATUS_UNSUCCESSFUL;
-
-    if (is_gdt_sel( info->Selector ))
-    {
-        if (!(info->Selector & ~3))
-            info->Entry = null_entry;
-        else if ((info->Selector | 3) == get_cs())
-            info->Entry = ldt_make_entry( 0, ~0u, LDT_FLAGS_CODE | LDT_FLAGS_32BIT );
-        else if ((info->Selector | 3) == get_ds())
-            info->Entry = ldt_make_entry( 0, ~0u, LDT_FLAGS_DATA | LDT_FLAGS_32BIT );
-        else if ((info->Selector | 3) == get_fs())
-            info->Entry = ldt_make_entry( NtCurrentTeb(), 0xfff, LDT_FLAGS_DATA | LDT_FLAGS_32BIT );
-        else
-            return STATUS_UNSUCCESSFUL;
-    }
-    else
-    {
-        SERVER_START_REQ( get_selector_entry )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->entry = info->Selector >> 3;
-            status = wine_server_call( req );
-            if (!status)
-            {
-                if (reply->flags)
-                    info->Entry = ldt_make_entry( (void *)reply->base, reply->limit, reply->flags );
-                else
-                    status = STATUS_UNSUCCESSFUL;
-            }
-        }
-        SERVER_END_REQ;
-    }
-    if (status == STATUS_SUCCESS && ret_len)
-        /* yes, that's a bit strange, but it's the way it is */
-        *ret_len = sizeof(info->Entry);
-
-    return status;
-}
-
-
-/******************************************************************************
- *           NtSetLdtEntries   (NTDLL.@)
- *           ZwSetLdtEntries   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
-{
-    sigset_t sigset;
-
-    if (sel1 >> 16 || sel2 >> 16) return STATUS_INVALID_LDT_DESCRIPTOR;
-    if (sel1 && (sel1 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
-    if (sel2 && (sel2 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
-
-    server_enter_uninterrupted_section( &ldt_mutex, &sigset );
-    if (sel1) ldt_set_entry( sel1, entry1 );
-    if (sel2) ldt_set_entry( sel2, entry2 );
-    server_leave_uninterrupted_section( &ldt_mutex, &sigset );
-   return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *             signal_init_threading
- */
-void signal_init_threading(void)
-{
-#ifdef __linux__
-    /* the preloader may have allocated it already */
-    gdt_fs_sel = get_fs();
-    if (!gdt_fs_sel || !is_gdt_sel( gdt_fs_sel ))
-    {
-        struct modify_ldt_s ldt_info = { -1 };
-
-        ldt_info.seg_32bit = 1;
-        ldt_info.usable = 1;
-        if (set_thread_area( &ldt_info ) >= 0) gdt_fs_sel = (ldt_info.entry_number << 3) | 3;
-        else gdt_fs_sel = 0;
-    }
-#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__)
-    gdt_fs_sel = GSEL( GUFS_SEL, SEL_UPL );
-#endif
-}
-
-
-/**********************************************************************
- *		signal_alloc_thread
- */
-NTSTATUS signal_alloc_thread( TEB *teb )
-{
-    struct x86_thread_data *thread_data = (struct x86_thread_data *)&teb->GdiTebBatch;
-
-    if (!gdt_fs_sel)
-    {
-        static int first_thread = 1;
-        sigset_t sigset;
-        int idx;
-        LDT_ENTRY entry = ldt_make_entry( teb, page_size - 1, LDT_FLAGS_DATA | LDT_FLAGS_32BIT );
-
-        if (first_thread)  /* no locking for first thread */
-        {
-            /* leave some space if libc is using the LDT for %gs */
-            if (!is_gdt_sel( get_gs() )) first_ldt_entry = 512;
-            idx = first_ldt_entry;
-            ldt_set_entry( (idx << 3) | 7, entry );
-            first_thread = 0;
-        }
-        else
-        {
-            server_enter_uninterrupted_section( &ldt_mutex, &sigset );
-            for (idx = first_ldt_entry; idx < LDT_SIZE; idx++)
-            {
-                if (__wine_ldt_copy.flags[idx]) continue;
-                ldt_set_entry( (idx << 3) | 7, entry );
-                break;
-            }
-            server_leave_uninterrupted_section( &ldt_mutex, &sigset );
-            if (idx == LDT_SIZE) return STATUS_TOO_MANY_THREADS;
-        }
-        thread_data->fs = (idx << 3) | 7;
-    }
-    else thread_data->fs = gdt_fs_sel;
-
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *		signal_free_thread
- */
-void signal_free_thread( TEB *teb )
-{
-    struct x86_thread_data *thread_data = (struct x86_thread_data *)&teb->GdiTebBatch;
-    sigset_t sigset;
-
-    if (gdt_fs_sel) return;
-
-    server_enter_uninterrupted_section( &ldt_mutex, &sigset );
-    __wine_ldt_copy.flags[thread_data->fs >> 3] = 0;
-    server_leave_uninterrupted_section( &ldt_mutex, &sigset );
-}
-
-
-/**********************************************************************
- *		signal_init_thread
- */
-void signal_init_thread( TEB *teb )
-{
-    const WORD fpu_cw = 0x27f;
-    struct x86_thread_data *thread_data = (struct x86_thread_data *)&teb->GdiTebBatch;
-
-    ldt_set_fs( thread_data->fs, teb );
-    thread_data->gs = get_gs();
-
-    __asm__ volatile ("fninit; fldcw %0" : : "m" (fpu_cw));
-}
-
-
-/**********************************************************************
- *		signal_init_process
- */
-void signal_init_process(void)
-{
-    struct sigaction sig_act;
-
-    sig_act.sa_mask = server_block_set;
-    sig_act.sa_flags = SA_SIGINFO | SA_RESTART | SA_ONSTACK;
-#ifdef __ANDROID__
-    sig_act.sa_flags |= SA_RESTORER;
-    sig_act.sa_restorer = rt_sigreturn;
-#endif
-    sig_act.sa_sigaction = int_handler;
-    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = fpe_handler;
-    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = abrt_handler;
-    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = quit_handler;
-    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = trap_handler;
-    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = segv_handler;
-    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
-    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
-    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
-    return;
-
- error:
-    perror("sigaction");
-    exit(1);
-}
-
-
-/***********************************************************************
- *           init_thread_context
- */
-static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
-{
-    context->SegCs  = get_cs();
-    context->SegDs  = get_ds();
-    context->SegEs  = get_ds();
-    context->SegFs  = get_fs();
-    context->SegGs  = get_gs();
-    context->SegSs  = get_ds();
-    context->EFlags = 0x202;
-    context->Eax    = (DWORD)entry;
-    context->Ebx    = (DWORD)arg;
-    context->Esp    = (DWORD)NtCurrentTeb()->Tib.StackBase - 16;
-    context->Eip    = (DWORD)relay;
-    context->FloatSave.ControlWord = 0x27f;
-    ((XMM_SAVE_AREA32 *)context->ExtendedRegisters)->ControlWord = 0x27f;
-    ((XMM_SAVE_AREA32 *)context->ExtendedRegisters)->MxCsr = 0x1f80;
-}
-
-
-/***********************************************************************
- *           attach_thread
- */
-PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
-                                        BOOL suspend, void *relay )
-{
-    CONTEXT *ctx;
-
-    if (suspend)
-    {
-        CONTEXT context = { CONTEXT_ALL };
-
-        init_thread_context( &context, entry, arg, relay );
-        wait_suspend( &context );
-        ctx = (CONTEXT *)((ULONG_PTR)context.Esp & ~15) - 1;
-        *ctx = context;
-    }
-    else
-    {
-        ctx = (CONTEXT *)((char *)NtCurrentTeb()->Tib.StackBase - 16) - 1;
-        init_thread_context( ctx, entry, arg, relay );
-    }
-    pthread_sigmask( SIG_UNBLOCK, &server_block_set, NULL );
-    ctx->ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;
-    pLdrInitializeThunk( ctx, (void **)&ctx->Eax, 0, 0 );
-    return ctx;
-}
-
-
-/***********************************************************************
- *           signal_start_thread
- */
-__ASM_GLOBAL_FUNC( signal_start_thread,
-                   "pushl %ebp\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
-                   __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
-                   "movl %esp,%ebp\n\t"
-                   __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
-                   "pushl %ebx\n\t"
-                   __ASM_CFI(".cfi_rel_offset %ebx,-4\n\t")
-                   "pushl %esi\n\t"
-                   __ASM_CFI(".cfi_rel_offset %esi,-8\n\t")
-                   "pushl %edi\n\t"
-                   __ASM_CFI(".cfi_rel_offset %edi,-12\n\t")
-                   /* store exit frame */
-                   "movl %ebp,%fs:0x1f4\n\t"    /* x86_thread_data()->exit_frame */
-                   /* switch to thread stack */
-                   "movl %fs:4,%eax\n\t"        /* NtCurrentTeb()->StackBase */
-                   "leal -0x1000(%eax),%esp\n\t"
-                   /* attach dlls */
-                   "pushl 20(%ebp)\n\t"         /* relay */
-                   "pushl 16(%ebp)\n\t"         /* suspend */
-                   "pushl 12(%ebp)\n\t"         /* arg */
-                   "pushl 8(%ebp)\n\t"          /* entry */
-                   "xorl %ebp,%ebp\n\t"
-                   "call " __ASM_NAME("attach_thread") "\n\t"
-                   "movl %eax,%esi\n\t"
-                   "leal -12(%eax),%esp\n\t"
-                   /* clear the stack */
-                   "andl $~0xfff,%eax\n\t"  /* round down to page size */
-                   "movl %eax,(%esp)\n\t"
-                   "call " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
-                   /* switch to the initial context */
-                   "movl $1,4(%esp)\n\t"
-                   "movl %esi,(%esp)\n\t"
-                   "call " __ASM_NAME("NtContinue") )
-
-
-/***********************************************************************
- *           signal_exit_thread
- */
-__ASM_GLOBAL_FUNC( signal_exit_thread,
-                   "movl 8(%esp),%ecx\n\t"
-                   /* fetch exit frame */
-                   "movl %fs:0x1f4,%edx\n\t"    /* x86_thread_data()->exit_frame */
-                   "testl %edx,%edx\n\t"
-                   "jnz 1f\n\t"
-                   "jmp *%ecx\n\t"
-                   /* switch to exit frame stack */
-                   "1:\tmovl 4(%esp),%eax\n\t"
-                   "movl $0,%fs:0x1f4\n\t"
-                   "movl %edx,%ebp\n\t"
-                   __ASM_CFI(".cfi_def_cfa %ebp,4\n\t")
-                   __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
-                   __ASM_CFI(".cfi_rel_offset %ebx,-4\n\t")
-                   __ASM_CFI(".cfi_rel_offset %esi,-8\n\t")
-                   __ASM_CFI(".cfi_rel_offset %edi,-12\n\t")
-                   "leal -20(%ebp),%esp\n\t"
-                   "pushl %eax\n\t"
-                   "call *%ecx" )
-
-/**********************************************************************
- *           NtCurrentTeb   (NTDLL.@)
- */
-__ASM_STDCALL_FUNC( NtCurrentTeb, 0, ".byte 0x64\n\tmovl 0x18,%eax\n\tret" )
-
-#endif  /* __i386__ */
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
deleted file mode 100644
index a1918908fc..0000000000
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ /dev/null
@@ -1,2577 +0,0 @@
-/*
- * x86-64 signal handling routines
- *
- * Copyright 1999, 2005 Alexandre Julliard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#ifdef __x86_64__
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef HAVE_MACHINE_SYSARCH_H
-# include <machine/sysarch.h>
-#endif
-#ifdef HAVE_SYS_PARAM_H
-# include <sys/param.h>
-#endif
-#ifdef HAVE_SYSCALL_H
-# include <syscall.h>
-#else
-# ifdef HAVE_SYS_SYSCALL_H
-#  include <sys/syscall.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SIGNAL_H
-# include <sys/signal.h>
-#endif
-#ifdef HAVE_SYS_UCONTEXT_H
-# include <sys/ucontext.h>
-#endif
-#ifdef HAVE_LIBUNWIND
-# define UNW_LOCAL_ONLY
-# include <libunwind.h>
-#endif
-#ifdef __APPLE__
-# include <mach/mach.h>
-#endif
-
-#define NONAMELESSUNION
-#define NONAMELESSSTRUCT
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winternl.h"
-#include "wine/exception.h"
-#include "wine/list.h"
-#include "wine/asm.h"
-#include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(seh);
-
-/***********************************************************************
- * signal context platform-specific definitions
- */
-#ifdef linux
-
-#include <asm/prctl.h>
-static inline int arch_prctl( int func, void *ptr ) { return syscall( __NR_arch_prctl, func, ptr ); }
-
-#define RAX_sig(context)     ((context)->uc_mcontext.gregs[REG_RAX])
-#define RBX_sig(context)     ((context)->uc_mcontext.gregs[REG_RBX])
-#define RCX_sig(context)     ((context)->uc_mcontext.gregs[REG_RCX])
-#define RDX_sig(context)     ((context)->uc_mcontext.gregs[REG_RDX])
-#define RSI_sig(context)     ((context)->uc_mcontext.gregs[REG_RSI])
-#define RDI_sig(context)     ((context)->uc_mcontext.gregs[REG_RDI])
-#define RBP_sig(context)     ((context)->uc_mcontext.gregs[REG_RBP])
-#define R8_sig(context)      ((context)->uc_mcontext.gregs[REG_R8])
-#define R9_sig(context)      ((context)->uc_mcontext.gregs[REG_R9])
-#define R10_sig(context)     ((context)->uc_mcontext.gregs[REG_R10])
-#define R11_sig(context)     ((context)->uc_mcontext.gregs[REG_R11])
-#define R12_sig(context)     ((context)->uc_mcontext.gregs[REG_R12])
-#define R13_sig(context)     ((context)->uc_mcontext.gregs[REG_R13])
-#define R14_sig(context)     ((context)->uc_mcontext.gregs[REG_R14])
-#define R15_sig(context)     ((context)->uc_mcontext.gregs[REG_R15])
-#define CS_sig(context)      (*((WORD *)&(context)->uc_mcontext.gregs[REG_CSGSFS] + 0))
-#define GS_sig(context)      (*((WORD *)&(context)->uc_mcontext.gregs[REG_CSGSFS] + 1))
-#define FS_sig(context)      (*((WORD *)&(context)->uc_mcontext.gregs[REG_CSGSFS] + 2))
-#define RSP_sig(context)     ((context)->uc_mcontext.gregs[REG_RSP])
-#define RIP_sig(context)     ((context)->uc_mcontext.gregs[REG_RIP])
-#define EFL_sig(context)     ((context)->uc_mcontext.gregs[REG_EFL])
-#define TRAP_sig(context)    ((context)->uc_mcontext.gregs[REG_TRAPNO])
-#define ERROR_sig(context)   ((context)->uc_mcontext.gregs[REG_ERR])
-#define FPU_sig(context)     ((XMM_SAVE_AREA32 *)((context)->uc_mcontext.fpregs))
-
-#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__)
-
-#define RAX_sig(context)     ((context)->uc_mcontext.mc_rax)
-#define RBX_sig(context)     ((context)->uc_mcontext.mc_rbx)
-#define RCX_sig(context)     ((context)->uc_mcontext.mc_rcx)
-#define RDX_sig(context)     ((context)->uc_mcontext.mc_rdx)
-#define RSI_sig(context)     ((context)->uc_mcontext.mc_rsi)
-#define RDI_sig(context)     ((context)->uc_mcontext.mc_rdi)
-#define RBP_sig(context)     ((context)->uc_mcontext.mc_rbp)
-#define R8_sig(context)      ((context)->uc_mcontext.mc_r8)
-#define R9_sig(context)      ((context)->uc_mcontext.mc_r9)
-#define R10_sig(context)     ((context)->uc_mcontext.mc_r10)
-#define R11_sig(context)     ((context)->uc_mcontext.mc_r11)
-#define R12_sig(context)     ((context)->uc_mcontext.mc_r12)
-#define R13_sig(context)     ((context)->uc_mcontext.mc_r13)
-#define R14_sig(context)     ((context)->uc_mcontext.mc_r14)
-#define R15_sig(context)     ((context)->uc_mcontext.mc_r15)
-#define CS_sig(context)      ((context)->uc_mcontext.mc_cs)
-#define DS_sig(context)      ((context)->uc_mcontext.mc_ds)
-#define ES_sig(context)      ((context)->uc_mcontext.mc_es)
-#define FS_sig(context)      ((context)->uc_mcontext.mc_fs)
-#define GS_sig(context)      ((context)->uc_mcontext.mc_gs)
-#define SS_sig(context)      ((context)->uc_mcontext.mc_ss)
-#define EFL_sig(context)     ((context)->uc_mcontext.mc_rflags)
-#define RIP_sig(context)     ((context)->uc_mcontext.mc_rip)
-#define RSP_sig(context)     ((context)->uc_mcontext.mc_rsp)
-#define TRAP_sig(context)    ((context)->uc_mcontext.mc_trapno)
-#define ERROR_sig(context)   ((context)->uc_mcontext.mc_err)
-#define FPU_sig(context)     ((XMM_SAVE_AREA32 *)((context)->uc_mcontext.mc_fpstate))
-
-#elif defined(__NetBSD__)
-
-#define RAX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RAX])
-#define RBX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RBX])
-#define RCX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RCX])
-#define RDX_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RDX])
-#define RSI_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RSI])
-#define RDI_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RDI])
-#define RBP_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RBP])
-#define R8_sig(context)     ((context)->uc_mcontext.__gregs[_REG_R8])
-#define R9_sig(context)     ((context)->uc_mcontext.__gregs[_REG_R9])
-#define R10_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R10])
-#define R11_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R11])
-#define R12_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R12])
-#define R13_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R13])
-#define R14_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R14])
-#define R15_sig(context)    ((context)->uc_mcontext.__gregs[_REG_R15])
-#define CS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_CS])
-#define DS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_DS])
-#define ES_sig(context)     ((context)->uc_mcontext.__gregs[_REG_ES])
-#define FS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_FS])
-#define GS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_GS])
-#define SS_sig(context)     ((context)->uc_mcontext.__gregs[_REG_SS])
-#define EFL_sig(context)    ((context)->uc_mcontext.__gregs[_REG_RFL])
-#define RIP_sig(context)    (*((unsigned long*)&(context)->uc_mcontext.__gregs[_REG_RIP]))
-#define RSP_sig(context)    (*((unsigned long*)&(context)->uc_mcontext.__gregs[_REG_URSP]))
-#define TRAP_sig(context)   ((context)->uc_mcontext.__gregs[_REG_TRAPNO])
-#define ERROR_sig(context)  ((context)->uc_mcontext.__gregs[_REG_ERR])
-#define FPU_sig(context)    ((XMM_SAVE_AREA32 *)((context)->uc_mcontext.__fpregs))
-
-#elif defined (__APPLE__)
-
-#define RAX_sig(context)     ((context)->uc_mcontext->__ss.__rax)
-#define RBX_sig(context)     ((context)->uc_mcontext->__ss.__rbx)
-#define RCX_sig(context)     ((context)->uc_mcontext->__ss.__rcx)
-#define RDX_sig(context)     ((context)->uc_mcontext->__ss.__rdx)
-#define RSI_sig(context)     ((context)->uc_mcontext->__ss.__rsi)
-#define RDI_sig(context)     ((context)->uc_mcontext->__ss.__rdi)
-#define RBP_sig(context)     ((context)->uc_mcontext->__ss.__rbp)
-#define R8_sig(context)      ((context)->uc_mcontext->__ss.__r8)
-#define R9_sig(context)      ((context)->uc_mcontext->__ss.__r9)
-#define R10_sig(context)     ((context)->uc_mcontext->__ss.__r10)
-#define R11_sig(context)     ((context)->uc_mcontext->__ss.__r11)
-#define R12_sig(context)     ((context)->uc_mcontext->__ss.__r12)
-#define R13_sig(context)     ((context)->uc_mcontext->__ss.__r13)
-#define R14_sig(context)     ((context)->uc_mcontext->__ss.__r14)
-#define R15_sig(context)     ((context)->uc_mcontext->__ss.__r15)
-#define CS_sig(context)      ((context)->uc_mcontext->__ss.__cs)
-#define FS_sig(context)      ((context)->uc_mcontext->__ss.__fs)
-#define GS_sig(context)      ((context)->uc_mcontext->__ss.__gs)
-#define EFL_sig(context)     ((context)->uc_mcontext->__ss.__rflags)
-#define RIP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__rip))
-#define RSP_sig(context)     (*((unsigned long*)&(context)->uc_mcontext->__ss.__rsp))
-#define TRAP_sig(context)    ((context)->uc_mcontext->__es.__trapno)
-#define ERROR_sig(context)   ((context)->uc_mcontext->__es.__err)
-#define FPU_sig(context)     ((XMM_SAVE_AREA32 *)&(context)->uc_mcontext->__fs.__fpu_fcw)
-
-#else
-#error You must define the signal context functions for your platform
-#endif
-
-enum i386_trap_code
-{
-    TRAP_x86_DIVIDE     = 0,   /* Division by zero exception */
-    TRAP_x86_TRCTRAP    = 1,   /* Single-step exception */
-    TRAP_x86_NMI        = 2,   /* NMI interrupt */
-    TRAP_x86_BPTFLT     = 3,   /* Breakpoint exception */
-    TRAP_x86_OFLOW      = 4,   /* Overflow exception */
-    TRAP_x86_BOUND      = 5,   /* Bound range exception */
-    TRAP_x86_PRIVINFLT  = 6,   /* Invalid opcode exception */
-    TRAP_x86_DNA        = 7,   /* Device not available exception */
-    TRAP_x86_DOUBLEFLT  = 8,   /* Double fault exception */
-    TRAP_x86_FPOPFLT    = 9,   /* Coprocessor segment overrun */
-    TRAP_x86_TSSFLT     = 10,  /* Invalid TSS exception */
-    TRAP_x86_SEGNPFLT   = 11,  /* Segment not present exception */
-    TRAP_x86_STKFLT     = 12,  /* Stack fault */
-    TRAP_x86_PROTFLT    = 13,  /* General protection fault */
-    TRAP_x86_PAGEFLT    = 14,  /* Page fault */
-    TRAP_x86_ARITHTRAP  = 16,  /* Floating point exception */
-    TRAP_x86_ALIGNFLT   = 17,  /* Alignment check exception */
-    TRAP_x86_MCHK       = 18,  /* Machine check exception */
-    TRAP_x86_CACHEFLT   = 19   /* Cache flush exception */
-};
-
-/* stack layout when calling an exception raise function */
-struct stack_layout
-{
-    CONTEXT           context;
-    ULONG64           unknown[4];
-    EXCEPTION_RECORD  rec;
-    ULONG64           rsi;
-    ULONG64           rdi;
-    ULONG64           rbp;
-    ULONG64           rip;
-    ULONG64           red_zone[16];
-};
-
-C_ASSERT( sizeof(struct stack_layout) == 0x630 ); /* Should match the size in call_user_exception_dispatcher(). */
-
-struct syscall_frame
-{
-    struct syscall_frame *prev_frame;
-    ULONG64               pad;
-    ULONG64               xmm[10 * 2];  /* xmm6-xmm15 */
-    ULONG64               mxcsr;
-    ULONG64               r12;
-    ULONG64               r13;
-    ULONG64               r14;
-    ULONG64               r15;
-    ULONG64               rdi;
-    ULONG64               rsi;
-    ULONG64               rbx;
-    ULONG64               rbp;
-    ULONG64               thunk_addr;
-    ULONG64               ret_addr;
-};
-
-struct amd64_thread_data
-{
-    DWORD_PTR             dr0;           /* 02f0 debug registers */
-    DWORD_PTR             dr1;           /* 02f8 */
-    DWORD_PTR             dr2;           /* 0300 */
-    DWORD_PTR             dr3;           /* 0308 */
-    DWORD_PTR             dr6;           /* 0310 */
-    DWORD_PTR             dr7;           /* 0318 */
-    void                 *exit_frame;    /* 0320 exit frame pointer */
-    struct syscall_frame *syscall_frame; /* 0328 syscall frame pointer */
-};
-
-C_ASSERT( sizeof(struct amd64_thread_data) <= sizeof(((struct ntdll_thread_data *)0)->cpu_data) );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct amd64_thread_data, exit_frame ) == 0x320 );
-C_ASSERT( offsetof( TEB, GdiTebBatch ) + offsetof( struct amd64_thread_data, syscall_frame ) == 0x328 );
-
-static inline struct amd64_thread_data *amd64_thread_data(void)
-{
-    return (struct amd64_thread_data *)ntdll_get_thread_data()->cpu_data;
-}
-
-
-/***********************************************************************
- * Definitions for Dwarf unwind tables
- */
-
-enum dwarf_call_frame_info
-{
-    DW_CFA_advance_loc = 0x40,
-    DW_CFA_offset = 0x80,
-    DW_CFA_restore = 0xc0,
-    DW_CFA_nop = 0x00,
-    DW_CFA_set_loc = 0x01,
-    DW_CFA_advance_loc1 = 0x02,
-    DW_CFA_advance_loc2 = 0x03,
-    DW_CFA_advance_loc4 = 0x04,
-    DW_CFA_offset_extended = 0x05,
-    DW_CFA_restore_extended = 0x06,
-    DW_CFA_undefined = 0x07,
-    DW_CFA_same_value = 0x08,
-    DW_CFA_register = 0x09,
-    DW_CFA_remember_state = 0x0a,
-    DW_CFA_restore_state = 0x0b,
-    DW_CFA_def_cfa = 0x0c,
-    DW_CFA_def_cfa_register = 0x0d,
-    DW_CFA_def_cfa_offset = 0x0e,
-    DW_CFA_def_cfa_expression = 0x0f,
-    DW_CFA_expression = 0x10,
-    DW_CFA_offset_extended_sf = 0x11,
-    DW_CFA_def_cfa_sf = 0x12,
-    DW_CFA_def_cfa_offset_sf = 0x13,
-    DW_CFA_val_offset = 0x14,
-    DW_CFA_val_offset_sf = 0x15,
-    DW_CFA_val_expression = 0x16,
-};
-
-enum dwarf_operation
-{
-    DW_OP_addr                 = 0x03,
-    DW_OP_deref                = 0x06,
-    DW_OP_const1u              = 0x08,
-    DW_OP_const1s              = 0x09,
-    DW_OP_const2u              = 0x0a,
-    DW_OP_const2s              = 0x0b,
-    DW_OP_const4u              = 0x0c,
-    DW_OP_const4s              = 0x0d,
-    DW_OP_const8u              = 0x0e,
-    DW_OP_const8s              = 0x0f,
-    DW_OP_constu               = 0x10,
-    DW_OP_consts               = 0x11,
-    DW_OP_dup                  = 0x12,
-    DW_OP_drop                 = 0x13,
-    DW_OP_over                 = 0x14,
-    DW_OP_pick                 = 0x15,
-    DW_OP_swap                 = 0x16,
-    DW_OP_rot                  = 0x17,
-    DW_OP_xderef               = 0x18,
-    DW_OP_abs                  = 0x19,
-    DW_OP_and                  = 0x1a,
-    DW_OP_div                  = 0x1b,
-    DW_OP_minus                = 0x1c,
-    DW_OP_mod                  = 0x1d,
-    DW_OP_mul                  = 0x1e,
-    DW_OP_neg                  = 0x1f,
-    DW_OP_not                  = 0x20,
-    DW_OP_or                   = 0x21,
-    DW_OP_plus                 = 0x22,
-    DW_OP_plus_uconst          = 0x23,
-    DW_OP_shl                  = 0x24,
-    DW_OP_shr                  = 0x25,
-    DW_OP_shra                 = 0x26,
-    DW_OP_xor                  = 0x27,
-    DW_OP_bra                  = 0x28,
-    DW_OP_eq                   = 0x29,
-    DW_OP_ge                   = 0x2a,
-    DW_OP_gt                   = 0x2b,
-    DW_OP_le                   = 0x2c,
-    DW_OP_lt                   = 0x2d,
-    DW_OP_ne                   = 0x2e,
-    DW_OP_skip                 = 0x2f,
-    DW_OP_lit0                 = 0x30,
-    DW_OP_lit1                 = 0x31,
-    DW_OP_lit2                 = 0x32,
-    DW_OP_lit3                 = 0x33,
-    DW_OP_lit4                 = 0x34,
-    DW_OP_lit5                 = 0x35,
-    DW_OP_lit6                 = 0x36,
-    DW_OP_lit7                 = 0x37,
-    DW_OP_lit8                 = 0x38,
-    DW_OP_lit9                 = 0x39,
-    DW_OP_lit10                = 0x3a,
-    DW_OP_lit11                = 0x3b,
-    DW_OP_lit12                = 0x3c,
-    DW_OP_lit13                = 0x3d,
-    DW_OP_lit14                = 0x3e,
-    DW_OP_lit15                = 0x3f,
-    DW_OP_lit16                = 0x40,
-    DW_OP_lit17                = 0x41,
-    DW_OP_lit18                = 0x42,
-    DW_OP_lit19                = 0x43,
-    DW_OP_lit20                = 0x44,
-    DW_OP_lit21                = 0x45,
-    DW_OP_lit22                = 0x46,
-    DW_OP_lit23                = 0x47,
-    DW_OP_lit24                = 0x48,
-    DW_OP_lit25                = 0x49,
-    DW_OP_lit26                = 0x4a,
-    DW_OP_lit27                = 0x4b,
-    DW_OP_lit28                = 0x4c,
-    DW_OP_lit29                = 0x4d,
-    DW_OP_lit30                = 0x4e,
-    DW_OP_lit31                = 0x4f,
-    DW_OP_reg0                 = 0x50,
-    DW_OP_reg1                 = 0x51,
-    DW_OP_reg2                 = 0x52,
-    DW_OP_reg3                 = 0x53,
-    DW_OP_reg4                 = 0x54,
-    DW_OP_reg5                 = 0x55,
-    DW_OP_reg6                 = 0x56,
-    DW_OP_reg7                 = 0x57,
-    DW_OP_reg8                 = 0x58,
-    DW_OP_reg9                 = 0x59,
-    DW_OP_reg10                = 0x5a,
-    DW_OP_reg11                = 0x5b,
-    DW_OP_reg12                = 0x5c,
-    DW_OP_reg13                = 0x5d,
-    DW_OP_reg14                = 0x5e,
-    DW_OP_reg15                = 0x5f,
-    DW_OP_reg16                = 0x60,
-    DW_OP_reg17                = 0x61,
-    DW_OP_reg18                = 0x62,
-    DW_OP_reg19                = 0x63,
-    DW_OP_reg20                = 0x64,
-    DW_OP_reg21                = 0x65,
-    DW_OP_reg22                = 0x66,
-    DW_OP_reg23                = 0x67,
-    DW_OP_reg24                = 0x68,
-    DW_OP_reg25                = 0x69,
-    DW_OP_reg26                = 0x6a,
-    DW_OP_reg27                = 0x6b,
-    DW_OP_reg28                = 0x6c,
-    DW_OP_reg29                = 0x6d,
-    DW_OP_reg30                = 0x6e,
-    DW_OP_reg31                = 0x6f,
-    DW_OP_breg0                = 0x70,
-    DW_OP_breg1                = 0x71,
-    DW_OP_breg2                = 0x72,
-    DW_OP_breg3                = 0x73,
-    DW_OP_breg4                = 0x74,
-    DW_OP_breg5                = 0x75,
-    DW_OP_breg6                = 0x76,
-    DW_OP_breg7                = 0x77,
-    DW_OP_breg8                = 0x78,
-    DW_OP_breg9                = 0x79,
-    DW_OP_breg10               = 0x7a,
-    DW_OP_breg11               = 0x7b,
-    DW_OP_breg12               = 0x7c,
-    DW_OP_breg13               = 0x7d,
-    DW_OP_breg14               = 0x7e,
-    DW_OP_breg15               = 0x7f,
-    DW_OP_breg16               = 0x80,
-    DW_OP_breg17               = 0x81,
-    DW_OP_breg18               = 0x82,
-    DW_OP_breg19               = 0x83,
-    DW_OP_breg20               = 0x84,
-    DW_OP_breg21               = 0x85,
-    DW_OP_breg22               = 0x86,
-    DW_OP_breg23               = 0x87,
-    DW_OP_breg24               = 0x88,
-    DW_OP_breg25               = 0x89,
-    DW_OP_breg26               = 0x8a,
-    DW_OP_breg27               = 0x8b,
-    DW_OP_breg28               = 0x8c,
-    DW_OP_breg29               = 0x8d,
-    DW_OP_breg30               = 0x8e,
-    DW_OP_breg31               = 0x8f,
-    DW_OP_regx                 = 0x90,
-    DW_OP_fbreg                = 0x91,
-    DW_OP_bregx                = 0x92,
-    DW_OP_piece                = 0x93,
-    DW_OP_deref_size           = 0x94,
-    DW_OP_xderef_size          = 0x95,
-    DW_OP_nop                  = 0x96,
-    DW_OP_push_object_address  = 0x97,
-    DW_OP_call2                = 0x98,
-    DW_OP_call4                = 0x99,
-    DW_OP_call_ref             = 0x9a,
-    DW_OP_form_tls_address     = 0x9b,
-    DW_OP_call_frame_cfa       = 0x9c,
-    DW_OP_bit_piece            = 0x9d,
-    DW_OP_lo_user              = 0xe0,
-    DW_OP_hi_user              = 0xff,
-    DW_OP_GNU_push_tls_address = 0xe0,
-    DW_OP_GNU_uninit           = 0xf0,
-    DW_OP_GNU_encoded_addr     = 0xf1,
-};
-
-#define DW_EH_PE_native   0x00
-#define DW_EH_PE_leb128   0x01
-#define DW_EH_PE_data2    0x02
-#define DW_EH_PE_data4    0x03
-#define DW_EH_PE_data8    0x04
-#define DW_EH_PE_signed   0x08
-#define DW_EH_PE_abs      0x00
-#define DW_EH_PE_pcrel    0x10
-#define DW_EH_PE_textrel  0x20
-#define DW_EH_PE_datarel  0x30
-#define DW_EH_PE_funcrel  0x40
-#define DW_EH_PE_aligned  0x50
-#define DW_EH_PE_indirect 0x80
-#define DW_EH_PE_omit     0xff
-
-struct dwarf_eh_bases
-{
-    void *tbase;
-    void *dbase;
-    void *func;
-};
-
-struct dwarf_cie
-{
-    unsigned int  length;
-    int           id;
-    unsigned char version;
-    unsigned char augmentation[1];
-};
-
-struct dwarf_fde
-{
-    unsigned int length;
-    unsigned int cie_offset;
-};
-
-extern const struct dwarf_fde *_Unwind_Find_FDE (void *, struct dwarf_eh_bases *);
-
-static unsigned char dwarf_get_u1( const unsigned char **p )
-{
-    return *(*p)++;
-}
-
-static unsigned short dwarf_get_u2( const unsigned char **p )
-{
-    unsigned int ret = (*p)[0] | ((*p)[1] << 8);
-    (*p) += 2;
-    return ret;
-}
-
-static unsigned int dwarf_get_u4( const unsigned char **p )
-{
-    unsigned int ret = (*p)[0] | ((*p)[1] << 8) | ((*p)[2] << 16) | ((*p)[3] << 24);
-    (*p) += 4;
-    return ret;
-}
-
-static ULONG64 dwarf_get_u8( const unsigned char **p )
-{
-    ULONG64 low  = dwarf_get_u4( p );
-    ULONG64 high = dwarf_get_u4( p );
-    return low | (high << 32);
-}
-
-static ULONG_PTR dwarf_get_uleb128( const unsigned char **p )
-{
-    ULONG_PTR ret = 0;
-    unsigned int shift = 0;
-    unsigned char byte;
-
-    do
-    {
-        byte = **p;
-        ret |= (ULONG_PTR)(byte & 0x7f) << shift;
-        shift += 7;
-        (*p)++;
-    } while (byte & 0x80);
-    return ret;
-}
-
-static LONG_PTR dwarf_get_sleb128( const unsigned char **p )
-{
-    ULONG_PTR ret = 0;
-    unsigned int shift = 0;
-    unsigned char byte;
-
-    do
-    {
-        byte = **p;
-        ret |= (ULONG_PTR)(byte & 0x7f) << shift;
-        shift += 7;
-        (*p)++;
-    } while (byte & 0x80);
-
-    if ((shift < 8 * sizeof(ret)) && (byte & 0x40)) ret |= -((ULONG_PTR)1 << shift);
-    return ret;
-}
-
-static ULONG_PTR dwarf_get_ptr( const unsigned char **p, unsigned char encoding )
-{
-    ULONG_PTR base;
-
-    if (encoding == DW_EH_PE_omit) return 0;
-
-    switch (encoding & 0xf0)
-    {
-    case DW_EH_PE_abs:
-        base = 0;
-        break;
-    case DW_EH_PE_pcrel:
-        base = (ULONG_PTR)*p;
-        break;
-    default:
-        FIXME( "unsupported encoding %02x\n", encoding );
-        return 0;
-    }
-
-    switch (encoding & 0x0f)
-    {
-    case DW_EH_PE_native:
-        return base + dwarf_get_u8( p );
-    case DW_EH_PE_leb128:
-        return base + dwarf_get_uleb128( p );
-    case DW_EH_PE_data2:
-        return base + dwarf_get_u2( p );
-    case DW_EH_PE_data4:
-        return base + dwarf_get_u4( p );
-    case DW_EH_PE_data8:
-        return base + dwarf_get_u8( p );
-    case DW_EH_PE_signed|DW_EH_PE_leb128:
-        return base + dwarf_get_sleb128( p );
-    case DW_EH_PE_signed|DW_EH_PE_data2:
-        return base + (signed short)dwarf_get_u2( p );
-    case DW_EH_PE_signed|DW_EH_PE_data4:
-        return base + (signed int)dwarf_get_u4( p );
-    case DW_EH_PE_signed|DW_EH_PE_data8:
-        return base + (LONG64)dwarf_get_u8( p );
-    default:
-        FIXME( "unsupported encoding %02x\n", encoding );
-        return 0;
-    }
-}
-
-enum reg_rule
-{
-    RULE_UNSET,          /* not set at all */
-    RULE_UNDEFINED,      /* undefined value */
-    RULE_SAME,           /* same value as previous frame */
-    RULE_CFA_OFFSET,     /* stored at cfa offset */
-    RULE_OTHER_REG,      /* stored in other register */
-    RULE_EXPRESSION,     /* address specified by expression */
-    RULE_VAL_EXPRESSION  /* value specified by expression */
-};
-
-#define NB_FRAME_REGS 41
-#define MAX_SAVED_STATES 16
-
-struct frame_state
-{
-    ULONG_PTR     cfa_offset;
-    unsigned char cfa_reg;
-    enum reg_rule cfa_rule;
-    enum reg_rule rules[NB_FRAME_REGS];
-    ULONG64       regs[NB_FRAME_REGS];
-};
-
-struct frame_info
-{
-    ULONG_PTR     ip;
-    ULONG_PTR     code_align;
-    LONG_PTR      data_align;
-    unsigned char retaddr_reg;
-    unsigned char fde_encoding;
-    unsigned char signal_frame;
-    unsigned char state_sp;
-    struct frame_state state;
-    struct frame_state *state_stack;
-};
-
-static const char *dwarf_reg_names[NB_FRAME_REGS] =
-{
-/*  0-7  */ "%rax", "%rdx", "%rcx", "%rbx", "%rsi", "%rdi", "%rbp", "%rsp",
-/*  8-16 */ "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15", "%rip",
-/* 17-24 */ "%xmm0", "%xmm1", "%xmm2", "%xmm3", "%xmm4", "%xmm5", "%xmm6", "%xmm7",
-/* 25-32 */ "%xmm8", "%xmm9", "%xmm10", "%xmm11", "%xmm12", "%xmm13", "%xmm14", "%xmm15",
-/* 33-40 */ "%st0", "%st1", "%st2", "%st3", "%st4", "%st5", "%st6", "%st7"
-};
-
-static BOOL valid_reg( ULONG_PTR reg )
-{
-    if (reg >= NB_FRAME_REGS) FIXME( "unsupported reg %lx\n", reg );
-    return (reg < NB_FRAME_REGS);
-}
-
-static void execute_cfa_instructions( const unsigned char *ptr, const unsigned char *end,
-                                      ULONG_PTR last_ip, struct frame_info *info )
-{
-    while (ptr < end && info->ip < last_ip + info->signal_frame)
-    {
-        enum dwarf_call_frame_info op = *ptr++;
-
-        if (op & 0xc0)
-        {
-            switch (op & 0xc0)
-            {
-            case DW_CFA_advance_loc:
-            {
-                ULONG_PTR offset = (op & 0x3f) * info->code_align;
-                TRACE( "%lx: DW_CFA_advance_loc %lu\n", info->ip, offset );
-                info->ip += offset;
-                break;
-            }
-            case DW_CFA_offset:
-            {
-                ULONG_PTR reg = op & 0x3f;
-                LONG_PTR offset = dwarf_get_uleb128( &ptr ) * info->data_align;
-                if (!valid_reg( reg )) break;
-                TRACE( "%lx: DW_CFA_offset %s, %ld\n", info->ip, dwarf_reg_names[reg], offset );
-                info->state.regs[reg]  = offset;
-                info->state.rules[reg] = RULE_CFA_OFFSET;
-                break;
-            }
-            case DW_CFA_restore:
-            {
-                ULONG_PTR reg = op & 0x3f;
-                if (!valid_reg( reg )) break;
-                TRACE( "%lx: DW_CFA_restore %s\n", info->ip, dwarf_reg_names[reg] );
-                info->state.rules[reg] = RULE_UNSET;
-                break;
-            }
-            }
-        }
-        else switch (op)
-        {
-        case DW_CFA_nop:
-            break;
-        case DW_CFA_set_loc:
-        {
-            ULONG_PTR loc = dwarf_get_ptr( &ptr, info->fde_encoding );
-            TRACE( "%lx: DW_CFA_set_loc %lx\n", info->ip, loc );
-            info->ip = loc;
-            break;
-        }
-        case DW_CFA_advance_loc1:
-        {
-            ULONG_PTR offset = *ptr++ * info->code_align;
-            TRACE( "%lx: DW_CFA_advance_loc1 %lu\n", info->ip, offset );
-            info->ip += offset;
-            break;
-        }
-        case DW_CFA_advance_loc2:
-        {
-            ULONG_PTR offset = dwarf_get_u2( &ptr ) * info->code_align;
-            TRACE( "%lx: DW_CFA_advance_loc2 %lu\n", info->ip, offset );
-            info->ip += offset;
-            break;
-        }
-        case DW_CFA_advance_loc4:
-        {
-            ULONG_PTR offset = dwarf_get_u4( &ptr ) * info->code_align;
-            TRACE( "%lx: DW_CFA_advance_loc4 %lu\n", info->ip, offset );
-            info->ip += offset;
-            break;
-        }
-        case DW_CFA_offset_extended:
-        case DW_CFA_offset_extended_sf:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            LONG_PTR offset = (op == DW_CFA_offset_extended) ? dwarf_get_uleb128( &ptr ) * info->data_align
-                                                             : dwarf_get_sleb128( &ptr ) * info->data_align;
-            if (!valid_reg( reg )) break;
-            TRACE( "%lx: DW_CFA_offset_extended %s, %ld\n", info->ip, dwarf_reg_names[reg], offset );
-            info->state.regs[reg]  = offset;
-            info->state.rules[reg] = RULE_CFA_OFFSET;
-            break;
-        }
-        case DW_CFA_restore_extended:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            if (!valid_reg( reg )) break;
-            TRACE( "%lx: DW_CFA_restore_extended %s\n", info->ip, dwarf_reg_names[reg] );
-            info->state.rules[reg] = RULE_UNSET;
-            break;
-        }
-        case DW_CFA_undefined:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            if (!valid_reg( reg )) break;
-            TRACE( "%lx: DW_CFA_undefined %s\n", info->ip, dwarf_reg_names[reg] );
-            info->state.rules[reg] = RULE_UNDEFINED;
-            break;
-        }
-        case DW_CFA_same_value:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            if (!valid_reg( reg )) break;
-            TRACE( "%lx: DW_CFA_same_value %s\n", info->ip, dwarf_reg_names[reg] );
-            info->state.regs[reg]  = reg;
-            info->state.rules[reg] = RULE_SAME;
-            break;
-        }
-        case DW_CFA_register:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            ULONG_PTR reg2 = dwarf_get_uleb128( &ptr );
-            if (!valid_reg( reg ) || !valid_reg( reg2 )) break;
-            TRACE( "%lx: DW_CFA_register %s == %s\n", info->ip, dwarf_reg_names[reg], dwarf_reg_names[reg2] );
-            info->state.regs[reg]  = reg2;
-            info->state.rules[reg] = RULE_OTHER_REG;
-            break;
-        }
-        case DW_CFA_remember_state:
-            TRACE( "%lx: DW_CFA_remember_state\n", info->ip );
-            if (info->state_sp >= MAX_SAVED_STATES)
-                FIXME( "%lx: DW_CFA_remember_state too many nested saves\n", info->ip );
-            else
-                info->state_stack[info->state_sp++] = info->state;
-            break;
-        case DW_CFA_restore_state:
-            TRACE( "%lx: DW_CFA_restore_state\n", info->ip );
-            if (!info->state_sp)
-                FIXME( "%lx: DW_CFA_restore_state without corresponding save\n", info->ip );
-            else
-                info->state = info->state_stack[--info->state_sp];
-            break;
-        case DW_CFA_def_cfa:
-        case DW_CFA_def_cfa_sf:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            ULONG_PTR offset = (op == DW_CFA_def_cfa) ? dwarf_get_uleb128( &ptr )
-                                                      : dwarf_get_sleb128( &ptr ) * info->data_align;
-            if (!valid_reg( reg )) break;
-            TRACE( "%lx: DW_CFA_def_cfa %s, %lu\n", info->ip, dwarf_reg_names[reg], offset );
-            info->state.cfa_reg    = reg;
-            info->state.cfa_offset = offset;
-            info->state.cfa_rule   = RULE_CFA_OFFSET;
-            break;
-        }
-        case DW_CFA_def_cfa_register:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            if (!valid_reg( reg )) break;
-            TRACE( "%lx: DW_CFA_def_cfa_register %s\n", info->ip, dwarf_reg_names[reg] );
-            info->state.cfa_reg = reg;
-            info->state.cfa_rule = RULE_CFA_OFFSET;
-            break;
-        }
-        case DW_CFA_def_cfa_offset:
-        case DW_CFA_def_cfa_offset_sf:
-        {
-            ULONG_PTR offset = (op == DW_CFA_def_cfa_offset) ? dwarf_get_uleb128( &ptr )
-                                                             : dwarf_get_sleb128( &ptr ) * info->data_align;
-            TRACE( "%lx: DW_CFA_def_cfa_offset %lu\n", info->ip, offset );
-            info->state.cfa_offset = offset;
-            info->state.cfa_rule = RULE_CFA_OFFSET;
-            break;
-        }
-        case DW_CFA_def_cfa_expression:
-        {
-            ULONG_PTR expr = (ULONG_PTR)ptr;
-            ULONG_PTR len = dwarf_get_uleb128( &ptr );
-            TRACE( "%lx: DW_CFA_def_cfa_expression %lx-%lx\n", info->ip, expr, expr+len );
-            info->state.cfa_offset = expr;
-            info->state.cfa_rule = RULE_VAL_EXPRESSION;
-            ptr += len;
-            break;
-        }
-        case DW_CFA_expression:
-        case DW_CFA_val_expression:
-        {
-            ULONG_PTR reg = dwarf_get_uleb128( &ptr );
-            ULONG_PTR expr = (ULONG_PTR)ptr;
-            ULONG_PTR len = dwarf_get_uleb128( &ptr );
-            if (!valid_reg( reg )) break;
-            TRACE( "%lx: DW_CFA_%sexpression %s %lx-%lx\n",
-                   info->ip, (op == DW_CFA_expression) ? "" : "val_", dwarf_reg_names[reg], expr, expr+len );
-            info->state.regs[reg]  = expr;
-            info->state.rules[reg] = (op == DW_CFA_expression) ? RULE_EXPRESSION : RULE_VAL_EXPRESSION;
-            ptr += len;
-            break;
-        }
-        default:
-            FIXME( "%lx: unknown CFA opcode %02x\n", info->ip, op );
-            break;
-        }
-    }
-}
-
-/* retrieve a context register from its dwarf number */
-static void *get_context_reg( CONTEXT *context, ULONG_PTR dw_reg )
-{
-    switch (dw_reg)
-    {
-    case 0:  return &context->Rax;
-    case 1:  return &context->Rdx;
-    case 2:  return &context->Rcx;
-    case 3:  return &context->Rbx;
-    case 4:  return &context->Rsi;
-    case 5:  return &context->Rdi;
-    case 6:  return &context->Rbp;
-    case 7:  return &context->Rsp;
-    case 8:  return &context->R8;
-    case 9:  return &context->R9;
-    case 10: return &context->R10;
-    case 11: return &context->R11;
-    case 12: return &context->R12;
-    case 13: return &context->R13;
-    case 14: return &context->R14;
-    case 15: return &context->R15;
-    case 16: return &context->Rip;
-    case 17: return &context->u.s.Xmm0;
-    case 18: return &context->u.s.Xmm1;
-    case 19: return &context->u.s.Xmm2;
-    case 20: return &context->u.s.Xmm3;
-    case 21: return &context->u.s.Xmm4;
-    case 22: return &context->u.s.Xmm5;
-    case 23: return &context->u.s.Xmm6;
-    case 24: return &context->u.s.Xmm7;
-    case 25: return &context->u.s.Xmm8;
-    case 26: return &context->u.s.Xmm9;
-    case 27: return &context->u.s.Xmm10;
-    case 28: return &context->u.s.Xmm11;
-    case 29: return &context->u.s.Xmm12;
-    case 30: return &context->u.s.Xmm13;
-    case 31: return &context->u.s.Xmm14;
-    case 32: return &context->u.s.Xmm15;
-    case 33: return &context->u.s.Legacy[0];
-    case 34: return &context->u.s.Legacy[1];
-    case 35: return &context->u.s.Legacy[2];
-    case 36: return &context->u.s.Legacy[3];
-    case 37: return &context->u.s.Legacy[4];
-    case 38: return &context->u.s.Legacy[5];
-    case 39: return &context->u.s.Legacy[6];
-    case 40: return &context->u.s.Legacy[7];
-    default: return NULL;
-    }
-}
-
-/* set a context register from its dwarf number */
-static void set_context_reg( CONTEXT *context, ULONG_PTR dw_reg, void *val )
-{
-    switch (dw_reg)
-    {
-    case 0:  context->Rax = *(ULONG64 *)val; break;
-    case 1:  context->Rdx = *(ULONG64 *)val; break;
-    case 2:  context->Rcx = *(ULONG64 *)val; break;
-    case 3:  context->Rbx = *(ULONG64 *)val; break;
-    case 4:  context->Rsi = *(ULONG64 *)val; break;
-    case 5:  context->Rdi = *(ULONG64 *)val; break;
-    case 6:  context->Rbp = *(ULONG64 *)val; break;
-    case 7:  context->Rsp = *(ULONG64 *)val; break;
-    case 8:  context->R8  = *(ULONG64 *)val; break;
-    case 9:  context->R9  = *(ULONG64 *)val; break;
-    case 10: context->R10 = *(ULONG64 *)val; break;
-    case 11: context->R11 = *(ULONG64 *)val; break;
-    case 12: context->R12 = *(ULONG64 *)val; break;
-    case 13: context->R13 = *(ULONG64 *)val; break;
-    case 14: context->R14 = *(ULONG64 *)val; break;
-    case 15: context->R15 = *(ULONG64 *)val; break;
-    case 16: context->Rip = *(ULONG64 *)val; break;
-    case 17: memcpy( &context->u.s.Xmm0, val, sizeof(M128A) ); break;
-    case 18: memcpy( &context->u.s.Xmm1, val, sizeof(M128A) ); break;
-    case 19: memcpy( &context->u.s.Xmm2, val, sizeof(M128A) ); break;
-    case 20: memcpy( &context->u.s.Xmm3, val, sizeof(M128A) ); break;
-    case 21: memcpy( &context->u.s.Xmm4, val, sizeof(M128A) ); break;
-    case 22: memcpy( &context->u.s.Xmm5, val, sizeof(M128A) ); break;
-    case 23: memcpy( &context->u.s.Xmm6, val, sizeof(M128A) ); break;
-    case 24: memcpy( &context->u.s.Xmm7, val, sizeof(M128A) ); break;
-    case 25: memcpy( &context->u.s.Xmm8, val, sizeof(M128A) ); break;
-    case 26: memcpy( &context->u.s.Xmm9, val, sizeof(M128A) ); break;
-    case 27: memcpy( &context->u.s.Xmm10, val, sizeof(M128A) ); break;
-    case 28: memcpy( &context->u.s.Xmm11, val, sizeof(M128A) ); break;
-    case 29: memcpy( &context->u.s.Xmm12, val, sizeof(M128A) ); break;
-    case 30: memcpy( &context->u.s.Xmm13, val, sizeof(M128A) ); break;
-    case 31: memcpy( &context->u.s.Xmm14, val, sizeof(M128A) ); break;
-    case 32: memcpy( &context->u.s.Xmm15, val, sizeof(M128A) ); break;
-    case 33: memcpy( &context->u.s.Legacy[0], val, sizeof(M128A) ); break;
-    case 34: memcpy( &context->u.s.Legacy[1], val, sizeof(M128A) ); break;
-    case 35: memcpy( &context->u.s.Legacy[2], val, sizeof(M128A) ); break;
-    case 36: memcpy( &context->u.s.Legacy[3], val, sizeof(M128A) ); break;
-    case 37: memcpy( &context->u.s.Legacy[4], val, sizeof(M128A) ); break;
-    case 38: memcpy( &context->u.s.Legacy[5], val, sizeof(M128A) ); break;
-    case 39: memcpy( &context->u.s.Legacy[6], val, sizeof(M128A) ); break;
-    case 40: memcpy( &context->u.s.Legacy[7], val, sizeof(M128A) ); break;
-    }
-}
-
-static ULONG_PTR eval_expression( const unsigned char *p, CONTEXT *context )
-{
-    ULONG_PTR reg, tmp, stack[64];
-    int sp = -1;
-    ULONG_PTR len = dwarf_get_uleb128(&p);
-    const unsigned char *end = p + len;
-
-    while (p < end)
-    {
-        unsigned char opcode = dwarf_get_u1(&p);
-
-        if (opcode >= DW_OP_lit0 && opcode <= DW_OP_lit31)
-            stack[++sp] = opcode - DW_OP_lit0;
-        else if (opcode >= DW_OP_reg0 && opcode <= DW_OP_reg31)
-            stack[++sp] = *(ULONG_PTR *)get_context_reg( context, opcode - DW_OP_reg0 );
-        else if (opcode >= DW_OP_breg0 && opcode <= DW_OP_breg31)
-            stack[++sp] = *(ULONG_PTR *)get_context_reg( context, opcode - DW_OP_breg0 ) + dwarf_get_sleb128(&p);
-        else switch (opcode)
-        {
-        case DW_OP_nop:         break;
-        case DW_OP_addr:        stack[++sp] = dwarf_get_u8(&p); break;
-        case DW_OP_const1u:     stack[++sp] = dwarf_get_u1(&p); break;
-        case DW_OP_const1s:     stack[++sp] = (signed char)dwarf_get_u1(&p); break;
-        case DW_OP_const2u:     stack[++sp] = dwarf_get_u2(&p); break;
-        case DW_OP_const2s:     stack[++sp] = (short)dwarf_get_u2(&p); break;
-        case DW_OP_const4u:     stack[++sp] = dwarf_get_u4(&p); break;
-        case DW_OP_const4s:     stack[++sp] = (signed int)dwarf_get_u4(&p); break;
-        case DW_OP_const8u:     stack[++sp] = dwarf_get_u8(&p); break;
-        case DW_OP_const8s:     stack[++sp] = (LONG_PTR)dwarf_get_u8(&p); break;
-        case DW_OP_constu:      stack[++sp] = dwarf_get_uleb128(&p); break;
-        case DW_OP_consts:      stack[++sp] = dwarf_get_sleb128(&p); break;
-        case DW_OP_deref:       stack[sp] = *(ULONG_PTR *)stack[sp]; break;
-        case DW_OP_dup:         stack[sp + 1] = stack[sp]; sp++; break;
-        case DW_OP_drop:        sp--; break;
-        case DW_OP_over:        stack[sp + 1] = stack[sp - 1]; sp++; break;
-        case DW_OP_pick:        stack[sp + 1] = stack[sp - dwarf_get_u1(&p)]; sp++; break;
-        case DW_OP_swap:        tmp = stack[sp]; stack[sp] = stack[sp-1]; stack[sp-1] = tmp; break;
-        case DW_OP_rot:         tmp = stack[sp]; stack[sp] = stack[sp-1]; stack[sp-1] = stack[sp-2]; stack[sp-2] = tmp; break;
-        case DW_OP_abs:         stack[sp] = labs(stack[sp]); break;
-        case DW_OP_neg:         stack[sp] = -stack[sp]; break;
-        case DW_OP_not:         stack[sp] = ~stack[sp]; break;
-        case DW_OP_and:         stack[sp-1] &= stack[sp]; sp--; break;
-        case DW_OP_or:          stack[sp-1] |= stack[sp]; sp--; break;
-        case DW_OP_minus:       stack[sp-1] -= stack[sp]; sp--; break;
-        case DW_OP_mul:         stack[sp-1] *= stack[sp]; sp--; break;
-        case DW_OP_plus:        stack[sp-1] += stack[sp]; sp--; break;
-        case DW_OP_xor:         stack[sp-1] ^= stack[sp]; sp--; break;
-        case DW_OP_shl:         stack[sp-1] <<= stack[sp]; sp--; break;
-        case DW_OP_shr:         stack[sp-1] >>= stack[sp]; sp--; break;
-        case DW_OP_plus_uconst: stack[sp] += dwarf_get_uleb128(&p); break;
-        case DW_OP_shra:        stack[sp-1] = (LONG_PTR)stack[sp-1] / (1 << stack[sp]); sp--; break;
-        case DW_OP_div:         stack[sp-1] = (LONG_PTR)stack[sp-1] / (LONG_PTR)stack[sp]; sp--; break;
-        case DW_OP_mod:         stack[sp-1] = (LONG_PTR)stack[sp-1] % (LONG_PTR)stack[sp]; sp--; break;
-        case DW_OP_ge:          stack[sp-1] = ((LONG_PTR)stack[sp-1] >= (LONG_PTR)stack[sp]); sp--; break;
-        case DW_OP_gt:          stack[sp-1] = ((LONG_PTR)stack[sp-1] >  (LONG_PTR)stack[sp]); sp--; break;
-        case DW_OP_le:          stack[sp-1] = ((LONG_PTR)stack[sp-1] <= (LONG_PTR)stack[sp]); sp--; break;
-        case DW_OP_lt:          stack[sp-1] = ((LONG_PTR)stack[sp-1] <  (LONG_PTR)stack[sp]); sp--; break;
-        case DW_OP_eq:          stack[sp-1] = (stack[sp-1] == stack[sp]); sp--; break;
-        case DW_OP_ne:          stack[sp-1] = (stack[sp-1] != stack[sp]); sp--; break;
-        case DW_OP_skip:        tmp = (short)dwarf_get_u2(&p); p += tmp; break;
-        case DW_OP_bra:         tmp = (short)dwarf_get_u2(&p); if (!stack[sp--]) p += tmp; break;
-        case DW_OP_GNU_encoded_addr: tmp = *p++; stack[++sp] = dwarf_get_ptr( &p, tmp ); break;
-        case DW_OP_regx:        stack[++sp] = *(ULONG_PTR *)get_context_reg( context, dwarf_get_uleb128(&p) ); break;
-        case DW_OP_bregx:
-            reg = dwarf_get_uleb128(&p);
-            tmp = dwarf_get_sleb128(&p);
-            stack[++sp] = *(ULONG_PTR *)get_context_reg( context, reg ) + tmp;
-            break;
-        case DW_OP_deref_size:
-            switch (*p++)
-            {
-            case 1: stack[sp] = *(unsigned char *)stack[sp]; break;
-            case 2: stack[sp] = *(unsigned short *)stack[sp]; break;
-            case 4: stack[sp] = *(unsigned int *)stack[sp]; break;
-            case 8: stack[sp] = *(ULONG_PTR *)stack[sp]; break;
-            }
-            break;
-        default:
-            FIXME( "unhandled opcode %02x\n", opcode );
-        }
-    }
-    return stack[sp];
-}
-
-/* apply the computed frame info to the actual context */
-static void apply_frame_state( CONTEXT *context, struct frame_state *state )
-{
-    unsigned int i;
-    ULONG_PTR cfa, value;
-    CONTEXT new_context = *context;
-
-    switch (state->cfa_rule)
-    {
-    case RULE_EXPRESSION:
-        cfa = *(ULONG_PTR *)eval_expression( (const unsigned char *)state->cfa_offset, context );
-        break;
-    case RULE_VAL_EXPRESSION:
-        cfa = eval_expression( (const unsigned char *)state->cfa_offset, context );
-        break;
-    default:
-        cfa = *(ULONG_PTR *)get_context_reg( context, state->cfa_reg ) + state->cfa_offset;
-        break;
-    }
-    if (!cfa) return;
-
-    for (i = 0; i < NB_FRAME_REGS; i++)
-    {
-        switch (state->rules[i])
-        {
-        case RULE_UNSET:
-        case RULE_UNDEFINED:
-        case RULE_SAME:
-            break;
-        case RULE_CFA_OFFSET:
-            set_context_reg( &new_context, i, (char *)cfa + state->regs[i] );
-            break;
-        case RULE_OTHER_REG:
-            set_context_reg( &new_context, i, get_context_reg( context, state->regs[i] ));
-            break;
-        case RULE_EXPRESSION:
-            value = eval_expression( (const unsigned char *)state->regs[i], context );
-            set_context_reg( &new_context, i, (void *)value );
-            break;
-        case RULE_VAL_EXPRESSION:
-            value = eval_expression( (const unsigned char *)state->regs[i], context );
-            set_context_reg( &new_context, i, &value );
-            break;
-        }
-    }
-    new_context.Rsp = cfa;
-    *context = new_context;
-}
-
-
-/***********************************************************************
- *           dwarf_virtual_unwind
- *
- * Equivalent of RtlVirtualUnwind for builtin modules.
- */
-static NTSTATUS dwarf_virtual_unwind( ULONG64 ip, ULONG64 *frame,CONTEXT *context,
-                                      const struct dwarf_fde *fde, const struct dwarf_eh_bases *bases,
-                                      PEXCEPTION_ROUTINE *handler, void **handler_data )
-{
-    const struct dwarf_cie *cie;
-    const unsigned char *ptr, *augmentation, *end;
-    ULONG_PTR len, code_end;
-    struct frame_info info;
-    struct frame_state state_stack[MAX_SAVED_STATES];
-    int aug_z_format = 0;
-    unsigned char lsda_encoding = DW_EH_PE_omit;
-
-    memset( &info, 0, sizeof(info) );
-    info.state_stack = state_stack;
-    info.ip = (ULONG_PTR)bases->func;
-    *handler = NULL;
-
-    cie = (const struct dwarf_cie *)((const char *)&fde->cie_offset - fde->cie_offset);
-
-    /* parse the CIE first */
-
-    if (cie->version != 1 && cie->version != 3)
-    {
-        FIXME( "unknown CIE version %u at %p\n", cie->version, cie );
-        return STATUS_INVALID_DISPOSITION;
-    }
-    ptr = cie->augmentation + strlen((const char *)cie->augmentation) + 1;
-
-    info.code_align = dwarf_get_uleb128( &ptr );
-    info.data_align = dwarf_get_sleb128( &ptr );
-    if (cie->version == 1)
-        info.retaddr_reg = *ptr++;
-    else
-        info.retaddr_reg = dwarf_get_uleb128( &ptr );
-    info.state.cfa_rule = RULE_CFA_OFFSET;
-
-    TRACE( "function %lx base %p cie %p len %x id %x version %x aug '%s' code_align %lu data_align %ld retaddr %s\n",
-           ip, bases->func, cie, cie->length, cie->id, cie->version, cie->augmentation,
-           info.code_align, info.data_align, dwarf_reg_names[info.retaddr_reg] );
-
-    end = NULL;
-    for (augmentation = cie->augmentation; *augmentation; augmentation++)
-    {
-        switch (*augmentation)
-        {
-        case 'z':
-            len = dwarf_get_uleb128( &ptr );
-            end = ptr + len;
-            aug_z_format = 1;
-            continue;
-        case 'L':
-            lsda_encoding = *ptr++;
-            continue;
-        case 'P':
-        {
-            unsigned char encoding = *ptr++;
-            *handler = (void *)dwarf_get_ptr( &ptr, encoding );
-            continue;
-        }
-        case 'R':
-            info.fde_encoding = *ptr++;
-            continue;
-        case 'S':
-            info.signal_frame = 1;
-            continue;
-        }
-        FIXME( "unknown augmentation '%c'\n", *augmentation );
-        if (!end) return STATUS_INVALID_DISPOSITION;  /* cannot continue */
-        break;
-    }
-    if (end) ptr = end;
-
-    end = (const unsigned char *)(&cie->length + 1) + cie->length;
-    execute_cfa_instructions( ptr, end, ip, &info );
-
-    ptr = (const unsigned char *)(fde + 1);
-    info.ip = dwarf_get_ptr( &ptr, info.fde_encoding );  /* fde code start */
-    code_end = info.ip + dwarf_get_ptr( &ptr, info.fde_encoding & 0x0f );  /* fde code length */
-
-    if (aug_z_format)  /* get length of augmentation data */
-    {
-        len = dwarf_get_uleb128( &ptr );
-        end = ptr + len;
-    }
-    else end = NULL;
-
-    *handler_data = (void *)dwarf_get_ptr( &ptr, lsda_encoding );
-    if (end) ptr = end;
-
-    end = (const unsigned char *)(&fde->length + 1) + fde->length;
-    TRACE( "fde %p len %x personality %p lsda %p code %lx-%lx\n",
-           fde, fde->length, *handler, *handler_data, info.ip, code_end );
-    execute_cfa_instructions( ptr, end, ip, &info );
-    *frame = context->Rsp;
-    apply_frame_state( context, &info.state );
-
-    TRACE( "next function rip=%016lx\n", context->Rip );
-    TRACE( "  rax=%016lx rbx=%016lx rcx=%016lx rdx=%016lx\n",
-           context->Rax, context->Rbx, context->Rcx, context->Rdx );
-    TRACE( "  rsi=%016lx rdi=%016lx rbp=%016lx rsp=%016lx\n",
-           context->Rsi, context->Rdi, context->Rbp, context->Rsp );
-    TRACE( "   r8=%016lx  r9=%016lx r10=%016lx r11=%016lx\n",
-           context->R8, context->R9, context->R10, context->R11 );
-    TRACE( "  r12=%016lx r13=%016lx r14=%016lx r15=%016lx\n",
-           context->R12, context->R13, context->R14, context->R15 );
-
-    return STATUS_SUCCESS;
-}
-
-
-#ifdef HAVE_LIBUNWIND
-/***********************************************************************
- *           libunwind_virtual_unwind
- *
- * Equivalent of RtlVirtualUnwind for builtin modules.
- */
-static NTSTATUS libunwind_virtual_unwind( ULONG64 ip, ULONG64 *frame, CONTEXT *context,
-                                          PEXCEPTION_ROUTINE *handler, void **handler_data )
-{
-    unw_context_t unw_context;
-    unw_cursor_t cursor;
-    unw_proc_info_t info;
-    int rc;
-
-#ifdef __APPLE__
-    rc = unw_getcontext( &unw_context );
-    if (rc == UNW_ESUCCESS)
-        rc = unw_init_local( &cursor, &unw_context );
-    if (rc == UNW_ESUCCESS)
-    {
-        unw_set_reg( &cursor, UNW_REG_IP,     context->Rip );
-        unw_set_reg( &cursor, UNW_REG_SP,     context->Rsp );
-        unw_set_reg( &cursor, UNW_X86_64_RAX, context->Rax );
-        unw_set_reg( &cursor, UNW_X86_64_RDX, context->Rdx );
-        unw_set_reg( &cursor, UNW_X86_64_RCX, context->Rcx );
-        unw_set_reg( &cursor, UNW_X86_64_RBX, context->Rbx );
-        unw_set_reg( &cursor, UNW_X86_64_RSI, context->Rsi );
-        unw_set_reg( &cursor, UNW_X86_64_RDI, context->Rdi );
-        unw_set_reg( &cursor, UNW_X86_64_RBP, context->Rbp );
-        unw_set_reg( &cursor, UNW_X86_64_R8,  context->R8 );
-        unw_set_reg( &cursor, UNW_X86_64_R9,  context->R9 );
-        unw_set_reg( &cursor, UNW_X86_64_R10, context->R10 );
-        unw_set_reg( &cursor, UNW_X86_64_R11, context->R11 );
-        unw_set_reg( &cursor, UNW_X86_64_R12, context->R12 );
-        unw_set_reg( &cursor, UNW_X86_64_R13, context->R13 );
-        unw_set_reg( &cursor, UNW_X86_64_R14, context->R14 );
-        unw_set_reg( &cursor, UNW_X86_64_R15, context->R15 );
-    }
-#else
-    RAX_sig(&unw_context) = context->Rax;
-    RCX_sig(&unw_context) = context->Rcx;
-    RDX_sig(&unw_context) = context->Rdx;
-    RBX_sig(&unw_context) = context->Rbx;
-    RSP_sig(&unw_context) = context->Rsp;
-    RBP_sig(&unw_context) = context->Rbp;
-    RSI_sig(&unw_context) = context->Rsi;
-    RDI_sig(&unw_context) = context->Rdi;
-    R8_sig(&unw_context)  = context->R8;
-    R9_sig(&unw_context)  = context->R9;
-    R10_sig(&unw_context) = context->R10;
-    R11_sig(&unw_context) = context->R11;
-    R12_sig(&unw_context) = context->R12;
-    R13_sig(&unw_context) = context->R13;
-    R14_sig(&unw_context) = context->R14;
-    R15_sig(&unw_context) = context->R15;
-    RIP_sig(&unw_context) = context->Rip;
-    CS_sig(&unw_context)  = context->SegCs;
-    FS_sig(&unw_context)  = context->SegFs;
-    GS_sig(&unw_context)  = context->SegGs;
-    EFL_sig(&unw_context) = context->EFlags;
-    rc = unw_init_local( &cursor, &unw_context );
-#endif
-    if (rc != UNW_ESUCCESS)
-    {
-        WARN( "setup failed: %d\n", rc );
-        return STATUS_INVALID_DISPOSITION;
-    }
-
-    *handler = NULL;
-    *frame = context->Rsp;
-
-    rc = unw_get_proc_info(&cursor, &info);
-    if (rc != UNW_ESUCCESS && rc != UNW_ENOINFO)
-    {
-        WARN( "failed to get info: %d\n", rc );
-        return STATUS_INVALID_DISPOSITION;
-    }
-    if (rc == UNW_ENOINFO || ip < info.start_ip || ip > info.end_ip || info.end_ip == info.start_ip + 1)
-        return STATUS_UNSUCCESSFUL;
-
-    TRACE( "ip %#lx function %#lx-%#lx personality %#lx lsda %#lx fde %#lx\n",
-           ip, (unsigned long)info.start_ip, (unsigned long)info.end_ip, (unsigned long)info.handler,
-           (unsigned long)info.lsda, (unsigned long)info.unwind_info );
-
-    if (!(rc = unw_step( &cursor )))
-    {
-        WARN( "last frame\n" );
-        return STATUS_UNSUCCESSFUL;
-    }
-    if (rc < 0)
-    {
-        WARN( "failed to unwind: %d\n", rc );
-        return STATUS_INVALID_DISPOSITION;
-    }
-
-    unw_get_reg( &cursor, UNW_REG_IP,     (unw_word_t *)&context->Rip );
-    unw_get_reg( &cursor, UNW_REG_SP,     (unw_word_t *)&context->Rsp );
-    unw_get_reg( &cursor, UNW_X86_64_RAX, (unw_word_t *)&context->Rax );
-    unw_get_reg( &cursor, UNW_X86_64_RDX, (unw_word_t *)&context->Rdx );
-    unw_get_reg( &cursor, UNW_X86_64_RCX, (unw_word_t *)&context->Rcx );
-    unw_get_reg( &cursor, UNW_X86_64_RBX, (unw_word_t *)&context->Rbx );
-    unw_get_reg( &cursor, UNW_X86_64_RSI, (unw_word_t *)&context->Rsi );
-    unw_get_reg( &cursor, UNW_X86_64_RDI, (unw_word_t *)&context->Rdi );
-    unw_get_reg( &cursor, UNW_X86_64_RBP, (unw_word_t *)&context->Rbp );
-    unw_get_reg( &cursor, UNW_X86_64_R8,  (unw_word_t *)&context->R8 );
-    unw_get_reg( &cursor, UNW_X86_64_R9,  (unw_word_t *)&context->R9 );
-    unw_get_reg( &cursor, UNW_X86_64_R10, (unw_word_t *)&context->R10 );
-    unw_get_reg( &cursor, UNW_X86_64_R11, (unw_word_t *)&context->R11 );
-    unw_get_reg( &cursor, UNW_X86_64_R12, (unw_word_t *)&context->R12 );
-    unw_get_reg( &cursor, UNW_X86_64_R13, (unw_word_t *)&context->R13 );
-    unw_get_reg( &cursor, UNW_X86_64_R14, (unw_word_t *)&context->R14 );
-    unw_get_reg( &cursor, UNW_X86_64_R15, (unw_word_t *)&context->R15 );
-    *handler = (void*)info.handler;
-    *handler_data = (void*)info.lsda;
-
-    TRACE( "next function rip=%016lx\n", context->Rip );
-    TRACE( "  rax=%016lx rbx=%016lx rcx=%016lx rdx=%016lx\n",
-           context->Rax, context->Rbx, context->Rcx, context->Rdx );
-    TRACE( "  rsi=%016lx rdi=%016lx rbp=%016lx rsp=%016lx\n",
-           context->Rsi, context->Rdi, context->Rbp, context->Rsp );
-    TRACE( "   r8=%016lx  r9=%016lx r10=%016lx r11=%016lx\n",
-           context->R8, context->R9, context->R10, context->R11 );
-    TRACE( "  r12=%016lx r13=%016lx r14=%016lx r15=%016lx\n",
-           context->R12, context->R13, context->R14, context->R15 );
-
-    return STATUS_SUCCESS;
-}
-#endif
-
-
-/***********************************************************************
- *           unwind_builtin_dll
- */
-NTSTATUS CDECL unwind_builtin_dll( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEXT *context )
-{
-    struct dwarf_eh_bases bases;
-    const struct dwarf_fde *fde = _Unwind_Find_FDE( (void *)(context->Rip - 1), &bases );
-
-    if (fde)
-        return dwarf_virtual_unwind( context->Rip, &dispatch->EstablisherFrame, context, fde,
-                                     &bases, &dispatch->LanguageHandler, &dispatch->HandlerData );
-#ifdef HAVE_LIBUNWIND
-    return libunwind_virtual_unwind( context->Rip, &dispatch->EstablisherFrame, context,
-                                     &dispatch->LanguageHandler, &dispatch->HandlerData );
-#endif
-    return STATUS_UNSUCCESSFUL;
-}
-
-
-static inline void set_sigcontext( const CONTEXT *context, ucontext_t *sigcontext )
-{
-    RAX_sig(sigcontext) = context->Rax;
-    RCX_sig(sigcontext) = context->Rcx;
-    RDX_sig(sigcontext) = context->Rdx;
-    RBX_sig(sigcontext) = context->Rbx;
-    RSP_sig(sigcontext) = context->Rsp;
-    RBP_sig(sigcontext) = context->Rbp;
-    RSI_sig(sigcontext) = context->Rsi;
-    RDI_sig(sigcontext) = context->Rdi;
-    R8_sig(sigcontext)  = context->R8;
-    R9_sig(sigcontext)  = context->R9;
-    R10_sig(sigcontext) = context->R10;
-    R11_sig(sigcontext) = context->R11;
-    R12_sig(sigcontext) = context->R12;
-    R13_sig(sigcontext) = context->R13;
-    R14_sig(sigcontext) = context->R14;
-    R15_sig(sigcontext) = context->R15;
-    RIP_sig(sigcontext) = context->Rip;
-    CS_sig(sigcontext)  = context->SegCs;
-    FS_sig(sigcontext)  = context->SegFs;
-    GS_sig(sigcontext)  = context->SegGs;
-    EFL_sig(sigcontext) = context->EFlags;
-#ifdef DS_sig
-    DS_sig(sigcontext) = context->SegDs;
-#endif
-#ifdef ES_sig
-    ES_sig(sigcontext) = context->SegEs;
-#endif
-#ifdef SS_sig
-    SS_sig(sigcontext) = context->SegSs;
-#endif
-}
-
-
-/***********************************************************************
- *           save_context
- *
- * Set the register values from a sigcontext.
- */
-static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
-{
-    context->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_DEBUG_REGISTERS;
-    context->Rax    = RAX_sig(sigcontext);
-    context->Rcx    = RCX_sig(sigcontext);
-    context->Rdx    = RDX_sig(sigcontext);
-    context->Rbx    = RBX_sig(sigcontext);
-    context->Rsp    = RSP_sig(sigcontext);
-    context->Rbp    = RBP_sig(sigcontext);
-    context->Rsi    = RSI_sig(sigcontext);
-    context->Rdi    = RDI_sig(sigcontext);
-    context->R8     = R8_sig(sigcontext);
-    context->R9     = R9_sig(sigcontext);
-    context->R10    = R10_sig(sigcontext);
-    context->R11    = R11_sig(sigcontext);
-    context->R12    = R12_sig(sigcontext);
-    context->R13    = R13_sig(sigcontext);
-    context->R14    = R14_sig(sigcontext);
-    context->R15    = R15_sig(sigcontext);
-    context->Rip    = RIP_sig(sigcontext);
-    context->SegCs  = CS_sig(sigcontext);
-    context->SegFs  = FS_sig(sigcontext);
-    context->SegGs  = GS_sig(sigcontext);
-    context->EFlags = EFL_sig(sigcontext);
-#ifdef DS_sig
-    context->SegDs  = DS_sig(sigcontext);
-#else
-    __asm__("movw %%ds,%0" : "=m" (context->SegDs));
-#endif
-#ifdef ES_sig
-    context->SegEs  = ES_sig(sigcontext);
-#else
-    __asm__("movw %%es,%0" : "=m" (context->SegEs));
-#endif
-#ifdef SS_sig
-    context->SegSs  = SS_sig(sigcontext);
-#else
-    __asm__("movw %%ss,%0" : "=m" (context->SegSs));
-#endif
-    context->Dr0    = amd64_thread_data()->dr0;
-    context->Dr1    = amd64_thread_data()->dr1;
-    context->Dr2    = amd64_thread_data()->dr2;
-    context->Dr3    = amd64_thread_data()->dr3;
-    context->Dr6    = amd64_thread_data()->dr6;
-    context->Dr7    = amd64_thread_data()->dr7;
-    if (FPU_sig(sigcontext))
-    {
-        context->ContextFlags |= CONTEXT_FLOATING_POINT;
-        context->u.FltSave = *FPU_sig(sigcontext);
-        context->MxCsr = context->u.FltSave.MxCsr;
-    }
-}
-
-
-/***********************************************************************
- *           restore_context
- *
- * Build a sigcontext from the register values.
- */
-static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
-{
-    amd64_thread_data()->dr0 = context->Dr0;
-    amd64_thread_data()->dr1 = context->Dr1;
-    amd64_thread_data()->dr2 = context->Dr2;
-    amd64_thread_data()->dr3 = context->Dr3;
-    amd64_thread_data()->dr6 = context->Dr6;
-    amd64_thread_data()->dr7 = context->Dr7;
-    set_sigcontext( context, sigcontext );
-    if (FPU_sig(sigcontext)) *FPU_sig(sigcontext) = context->u.FltSave;
-}
-
-
-/***********************************************************************
- *           set_full_cpu_context
- *
- * Set the new CPU context.
- */
-extern void set_full_cpu_context( const CONTEXT *context );
-__ASM_GLOBAL_FUNC( set_full_cpu_context,
-                   "subq $40,%rsp\n\t"
-                   __ASM_SEH(".seh_stackalloc 0x40\n\t")
-                   __ASM_SEH(".seh_endprologue\n\t")
-                   __ASM_CFI(".cfi_adjust_cfa_offset 40\n\t")
-                   "ldmxcsr 0x34(%rdi)\n\t"         /* context->MxCsr */
-                   "movw 0x38(%rdi),%ax\n\t"        /* context->SegCs */
-                   "movq %rax,8(%rsp)\n\t"
-                   "movw 0x42(%rdi),%ax\n\t"        /* context->SegSs */
-                   "movq %rax,32(%rsp)\n\t"
-                   "movq 0x44(%rdi),%rax\n\t"       /* context->Eflags */
-                   "movq %rax,16(%rsp)\n\t"
-                   "movq 0x80(%rdi),%rcx\n\t"       /* context->Rcx */
-                   "movq 0x88(%rdi),%rdx\n\t"       /* context->Rdx */
-                   "movq 0x90(%rdi),%rbx\n\t"       /* context->Rbx */
-                   "movq 0x98(%rdi),%rax\n\t"       /* context->Rsp */
-                   "movq %rax,24(%rsp)\n\t"
-                   "movq 0xa0(%rdi),%rbp\n\t"       /* context->Rbp */
-                   "movq 0xa8(%rdi),%rsi\n\t"       /* context->Rsi */
-                   "movq 0xb8(%rdi),%r8\n\t"        /* context->R8 */
-                   "movq 0xc0(%rdi),%r9\n\t"        /* context->R9 */
-                   "movq 0xc8(%rdi),%r10\n\t"       /* context->R10 */
-                   "movq 0xd0(%rdi),%r11\n\t"       /* context->R11 */
-                   "movq 0xd8(%rdi),%r12\n\t"       /* context->R12 */
-                   "movq 0xe0(%rdi),%r13\n\t"       /* context->R13 */
-                   "movq 0xe8(%rdi),%r14\n\t"       /* context->R14 */
-                   "movq 0xf0(%rdi),%r15\n\t"       /* context->R15 */
-                   "movq 0xf8(%rdi),%rax\n\t"       /* context->Rip */
-                   "movq %rax,(%rsp)\n\t"
-                   "fxrstor 0x100(%rdi)\n\t"        /* context->FtlSave */
-                   "movdqa 0x1a0(%rdi),%xmm0\n\t"   /* context->Xmm0 */
-                   "movdqa 0x1b0(%rdi),%xmm1\n\t"   /* context->Xmm1 */
-                   "movdqa 0x1c0(%rdi),%xmm2\n\t"   /* context->Xmm2 */
-                   "movdqa 0x1d0(%rdi),%xmm3\n\t"   /* context->Xmm3 */
-                   "movdqa 0x1e0(%rdi),%xmm4\n\t"   /* context->Xmm4 */
-                   "movdqa 0x1f0(%rdi),%xmm5\n\t"   /* context->Xmm5 */
-                   "movdqa 0x200(%rdi),%xmm6\n\t"   /* context->Xmm6 */
-                   "movdqa 0x210(%rdi),%xmm7\n\t"   /* context->Xmm7 */
-                   "movdqa 0x220(%rdi),%xmm8\n\t"   /* context->Xmm8 */
-                   "movdqa 0x230(%rdi),%xmm9\n\t"   /* context->Xmm9 */
-                   "movdqa 0x240(%rdi),%xmm10\n\t"  /* context->Xmm10 */
-                   "movdqa 0x250(%rdi),%xmm11\n\t"  /* context->Xmm11 */
-                   "movdqa 0x260(%rdi),%xmm12\n\t"  /* context->Xmm12 */
-                   "movdqa 0x270(%rdi),%xmm13\n\t"  /* context->Xmm13 */
-                   "movdqa 0x280(%rdi),%xmm14\n\t"  /* context->Xmm14 */
-                   "movdqa 0x290(%rdi),%xmm15\n\t"  /* context->Xmm15 */
-                   "movq 0x78(%rdi),%rax\n\t"       /* context->Rax */
-                   "movq 0xb0(%rdi),%rdi\n\t"       /* context->Rdi */
-                   "iretq" );
-
-
-/***********************************************************************
- *           get_server_context_flags
- *
- * Convert CPU-specific flags to generic server flags
- */
-static unsigned int get_server_context_flags( DWORD flags )
-{
-    unsigned int ret = 0;
-
-    flags &= ~CONTEXT_AMD64;  /* get rid of CPU id */
-    if (flags & CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
-    if (flags & CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
-    if (flags & CONTEXT_SEGMENTS) ret |= SERVER_CTX_SEGMENTS;
-    if (flags & CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
-    if (flags & CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
-    return ret;
-}
-
-
-/***********************************************************************
- *           context_to_server
- *
- * Convert a register context to the server format.
- */
-NTSTATUS context_to_server( context_t *to, const CONTEXT *from )
-{
-    DWORD flags = from->ContextFlags & ~CONTEXT_AMD64;  /* get rid of CPU id */
-
-    memset( to, 0, sizeof(*to) );
-    to->cpu = CPU_x86_64;
-
-    if (flags & CONTEXT_CONTROL)
-    {
-        to->flags |= SERVER_CTX_CONTROL;
-        to->ctl.x86_64_regs.rbp   = from->Rbp;
-        to->ctl.x86_64_regs.rip   = from->Rip;
-        to->ctl.x86_64_regs.rsp   = from->Rsp;
-        to->ctl.x86_64_regs.cs    = from->SegCs;
-        to->ctl.x86_64_regs.ss    = from->SegSs;
-        to->ctl.x86_64_regs.flags = from->EFlags;
-    }
-    if (flags & CONTEXT_INTEGER)
-    {
-        to->flags |= SERVER_CTX_INTEGER;
-        to->integer.x86_64_regs.rax = from->Rax;
-        to->integer.x86_64_regs.rcx = from->Rcx;
-        to->integer.x86_64_regs.rdx = from->Rdx;
-        to->integer.x86_64_regs.rbx = from->Rbx;
-        to->integer.x86_64_regs.rsi = from->Rsi;
-        to->integer.x86_64_regs.rdi = from->Rdi;
-        to->integer.x86_64_regs.r8  = from->R8;
-        to->integer.x86_64_regs.r9  = from->R9;
-        to->integer.x86_64_regs.r10 = from->R10;
-        to->integer.x86_64_regs.r11 = from->R11;
-        to->integer.x86_64_regs.r12 = from->R12;
-        to->integer.x86_64_regs.r13 = from->R13;
-        to->integer.x86_64_regs.r14 = from->R14;
-        to->integer.x86_64_regs.r15 = from->R15;
-    }
-    if (flags & CONTEXT_SEGMENTS)
-    {
-        to->flags |= SERVER_CTX_SEGMENTS;
-        to->seg.x86_64_regs.ds = from->SegDs;
-        to->seg.x86_64_regs.es = from->SegEs;
-        to->seg.x86_64_regs.fs = from->SegFs;
-        to->seg.x86_64_regs.gs = from->SegGs;
-    }
-    if (flags & CONTEXT_FLOATING_POINT)
-    {
-        to->flags |= SERVER_CTX_FLOATING_POINT;
-        memcpy( to->fp.x86_64_regs.fpregs, &from->u.FltSave, sizeof(to->fp.x86_64_regs.fpregs) );
-    }
-    if (flags & CONTEXT_DEBUG_REGISTERS)
-    {
-        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
-        to->debug.x86_64_regs.dr0 = from->Dr0;
-        to->debug.x86_64_regs.dr1 = from->Dr1;
-        to->debug.x86_64_regs.dr2 = from->Dr2;
-        to->debug.x86_64_regs.dr3 = from->Dr3;
-        to->debug.x86_64_regs.dr6 = from->Dr6;
-        to->debug.x86_64_regs.dr7 = from->Dr7;
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           context_from_server
- *
- * Convert a register context from the server format.
- */
-NTSTATUS context_from_server( CONTEXT *to, const context_t *from )
-{
-    if (from->cpu != CPU_x86_64) return STATUS_INVALID_PARAMETER;
-
-    to->ContextFlags = CONTEXT_AMD64;
-    if (from->flags & SERVER_CTX_CONTROL)
-    {
-        to->ContextFlags |= CONTEXT_CONTROL;
-        to->Rbp    = from->ctl.x86_64_regs.rbp;
-        to->Rip    = from->ctl.x86_64_regs.rip;
-        to->Rsp    = from->ctl.x86_64_regs.rsp;
-        to->SegCs  = from->ctl.x86_64_regs.cs;
-        to->SegSs  = from->ctl.x86_64_regs.ss;
-        to->EFlags = from->ctl.x86_64_regs.flags;
-    }
-
-    if (from->flags & SERVER_CTX_INTEGER)
-    {
-        to->ContextFlags |= CONTEXT_INTEGER;
-        to->Rax = from->integer.x86_64_regs.rax;
-        to->Rcx = from->integer.x86_64_regs.rcx;
-        to->Rdx = from->integer.x86_64_regs.rdx;
-        to->Rbx = from->integer.x86_64_regs.rbx;
-        to->Rsi = from->integer.x86_64_regs.rsi;
-        to->Rdi = from->integer.x86_64_regs.rdi;
-        to->R8  = from->integer.x86_64_regs.r8;
-        to->R9  = from->integer.x86_64_regs.r9;
-        to->R10 = from->integer.x86_64_regs.r10;
-        to->R11 = from->integer.x86_64_regs.r11;
-        to->R12 = from->integer.x86_64_regs.r12;
-        to->R13 = from->integer.x86_64_regs.r13;
-        to->R14 = from->integer.x86_64_regs.r14;
-        to->R15 = from->integer.x86_64_regs.r15;
-    }
-    if (from->flags & SERVER_CTX_SEGMENTS)
-    {
-        to->ContextFlags |= CONTEXT_SEGMENTS;
-        to->SegDs = from->seg.x86_64_regs.ds;
-        to->SegEs = from->seg.x86_64_regs.es;
-        to->SegFs = from->seg.x86_64_regs.fs;
-        to->SegGs = from->seg.x86_64_regs.gs;
-    }
-    if (from->flags & SERVER_CTX_FLOATING_POINT)
-    {
-        to->ContextFlags |= CONTEXT_FLOATING_POINT;
-        memcpy( &to->u.FltSave, from->fp.x86_64_regs.fpregs, sizeof(from->fp.x86_64_regs.fpregs) );
-        to->MxCsr = to->u.FltSave.MxCsr;
-    }
-    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
-    {
-        to->ContextFlags |= CONTEXT_DEBUG_REGISTERS;
-        to->Dr0 = from->debug.x86_64_regs.dr0;
-        to->Dr1 = from->debug.x86_64_regs.dr1;
-        to->Dr2 = from->debug.x86_64_regs.dr2;
-        to->Dr3 = from->debug.x86_64_regs.dr3;
-        to->Dr6 = from->debug.x86_64_regs.dr6;
-        to->Dr7 = from->debug.x86_64_regs.dr7;
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *              NtSetContextThread  (NTDLL.@)
- *              ZwSetContextThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
-{
-    NTSTATUS ret = STATUS_SUCCESS;
-    DWORD flags = context->ContextFlags & ~CONTEXT_AMD64;
-    BOOL self = (handle == GetCurrentThread());
-
-    /* debug registers require a server call */
-    if (self && (flags & CONTEXT_DEBUG_REGISTERS))
-        self = (amd64_thread_data()->dr0 == context->Dr0 &&
-                amd64_thread_data()->dr1 == context->Dr1 &&
-                amd64_thread_data()->dr2 == context->Dr2 &&
-                amd64_thread_data()->dr3 == context->Dr3 &&
-                amd64_thread_data()->dr6 == context->Dr6 &&
-                amd64_thread_data()->dr7 == context->Dr7);
-
-    if (!self)
-    {
-        context_t server_context;
-
-        context_to_server( &server_context, context );
-        ret = set_thread_context( handle, &server_context, &self );
-        if (ret || !self) return ret;
-        if (flags & CONTEXT_DEBUG_REGISTERS)
-        {
-            amd64_thread_data()->dr0 = context->Dr0;
-            amd64_thread_data()->dr1 = context->Dr1;
-            amd64_thread_data()->dr2 = context->Dr2;
-            amd64_thread_data()->dr3 = context->Dr3;
-            amd64_thread_data()->dr6 = context->Dr6;
-            amd64_thread_data()->dr7 = context->Dr7;
-        }
-    }
-
-    if (flags & CONTEXT_FULL)
-    {
-        if (!(flags & CONTEXT_CONTROL))
-            FIXME( "setting partial context (%x) not supported\n", flags );
-        else
-            set_full_cpu_context( context );
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *              NtGetContextThread  (NTDLL.@)
- *              ZwGetContextThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
-{
-    NTSTATUS ret;
-    DWORD needed_flags;
-    struct syscall_frame *frame = amd64_thread_data()->syscall_frame;
-    BOOL self = (handle == GetCurrentThread());
-
-    if (!context) return STATUS_INVALID_PARAMETER;
-
-    needed_flags = context->ContextFlags & ~CONTEXT_AMD64;
-
-    /* debug registers require a server call */
-    if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)) self = FALSE;
-
-    if (!self)
-    {
-        context_t server_context;
-        unsigned int server_flags = get_server_context_flags( context->ContextFlags );
-
-        if ((ret = get_thread_context( handle, &server_context, server_flags, &self ))) return ret;
-        if ((ret = context_from_server( context, &server_context ))) return ret;
-        needed_flags &= ~context->ContextFlags;
-    }
-
-    if (self)
-    {
-        if (needed_flags & CONTEXT_INTEGER)
-        {
-            context->Rax = 0;
-            context->Rbx = frame->rbx;
-            context->Rcx = 0;
-            context->Rdx = 0;
-            context->Rsi = frame->rsi;
-            context->Rdi = frame->rdi;
-            context->R8  = 0;
-            context->R9  = 0;
-            context->R10 = 0;
-            context->R11 = 0;
-            context->R12 = frame->r12;
-            context->R13 = frame->r13;
-            context->R14 = frame->r14;
-            context->R15 = frame->r15;
-            context->ContextFlags |= CONTEXT_INTEGER;
-        }
-        if (needed_flags & CONTEXT_CONTROL)
-        {
-            context->Rsp    = (ULONG64)&frame->ret_addr;
-            context->Rbp    = frame->rbp;
-            context->Rip    = frame->thunk_addr;
-            context->EFlags = 0x202;
-            __asm__( "movw %%cs,%0" : "=g" (context->SegCs) );
-            __asm__( "movw %%ss,%0" : "=g" (context->SegSs) );
-            context->ContextFlags |= CONTEXT_CONTROL;
-        }
-        if (needed_flags & CONTEXT_SEGMENTS)
-        {
-            __asm__( "movw %%ds,%0" : "=g" (context->SegDs) );
-            __asm__( "movw %%es,%0" : "=g" (context->SegEs) );
-            __asm__( "movw %%fs,%0" : "=g" (context->SegFs) );
-            __asm__( "movw %%gs,%0" : "=g" (context->SegGs) );
-            context->ContextFlags |= CONTEXT_SEGMENTS;
-        }
-        if (needed_flags & CONTEXT_FLOATING_POINT)
-        {
-            __asm__( "fxsave %0" : "=m" (context->u.FltSave) );
-            context->MxCsr = frame->mxcsr;
-            memset( &context->u.s.Xmm0, 0, 6 * sizeof(context->u.s.Xmm0) );
-            memcpy( &context->u.s.Xmm6, frame->xmm, 10 * sizeof(context->u.s.Xmm0) );
-            context->ContextFlags |= CONTEXT_FLOATING_POINT;
-        }
-        /* update the cached version of the debug registers */
-        if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64))
-        {
-            amd64_thread_data()->dr0 = context->Dr0;
-            amd64_thread_data()->dr1 = context->Dr1;
-            amd64_thread_data()->dr2 = context->Dr2;
-            amd64_thread_data()->dr3 = context->Dr3;
-            amd64_thread_data()->dr6 = context->Dr6;
-            amd64_thread_data()->dr7 = context->Dr7;
-        }
-    }
-    return STATUS_SUCCESS;
-}
-
-
-extern void CDECL raise_func_trampoline( void *dispatcher );
-
-__ASM_GLOBAL_FUNC( raise_func_trampoline,
-                   "jmpq *%r8\n\t")
-
-/***********************************************************************
- *           setup_raise_exception
- */
-static void setup_raise_exception( ucontext_t *sigcontext, EXCEPTION_RECORD *rec, CONTEXT *context )
-{
-    void *stack_ptr = (void *)(RSP_sig(sigcontext) & ~15);
-    struct stack_layout *stack;
-    NTSTATUS status;
-
-    if (rec->ExceptionCode == EXCEPTION_SINGLE_STEP)
-    {
-        /* when single stepping can't tell whether this is a hw bp or a
-         * single step interrupt. try to avoid as much overhead as possible
-         * and only do a server call if there is any hw bp enabled. */
-
-        if (!(context->EFlags & 0x100) || (context->Dr7 & 0xff))
-        {
-            /* (possible) hardware breakpoint, fetch the debug registers */
-            DWORD saved_flags = context->ContextFlags;
-            context->ContextFlags = CONTEXT_DEBUG_REGISTERS;
-            NtGetContextThread(GetCurrentThread(), context);
-            context->ContextFlags |= saved_flags;  /* restore flags */
-        }
-        context->EFlags &= ~0x100;  /* clear single-step flag */
-    }
-
-    status = send_debug_event( rec, context, TRUE );
-    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
-    {
-        restore_context( context, sigcontext );
-        return;
-    }
-
-    /* fix up instruction pointer in context for EXCEPTION_BREAKPOINT */
-    if (rec->ExceptionCode == EXCEPTION_BREAKPOINT) context->Rip--;
-
-    stack = virtual_setup_exception( stack_ptr, sizeof(*stack), rec );
-    stack->rec          = *rec;
-    stack->context      = *context;
-    RIP_sig(sigcontext) = (ULONG_PTR)raise_func_trampoline;
-    R8_sig(sigcontext)  = (ULONG_PTR)pKiUserExceptionDispatcher;
-    RSP_sig(sigcontext) = (ULONG_PTR)stack;
-    /* clear single-step, direction, and align check flag */
-    EFL_sig(sigcontext) &= ~(0x100|0x400|0x40000);
-}
-
-
-/***********************************************************************
- *           setup_exception
- *
- * Setup a proper stack frame for the raise function, and modify the
- * sigcontext so that the return from the signal handler will call
- * the raise function.
- */
-static void setup_exception( ucontext_t *sigcontext, EXCEPTION_RECORD *rec )
-{
-    CONTEXT context;
-
-    rec->ExceptionAddress = (void *)RIP_sig(sigcontext);
-    save_context( &context, sigcontext );
-    setup_raise_exception( sigcontext, rec, &context );
-}
-
-
-/***********************************************************************
- *           call_user_apc
- */
-void WINAPI call_user_apc( CONTEXT *context_ptr, ULONG_PTR ctx, ULONG_PTR arg1,
-                           ULONG_PTR arg2, PNTAPCFUNC func )
-{
-    CONTEXT context;
-
-    if (!context_ptr)
-    {
-        context.ContextFlags = CONTEXT_FULL;
-        NtGetContextThread( GetCurrentThread(), &context );
-        context.Rax = STATUS_USER_APC;
-        context_ptr = &context;
-    }
-    pKiUserApcDispatcher( context_ptr, ctx, arg1, arg2, func );
-}
-
-
-/***********************************************************************
- *           call_raise_user_exception_dispatcher
- */
-__ASM_GLOBAL_FUNC( call_raise_user_exception_dispatcher,
-                   "movq %gs:0x30,%rdx\n\t"
-                   "movq 0x328(%rdx),%rax\n\t"    /* amd64_thread_data()->syscall_frame */
-                   "pushq (%rax)\n\t"             /* frame->prev_frame */
-                   "popq 0x328(%rdx)\n\t"
-                   "movdqu 0x10(%rax),%xmm6\n\t"  /* frame->xmm[0..19 */
-                   "movdqu 0x20(%rax),%xmm7\n\t"
-                   "movdqu 0x30(%rax),%xmm8\n\t"
-                   "movdqu 0x40(%rax),%xmm9\n\t"
-                   "movdqu 0x50(%rax),%xmm10\n\t"
-                   "movdqu 0x60(%rax),%xmm11\n\t"
-                   "movdqu 0x70(%rax),%xmm12\n\t"
-                   "movdqu 0x80(%rax),%xmm13\n\t"
-                   "movdqu 0x90(%rax),%xmm14\n\t"
-                   "movdqu 0xa0(%rax),%xmm15\n\t"
-                   "ldmxcsr 0xb0(%rax)\n\t"       /* frame->mxcsr */
-                   "movq 0xb8(%rax),%r12\n\t"     /* frame->r12 */
-                   "movq 0xc0(%rax),%r13\n\t"     /* frame->r13 */
-                   "movq 0xc8(%rax),%r14\n\t"     /* frame->r14 */
-                   "movq 0xd0(%rax),%r15\n\t"     /* frame->r15 */
-                   "movq 0xd8(%rax),%rdi\n\t"     /* frame->rdi */
-                   "movq 0xe0(%rax),%rsi\n\t"     /* frame->rsi */
-                   "movq 0xe8(%rax),%rbx\n\t"     /* frame->rbx */
-                   "movq 0xf0(%rax),%rbp\n\t"     /* frame->rbp */
-                   "leaq 0x100(%rax),%rsp\n\t"
-                   "jmpq *%rcx" )
-
-
-/***********************************************************************
- *           call_user_exception_dispatcher
- */
-
-extern void WINAPI user_exception_dispatcher_trampoline( struct stack_layout *stack,
-        void *pKiUserExceptionDispatcher );
-
-__ASM_GLOBAL_FUNC( user_exception_dispatcher_trampoline,
-                   "movq %rcx,%rsp\n\t"
-                   "movq 0x98(%rsp),%rcx\n\t" /* context->Rsp */
-                   "movq 0xa0(%rsp),%rbp\n\t"
-                   "movq 0xa8(%rsp),%rsi\n\t"
-                   "movq 0xb0(%rsp),%rdi\n\t"
-                   "jmpq *%rdx")
-
-void WINAPI do_call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context,
-                                               NTSTATUS (WINAPI *dispatcher)(EXCEPTION_RECORD*,CONTEXT*),
-                                               struct stack_layout *stack )
-{
-    struct syscall_frame *frame = amd64_thread_data()->syscall_frame;
-
-    memmove(&stack->context, context, sizeof(*context));
-    memcpy(&stack->rec, rec, sizeof(*rec));
-
-    /* fix up instruction pointer in context for EXCEPTION_BREAKPOINT */
-    if (stack->rec.ExceptionCode == EXCEPTION_BREAKPOINT) stack->context.Rip--;
-
-    amd64_thread_data()->syscall_frame = frame->prev_frame;
-    user_exception_dispatcher_trampoline( stack, dispatcher );
-}
-
-__ASM_GLOBAL_FUNC( call_user_exception_dispatcher,
-                   "movq 0x98(%rdx),%r9\n\t" /* context->Rsp */
-                   "andq $~0xf,%r9\n\t"
-                   "subq $0x630,%r9\n\t" /* sizeof(struct stack_layout) */
-                   "cmpq %rsp,%r9\n\t"
-                   "cmovbq %r9,%rsp\n\t"
-                   "jmp " __ASM_NAME("do_call_user_exception_dispatcher") "\n\t")
-
-/***********************************************************************
- *           is_privileged_instr
- *
- * Check if the fault location is a privileged instruction.
- */
-static inline DWORD is_privileged_instr( CONTEXT *context )
-{
-    BYTE instr[16];
-    unsigned int i, prefix_count = 0;
-    unsigned int len = virtual_uninterrupted_read_memory( (BYTE *)context->Rip, instr, sizeof(instr) );
-
-    for (i = 0; i < len; i++) switch (instr[i])
-    {
-    /* instruction prefixes */
-    case 0x2e:  /* %cs: */
-    case 0x36:  /* %ss: */
-    case 0x3e:  /* %ds: */
-    case 0x26:  /* %es: */
-    case 0x40:  /* rex */
-    case 0x41:  /* rex */
-    case 0x42:  /* rex */
-    case 0x43:  /* rex */
-    case 0x44:  /* rex */
-    case 0x45:  /* rex */
-    case 0x46:  /* rex */
-    case 0x47:  /* rex */
-    case 0x48:  /* rex */
-    case 0x49:  /* rex */
-    case 0x4a:  /* rex */
-    case 0x4b:  /* rex */
-    case 0x4c:  /* rex */
-    case 0x4d:  /* rex */
-    case 0x4e:  /* rex */
-    case 0x4f:  /* rex */
-    case 0x64:  /* %fs: */
-    case 0x65:  /* %gs: */
-    case 0x66:  /* opcode size */
-    case 0x67:  /* addr size */
-    case 0xf0:  /* lock */
-    case 0xf2:  /* repne */
-    case 0xf3:  /* repe */
-        if (++prefix_count >= 15) return EXCEPTION_ILLEGAL_INSTRUCTION;
-        continue;
-
-    case 0x0f: /* extended instruction */
-        if (i == len - 1) return 0;
-        switch (instr[i + 1])
-        {
-        case 0x06: /* clts */
-        case 0x08: /* invd */
-        case 0x09: /* wbinvd */
-        case 0x20: /* mov crX, reg */
-        case 0x21: /* mov drX, reg */
-        case 0x22: /* mov reg, crX */
-        case 0x23: /* mov reg drX */
-            return EXCEPTION_PRIV_INSTRUCTION;
-        }
-        return 0;
-    case 0x6c: /* insb (%dx) */
-    case 0x6d: /* insl (%dx) */
-    case 0x6e: /* outsb (%dx) */
-    case 0x6f: /* outsl (%dx) */
-    case 0xcd: /* int $xx */
-    case 0xe4: /* inb al,XX */
-    case 0xe5: /* in (e)ax,XX */
-    case 0xe6: /* outb XX,al */
-    case 0xe7: /* out XX,(e)ax */
-    case 0xec: /* inb (%dx),%al */
-    case 0xed: /* inl (%dx),%eax */
-    case 0xee: /* outb %al,(%dx) */
-    case 0xef: /* outl %eax,(%dx) */
-    case 0xf4: /* hlt */
-    case 0xfa: /* cli */
-    case 0xfb: /* sti */
-        return EXCEPTION_PRIV_INSTRUCTION;
-    default:
-        return 0;
-    }
-    return 0;
-}
-
-
-/***********************************************************************
- *           handle_interrupt
- *
- * Handle an interrupt.
- */
-static inline BOOL handle_interrupt( ucontext_t *sigcontext, EXCEPTION_RECORD *rec, CONTEXT *context )
-{
-    switch (ERROR_sig(sigcontext) >> 3)
-    {
-    case 0x2c:
-        rec->ExceptionCode = STATUS_ASSERTION_FAILURE;
-        break;
-    case 0x2d:
-        switch (context->Rax)
-        {
-            case 1: /* BREAKPOINT_PRINT */
-            case 3: /* BREAKPOINT_LOAD_SYMBOLS */
-            case 4: /* BREAKPOINT_UNLOAD_SYMBOLS */
-            case 5: /* BREAKPOINT_COMMAND_STRING (>= Win2003) */
-                RIP_sig(sigcontext) += 3;
-                return TRUE;
-        }
-        context->Rip += 3;
-        rec->ExceptionCode = EXCEPTION_BREAKPOINT;
-        rec->ExceptionAddress = (void *)context->Rip;
-        rec->NumberParameters = 1;
-        rec->ExceptionInformation[0] = context->Rax;
-        break;
-    default:
-        return FALSE;
-    }
-    setup_raise_exception( sigcontext, rec, context );
-    return TRUE;
-}
-
-
-/**********************************************************************
- *		segv_handler
- *
- * Handler for SIGSEGV and related errors.
- */
-static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-    CONTEXT context;
-    ucontext_t *ucontext = sigcontext;
-
-    rec.ExceptionAddress = (void *)RIP_sig(ucontext);
-    save_context( &context, sigcontext );
-
-    switch(TRAP_sig(ucontext))
-    {
-    case TRAP_x86_OFLOW:   /* Overflow exception */
-        rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
-        break;
-    case TRAP_x86_BOUND:   /* Bound range exception */
-        rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
-        break;
-    case TRAP_x86_PRIVINFLT:   /* Invalid opcode exception */
-        rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
-        break;
-    case TRAP_x86_STKFLT:  /* Stack fault */
-        rec.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
-        break;
-    case TRAP_x86_SEGNPFLT:  /* Segment not present exception */
-    case TRAP_x86_PROTFLT:   /* General protection fault */
-        {
-            WORD err = ERROR_sig(ucontext);
-            if (!err && (rec.ExceptionCode = is_privileged_instr( &context ))) break;
-            if ((err & 7) == 2 && handle_interrupt( ucontext, &rec, &context )) return;
-            rec.ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
-            rec.NumberParameters = 2;
-            rec.ExceptionInformation[0] = 0;
-            rec.ExceptionInformation[1] = 0xffffffffffffffff;
-        }
-        break;
-    case TRAP_x86_PAGEFLT:  /* Page fault */
-        rec.NumberParameters = 2;
-        rec.ExceptionInformation[0] = (ERROR_sig(ucontext) >> 1) & 0x09;
-        rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
-        rec.ExceptionCode = virtual_handle_fault( siginfo->si_addr, rec.ExceptionInformation[0],
-                                                  (void *)RSP_sig(ucontext) );
-        if (!rec.ExceptionCode) return;
-        break;
-    case TRAP_x86_ALIGNFLT:  /* Alignment check exception */
-        rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
-        break;
-    default:
-        ERR( "Got unexpected trap %ld\n", (ULONG_PTR)TRAP_sig(ucontext) );
-        /* fall through */
-    case TRAP_x86_NMI:       /* NMI interrupt */
-    case TRAP_x86_DNA:       /* Device not available exception */
-    case TRAP_x86_DOUBLEFLT: /* Double fault exception */
-    case TRAP_x86_TSSFLT:    /* Invalid TSS exception */
-    case TRAP_x86_MCHK:      /* Machine check exception */
-    case TRAP_x86_CACHEFLT:  /* Cache flush exception */
-        rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
-        break;
-    }
-    setup_raise_exception( sigcontext, &rec, &context );
-}
-
-
-/**********************************************************************
- *		trap_handler
- *
- * Handler for SIGTRAP.
- */
-static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-    CONTEXT context;
-    ucontext_t *ucontext = sigcontext;
-
-    rec.ExceptionAddress = (void *)RIP_sig(ucontext);
-    save_context( &context, sigcontext );
-
-    switch (siginfo->si_code)
-    {
-    case TRAP_TRACE:  /* Single-step exception */
-    case 4 /* TRAP_HWBKPT */: /* Hardware breakpoint exception */
-        rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
-        break;
-    case TRAP_BRKPT:   /* Breakpoint exception */
-#ifdef SI_KERNEL
-    case SI_KERNEL:
-#endif
-        /* Check if this is actually icebp instruction */
-        if (((unsigned char *)RIP_sig(ucontext))[-1] == 0xF1)
-        {
-            rec.ExceptionCode = EXCEPTION_SINGLE_STEP;
-            break;
-        }
-        rec.ExceptionAddress = (char *)rec.ExceptionAddress - 1;  /* back up over the int3 instruction */
-        /* fall through */
-    default:
-        rec.ExceptionCode = EXCEPTION_BREAKPOINT;
-        rec.NumberParameters = 1;
-        rec.ExceptionInformation[0] = 0;
-        break;
-    }
-    setup_raise_exception( sigcontext, &rec, &context );
-}
-
-
-/**********************************************************************
- *		fpe_handler
- *
- * Handler for SIGFPE.
- */
-static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { 0 };
-
-    switch (siginfo->si_code)
-    {
-    case FPE_FLTSUB:
-        rec.ExceptionCode = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
-        break;
-    case FPE_INTDIV:
-        rec.ExceptionCode = EXCEPTION_INT_DIVIDE_BY_ZERO;
-        break;
-    case FPE_INTOVF:
-        rec.ExceptionCode = EXCEPTION_INT_OVERFLOW;
-        break;
-    case FPE_FLTDIV:
-        rec.ExceptionCode = EXCEPTION_FLT_DIVIDE_BY_ZERO;
-        break;
-    case FPE_FLTOVF:
-        rec.ExceptionCode = EXCEPTION_FLT_OVERFLOW;
-        break;
-    case FPE_FLTUND:
-        rec.ExceptionCode = EXCEPTION_FLT_UNDERFLOW;
-        break;
-    case FPE_FLTRES:
-        rec.ExceptionCode = EXCEPTION_FLT_INEXACT_RESULT;
-        break;
-    case FPE_FLTINV:
-    default:
-        rec.ExceptionCode = EXCEPTION_FLT_INVALID_OPERATION;
-        break;
-    }
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		int_handler
- *
- * Handler for SIGINT.
- */
-static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { CONTROL_C_EXIT };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		abrt_handler
- *
- * Handler for SIGABRT.
- */
-static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
-{
-    EXCEPTION_RECORD rec = { EXCEPTION_WINE_ASSERTION, EH_NONCONTINUABLE };
-
-    setup_exception( sigcontext, &rec );
-}
-
-
-/**********************************************************************
- *		quit_handler
- *
- * Handler for SIGQUIT.
- */
-static void quit_handler( int signal, siginfo_t *siginfo, void *ucontext )
-{
-    abort_thread(0);
-}
-
-
-/**********************************************************************
- *		usr1_handler
- *
- * Handler for SIGUSR1, used to signal a thread that it got suspended.
- */
-static void usr1_handler( int signal, siginfo_t *siginfo, void *ucontext )
-{
-    CONTEXT context;
-
-    save_context( &context, ucontext );
-    wait_suspend( &context );
-    restore_context( &context, ucontext );
-}
-
-
-/**********************************************************************
- *           get_thread_ldt_entry
- */
-NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *           NtSetLdtEntries   (NTDLL.@)
- *           ZwSetLdtEntries   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_ENTRY entry2 )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/**********************************************************************
- *             signal_init_threading
- */
-void signal_init_threading(void)
-{
-}
-
-
-/**********************************************************************
- *		signal_alloc_thread
- */
-NTSTATUS signal_alloc_thread( TEB *teb )
-{
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *		signal_free_thread
- */
-void signal_free_thread( TEB *teb )
-{
-}
-
-#ifdef __APPLE__
-/**********************************************************************
- *		mac_thread_gsbase
- */
-static void *mac_thread_gsbase(void)
-{
-    struct thread_identifier_info tiinfo;
-    unsigned int info_count = THREAD_IDENTIFIER_INFO_COUNT;
-    static int gsbase_offset = -1;
-
-    kern_return_t kr = thread_info(mach_thread_self(), THREAD_IDENTIFIER_INFO, (thread_info_t) &tiinfo, &info_count);
-    if (kr == KERN_SUCCESS) return (void*)tiinfo.thread_handle;
-
-    if (gsbase_offset < 0)
-    {
-        /* Search for the array of TLS slots within the pthread data structure.
-           That's what the macOS pthread implementation uses for gsbase. */
-        const void* const sentinel1 = (const void*)0x2bffb6b4f11228ae;
-        const void* const sentinel2 = (const void*)0x0845a7ff6ab76707;
-        int rc;
-        pthread_key_t key;
-        const void** p = (const void**)pthread_self();
-        int i;
-
-        gsbase_offset = 0;
-        if ((rc = pthread_key_create(&key, NULL))) return NULL;
-
-        pthread_setspecific(key, sentinel1);
-
-        for (i = key + 1; i < 2000; i++) /* arbitrary limit */
-        {
-            if (p[i] == sentinel1)
-            {
-                pthread_setspecific(key, sentinel2);
-
-                if (p[i] == sentinel2)
-                {
-                    gsbase_offset = (i - key) * sizeof(*p);
-                    break;
-                }
-
-                pthread_setspecific(key, sentinel1);
-            }
-        }
-
-        pthread_key_delete(key);
-    }
-
-    if (gsbase_offset) return (char*)pthread_self() + gsbase_offset;
-    return NULL;
-}
-#endif
-
-
-/**********************************************************************
- *		signal_init_thread
- */
-void signal_init_thread( TEB *teb )
-{
-    const WORD fpu_cw = 0x27f;
-
-#if defined __linux__
-    arch_prctl( ARCH_SET_GS, teb );
-#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
-    amd64_set_gsbase( teb );
-#elif defined(__NetBSD__)
-    sysarch( X86_64_SET_GSBASE, &teb );
-#elif defined (__APPLE__)
-    __asm__ volatile (".byte 0x65\n\tmovq %0,%c1"
-                      :
-                      : "r" (teb->Tib.Self), "n" (FIELD_OFFSET(TEB, Tib.Self)));
-    __asm__ volatile (".byte 0x65\n\tmovq %0,%c1"
-                      :
-                      : "r" (teb->ThreadLocalStoragePointer), "n" (FIELD_OFFSET(TEB, ThreadLocalStoragePointer)));
-
-    /* alloc_tls_slot() needs to poke a value to an address relative to each
-       thread's gsbase.  Have each thread record its gsbase pointer into its
-       TEB so alloc_tls_slot() can find it. */
-    teb->Reserved5[0] = mac_thread_gsbase();
-#else
-# error Please define setting %gs for your architecture
-#endif
-
-#ifdef __GNUC__
-    __asm__ volatile ("fninit; fldcw %0" : : "m" (fpu_cw));
-#else
-    FIXME("FPU setup not implemented for this platform.\n");
-#endif
-}
-
-
-/**********************************************************************
- *		signal_init_process
- */
-void signal_init_process(void)
-{
-    struct sigaction sig_act;
-
-    sig_act.sa_mask = server_block_set;
-    sig_act.sa_flags = SA_SIGINFO | SA_RESTART | SA_ONSTACK;
-
-    sig_act.sa_sigaction = int_handler;
-    if (sigaction( SIGINT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = fpe_handler;
-    if (sigaction( SIGFPE, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = abrt_handler;
-    if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = quit_handler;
-    if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = trap_handler;
-    if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = segv_handler;
-    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
-    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
-    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
-    return;
-
- error:
-    perror("sigaction");
-    exit(1);
-}
-
-
-/***********************************************************************
- *           init_thread_context
- */
-static void init_thread_context( CONTEXT *context, LPTHREAD_START_ROUTINE entry, void *arg, void *relay )
-{
-    __asm__( "movw %%cs,%0" : "=m" (context->SegCs) );
-    __asm__( "movw %%ss,%0" : "=m" (context->SegSs) );
-    context->Rcx    = (ULONG_PTR)entry;
-    context->Rdx    = (ULONG_PTR)arg;
-    context->Rsp    = (ULONG_PTR)NtCurrentTeb()->Tib.StackBase - 0x28;
-    context->Rip    = (ULONG_PTR)relay;
-    context->EFlags = 0x200;
-    context->u.FltSave.ControlWord = 0x27f;
-    context->u.FltSave.MxCsr = context->MxCsr = 0x1f80;
-}
-
-
-/***********************************************************************
- *           attach_thread
- */
-PCONTEXT DECLSPEC_HIDDEN attach_thread( LPTHREAD_START_ROUTINE entry, void *arg,
-                                        BOOL suspend, void *relay )
-{
-    CONTEXT *ctx;
-
-    if (suspend)
-    {
-        CONTEXT context = { 0 };
-
-        context.ContextFlags = CONTEXT_ALL;
-        init_thread_context( &context, entry, arg, relay );
-        wait_suspend( &context );
-        ctx = (CONTEXT *)((ULONG_PTR)context.Rsp & ~15) - 1;
-        *ctx = context;
-    }
-    else
-    {
-        ctx = (CONTEXT *)((char *)NtCurrentTeb()->Tib.StackBase - 0x30) - 1;
-        init_thread_context( ctx, entry, arg, relay );
-    }
-    pthread_sigmask( SIG_UNBLOCK, &server_block_set, NULL );
-    ctx->ContextFlags = CONTEXT_FULL;
-    pLdrInitializeThunk( ctx, (void **)&ctx->Rcx, 0, 0 );
-    return ctx;
-}
-
-
-/***********************************************************************
- *           signal_start_thread
- */
-__ASM_GLOBAL_FUNC( signal_start_thread,
-                   "subq $56,%rsp\n\t"
-                   __ASM_SEH(".seh_stackalloc 56\n\t")
-                   __ASM_SEH(".seh_endprologue\n\t")
-                   __ASM_CFI(".cfi_adjust_cfa_offset 56\n\t")
-                   "movq %rbp,48(%rsp)\n\t"
-                   __ASM_CFI(".cfi_rel_offset %rbp,48\n\t")
-                   "movq %rbx,40(%rsp)\n\t"
-                   __ASM_CFI(".cfi_rel_offset %rbx,40\n\t")
-                   "movq %r12,32(%rsp)\n\t"
-                   __ASM_CFI(".cfi_rel_offset %r12,32\n\t")
-                   "movq %r13,24(%rsp)\n\t"
-                   __ASM_CFI(".cfi_rel_offset %r13,24\n\t")
-                   "movq %r14,16(%rsp)\n\t"
-                   __ASM_CFI(".cfi_rel_offset %r14,16\n\t")
-                   "movq %r15,8(%rsp)\n\t"
-                   __ASM_CFI(".cfi_rel_offset %r15,8\n\t")
-                   /* store exit frame */
-                   "movq %gs:0x30,%rax\n\t"
-                   "movq %rsp,0x320(%rax)\n\t"      /* amd64_thread_data()->exit_frame */
-                   /* switch to thread stack */
-                   "movq 8(%rax),%rax\n\t"          /* NtCurrentTeb()->Tib.StackBase */
-                   "leaq -0x1000(%rax),%rsp\n\t"
-                   /* attach dlls */
-                   "call " __ASM_NAME("attach_thread") "\n\t"
-                   "movq %rax,%rbx\n\t"
-                   "leaq -32(%rax),%rsp\n\t"
-                   /* clear the stack */
-                   "andq $~0xfff,%rax\n\t"  /* round down to page size */
-                   "movq %rax,%rdi\n\t"
-                   "call " __ASM_NAME("virtual_clear_thread_stack") "\n\t"
-                   /* switch to the initial context */
-                   "movl $1,%edx\n\t"
-                   "movq %rbx,%rcx\n\t"
-                   "call " __ASM_NAME("NtContinue") )
-
-
-/***********************************************************************
- *           signal_exit_thread
- */
-__ASM_GLOBAL_FUNC( signal_exit_thread,
-                   /* fetch exit frame */
-                   "movq %gs:0x30,%rax\n\t"
-                   "movq 0x320(%rax),%rdx\n\t"      /* amd64_thread_data()->exit_frame */
-                   "testq %rdx,%rdx\n\t"
-                   "jnz 1f\n\t"
-                   "jmp *%rsi\n"
-                   /* switch to exit frame stack */
-                   "1:\tmovq $0,0x330(%rax)\n\t"
-                   "movq %rdx,%rsp\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset 56\n\t")
-                   __ASM_CFI(".cfi_rel_offset %rbp,48\n\t")
-                   __ASM_CFI(".cfi_rel_offset %rbx,40\n\t")
-                   __ASM_CFI(".cfi_rel_offset %r12,32\n\t")
-                   __ASM_CFI(".cfi_rel_offset %r13,24\n\t")
-                   __ASM_CFI(".cfi_rel_offset %r14,16\n\t")
-                   __ASM_CFI(".cfi_rel_offset %r15,8\n\t")
-                   "call *%rsi" )
-
-#endif  /* __x86_64__ */
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
deleted file mode 100644
index 23dca9c61b..0000000000
--- a/dlls/ntdll/unix/sync.c
+++ /dev/null
@@ -1,2773 +0,0 @@
-/*
- * Process synchronisation
- *
- * Copyright 1996, 1997, 1998 Marcus Meissner
- * Copyright 1997, 1999 Alexandre Julliard
- * Copyright 1999, 2000 Juergen Schmied
- * Copyright 2003 Eric Pouech
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <errno.h>
-#include <limits.h>
-#include <signal.h>
-#ifdef HAVE_SYS_SYSCALL_H
-#include <sys/syscall.h>
-#endif
-#ifdef HAVE_SYS_TIME_H
-# include <sys/time.h>
-#endif
-#ifdef HAVE_POLL_H
-#include <poll.h>
-#endif
-#ifdef HAVE_SYS_POLL_H
-# include <sys/poll.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef HAVE_SCHED_H
-# include <sched.h>
-#endif
-#include <string.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <time.h>
-#ifdef __APPLE__
-# include <mach/mach.h>
-# include <mach/task.h>
-# include <mach/semaphore.h>
-# include <mach/mach_time.h>
-#endif
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#define NONAMELESSUNION
-#include "windef.h"
-#include "winternl.h"
-#include "ddk/wdm.h"
-#include "wine/server.h"
-#include "wine/exception.h"
-#include "wine/debug.h"
-#include "unix_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(sync);
-
-HANDLE keyed_event = 0;
-
-static const LARGE_INTEGER zero_timeout;
-
-static pthread_mutex_t addr_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-/* return a monotonic time counter, in Win32 ticks */
-static inline ULONGLONG monotonic_counter(void)
-{
-    struct timeval now;
-#ifdef __APPLE__
-    static mach_timebase_info_data_t timebase;
-
-    if (!timebase.denom) mach_timebase_info( &timebase );
-#ifdef HAVE_MACH_CONTINUOUS_TIME
-    if (&mach_continuous_time != NULL)
-        return mach_continuous_time() * timebase.numer / timebase.denom / 100;
-#endif
-    return mach_absolute_time() * timebase.numer / timebase.denom / 100;
-#elif defined(HAVE_CLOCK_GETTIME)
-    struct timespec ts;
-#ifdef CLOCK_MONOTONIC_RAW
-    if (!clock_gettime( CLOCK_MONOTONIC_RAW, &ts ))
-        return ts.tv_sec * (ULONGLONG)TICKSPERSEC + ts.tv_nsec / 100;
-#endif
-    if (!clock_gettime( CLOCK_MONOTONIC, &ts ))
-        return ts.tv_sec * (ULONGLONG)TICKSPERSEC + ts.tv_nsec / 100;
-#endif
-    gettimeofday( &now, 0 );
-    return now.tv_sec * (ULONGLONG)TICKSPERSEC + now.tv_usec * 10 + TICKS_1601_TO_1970 - server_start_time;
-}
-
-
-#ifdef __linux__
-
-#define FUTEX_WAIT 0
-#define FUTEX_WAKE 1
-#define FUTEX_WAIT_BITSET 9
-#define FUTEX_WAKE_BITSET 10
-
-static int futex_private = 128;
-
-static inline int futex_wait( const int *addr, int val, struct timespec *timeout )
-{
-    return syscall( __NR_futex, addr, FUTEX_WAIT | futex_private, val, timeout, 0, 0 );
-}
-
-static inline int futex_wake( const int *addr, int val )
-{
-    return syscall( __NR_futex, addr, FUTEX_WAKE | futex_private, val, NULL, 0, 0 );
-}
-
-static inline int futex_wait_bitset( const int *addr, int val, struct timespec *timeout, int mask )
-{
-    return syscall( __NR_futex, addr, FUTEX_WAIT_BITSET | futex_private, val, timeout, 0, mask );
-}
-
-static inline int futex_wake_bitset( const int *addr, int val, int mask )
-{
-    return syscall( __NR_futex, addr, FUTEX_WAKE_BITSET | futex_private, val, NULL, 0, mask );
-}
-
-static inline int use_futexes(void)
-{
-    static int supported = -1;
-
-    if (supported == -1)
-    {
-        futex_wait( &supported, 10, NULL );
-        if (errno == ENOSYS)
-        {
-            futex_private = 0;
-            futex_wait( &supported, 10, NULL );
-        }
-        supported = (errno != ENOSYS);
-    }
-    return supported;
-}
-
-static int *get_futex(void **ptr)
-{
-    if (sizeof(void *) == 8)
-        return (int *)((((ULONG_PTR)ptr) + 3) & ~3);
-    else if (!(((ULONG_PTR)ptr) & 3))
-        return (int *)ptr;
-    else
-        return NULL;
-}
-
-static void timespec_from_timeout( struct timespec *timespec, const LARGE_INTEGER *timeout )
-{
-    LARGE_INTEGER now;
-    timeout_t diff;
-
-    if (timeout->QuadPart > 0)
-    {
-        NtQuerySystemTime( &now );
-        diff = timeout->QuadPart - now.QuadPart;
-    }
-    else
-        diff = -timeout->QuadPart;
-
-    timespec->tv_sec  = diff / TICKSPERSEC;
-    timespec->tv_nsec = (diff % TICKSPERSEC) * 100;
-}
-
-#endif
-
-
-static BOOL compare_addr( const void *addr, const void *cmp, SIZE_T size )
-{
-    switch (size)
-    {
-        case 1:
-            return (*(const UCHAR *)addr == *(const UCHAR *)cmp);
-        case 2:
-            return (*(const USHORT *)addr == *(const USHORT *)cmp);
-        case 4:
-            return (*(const ULONG *)addr == *(const ULONG *)cmp);
-        case 8:
-            return (*(const ULONG64 *)addr == *(const ULONG64 *)cmp);
-    }
-
-    return FALSE;
-}
-
-
-/* create a struct security_descriptor and contained information in one contiguous piece of memory */
-NTSTATUS alloc_object_attributes( const OBJECT_ATTRIBUTES *attr, struct object_attributes **ret,
-                                  data_size_t *ret_len )
-{
-    unsigned int len = sizeof(**ret);
-    SID *owner = NULL, *group = NULL;
-    ACL *dacl = NULL, *sacl = NULL;
-    SECURITY_DESCRIPTOR *sd;
-
-    *ret = NULL;
-    *ret_len = 0;
-
-    if (!attr) return STATUS_SUCCESS;
-
-    if (attr->Length != sizeof(*attr)) return STATUS_INVALID_PARAMETER;
-
-    if ((sd = attr->SecurityDescriptor))
-    {
-        len += sizeof(struct security_descriptor);
-	if (sd->Revision != SECURITY_DESCRIPTOR_REVISION) return STATUS_UNKNOWN_REVISION;
-        if (sd->Control & SE_SELF_RELATIVE)
-        {
-            SECURITY_DESCRIPTOR_RELATIVE *rel = (SECURITY_DESCRIPTOR_RELATIVE *)sd;
-            if (rel->Owner) owner = (PSID)((BYTE *)rel + rel->Owner);
-            if (rel->Group) group = (PSID)((BYTE *)rel + rel->Group);
-            if ((sd->Control & SE_SACL_PRESENT) && rel->Sacl) sacl = (PSID)((BYTE *)rel + rel->Sacl);
-            if ((sd->Control & SE_DACL_PRESENT) && rel->Dacl) dacl = (PSID)((BYTE *)rel + rel->Dacl);
-        }
-        else
-        {
-            owner = sd->Owner;
-            group = sd->Group;
-            if (sd->Control & SE_SACL_PRESENT) sacl = sd->Sacl;
-            if (sd->Control & SE_DACL_PRESENT) dacl = sd->Dacl;
-        }
-
-        if (owner) len += offsetof( SID, SubAuthority[owner->SubAuthorityCount] );
-        if (group) len += offsetof( SID, SubAuthority[group->SubAuthorityCount] );
-        if (sacl) len += sacl->AclSize;
-        if (dacl) len += dacl->AclSize;
-
-        /* fix alignment for the Unicode name that follows the structure */
-        len = (len + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1);
-    }
-
-    if (attr->ObjectName)
-    {
-        if (attr->ObjectName->Length & (sizeof(WCHAR) - 1)) return STATUS_OBJECT_NAME_INVALID;
-        len += attr->ObjectName->Length;
-    }
-    else if (attr->RootDirectory) return STATUS_OBJECT_NAME_INVALID;
-
-    len = (len + 3) & ~3;  /* DWORD-align the entire structure */
-
-    if (!(*ret = calloc( len, 1 ))) return STATUS_NO_MEMORY;
-
-    (*ret)->rootdir = wine_server_obj_handle( attr->RootDirectory );
-    (*ret)->attributes = attr->Attributes;
-
-    if (attr->SecurityDescriptor)
-    {
-        struct security_descriptor *descr = (struct security_descriptor *)(*ret + 1);
-        unsigned char *ptr = (unsigned char *)(descr + 1);
-
-        descr->control = sd->Control & ~SE_SELF_RELATIVE;
-        if (owner) descr->owner_len = offsetof( SID, SubAuthority[owner->SubAuthorityCount] );
-        if (group) descr->group_len = offsetof( SID, SubAuthority[group->SubAuthorityCount] );
-        if (sacl) descr->sacl_len = sacl->AclSize;
-        if (dacl) descr->dacl_len = dacl->AclSize;
-
-        memcpy( ptr, owner, descr->owner_len );
-        ptr += descr->owner_len;
-        memcpy( ptr, group, descr->group_len );
-        ptr += descr->group_len;
-        memcpy( ptr, sacl, descr->sacl_len );
-        ptr += descr->sacl_len;
-        memcpy( ptr, dacl, descr->dacl_len );
-        (*ret)->sd_len = (sizeof(*descr) + descr->owner_len + descr->group_len + descr->sacl_len +
-                          descr->dacl_len + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1);
-    }
-
-    if (attr->ObjectName)
-    {
-        unsigned char *ptr = (unsigned char *)(*ret + 1) + (*ret)->sd_len;
-        (*ret)->name_len = attr->ObjectName->Length;
-        memcpy( ptr, attr->ObjectName->Buffer, (*ret)->name_len );
-    }
-
-    *ret_len = len;
-    return STATUS_SUCCESS;
-}
-
-
-static NTSTATUS validate_open_object_attributes( const OBJECT_ATTRIBUTES *attr )
-{
-    if (!attr || attr->Length != sizeof(*attr)) return STATUS_INVALID_PARAMETER;
-
-    if (attr->ObjectName)
-    {
-        if (attr->ObjectName->Length & (sizeof(WCHAR) - 1)) return STATUS_OBJECT_NAME_INVALID;
-    }
-    else if (attr->RootDirectory) return STATUS_OBJECT_NAME_INVALID;
-
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtCreateSemaphore (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                                   LONG initial, LONG max )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_semaphore )
-    {
-        req->access  = access;
-        req->initial = initial;
-        req->max     = max;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtOpenSemaphore (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_semaphore )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtQuerySemaphore (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS class,
-                                  void *info, ULONG len, ULONG *ret_len )
-{
-    NTSTATUS ret;
-    SEMAPHORE_BASIC_INFORMATION *out = info;
-
-    TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
-
-    if (class != SemaphoreBasicInformation)
-    {
-        FIXME("(%p,%d,%u) Unknown class\n", handle, class, len);
-        return STATUS_INVALID_INFO_CLASS;
-    }
-
-    if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-
-    SERVER_START_REQ( query_semaphore )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (!(ret = wine_server_call( req )))
-        {
-            out->CurrentCount = reply->current;
-            out->MaximumCount = reply->max;
-            if (ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtReleaseSemaphore (NTDLL.@)
- */
-NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( release_semaphore )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->count  = count;
-        if (!(ret = wine_server_call( req )))
-        {
-            if (previous) *previous = reply->prev_count;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *              NtCreateEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                               EVENT_TYPE type, BOOLEAN state )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_event )
-    {
-        req->access = access;
-        req->manual_reset = (type == NotificationEvent);
-        req->initial_state = state;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtOpenEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_event )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtSetEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( event_op )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->op     = SET_EVENT;
-        ret = wine_server_call( req );
-        if (!ret && prev_state) *prev_state = reply->state;
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtResetEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( event_op )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->op     = RESET_EVENT;
-        ret = wine_server_call( req );
-        if (!ret && prev_state) *prev_state = reply->state;
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtClearEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtClearEvent( HANDLE handle )
-{
-    /* FIXME: same as NtResetEvent ??? */
-    return NtResetEvent( handle, NULL );
-}
-
-
-/******************************************************************************
- *              NtPulseEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( event_op )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->op     = PULSE_EVENT;
-        ret = wine_server_call( req );
-        if (!ret && prev_state) *prev_state = reply->state;
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtQueryEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
-                              void *info, ULONG len, ULONG *ret_len )
-{
-    NTSTATUS ret;
-    EVENT_BASIC_INFORMATION *out = info;
-
-    TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
-
-    if (class != EventBasicInformation)
-    {
-        FIXME("(%p, %d, %d) Unknown class\n",
-              handle, class, len);
-        return STATUS_INVALID_INFO_CLASS;
-    }
-
-    if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-
-    SERVER_START_REQ( query_event )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (!(ret = wine_server_call( req )))
-        {
-            out->EventType  = reply->manual_reset ? NotificationEvent : SynchronizationEvent;
-            out->EventState = reply->state;
-            if (ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtCreateMutant (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                                BOOLEAN owned )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_mutex )
-    {
-        req->access  = access;
-        req->owned   = owned;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return ret;
-}
-
-
-/**************************************************************************
- *              NtOpenMutant (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_mutex )
-    {
-        req->access  = access;
-        req->attributes = attr->Attributes;
-        req->rootdir = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *              NtReleaseMutant (NTDLL.@)
- */
-NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( release_mutex )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        ret = wine_server_call( req );
-        if (prev_count) *prev_count = 1 - reply->prev_count;
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************
- *              NtQueryMutant (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
-                               void *info, ULONG len, ULONG *ret_len )
-{
-    NTSTATUS ret;
-    MUTANT_BASIC_INFORMATION *out = info;
-
-    TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
-
-    if (class != MutantBasicInformation)
-    {
-        FIXME( "(%p, %d, %d) Unknown class\n", handle, class, len );
-        return STATUS_INVALID_INFO_CLASS;
-    }
-
-    if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-
-    SERVER_START_REQ( query_mutex )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (!(ret = wine_server_call( req )))
-        {
-            out->CurrentCount   = 1 - reply->count;
-            out->OwnedByCaller  = reply->owned;
-            out->AbandonedState = reply->abandoned;
-            if (ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtCreateJobObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateJobObject( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_job )
-    {
-        req->access = access;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtOpenJobObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenJobObject( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_job )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtTerminateJobObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p, %d)\n", handle, status );
-
-    SERVER_START_REQ( terminate_job )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->status = status;
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtQueryInformationJobObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, void *info,
-                                             ULONG len, ULONG *ret_len )
-{
-    NTSTATUS ret;
-
-    TRACE( "semi-stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
-
-    if (class >= MaxJobObjectInfoClass) return STATUS_INVALID_PARAMETER;
-
-    switch (class)
-    {
-    case JobObjectBasicAccountingInformation:
-    {
-        JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *accounting = info;
-
-        if (len < sizeof(*accounting)) return STATUS_INFO_LENGTH_MISMATCH;
-        SERVER_START_REQ(get_job_info)
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (!(ret = wine_server_call( req )))
-            {
-                memset( accounting, 0, sizeof(*accounting) );
-                accounting->TotalProcesses = reply->total_processes;
-                accounting->ActiveProcesses = reply->active_processes;
-            }
-        }
-        SERVER_END_REQ;
-        if (ret_len) *ret_len = sizeof(*accounting);
-        return ret;
-    }
-    case JobObjectBasicProcessIdList:
-    {
-        JOBOBJECT_BASIC_PROCESS_ID_LIST *process = info;
-
-        if (len < sizeof(*process)) return STATUS_INFO_LENGTH_MISMATCH;
-        memset( process, 0, sizeof(*process) );
-        if (ret_len) *ret_len = sizeof(*process);
-        return STATUS_SUCCESS;
-    }
-    case JobObjectExtendedLimitInformation:
-    {
-        JOBOBJECT_EXTENDED_LIMIT_INFORMATION *extended_limit = info;
-
-        if (len < sizeof(*extended_limit)) return STATUS_INFO_LENGTH_MISMATCH;
-        memset( extended_limit, 0, sizeof(*extended_limit) );
-        if (ret_len) *ret_len = sizeof(*extended_limit);
-        return STATUS_SUCCESS;
-    }
-    case JobObjectBasicLimitInformation:
-    {
-        JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit = info;
-
-        if (len < sizeof(*basic_limit)) return STATUS_INFO_LENGTH_MISMATCH;
-        memset( basic_limit, 0, sizeof(*basic_limit) );
-        if (ret_len) *ret_len = sizeof(*basic_limit);
-        return STATUS_SUCCESS;
-    }
-    default:
-        return STATUS_NOT_IMPLEMENTED;
-    }
-}
-
-
-/**************************************************************************
- *		NtSetInformationJobObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, void *info, ULONG len )
-{
-    NTSTATUS status = STATUS_NOT_IMPLEMENTED;
-    JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit;
-    ULONG info_size = sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION);
-    DWORD limit_flags = JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS;
-
-    TRACE( "(%p, %u, %p, %u)\n", handle, class, info, len );
-
-    if (class >= MaxJobObjectInfoClass) return STATUS_INVALID_PARAMETER;
-
-    switch (class)
-    {
-
-    case JobObjectExtendedLimitInformation:
-        info_size = sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION);
-        limit_flags = JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS;
-        /* fall through */
-    case JobObjectBasicLimitInformation:
-        if (len != info_size) return STATUS_INVALID_PARAMETER;
-        basic_limit = info;
-        if (basic_limit->LimitFlags & ~limit_flags) return STATUS_INVALID_PARAMETER;
-        SERVER_START_REQ( set_job_limits )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->limit_flags = basic_limit->LimitFlags;
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        break;
-    case JobObjectAssociateCompletionPortInformation:
-        if (len != sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT)) return STATUS_INVALID_PARAMETER;
-        SERVER_START_REQ( set_job_completion_port )
-        {
-            JOBOBJECT_ASSOCIATE_COMPLETION_PORT *port_info = info;
-            req->job = wine_server_obj_handle( handle );
-            req->port = wine_server_obj_handle( port_info->CompletionPort );
-            req->key = wine_server_client_ptr( port_info->CompletionKey );
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        break;
-    case JobObjectBasicUIRestrictions:
-        status = STATUS_SUCCESS;
-        /* fall through */
-    default:
-        FIXME( "stub: %p %u %p %u\n", handle, class, info, len );
-    }
-    return status;
-}
-
-
-/**************************************************************************
- *		NtIsProcessInJob (NTDLL.@)
- */
-NTSTATUS WINAPI NtIsProcessInJob( HANDLE process, HANDLE job )
-{
-    NTSTATUS status;
-
-    TRACE( "(%p %p)\n", job, process );
-
-    SERVER_START_REQ( process_in_job )
-    {
-        req->job     = wine_server_obj_handle( job );
-        req->process = wine_server_obj_handle( process );
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/**************************************************************************
- *		NtAssignProcessToJobObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtAssignProcessToJobObject( HANDLE job, HANDLE process )
-{
-    NTSTATUS status;
-
-    TRACE( "(%p %p)\n", job, process );
-
-    SERVER_START_REQ( assign_job )
-    {
-        req->job     = wine_server_obj_handle( job );
-        req->process = wine_server_obj_handle( process );
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/**************************************************************************
- *           NtCreateDirectoryObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateDirectoryObject( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if (!handle) return STATUS_ACCESS_VIOLATION;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_directory )
-    {
-        req->access = access;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    return ret;
-}
-
-
-/**************************************************************************
- *           NtOpenDirectoryObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenDirectoryObject( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if (!handle) return STATUS_ACCESS_VIOLATION;
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_directory )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *           NtQueryDirectoryObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryDirectoryObject( HANDLE handle, DIRECTORY_BASIC_INFORMATION *buffer,
-                                        ULONG size, BOOLEAN single_entry, BOOLEAN restart,
-                                        ULONG *context, ULONG *ret_size )
-{
-    NTSTATUS ret;
-
-    if (restart) *context = 0;
-
-    if (single_entry)
-    {
-        if (size <= sizeof(*buffer) + 2 * sizeof(WCHAR)) return STATUS_BUFFER_OVERFLOW;
-
-        SERVER_START_REQ( get_directory_entry )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->index = *context;
-            wine_server_set_reply( req, buffer + 1, size - sizeof(*buffer) - 2*sizeof(WCHAR) );
-            if (!(ret = wine_server_call( req )))
-            {
-                buffer->ObjectName.Buffer = (WCHAR *)(buffer + 1);
-                buffer->ObjectName.Length = reply->name_len;
-                buffer->ObjectName.MaximumLength = reply->name_len + sizeof(WCHAR);
-                buffer->ObjectTypeName.Buffer = (WCHAR *)(buffer + 1) + reply->name_len/sizeof(WCHAR) + 1;
-                buffer->ObjectTypeName.Length = wine_server_reply_size( reply ) - reply->name_len;
-                buffer->ObjectTypeName.MaximumLength = buffer->ObjectTypeName.Length + sizeof(WCHAR);
-                /* make room for the terminating null */
-                memmove( buffer->ObjectTypeName.Buffer, buffer->ObjectTypeName.Buffer - 1,
-                         buffer->ObjectTypeName.Length );
-                buffer->ObjectName.Buffer[buffer->ObjectName.Length/sizeof(WCHAR)] = 0;
-                buffer->ObjectTypeName.Buffer[buffer->ObjectTypeName.Length/sizeof(WCHAR)] = 0;
-                (*context)++;
-            }
-        }
-        SERVER_END_REQ;
-        if (ret_size)
-            *ret_size = buffer->ObjectName.MaximumLength + buffer->ObjectTypeName.MaximumLength + sizeof(*buffer);
-    }
-    else
-    {
-        FIXME("multiple entries not implemented\n");
-        ret = STATUS_NOT_IMPLEMENTED;
-    }
-    return ret;
-}
-
-
-/**************************************************************************
- *           NtCreateSymbolicLinkObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateSymbolicLinkObject( HANDLE *handle, ACCESS_MASK access,
-                                            OBJECT_ATTRIBUTES *attr, UNICODE_STRING *target )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if (!handle || !attr || !target) return STATUS_ACCESS_VIOLATION;
-    if (!target->Buffer) return STATUS_INVALID_PARAMETER;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_symlink )
-    {
-        req->access = access;
-        wine_server_add_data( req, objattr, len );
-        wine_server_add_data( req, target->Buffer, target->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    free( objattr );
-    return ret;
-}
-
-
-/**************************************************************************
- *           NtOpenSymbolicLinkObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenSymbolicLinkObject( HANDLE *handle, ACCESS_MASK access,
-                                          const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if (!handle) return STATUS_ACCESS_VIOLATION;
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_symlink )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *           NtQuerySymbolicLinkObject   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySymbolicLinkObject( HANDLE handle, UNICODE_STRING *target, ULONG *length )
-{
-    NTSTATUS ret;
-
-    if (!target) return STATUS_ACCESS_VIOLATION;
-
-    SERVER_START_REQ( query_symlink )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (target->MaximumLength >= sizeof(WCHAR))
-            wine_server_set_reply( req, target->Buffer, target->MaximumLength - sizeof(WCHAR) );
-        if (!(ret = wine_server_call( req )))
-        {
-            target->Length = wine_server_reply_size(reply);
-            target->Buffer[target->Length / sizeof(WCHAR)] = 0;
-            if (length) *length = reply->total + sizeof(WCHAR);
-        }
-        else if (length && ret == STATUS_BUFFER_TOO_SMALL) *length = reply->total + sizeof(WCHAR);
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtMakeTemporaryObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtMakeTemporaryObject( HANDLE handle )
-{
-    NTSTATUS ret;
-
-    TRACE("%p\n", handle);
-
-    SERVER_START_REQ( make_temporary )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtCreateTimer (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                               TIMER_TYPE type )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if (type != NotificationTimer && type != SynchronizationTimer) return STATUS_INVALID_PARAMETER;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_timer )
-    {
-        req->access  = access;
-        req->manual  = (type == NotificationTimer);
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return ret;
-
-}
-
-
-/**************************************************************************
- *		NtOpenTimer (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_timer )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtSetTimer (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetTimer( HANDLE handle, const LARGE_INTEGER *when, PTIMER_APC_ROUTINE callback,
-                            void *arg, BOOLEAN resume, ULONG period, BOOLEAN *state )
-{
-    NTSTATUS ret = STATUS_SUCCESS;
-
-    TRACE( "(%p,%p,%p,%p,%08x,0x%08x,%p)\n", handle, when, callback, arg, resume, period, state );
-
-    SERVER_START_REQ( set_timer )
-    {
-        req->handle   = wine_server_obj_handle( handle );
-        req->period   = period;
-        req->expire   = when->QuadPart;
-        req->callback = wine_server_client_ptr( callback );
-        req->arg      = wine_server_client_ptr( arg );
-        ret = wine_server_call( req );
-        if (state) *state = reply->signaled;
-    }
-    SERVER_END_REQ;
-
-    /* set error but can still succeed */
-    if (resume && ret == STATUS_SUCCESS) return STATUS_TIMER_RESUME_IGNORED;
-    return ret;
-}
-
-
-/**************************************************************************
- *		NtCancelTimer (NTDLL.@)
- */
-NTSTATUS WINAPI NtCancelTimer( HANDLE handle, BOOLEAN *state )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( cancel_timer )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        ret = wine_server_call( req );
-        if (state) *state = reply->signaled;
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *		NtQueryTimer (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryTimer( HANDLE handle, TIMER_INFORMATION_CLASS class,
-                              void *info, ULONG len, ULONG *ret_len )
-{
-    TIMER_BASIC_INFORMATION *basic_info = info;
-    NTSTATUS ret;
-    LARGE_INTEGER now;
-
-    TRACE( "(%p,%d,%p,0x%08x,%p)\n", handle, class, info, len, ret_len );
-
-    switch (class)
-    {
-    case TimerBasicInformation:
-        if (len < sizeof(TIMER_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-
-        SERVER_START_REQ( get_timer_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            ret = wine_server_call(req);
-            /* convert server time to absolute NTDLL time */
-            basic_info->RemainingTime.QuadPart = reply->when;
-            basic_info->TimerState = reply->signaled;
-        }
-        SERVER_END_REQ;
-
-        /* convert into relative time */
-        if (basic_info->RemainingTime.QuadPart > 0) NtQuerySystemTime( &now );
-        else
-        {
-            NtQueryPerformanceCounter( &now, NULL );
-            basic_info->RemainingTime.QuadPart = -basic_info->RemainingTime.QuadPart;
-        }
-
-        if (now.QuadPart > basic_info->RemainingTime.QuadPart)
-            basic_info->RemainingTime.QuadPart = 0;
-        else
-            basic_info->RemainingTime.QuadPart -= now.QuadPart;
-
-        if (ret_len) *ret_len = sizeof(TIMER_BASIC_INFORMATION);
-        return ret;
-    }
-
-    FIXME( "Unhandled class %d\n", class );
-    return STATUS_INVALID_INFO_CLASS;
-}
-
-
-/******************************************************************
- *		NtWaitForMultipleObjects (NTDLL.@)
- */
-NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
-                                          BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    select_op_t select_op;
-    UINT i, flags = SELECT_INTERRUPTIBLE;
-
-    if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
-
-    if (alertable) flags |= SELECT_ALERTABLE;
-    select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
-    for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-    return server_wait( &select_op, offsetof( select_op_t, wait.handles[count] ), flags, timeout );
-}
-
-
-/******************************************************************
- *		NtWaitForSingleObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtWaitForSingleObject( HANDLE handle, BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    return NtWaitForMultipleObjects( 1, &handle, FALSE, alertable, timeout );
-}
-
-
-/******************************************************************
- *		NtSignalAndWaitForSingleObject (NTDLL.@)
- */
-NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
-                                                BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    select_op_t select_op;
-    UINT flags = SELECT_INTERRUPTIBLE;
-
-    if (!signal) return STATUS_INVALID_HANDLE;
-
-    if (alertable) flags |= SELECT_ALERTABLE;
-    select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
-    select_op.signal_and_wait.wait = wine_server_obj_handle( wait );
-    select_op.signal_and_wait.signal = wine_server_obj_handle( signal );
-    return server_wait( &select_op, sizeof(select_op.signal_and_wait), flags, timeout );
-}
-
-
-/******************************************************************
- *		NtYieldExecution (NTDLL.@)
- */
-NTSTATUS WINAPI NtYieldExecution(void)
-{
-#ifdef HAVE_SCHED_YIELD
-    sched_yield();
-    return STATUS_SUCCESS;
-#else
-    return STATUS_NO_YIELD_PERFORMED;
-#endif
-}
-
-
-/******************************************************************
- *		NtDelayExecution (NTDLL.@)
- */
-NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    /* if alertable, we need to query the server */
-    if (alertable) return server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, timeout );
-
-    if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)  /* sleep forever */
-    {
-        for (;;) select( 0, NULL, NULL, NULL, NULL );
-    }
-    else
-    {
-        LARGE_INTEGER now;
-        timeout_t when, diff;
-
-        if ((when = timeout->QuadPart) < 0)
-        {
-            NtQuerySystemTime( &now );
-            when = now.QuadPart - when;
-        }
-
-        /* Note that we yield after establishing the desired timeout */
-        NtYieldExecution();
-        if (!when) return STATUS_SUCCESS;
-
-        for (;;)
-        {
-            struct timeval tv;
-            NtQuerySystemTime( &now );
-            diff = (when - now.QuadPart + 9) / 10;
-            if (diff <= 0) break;
-            tv.tv_sec  = diff / 1000000;
-            tv.tv_usec = diff % 1000000;
-            if (select( 0, NULL, NULL, NULL, &tv ) != -1) break;
-        }
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtQueryPerformanceCounter (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryPerformanceCounter( LARGE_INTEGER *counter, LARGE_INTEGER *frequency )
-{
-    __TRY
-    {
-        counter->QuadPart = monotonic_counter();
-        if (frequency) frequency->QuadPart = TICKSPERSEC;
-    }
-    __EXCEPT_PAGE_FAULT
-    {
-        return STATUS_ACCESS_VIOLATION;
-    }
-    __ENDTRY
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *              NtQuerySystemTime (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySystemTime( LARGE_INTEGER *time )
-{
-#ifdef HAVE_CLOCK_GETTIME
-    struct timespec ts;
-    static clockid_t clock_id = CLOCK_MONOTONIC; /* placeholder */
-
-    if (clock_id == CLOCK_MONOTONIC)
-    {
-#ifdef CLOCK_REALTIME_COARSE
-        struct timespec res;
-
-        /* Use CLOCK_REALTIME_COARSE if it has 1 ms or better resolution */
-        if (!clock_getres( CLOCK_REALTIME_COARSE, &res ) && res.tv_sec == 0 && res.tv_nsec <= 1000000)
-            clock_id = CLOCK_REALTIME_COARSE;
-        else
-#endif /* CLOCK_REALTIME_COARSE */
-            clock_id = CLOCK_REALTIME;
-    }
-
-    if (!clock_gettime( clock_id, &ts ))
-    {
-        time->QuadPart = ts.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
-        time->QuadPart += (ts.tv_nsec + 50) / 100;
-    }
-    else
-#endif /* HAVE_CLOCK_GETTIME */
-    {
-        struct timeval now;
-
-        gettimeofday( &now, 0 );
-        time->QuadPart = now.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
-        time->QuadPart += now.tv_usec * 10;
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *              NtSetSystemTime (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetSystemTime( const LARGE_INTEGER *new, LARGE_INTEGER *old )
-{
-    LARGE_INTEGER now;
-    LONGLONG diff;
-
-    NtQuerySystemTime( &now );
-    if (old) *old = now;
-    diff = new->QuadPart - now.QuadPart;
-    if (diff > -TICKSPERSEC / 2 && diff < TICKSPERSEC / 2) return STATUS_SUCCESS;
-    ERR( "not allowed: difference %d ms\n", (int)(diff / 10000) );
-    return STATUS_PRIVILEGE_NOT_HELD;
-}
-
-
-/***********************************************************************
- *              NtQueryTimerResolution (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryTimerResolution( ULONG *min_res, ULONG *max_res, ULONG *current_res )
-{
-    FIXME( "(%p,%p,%p), stub!\n", min_res, max_res, current_res );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *              NtSetTimerResolution (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetTimerResolution( ULONG res, BOOLEAN set, ULONG *current_res )
-{
-    FIXME( "(%u,%u,%p), stub!\n", res, set, current_res );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtSetIntervalProfile (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetIntervalProfile( ULONG interval, KPROFILE_SOURCE source )
-{
-    FIXME( "%u,%d\n", interval, source );
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtGetTickCount (NTDLL.@)
- */
-ULONG WINAPI NtGetTickCount(void)
-{
-    /* note: we ignore TickCountMultiplier */
-    return user_shared_data->u.TickCount.LowPart;
-}
-
-
-/******************************************************************************
- *              RtlGetSystemTimePrecise (NTDLL.@)
- */
-LONGLONG WINAPI RtlGetSystemTimePrecise(void)
-{
-    struct timeval now;
-#ifdef HAVE_CLOCK_GETTIME
-    struct timespec ts;
-
-    if (!clock_gettime( CLOCK_REALTIME, &ts ))
-        return ts.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970 + (ts.tv_nsec + 50) / 100;
-#endif
-    gettimeofday( &now, 0 );
-    return now.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970 + now.tv_usec * 10;
-}
-
-
-/******************************************************************************
- *              NtCreateKeyedEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateKeyedEvent( HANDLE *handle, ACCESS_MASK access,
-                                    const OBJECT_ATTRIBUTES *attr, ULONG flags )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_keyed_event )
-    {
-        req->access = access;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtOpenKeyedEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenKeyedEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_keyed_event )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-/******************************************************************************
- *              NtWaitForKeyedEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtWaitForKeyedEvent( HANDLE handle, const void *key,
-                                     BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    select_op_t select_op;
-    UINT flags = SELECT_INTERRUPTIBLE;
-
-    if (!handle) handle = keyed_event;
-    if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
-    if (alertable) flags |= SELECT_ALERTABLE;
-    select_op.keyed_event.op     = SELECT_KEYED_EVENT_WAIT;
-    select_op.keyed_event.handle = wine_server_obj_handle( handle );
-    select_op.keyed_event.key    = wine_server_client_ptr( key );
-    return server_wait( &select_op, sizeof(select_op.keyed_event), flags, timeout );
-}
-
-
-/******************************************************************************
- *              NtReleaseKeyedEvent (NTDLL.@)
- */
-NTSTATUS WINAPI NtReleaseKeyedEvent( HANDLE handle, const void *key,
-                                     BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    select_op_t select_op;
-    UINT flags = SELECT_INTERRUPTIBLE;
-
-    if (!handle) handle = keyed_event;
-    if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
-    if (alertable) flags |= SELECT_ALERTABLE;
-    select_op.keyed_event.op     = SELECT_KEYED_EVENT_RELEASE;
-    select_op.keyed_event.handle = wine_server_obj_handle( handle );
-    select_op.keyed_event.key    = wine_server_client_ptr( key );
-    return server_wait( &select_op, sizeof(select_op.keyed_event), flags, timeout );
-}
-
-
-/***********************************************************************
- *             NtCreateIoCompletion (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateIoCompletion( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
-                                      ULONG threads )
-{
-    NTSTATUS status;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    TRACE( "(%p, %x, %p, %d)\n", handle, access, attr, threads );
-
-    if (!handle) return STATUS_INVALID_PARAMETER;
-    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
-
-    SERVER_START_REQ( create_completion )
-    {
-        req->access     = access;
-        req->concurrent = threads;
-        wine_server_add_data( req, objattr, len );
-        if (!(status = wine_server_call( req ))) *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtOpenIoCompletion (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenIoCompletion( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS status;
-
-    if (!handle) return STATUS_INVALID_PARAMETER;
-    if ((status = validate_open_object_attributes( attr ))) return status;
-
-    SERVER_START_REQ( open_completion )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        status = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtSetIoCompletion (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetIoCompletion( HANDLE handle, ULONG_PTR key, ULONG_PTR value,
-                                   NTSTATUS status, SIZE_T count )
-{
-    NTSTATUS ret;
-
-    TRACE( "(%p, %lx, %lx, %x, %lx)\n", handle, key, value, status, count );
-
-    SERVER_START_REQ( add_completion )
-    {
-        req->handle      = wine_server_obj_handle( handle );
-        req->ckey        = key;
-        req->cvalue      = value;
-        req->status      = status;
-        req->information = count;
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/***********************************************************************
- *             NtRemoveIoCompletion (NTDLL.@)
- */
-NTSTATUS WINAPI NtRemoveIoCompletion( HANDLE handle, ULONG_PTR *key, ULONG_PTR *value,
-                                      IO_STATUS_BLOCK *io, LARGE_INTEGER *timeout )
-{
-    NTSTATUS status;
-
-    TRACE( "(%p, %p, %p, %p, %p)\n", handle, key, value, io, timeout );
-
-    for (;;)
-    {
-        SERVER_START_REQ( remove_completion )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (!(status = wine_server_call( req )))
-            {
-                *key            = reply->ckey;
-                *value          = reply->cvalue;
-                io->Information = reply->information;
-                io->u.Status    = reply->status;
-            }
-        }
-        SERVER_END_REQ;
-        if (status != STATUS_PENDING) return status;
-        status = NtWaitForSingleObject( handle, FALSE, timeout );
-        if (status != WAIT_OBJECT_0) return status;
-    }
-}
-
-
-/***********************************************************************
- *             NtRemoveIoCompletionEx (NTDLL.@)
- */
-NTSTATUS WINAPI NtRemoveIoCompletionEx( HANDLE handle, FILE_IO_COMPLETION_INFORMATION *info, ULONG count,
-                                        ULONG *written, LARGE_INTEGER *timeout, BOOLEAN alertable )
-{
-    NTSTATUS status;
-    ULONG i = 0;
-
-    TRACE( "%p %p %u %p %p %u\n", handle, info, count, written, timeout, alertable );
-
-    for (;;)
-    {
-        while (i < count)
-        {
-            SERVER_START_REQ( remove_completion )
-            {
-                req->handle = wine_server_obj_handle( handle );
-                if (!(status = wine_server_call( req )))
-                {
-                    info[i].CompletionKey             = reply->ckey;
-                    info[i].CompletionValue           = reply->cvalue;
-                    info[i].IoStatusBlock.Information = reply->information;
-                    info[i].IoStatusBlock.u.Status    = reply->status;
-                }
-            }
-            SERVER_END_REQ;
-            if (status != STATUS_SUCCESS) break;
-            ++i;
-        }
-        if (i || status != STATUS_PENDING)
-        {
-            if (status == STATUS_PENDING) status = STATUS_SUCCESS;
-            break;
-        }
-        status = NtWaitForSingleObject( handle, alertable, timeout );
-        if (status != WAIT_OBJECT_0) break;
-    }
-    *written = i ? i : 1;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtQueryIoCompletion (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryIoCompletion( HANDLE handle, IO_COMPLETION_INFORMATION_CLASS class,
-                                     void *buffer, ULONG len, ULONG *ret_len )
-{
-    NTSTATUS status;
-
-    TRACE( "(%p, %d, %p, 0x%x, %p)\n", handle, class, buffer, len, ret_len );
-
-    if (!buffer) return STATUS_INVALID_PARAMETER;
-
-    switch (class)
-    {
-    case IoCompletionBasicInformation:
-    {
-        ULONG *info = buffer;
-        if (ret_len) *ret_len = sizeof(*info);
-        if (len == sizeof(*info))
-        {
-            SERVER_START_REQ( query_completion )
-            {
-                req->handle = wine_server_obj_handle( handle );
-                if (!(status = wine_server_call( req ))) *info = reply->depth;
-            }
-            SERVER_END_REQ;
-        }
-        else status = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-    default:
-        return STATUS_INVALID_PARAMETER;
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *             NtCreateSection (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
-                                 const LARGE_INTEGER *size, ULONG protect,
-                                 ULONG sec_flags, HANDLE file )
-{
-    NTSTATUS ret;
-    unsigned int file_access;
-    data_size_t len;
-    struct object_attributes *objattr;
-
-    switch (protect & 0xff)
-    {
-    case PAGE_READONLY:
-    case PAGE_EXECUTE_READ:
-    case PAGE_WRITECOPY:
-    case PAGE_EXECUTE_WRITECOPY:
-        file_access = FILE_READ_DATA;
-        break;
-    case PAGE_READWRITE:
-    case PAGE_EXECUTE_READWRITE:
-        if (sec_flags & SEC_IMAGE) file_access = FILE_READ_DATA;
-        else file_access = FILE_READ_DATA | FILE_WRITE_DATA;
-        break;
-    case PAGE_EXECUTE:
-    case PAGE_NOACCESS:
-        file_access = 0;
-        break;
-    default:
-        return STATUS_INVALID_PAGE_PROTECTION;
-    }
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    SERVER_START_REQ( create_mapping )
-    {
-        req->access      = access;
-        req->flags       = sec_flags;
-        req->file_handle = wine_server_obj_handle( file );
-        req->file_access = file_access;
-        req->size        = size ? size->QuadPart : 0;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    return ret;
-}
-
-
-/***********************************************************************
- *             NtOpenSection (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-
-    if ((ret = validate_open_object_attributes( attr ))) return ret;
-
-    SERVER_START_REQ( open_mapping )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/***********************************************************************
- *             NtCreatePort (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreatePort( HANDLE *handle, OBJECT_ATTRIBUTES *attr, ULONG info_len,
-                              ULONG data_len, ULONG *reserved )
-{
-    FIXME( "(%p,%p,%u,%u,%p),stub!\n", handle, attr, info_len, data_len, reserved );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtConnectPort (NTDLL.@)
- */
-NTSTATUS WINAPI NtConnectPort( HANDLE *handle, UNICODE_STRING *name, SECURITY_QUALITY_OF_SERVICE *qos,
-                               LPC_SECTION_WRITE *write, LPC_SECTION_READ *read, ULONG *max_len,
-                               void *info, ULONG *info_len )
-{
-    FIXME( "(%p,%s,%p,%p,%p,%p,%p,%p),stub!\n", handle, debugstr_us(name), qos,
-           write, read, max_len, info, info_len );
-    if (info && info_len) TRACE("msg = %s\n", debugstr_an( info, *info_len ));
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtSecureConnectPort (NTDLL.@)
- */
-NTSTATUS WINAPI NtSecureConnectPort( HANDLE *handle, UNICODE_STRING *name, SECURITY_QUALITY_OF_SERVICE *qos,
-                                     LPC_SECTION_WRITE *write, PSID sid, LPC_SECTION_READ *read,
-                                     ULONG *max_len, void *info, ULONG *info_len )
-{
-    FIXME( "(%p,%s,%p,%p,%p,%p,%p,%p,%p),stub!\n", handle, debugstr_us(name), qos,
-           write, sid, read, max_len, info, info_len );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtListenPort (NTDLL.@)
- */
-NTSTATUS WINAPI NtListenPort( HANDLE handle, LPC_MESSAGE *msg )
-{
-    FIXME("(%p,%p),stub!\n", handle, msg );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtAcceptConnectPort (NTDLL.@)
- */
-NTSTATUS WINAPI NtAcceptConnectPort( HANDLE *handle, ULONG id, LPC_MESSAGE *msg, BOOLEAN accept,
-                                     LPC_SECTION_WRITE *write, LPC_SECTION_READ *read )
-{
-    FIXME("(%p,%u,%p,%d,%p,%p),stub!\n", handle, id, msg, accept, write, read );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtCompleteConnectPort (NTDLL.@)
- */
-NTSTATUS WINAPI NtCompleteConnectPort( HANDLE handle )
-{
-    FIXME( "(%p),stub!\n", handle );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtRegisterThreadTerminatePort (NTDLL.@)
- */
-NTSTATUS WINAPI NtRegisterThreadTerminatePort( HANDLE handle )
-{
-    FIXME( "(%p),stub!\n", handle );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtRequestWaitReplyPort (NTDLL.@)
- */
-NTSTATUS WINAPI NtRequestWaitReplyPort( HANDLE handle, LPC_MESSAGE *msg_in, LPC_MESSAGE *msg_out )
-{
-    FIXME( "(%p,%p,%p),stub!\n", handle, msg_in, msg_out );
-    if (msg_in)
-        TRACE("datasize %u msgsize %u type %u ranges %u client %p/%p msgid %lu size %lu data %s\n",
-              msg_in->DataSize, msg_in->MessageSize, msg_in->MessageType, msg_in->VirtualRangesOffset,
-              msg_in->ClientId.UniqueProcess, msg_in->ClientId.UniqueThread, msg_in->MessageId,
-              msg_in->SectionSize, debugstr_an( (const char *)msg_in->Data, msg_in->DataSize ));
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/***********************************************************************
- *             NtReplyWaitReceivePort (NTDLL.@)
- */
-NTSTATUS WINAPI NtReplyWaitReceivePort( HANDLE handle, ULONG *id, LPC_MESSAGE *reply, LPC_MESSAGE *msg )
-{
-    FIXME("(%p,%p,%p,%p),stub!\n", handle, id, reply, msg );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-#define MAX_ATOM_LEN  255
-#define IS_INTATOM(x) (((ULONG_PTR)(x) >> 16) == 0)
-
-static NTSTATUS is_integral_atom( const WCHAR *atomstr, ULONG len, RTL_ATOM *ret_atom )
-{
-    RTL_ATOM atom;
-
-    if ((ULONG_PTR)atomstr >> 16)
-    {
-        const WCHAR* ptr = atomstr;
-        if (!len) return STATUS_OBJECT_NAME_INVALID;
-
-        if (*ptr++ == '#')
-        {
-            atom = 0;
-            while (ptr < atomstr + len && *ptr >= '0' && *ptr <= '9')
-            {
-                atom = atom * 10 + *ptr++ - '0';
-            }
-            if (ptr > atomstr + 1 && ptr == atomstr + len) goto done;
-        }
-        if (len > MAX_ATOM_LEN) return STATUS_INVALID_PARAMETER;
-        return STATUS_MORE_ENTRIES;
-    }
-    else atom = LOWORD( atomstr );
-done:
-    if (!atom || atom >= MAXINTATOM) return STATUS_INVALID_PARAMETER;
-    *ret_atom = atom;
-    return STATUS_SUCCESS;
-}
-
-static ULONG integral_atom_name( WCHAR *buffer, ULONG len, RTL_ATOM atom )
-{
-    char tmp[16];
-    int ret = sprintf( tmp, "#%u", atom );
-
-    len /= sizeof(WCHAR);
-    if (len)
-    {
-        if (len <= ret) ret = len - 1;
-        ascii_to_unicode( buffer, tmp, ret );
-        buffer[ret] = 0;
-    }
-    return ret * sizeof(WCHAR);
-}
-
-
-/***********************************************************************
- *             NtAddAtom (NTDLL.@)
- */
-NTSTATUS WINAPI NtAddAtom( const WCHAR *name, ULONG length, RTL_ATOM *atom )
-{
-    NTSTATUS status = is_integral_atom( name, length / sizeof(WCHAR), atom );
-
-    if (status == STATUS_MORE_ENTRIES)
-    {
-        SERVER_START_REQ( add_atom )
-        {
-            wine_server_add_data( req, name, length );
-            req->table = 0;
-            status = wine_server_call( req );
-            *atom = reply->atom;
-        }
-        SERVER_END_REQ;
-    }
-    TRACE( "%s -> %x\n", debugstr_wn(name, length/sizeof(WCHAR)), status == STATUS_SUCCESS ? *atom : 0 );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtDeleteAtom (NTDLL.@)
- */
-NTSTATUS WINAPI NtDeleteAtom( RTL_ATOM atom )
-{
-    NTSTATUS status;
-
-    SERVER_START_REQ( delete_atom )
-    {
-        req->atom = atom;
-        req->table = 0;
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtFindAtom (NTDLL.@)
- */
-NTSTATUS WINAPI NtFindAtom( const WCHAR *name, ULONG length, RTL_ATOM *atom )
-{
-    NTSTATUS status = is_integral_atom( name, length / sizeof(WCHAR), atom );
-
-    if (status == STATUS_MORE_ENTRIES)
-    {
-        SERVER_START_REQ( find_atom )
-        {
-            wine_server_add_data( req, name, length );
-            req->table = 0;
-            status = wine_server_call( req );
-            *atom = reply->atom;
-        }
-        SERVER_END_REQ;
-    }
-    TRACE( "%s -> %x\n", debugstr_wn(name, length/sizeof(WCHAR)), status == STATUS_SUCCESS ? *atom : 0 );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtQueryInformationAtom (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryInformationAtom( RTL_ATOM atom, ATOM_INFORMATION_CLASS class,
-                                        void *ptr, ULONG size, ULONG *retsize )
-{
-    NTSTATUS status;
-
-    switch (class)
-    {
-    case AtomBasicInformation:
-    {
-        ULONG name_len;
-        ATOM_BASIC_INFORMATION *abi = ptr;
-
-        if (size < sizeof(ATOM_BASIC_INFORMATION)) return STATUS_INVALID_PARAMETER;
-        name_len = size - sizeof(ATOM_BASIC_INFORMATION);
-
-        if (atom < MAXINTATOM)
-        {
-            if (atom)
-            {
-                abi->NameLength = integral_atom_name( abi->Name, name_len, atom );
-                status = name_len ? STATUS_SUCCESS : STATUS_BUFFER_TOO_SMALL;
-                abi->ReferenceCount = 1;
-                abi->Pinned = 1;
-            }
-            else status = STATUS_INVALID_PARAMETER;
-        }
-        else
-        {
-            SERVER_START_REQ( get_atom_information )
-            {
-                req->atom = atom;
-                if (name_len) wine_server_set_reply( req, abi->Name, name_len );
-                status = wine_server_call( req );
-                if (status == STATUS_SUCCESS)
-                {
-                    name_len = wine_server_reply_size( reply );
-                    if (name_len)
-                    {
-                        abi->NameLength = name_len;
-                        abi->Name[name_len / sizeof(WCHAR)] = 0;
-                    }
-                    else
-                    {
-                        name_len = reply->total;
-                        abi->NameLength = name_len;
-                        status = STATUS_BUFFER_TOO_SMALL;
-                    }
-                    abi->ReferenceCount = reply->count;
-                    abi->Pinned = reply->pinned;
-                }
-                else name_len = 0;
-            }
-            SERVER_END_REQ;
-        }
-        TRACE( "%x -> %s (%u)\n", atom, debugstr_wn(abi->Name, abi->NameLength / sizeof(WCHAR)), status );
-        if (retsize) *retsize = sizeof(ATOM_BASIC_INFORMATION) + name_len;
-        break;
-    }
-
-    default:
-        FIXME( "Unsupported class %u\n", class );
-        status = STATUS_INVALID_INFO_CLASS;
-        break;
-    }
-    return status;
-}
-
-
-#ifdef __linux__
-
-NTSTATUS CDECL fast_RtlpWaitForCriticalSection( RTL_CRITICAL_SECTION *crit, int timeout )
-{
-    int val;
-    struct timespec timespec;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    timespec.tv_sec  = timeout;
-    timespec.tv_nsec = 0;
-    while ((val = InterlockedCompareExchange( (int *)&crit->LockSemaphore, 0, 1 )) != 1)
-    {
-        /* note: this may wait longer than specified in case of signals or */
-        /*       multiple wake-ups, but that shouldn't be a problem */
-        if (futex_wait( (int *)&crit->LockSemaphore, val, &timespec ) == -1 && errno == ETIMEDOUT)
-            return STATUS_TIMEOUT;
-    }
-    return STATUS_WAIT_0;
-}
-
-NTSTATUS CDECL fast_RtlpUnWaitCriticalSection( RTL_CRITICAL_SECTION *crit )
-{
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    *(int *)&crit->LockSemaphore = 1;
-    futex_wake( (int *)&crit->LockSemaphore, 1 );
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS CDECL fast_RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
-{
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-    return STATUS_SUCCESS;
-}
-
-#elif defined(__APPLE__)
-
-static inline semaphore_t get_mach_semaphore( RTL_CRITICAL_SECTION *crit )
-{
-    semaphore_t ret = *(int *)&crit->LockSemaphore;
-    if (!ret)
-    {
-        semaphore_t sem;
-        if (semaphore_create( mach_task_self(), &sem, SYNC_POLICY_FIFO, 0 )) return 0;
-        if (!(ret = InterlockedCompareExchange( (int *)&crit->LockSemaphore, sem, 0 )))
-            ret = sem;
-        else
-            semaphore_destroy( mach_task_self(), sem );  /* somebody beat us to it */
-    }
-    return ret;
-}
-
-NTSTATUS CDECL fast_RtlpWaitForCriticalSection( RTL_CRITICAL_SECTION *crit, int timeout )
-{
-    mach_timespec_t timespec;
-    semaphore_t sem = get_mach_semaphore( crit );
-
-    timespec.tv_sec = timeout;
-    timespec.tv_nsec = 0;
-    for (;;)
-    {
-        switch( semaphore_timedwait( sem, timespec ))
-        {
-        case KERN_SUCCESS:
-            return STATUS_WAIT_0;
-        case KERN_ABORTED:
-            continue;  /* got a signal, restart */
-        case KERN_OPERATION_TIMED_OUT:
-            return STATUS_TIMEOUT;
-        default:
-            return STATUS_INVALID_HANDLE;
-        }
-    }
-}
-
-NTSTATUS CDECL fast_RtlpUnWaitCriticalSection( RTL_CRITICAL_SECTION *crit )
-{
-    semaphore_t sem = get_mach_semaphore( crit );
-    semaphore_signal( sem );
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS CDECL fast_RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
-{
-    semaphore_destroy( mach_task_self(), *(int *)&crit->LockSemaphore );
-    return STATUS_SUCCESS;
-}
-
-#else  /* __APPLE__ */
-
-NTSTATUS CDECL fast_RtlpWaitForCriticalSection( RTL_CRITICAL_SECTION *crit, int timeout )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlpUnWaitCriticalSection( RTL_CRITICAL_SECTION *crit )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-#endif
-
-
-#ifdef __linux__
-
-/* Futex-based SRW lock implementation:
- *
- * Since we can rely on the kernel to release all threads and don't need to
- * worry about NtReleaseKeyedEvent(), we can simplify the layout a bit. The
- * layout looks like this:
- *
- *    31 - Exclusive lock bit, set if the resource is owned exclusively.
- * 30-16 - Number of exclusive waiters. Unlike the fallback implementation,
- *         this does not include the thread owning the lock, or shared threads
- *         waiting on the lock.
- *    15 - Does this lock have any shared waiters? We use this as an
- *         optimization to avoid unnecessary FUTEX_WAKE_BITSET calls when
- *         releasing an exclusive lock.
- *  14-0 - Number of shared owners. Unlike the fallback implementation, this
- *         does not include the number of shared threads waiting on the lock.
- *         Thus the state [1, x, >=1] will never occur.
- */
-
-#define SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT        0x80000000
-#define SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK    0x7fff0000
-#define SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_INC     0x00010000
-#define SRWLOCK_FUTEX_SHARED_WAITERS_BIT        0x00008000
-#define SRWLOCK_FUTEX_SHARED_OWNERS_MASK        0x00007fff
-#define SRWLOCK_FUTEX_SHARED_OWNERS_INC         0x00000001
-
-/* Futex bitmasks; these are independent from the bits in the lock itself. */
-#define SRWLOCK_FUTEX_BITSET_EXCLUSIVE  1
-#define SRWLOCK_FUTEX_BITSET_SHARED     2
-
-NTSTATUS CDECL fast_RtlTryAcquireSRWLockExclusive( RTL_SRWLOCK *lock )
-{
-    int old, new, *futex;
-    NTSTATUS ret;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &lock->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    do
-    {
-        old = *futex;
-
-        if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
-                && !(old & SRWLOCK_FUTEX_SHARED_OWNERS_MASK))
-        {
-            /* Not locked exclusive or shared. We can try to grab it. */
-            new = old | SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT;
-            ret = STATUS_SUCCESS;
-        }
-        else
-        {
-            new = old;
-            ret = STATUS_TIMEOUT;
-        }
-    } while (InterlockedCompareExchange( futex, new, old ) != old);
-
-    return ret;
-}
-
-NTSTATUS CDECL fast_RtlAcquireSRWLockExclusive( RTL_SRWLOCK *lock )
-{
-    int old, new, *futex;
-    BOOLEAN wait;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &lock->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    /* Atomically increment the exclusive waiter count. */
-    do
-    {
-        old = *futex;
-        new = old + SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_INC;
-        assert(new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK);
-    } while (InterlockedCompareExchange( futex, new, old ) != old);
-
-    for (;;)
-    {
-        do
-        {
-            old = *futex;
-
-            if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
-                    && !(old & SRWLOCK_FUTEX_SHARED_OWNERS_MASK))
-            {
-                /* Not locked exclusive or shared. We can try to grab it. */
-                new = old | SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT;
-                assert(old & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK);
-                new -= SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_INC;
-                wait = FALSE;
-            }
-            else
-            {
-                new = old;
-                wait = TRUE;
-            }
-        } while (InterlockedCompareExchange( futex, new, old ) != old);
-
-        if (!wait)
-            return STATUS_SUCCESS;
-
-        futex_wait_bitset( futex, new, NULL, SRWLOCK_FUTEX_BITSET_EXCLUSIVE );
-    }
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS CDECL fast_RtlTryAcquireSRWLockShared( RTL_SRWLOCK *lock )
-{
-    int new, old, *futex;
-    NTSTATUS ret;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &lock->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    do
-    {
-        old = *futex;
-
-        if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
-                && !(old & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
-        {
-            /* Not locked exclusive, and no exclusive waiters. We can try to
-             * grab it. */
-            new = old + SRWLOCK_FUTEX_SHARED_OWNERS_INC;
-            assert(new & SRWLOCK_FUTEX_SHARED_OWNERS_MASK);
-            ret = STATUS_SUCCESS;
-        }
-        else
-        {
-            new = old;
-            ret = STATUS_TIMEOUT;
-        }
-    } while (InterlockedCompareExchange( futex, new, old ) != old);
-
-    return ret;
-}
-
-NTSTATUS CDECL fast_RtlAcquireSRWLockShared( RTL_SRWLOCK *lock )
-{
-    int old, new, *futex;
-    BOOLEAN wait;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &lock->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    for (;;)
-    {
-        do
-        {
-            old = *futex;
-
-            if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
-                    && !(old & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
-            {
-                /* Not locked exclusive, and no exclusive waiters. We can try
-                 * to grab it. */
-                new = old + SRWLOCK_FUTEX_SHARED_OWNERS_INC;
-                assert(new & SRWLOCK_FUTEX_SHARED_OWNERS_MASK);
-                wait = FALSE;
-            }
-            else
-            {
-                new = old | SRWLOCK_FUTEX_SHARED_WAITERS_BIT;
-                wait = TRUE;
-            }
-        } while (InterlockedCompareExchange( futex, new, old ) != old);
-
-        if (!wait)
-            return STATUS_SUCCESS;
-
-        futex_wait_bitset( futex, new, NULL, SRWLOCK_FUTEX_BITSET_SHARED );
-    }
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS CDECL fast_RtlReleaseSRWLockExclusive( RTL_SRWLOCK *lock )
-{
-    int old, new, *futex;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &lock->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    do
-    {
-        old = *futex;
-
-        if (!(old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT))
-        {
-            ERR("Lock %p is not owned exclusive! (%#x)\n", lock, *futex);
-            return STATUS_RESOURCE_NOT_OWNED;
-        }
-
-        new = old & ~SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT;
-
-        if (!(new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
-            new &= ~SRWLOCK_FUTEX_SHARED_WAITERS_BIT;
-    } while (InterlockedCompareExchange( futex, new, old ) != old);
-
-    if (new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK)
-        futex_wake_bitset( futex, 1, SRWLOCK_FUTEX_BITSET_EXCLUSIVE );
-    else if (old & SRWLOCK_FUTEX_SHARED_WAITERS_BIT)
-        futex_wake_bitset( futex, INT_MAX, SRWLOCK_FUTEX_BITSET_SHARED );
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS CDECL fast_RtlReleaseSRWLockShared( RTL_SRWLOCK *lock )
-{
-    int old, new, *futex;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &lock->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    do
-    {
-        old = *futex;
-
-        if (old & SRWLOCK_FUTEX_EXCLUSIVE_LOCK_BIT)
-        {
-            ERR("Lock %p is owned exclusive! (%#x)\n", lock, *futex);
-            return STATUS_RESOURCE_NOT_OWNED;
-        }
-        else if (!(old & SRWLOCK_FUTEX_SHARED_OWNERS_MASK))
-        {
-            ERR("Lock %p is not owned shared! (%#x)\n", lock, *futex);
-            return STATUS_RESOURCE_NOT_OWNED;
-        }
-
-        new = old - SRWLOCK_FUTEX_SHARED_OWNERS_INC;
-    } while (InterlockedCompareExchange( futex, new, old ) != old);
-
-    /* Optimization: only bother waking if there are actually exclusive waiters. */
-    if (!(new & SRWLOCK_FUTEX_SHARED_OWNERS_MASK) && (new & SRWLOCK_FUTEX_EXCLUSIVE_WAITERS_MASK))
-        futex_wake_bitset( futex, 1, SRWLOCK_FUTEX_BITSET_EXCLUSIVE );
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS wait_cv( int *futex, int val, const LARGE_INTEGER *timeout )
-{
-    struct timespec timespec;
-    int ret;
-
-    if (timeout && timeout->QuadPart != TIMEOUT_INFINITE)
-    {
-        timespec_from_timeout( &timespec, timeout );
-        ret = futex_wait( futex, val, &timespec );
-    }
-    else
-        ret = futex_wait( futex, val, NULL );
-
-    if (ret == -1 && errno == ETIMEDOUT)
-        return STATUS_TIMEOUT;
-    return STATUS_WAIT_0;
-}
-
-NTSTATUS CDECL fast_RtlSleepConditionVariableCS( RTL_CONDITION_VARIABLE *variable,
-                                                 RTL_CRITICAL_SECTION *cs, const LARGE_INTEGER *timeout )
-{
-    NTSTATUS status;
-    int val, *futex;
-
-    if (!use_futexes())
-        return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &variable->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    val = *futex;
-
-    if (cs->RecursionCount == 1)
-    {
-        /* FIXME: simplified version of RtlLeaveCriticalSection/RtlEnterCriticalSection to avoid imports */
-        cs->RecursionCount = 0;
-        cs->OwningThread   = 0;
-        if (InterlockedDecrement( &cs->LockCount ) >= 0) fast_RtlpUnWaitCriticalSection( cs );
-
-        status = wait_cv( futex, val, timeout );
-
-        if (InterlockedIncrement( &cs->LockCount )) fast_RtlpWaitForCriticalSection( cs, INT_MAX );
-        cs->OwningThread   = ULongToHandle( GetCurrentThreadId() );
-        cs->RecursionCount = 1;
-    }
-    else status = wait_cv( futex, val, timeout );
-    return status;
-}
-
-NTSTATUS CDECL fast_RtlSleepConditionVariableSRW( RTL_CONDITION_VARIABLE *variable, RTL_SRWLOCK *lock,
-                                                  const LARGE_INTEGER *timeout, ULONG flags )
-{
-    NTSTATUS status;
-    int val, *futex;
-
-    if (!use_futexes())
-        return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &variable->Ptr )) || !get_futex( &lock->Ptr ))
-        return STATUS_NOT_IMPLEMENTED;
-
-    val = *futex;
-
-    if (flags & RTL_CONDITION_VARIABLE_LOCKMODE_SHARED)
-        fast_RtlReleaseSRWLockShared( lock );
-    else
-        fast_RtlReleaseSRWLockExclusive( lock );
-
-    status = wait_cv( futex, val, timeout );
-
-    if (flags & RTL_CONDITION_VARIABLE_LOCKMODE_SHARED)
-        fast_RtlAcquireSRWLockShared( lock );
-    else
-        fast_RtlAcquireSRWLockExclusive( lock );
-    return status;
-}
-
-NTSTATUS CDECL fast_RtlWakeConditionVariable( RTL_CONDITION_VARIABLE *variable, int count )
-{
-    int *futex;
-
-    if (!use_futexes()) return STATUS_NOT_IMPLEMENTED;
-
-    if (!(futex = get_futex( &variable->Ptr )))
-        return STATUS_NOT_IMPLEMENTED;
-
-    InterlockedIncrement( futex );
-    futex_wake( futex, count );
-    return STATUS_SUCCESS;
-}
-
-
-/* We can't map addresses to futex directly, because an application can wait on
- * 8 bytes, and we can't pass all 8 as the compare value to futex(). Instead we
- * map all addresses to a small fixed table of futexes. This may result in
- * spurious wakes, but the application is already expected to handle those. */
-
-static int addr_futex_table[256];
-
-static inline int *hash_addr( const void *addr )
-{
-    ULONG_PTR val = (ULONG_PTR)addr;
-
-    return &addr_futex_table[(val >> 2) & 255];
-}
-
-static inline NTSTATUS fast_wait_addr( const void *addr, const void *cmp, SIZE_T size,
-                                       const LARGE_INTEGER *timeout )
-{
-    int *futex;
-    int val;
-    struct timespec timespec;
-    int ret;
-
-    if (!use_futexes())
-        return STATUS_NOT_IMPLEMENTED;
-
-    futex = hash_addr( addr );
-
-    /* We must read the previous value of the futex before checking the value
-     * of the address being waited on. That way, if we receive a wake between
-     * now and waiting on the futex, we know that val will have changed.
-     * Use an atomic load so that memory accesses are ordered between this read
-     * and the increment below. */
-    val = InterlockedCompareExchange( futex, 0, 0 );
-    if (!compare_addr( addr, cmp, size ))
-        return STATUS_SUCCESS;
-
-    if (timeout)
-    {
-        timespec_from_timeout( &timespec, timeout );
-        ret = futex_wait( futex, val, &timespec );
-    }
-    else
-        ret = futex_wait( futex, val, NULL );
-
-    if (ret == -1 && errno == ETIMEDOUT)
-        return STATUS_TIMEOUT;
-    return STATUS_SUCCESS;
-}
-
-static inline NTSTATUS fast_wake_addr( const void *addr )
-{
-    int *futex;
-
-    if (!use_futexes())
-        return STATUS_NOT_IMPLEMENTED;
-
-    futex = hash_addr( addr );
-
-    InterlockedIncrement( futex );
-
-    futex_wake( futex, INT_MAX );
-    return STATUS_SUCCESS;
-}
-
-#else
-
-NTSTATUS CDECL fast_RtlTryAcquireSRWLockExclusive( RTL_SRWLOCK *lock )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlAcquireSRWLockExclusive( RTL_SRWLOCK *lock )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlTryAcquireSRWLockShared( RTL_SRWLOCK *lock )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlAcquireSRWLockShared( RTL_SRWLOCK *lock )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlReleaseSRWLockExclusive( RTL_SRWLOCK *lock )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlReleaseSRWLockShared( RTL_SRWLOCK *lock )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlSleepConditionVariableSRW( RTL_CONDITION_VARIABLE *variable, RTL_SRWLOCK *lock,
-                                                  const LARGE_INTEGER *timeout, ULONG flags )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlSleepConditionVariableCS( RTL_CONDITION_VARIABLE *variable,
-                                                 RTL_CRITICAL_SECTION *cs, const LARGE_INTEGER *timeout )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-NTSTATUS CDECL fast_RtlWakeConditionVariable( RTL_CONDITION_VARIABLE *variable, int count )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static inline NTSTATUS fast_wait_addr( const void *addr, const void *cmp, SIZE_T size,
-                                       const LARGE_INTEGER *timeout )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static inline NTSTATUS fast_wake_addr( const void *addr )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-#endif
-
-
-/***********************************************************************
- *           RtlWaitOnAddress   (NTDLL.@)
- */
-NTSTATUS WINAPI RtlWaitOnAddress( const void *addr, const void *cmp, SIZE_T size,
-                                  const LARGE_INTEGER *timeout )
-{
-    select_op_t select_op;
-    NTSTATUS ret;
-    timeout_t abs_timeout = timeout ? timeout->QuadPart : TIMEOUT_INFINITE;
-
-    if (size != 1 && size != 2 && size != 4 && size != 8)
-        return STATUS_INVALID_PARAMETER;
-
-    if ((ret = fast_wait_addr( addr, cmp, size, timeout )) != STATUS_NOT_IMPLEMENTED)
-        return ret;
-
-    pthread_mutex_lock( &addr_mutex );
-    if (!compare_addr( addr, cmp, size ))
-    {
-        pthread_mutex_unlock( &addr_mutex );
-        return STATUS_SUCCESS;
-    }
-
-    if (abs_timeout < 0)
-    {
-        LARGE_INTEGER now;
-
-        NtQueryPerformanceCounter( &now, NULL );
-        abs_timeout -= now.QuadPart;
-    }
-
-    select_op.keyed_event.op     = SELECT_KEYED_EVENT_WAIT;
-    select_op.keyed_event.handle = wine_server_obj_handle( keyed_event );
-    select_op.keyed_event.key    = wine_server_client_ptr( addr );
-
-    return server_select( &select_op, sizeof(select_op.keyed_event), SELECT_INTERRUPTIBLE,
-                          abs_timeout, NULL, &addr_mutex, NULL );
-}
-
-/***********************************************************************
- *           RtlWakeAddressAll    (NTDLL.@)
- */
-void WINAPI RtlWakeAddressAll( const void *addr )
-{
-    if (fast_wake_addr( addr ) != STATUS_NOT_IMPLEMENTED) return;
-
-    pthread_mutex_lock( &addr_mutex );
-    while (NtReleaseKeyedEvent( 0, addr, 0, &zero_timeout ) == STATUS_SUCCESS) {}
-    pthread_mutex_unlock( &addr_mutex );
-}
-
-/***********************************************************************
- *           RtlWakeAddressSingle (NTDLL.@)
- */
-void WINAPI RtlWakeAddressSingle( const void *addr )
-{
-    if (fast_wake_addr( addr ) != STATUS_NOT_IMPLEMENTED) return;
-
-    pthread_mutex_lock( &addr_mutex );
-    NtReleaseKeyedEvent( 0, addr, 0, &zero_timeout );
-    pthread_mutex_unlock( &addr_mutex );
-}
diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
deleted file mode 100644
index 3148f23df3..0000000000
--- a/dlls/ntdll/unix/system.c
+++ /dev/null
@@ -1,3168 +0,0 @@
-/*
- * System information APIs
- *
- * Copyright 1996-1998 Marcus Meissner
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <string.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#ifdef HAVE_SYS_TIME_H
-# include <sys/time.h>
-#endif
-#include <time.h>
-#ifdef HAVE_SYS_PARAM_H
-# include <sys/param.h>
-#endif
-#ifdef HAVE_SYS_SYSCTL_H
-# include <sys/sysctl.h>
-#endif
-#ifdef HAVE_MACHINE_CPU_H
-# include <machine/cpu.h>
-#endif
-#ifdef HAVE_IOKIT_IOKITLIB_H
-# include <CoreFoundation/CoreFoundation.h>
-# include <IOKit/IOKitLib.h>
-# include <IOKit/pwr_mgt/IOPM.h>
-# include <IOKit/pwr_mgt/IOPMLib.h>
-# include <IOKit/ps/IOPowerSources.h>
-#endif
-#ifdef __APPLE__
-# include <mach/mach.h>
-# include <mach/machine.h>
-# include <mach/mach_init.h>
-# include <mach/mach_host.h>
-# include <mach/vm_map.h>
-#endif
-
-#define NONAMELESSUNION
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winternl.h"
-#include "ddk/wdm.h"
-#include "wine/asm.h"
-#include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
-
-#include "pshpack1.h"
-
-struct smbios_prologue
-{
-    BYTE calling_method;
-    BYTE major_version;
-    BYTE minor_version;
-    BYTE revision;
-    DWORD length;
-};
-
-struct smbios_header
-{
-    BYTE type;
-    BYTE length;
-    WORD handle;
-};
-
-struct smbios_bios
-{
-    struct smbios_header hdr;
-    BYTE vendor;
-    BYTE version;
-    WORD start;
-    BYTE date;
-    BYTE size;
-    UINT64 characteristics;
-    BYTE characteristics_ext[2];
-    BYTE system_bios_major_release;
-    BYTE system_bios_minor_release;
-    BYTE ec_firmware_major_release;
-    BYTE ec_firmware_minor_release;
-};
-
-struct smbios_system
-{
-    struct smbios_header hdr;
-    BYTE vendor;
-    BYTE product;
-    BYTE version;
-    BYTE serial;
-    BYTE uuid[16];
-    BYTE wake_up_type;
-    BYTE sku_number;
-    BYTE family;
-};
-
-struct smbios_board
-{
-    struct smbios_header hdr;
-    BYTE vendor;
-    BYTE product;
-    BYTE version;
-    BYTE serial;
-    BYTE asset_tag;
-    BYTE feature_flags;
-    BYTE location;
-    WORD chassis_handle;
-    BYTE board_type;
-    BYTE num_contained_handles;
-};
-
-struct smbios_chassis
-{
-    struct smbios_header hdr;
-    BYTE vendor;
-    BYTE type;
-    BYTE version;
-    BYTE serial;
-    BYTE asset_tag;
-    BYTE boot_state;
-    BYTE power_supply_state;
-    BYTE thermal_state;
-    BYTE security_status;
-    DWORD oem_defined;
-    BYTE height;
-    BYTE num_power_cords;
-    BYTE num_contained_elements;
-    BYTE contained_element_rec_length;
-};
-
-struct smbios_boot_info
-{
-    struct smbios_header hdr;
-    BYTE reserved[6];
-    BYTE boot_status[10];
-};
-
-#include "poppack.h"
-
-/* Firmware table providers */
-#define ACPI 0x41435049
-#define FIRM 0x4649524D
-#define RSMB 0x52534D42
-
-static SYSTEM_CPU_INFORMATION cpu_info;
-
-/*******************************************************************************
- * Architecture specific feature detection for CPUs
- *
- * This a set of mutually exclusive #if define()s each providing its own get_cpuinfo() to be called
- * from init_cpu_info();
- */
-#if defined(__i386__) || defined(__x86_64__)
-
-#define AUTH	0x68747541	/* "Auth" */
-#define ENTI	0x69746e65	/* "enti" */
-#define CAMD	0x444d4163	/* "cAMD" */
-
-#define GENU	0x756e6547	/* "Genu" */
-#define INEI	0x49656e69	/* "ineI" */
-#define NTEL	0x6c65746e	/* "ntel" */
-
-extern void do_cpuid(unsigned int ax, unsigned int *p);
-
-#ifdef __i386__
-__ASM_GLOBAL_FUNC( do_cpuid,
-                   "pushl %esi\n\t"
-                   "pushl %ebx\n\t"
-                   "movl 12(%esp),%eax\n\t"
-                   "movl 16(%esp),%esi\n\t"
-                   "cpuid\n\t"
-                   "movl %eax,(%esi)\n\t"
-                   "movl %ebx,4(%esi)\n\t"
-                   "movl %ecx,8(%esi)\n\t"
-                   "movl %edx,12(%esi)\n\t"
-                   "popl %ebx\n\t"
-                   "popl %esi\n\t"
-                   "ret" )
-#else
-__ASM_GLOBAL_FUNC( do_cpuid,
-                   "pushq %rbx\n\t"
-                   "movl %edi,%eax\n\t"
-                   "cpuid\n\t"
-                   "movl %eax,(%rsi)\n\t"
-                   "movl %ebx,4(%rsi)\n\t"
-                   "movl %ecx,8(%rsi)\n\t"
-                   "movl %edx,12(%rsi)\n\t"
-                   "popq %rbx\n\t"
-                   "ret" )
-#endif
-
-#ifdef __i386__
-extern int have_cpuid(void);
-__ASM_GLOBAL_FUNC( have_cpuid,
-                   "pushfl\n\t"
-                   "pushfl\n\t"
-                   "movl (%esp),%ecx\n\t"
-                   "xorl $0x00200000,(%esp)\n\t"
-                   "popfl\n\t"
-                   "pushfl\n\t"
-                   "popl %eax\n\t"
-                   "popfl\n\t"
-                   "xorl %ecx,%eax\n\t"
-                   "andl $0x00200000,%eax\n\t"
-                   "ret" )
-#else
-static int have_cpuid(void)
-{
-    return 1;
-}
-#endif
-
-/* Detect if a SSE2 processor is capable of Denormals Are Zero (DAZ) mode.
- *
- * This function assumes you have already checked for SSE2/FXSAVE support. */
-static inline BOOL have_sse_daz_mode(void)
-{
-#ifdef __i386__
-    typedef struct DECLSPEC_ALIGN(16) _M128A {
-        ULONGLONG Low;
-        LONGLONG High;
-    } M128A;
-
-    typedef struct _XMM_SAVE_AREA32 {
-        WORD ControlWord;
-        WORD StatusWord;
-        BYTE TagWord;
-        BYTE Reserved1;
-        WORD ErrorOpcode;
-        DWORD ErrorOffset;
-        WORD ErrorSelector;
-        WORD Reserved2;
-        DWORD DataOffset;
-        WORD DataSelector;
-        WORD Reserved3;
-        DWORD MxCsr;
-        DWORD MxCsr_Mask;
-        M128A FloatRegisters[8];
-        M128A XmmRegisters[16];
-        BYTE Reserved4[96];
-    } XMM_SAVE_AREA32;
-
-    /* Intel says we need a zeroed 16-byte aligned buffer */
-    char buffer[512 + 16];
-    XMM_SAVE_AREA32 *state = (XMM_SAVE_AREA32 *)(((ULONG_PTR)buffer + 15) & ~15);
-    memset(buffer, 0, sizeof(buffer));
-
-    __asm__ __volatile__( "fxsave %0" : "=m" (*state) : "m" (*state) );
-
-    return (state->MxCsr_Mask & (1 << 6)) >> 6;
-#else /* all x86_64 processors include SSE2 with DAZ mode */
-    return TRUE;
-#endif
-}
-
-static void get_cpuinfo( SYSTEM_CPU_INFORMATION *info )
-{
-    unsigned int regs[4], regs2[4];
-
-#if defined(__i386__)
-    info->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
-#elif defined(__x86_64__)
-    info->Architecture = PROCESSOR_ARCHITECTURE_AMD64;
-#endif
-
-    /* We're at least a 386 */
-    info->FeatureSet = CPU_FEATURE_VME | CPU_FEATURE_X86 | CPU_FEATURE_PGE;
-    info->Level = 3;
-
-    if (!have_cpuid()) return;
-
-    do_cpuid( 0x00000000, regs );  /* get standard cpuid level and vendor name */
-    if (regs[0]>=0x00000001)   /* Check for supported cpuid version */
-    {
-        do_cpuid( 0x00000001, regs2 ); /* get cpu features */
-        if (regs2[3] & (1 << 3 )) info->FeatureSet |= CPU_FEATURE_PSE;
-        if (regs2[3] & (1 << 4 )) info->FeatureSet |= CPU_FEATURE_TSC;
-        if (regs2[3] & (1 << 6 )) info->FeatureSet |= CPU_FEATURE_PAE;
-        if (regs2[3] & (1 << 8 )) info->FeatureSet |= CPU_FEATURE_CX8;
-        if (regs2[3] & (1 << 11)) info->FeatureSet |= CPU_FEATURE_SEP;
-        if (regs2[3] & (1 << 12)) info->FeatureSet |= CPU_FEATURE_MTRR;
-        if (regs2[3] & (1 << 15)) info->FeatureSet |= CPU_FEATURE_CMOV;
-        if (regs2[3] & (1 << 16)) info->FeatureSet |= CPU_FEATURE_PAT;
-        if (regs2[3] & (1 << 23)) info->FeatureSet |= CPU_FEATURE_MMX;
-        if (regs2[3] & (1 << 24)) info->FeatureSet |= CPU_FEATURE_FXSR;
-        if (regs2[3] & (1 << 25)) info->FeatureSet |= CPU_FEATURE_SSE;
-        if (regs2[3] & (1 << 26)) info->FeatureSet |= CPU_FEATURE_SSE2;
-        if (regs2[2] & (1 << 0 )) info->FeatureSet |= CPU_FEATURE_SSE3;
-        if (regs2[2] & (1 << 13)) info->FeatureSet |= CPU_FEATURE_CX128;
-        if (regs2[2] & (1 << 27)) info->FeatureSet |= CPU_FEATURE_XSAVE;
-        if((regs2[3] & (1 << 26)) && (regs2[3] & (1 << 24)) && have_sse_daz_mode()) /* has SSE2 and FXSAVE/FXRSTOR */
-            info->FeatureSet |= CPU_FEATURE_DAZ;
-
-        if (regs[1] == AUTH && regs[3] == ENTI && regs[2] == CAMD)
-        {
-            info->Level = (regs2[0] >> 8) & 0xf; /* family */
-            if (info->Level == 0xf)  /* AMD says to add the extended family to the family if family is 0xf */
-                info->Level += (regs2[0] >> 20) & 0xff;
-
-            /* repack model and stepping to make a "revision" */
-            info->Revision  = ((regs2[0] >> 16) & 0xf) << 12; /* extended model */
-            info->Revision |= ((regs2[0] >> 4 ) & 0xf) << 8;  /* model          */
-            info->Revision |= regs2[0] & 0xf;                 /* stepping       */
-
-            do_cpuid( 0x80000000, regs );  /* get vendor cpuid level */
-            if (regs[0] >= 0x80000001)
-            {
-                do_cpuid( 0x80000001, regs2 );  /* get vendor features */
-                if (regs2[2] & (1 << 2))   info->FeatureSet |= CPU_FEATURE_VIRT;
-                if (regs2[3] & (1 << 20))  info->FeatureSet |= CPU_FEATURE_NX;
-                if (regs2[3] & (1 << 27))  info->FeatureSet |= CPU_FEATURE_TSC;
-                if (regs2[3] & (1u << 31)) info->FeatureSet |= CPU_FEATURE_3DNOW;
-            }
-        }
-        else if (regs[1] == GENU && regs[3] == INEI && regs[2] == NTEL)
-        {
-            info->Level = ((regs2[0] >> 8) & 0xf) + ((regs2[0] >> 20) & 0xff); /* family + extended family */
-            if(info->Level == 15) info->Level = 6;
-
-            /* repack model and stepping to make a "revision" */
-            info->Revision  = ((regs2[0] >> 16) & 0xf) << 12; /* extended model */
-            info->Revision |= ((regs2[0] >> 4 ) & 0xf) << 8;  /* model          */
-            info->Revision |= regs2[0] & 0xf;                 /* stepping       */
-
-            if(regs2[2] & (1 << 5))  info->FeatureSet |= CPU_FEATURE_VIRT;
-            if(regs2[3] & (1 << 21)) info->FeatureSet |= CPU_FEATURE_DS;
-
-            do_cpuid( 0x80000000, regs );  /* get vendor cpuid level */
-            if (regs[0] >= 0x80000001)
-            {
-                do_cpuid( 0x80000001, regs2 );  /* get vendor features */
-                if (regs2[3] & (1 << 20)) info->FeatureSet |= CPU_FEATURE_NX;
-                if (regs2[3] & (1 << 27)) info->FeatureSet |= CPU_FEATURE_TSC;
-            }
-        }
-        else
-        {
-            info->Level = (regs2[0] >> 8) & 0xf; /* family */
-
-            /* repack model and stepping to make a "revision" */
-            info->Revision = ((regs2[0] >> 4 ) & 0xf) << 8;  /* model    */
-            info->Revision |= regs2[0] & 0xf;                /* stepping */
-        }
-    }
-}
-
-#elif defined(__arm__)
-
-static inline void get_cpuinfo( SYSTEM_CPU_INFORMATION *info )
-{
-#ifdef linux
-    char line[512];
-    char *s, *value;
-    FILE *f = fopen("/proc/cpuinfo", "r");
-    if (f)
-    {
-        while (fgets( line, sizeof(line), f ))
-        {
-            /* NOTE: the ':' is the only character we can rely on */
-            if (!(value = strchr(line,':'))) continue;
-            /* terminate the valuename */
-            s = value - 1;
-            while ((s >= line) && (*s == ' ' || *s == '\t')) s--;
-            s[1] = 0;
-            /* and strip leading spaces from value */
-            value += 1;
-            while (*value == ' ' || *value == '\t') value++;
-            if ((s = strchr( value,'\n' ))) *s = 0;
-            if (!strcmp( line, "CPU architecture" ))
-            {
-                info->Level = atoi(value);
-                continue;
-            }
-            if (!strcmp( line, "CPU revision" ))
-            {
-                info->Revision = atoi(value);
-                continue;
-            }
-            if (!strcmp( line, "Features" ))
-            {
-                if (strstr(value, "crc32")) info->FeatureSet |= CPU_FEATURE_ARM_V8_CRC32;
-                if (strstr(value, "aes"))   info->FeatureSet |= CPU_FEATURE_ARM_V8_CRYPTO;
-                continue;
-            }
-        }
-        fclose( f );
-    }
-#elif defined(__FreeBSD__)
-    size_t valsize;
-    char buf[8];
-    int value;
-
-    valsize = sizeof(buf);
-    if (!sysctlbyname("hw.machine_arch", &buf, &valsize, NULL, 0) && sscanf(buf, "armv%i", &value) == 1)
-        info->Level = value;
-
-    valsize = sizeof(value);
-    if (!sysctlbyname("hw.floatingpoint", &value, &valsize, NULL, 0))
-        info->FeatureSet |= CPU_FEATURE_ARM_VFP_32;
-#else
-    FIXME("CPU Feature detection not implemented.\n");
-#endif
-    info->Architecture = PROCESSOR_ARCHITECTURE_ARM;
-}
-
-#elif defined(__aarch64__)
-
-static void get_cpuinfo( SYSTEM_CPU_INFORMATION *info )
-{
-#ifdef linux
-    char line[512];
-    char *s, *value;
-    FILE *f = fopen("/proc/cpuinfo", "r");
-    if (f)
-    {
-        while (fgets( line, sizeof(line), f ))
-        {
-            /* NOTE: the ':' is the only character we can rely on */
-            if (!(value = strchr(line,':'))) continue;
-            /* terminate the valuename */
-            s = value - 1;
-            while ((s >= line) && (*s == ' ' || *s == '\t')) s--;
-            s[1] = 0;
-            /* and strip leading spaces from value */
-            value += 1;
-            while (*value == ' ' || *value == '\t') value++;
-            if ((s = strchr( value,'\n' ))) *s = 0;
-            if (!strcmp( line, "CPU architecture" ))
-            {
-                info->Level = atoi(value);
-                continue;
-            }
-            if (!strcmp( line, "CPU revision" ))
-            {
-                info->Revision = atoi(value);
-                continue;
-            }
-            if (!strcmp( line, "Features" ))
-            {
-                if (strstr(value, "crc32")) info->FeatureSet |= CPU_FEATURE_ARM_V8_CRC32;
-                if (strstr(value, "aes"))   info->FeatureSet |= CPU_FEATURE_ARM_V8_CRYPTO;
-                continue;
-            }
-        }
-        fclose( f );
-    }
-#else
-    FIXME("CPU Feature detection not implemented.\n");
-#endif
-    info->Level = max(info->Level, 8);
-    info->Architecture = PROCESSOR_ARCHITECTURE_ARM64;
-}
-
-#endif /* End architecture specific feature detection for CPUs */
-
-/******************************************************************
- *		init_cpu_info
- *
- * inits a couple of places with CPU related information:
- * - cpu_info in this file
- * - Peb->NumberOfProcessors
- * - SharedUserData->ProcessFeatures[] array
- */
-void init_cpu_info(void)
-{
-    long num;
-
-#ifdef _SC_NPROCESSORS_ONLN
-    num = sysconf(_SC_NPROCESSORS_ONLN);
-    if (num < 1)
-    {
-        num = 1;
-        WARN("Failed to detect the number of processors.\n");
-    }
-#elif defined(CTL_HW) && defined(HW_NCPU)
-    int mib[2];
-    size_t len = sizeof(num);
-    mib[0] = CTL_HW;
-    mib[1] = HW_NCPU;
-    if (sysctl(mib, 2, &num, &len, NULL, 0) != 0)
-    {
-        num = 1;
-        WARN("Failed to detect the number of processors.\n");
-    }
-#else
-    num = 1;
-    FIXME("Detecting the number of processors is not supported.\n");
-#endif
-    NtCurrentTeb()->Peb->NumberOfProcessors = num;
-    get_cpuinfo( &cpu_info );
-    TRACE( "<- CPU arch %d, level %d, rev %d, features 0x%x\n",
-           cpu_info.Architecture, cpu_info.Level, cpu_info.Revision, cpu_info.FeatureSet );
-}
-
-static BOOL grow_logical_proc_buf( SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata, DWORD *max_len )
-{
-    SYSTEM_LOGICAL_PROCESSOR_INFORMATION *new_data;
-
-    *max_len *= 2;
-    if (!(new_data = realloc( *pdata, *max_len*sizeof(*new_data) ))) return FALSE;
-    *pdata = new_data;
-    return TRUE;
-}
-
-static BOOL grow_logical_proc_ex_buf( SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *max_len )
-{
-    SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *new_dataex;
-    DWORD new_len = *max_len * 2;
-    if (!(new_dataex = realloc( *pdataex, new_len * sizeof(*new_dataex) ))) return FALSE;
-    memset( new_dataex + *max_len, 0, (new_len - *max_len) * sizeof(*new_dataex) );
-    *pdataex = new_dataex;
-    *max_len = new_len;
-    return TRUE;
-}
-
-static DWORD log_proc_ex_size_plus(DWORD size)
-{
-    /* add SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.Relationship and .Size */
-    return sizeof(LOGICAL_PROCESSOR_RELATIONSHIP) + sizeof(DWORD) + size;
-}
-
-static DWORD count_bits(ULONG_PTR mask)
-{
-    DWORD count = 0;
-    while (mask > 0)
-    {
-        mask >>= 1;
-        count++;
-    }
-    return count;
-}
-
-/* Store package and core information for a logical processor. Parsing of processor
- * data may happen in multiple passes; the 'id' parameter is then used to locate
- * previously stored data. The type of data stored in 'id' depends on 'rel':
- * - RelationProcessorPackage: package id ('CPU socket').
- * - RelationProcessorCore: physical core number.
- */
-static BOOL logical_proc_info_add_by_id( SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata,
-                                         SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *len,
-                                         DWORD *pmax_len, LOGICAL_PROCESSOR_RELATIONSHIP rel,
-                                         DWORD id, ULONG_PTR mask )
-{
-    if (pdata)
-    {
-        DWORD i;
-
-        for (i = 0; i < *len; i++)
-        {
-            if (rel == RelationProcessorPackage && (*pdata)[i].Relationship == rel && (*pdata)[i].u.Reserved[1] == id)
-            {
-                (*pdata)[i].ProcessorMask |= mask;
-                return TRUE;
-            }
-            else if (rel == RelationProcessorCore && (*pdata)[i].Relationship == rel && (*pdata)[i].u.Reserved[1] == id)
-                return TRUE;
-        }
-
-        while (*len == *pmax_len)
-        {
-            if (!grow_logical_proc_buf(pdata, pmax_len)) return FALSE;
-        }
-
-        (*pdata)[i].Relationship = rel;
-        (*pdata)[i].ProcessorMask = mask;
-        if (rel == RelationProcessorCore)
-            (*pdata)[i].u.ProcessorCore.Flags = count_bits(mask) > 1 ? LTP_PC_SMT : 0;
-        (*pdata)[i].u.Reserved[0] = 0;
-        (*pdata)[i].u.Reserved[1] = id;
-        *len = i+1;
-    }
-    else
-    {
-        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
-        DWORD ofs = 0;
-
-        while (ofs < *len)
-        {
-            dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
-            if (rel == RelationProcessorPackage && dataex->Relationship == rel && dataex->u.Processor.Reserved[1] == id)
-            {
-                dataex->u.Processor.GroupMask[0].Mask |= mask;
-                return TRUE;
-            }
-            else if (rel == RelationProcessorCore && dataex->Relationship == rel && dataex->u.Processor.Reserved[1] == id)
-            {
-                return TRUE;
-            }
-            ofs += dataex->Size;
-        }
-
-        /* TODO: For now, just one group. If more than 64 processors, then we
-         * need another group. */
-
-        while (ofs + log_proc_ex_size_plus(sizeof(PROCESSOR_RELATIONSHIP)) > *pmax_len)
-        {
-            if (!grow_logical_proc_ex_buf(pdataex, pmax_len)) return FALSE;
-        }
-
-        dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
-
-        dataex->Relationship = rel;
-        dataex->Size = log_proc_ex_size_plus(sizeof(PROCESSOR_RELATIONSHIP));
-        if (rel == RelationProcessorCore)
-            dataex->u.Processor.Flags = count_bits(mask) > 1 ? LTP_PC_SMT : 0;
-        else
-            dataex->u.Processor.Flags = 0;
-        dataex->u.Processor.EfficiencyClass = 0;
-        dataex->u.Processor.GroupCount = 1;
-        dataex->u.Processor.GroupMask[0].Mask = mask;
-        dataex->u.Processor.GroupMask[0].Group = 0;
-        /* mark for future lookup */
-        dataex->u.Processor.Reserved[0] = 0;
-        dataex->u.Processor.Reserved[1] = id;
-
-        *len += dataex->Size;
-    }
-
-    return TRUE;
-}
-
-static BOOL logical_proc_info_add_cache( SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata,
-                                         SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *len,
-                                         DWORD *pmax_len, ULONG_PTR mask, CACHE_DESCRIPTOR *cache )
-{
-    if (pdata)
-    {
-        DWORD i;
-
-        for (i = 0; i < *len; i++)
-        {
-            if ((*pdata)[i].Relationship==RelationCache && (*pdata)[i].ProcessorMask==mask
-                    && (*pdata)[i].u.Cache.Level==cache->Level && (*pdata)[i].u.Cache.Type==cache->Type)
-                return TRUE;
-        }
-
-        while (*len == *pmax_len)
-            if (!grow_logical_proc_buf(pdata, pmax_len)) return FALSE;
-
-        (*pdata)[i].Relationship = RelationCache;
-        (*pdata)[i].ProcessorMask = mask;
-        (*pdata)[i].u.Cache = *cache;
-        *len = i+1;
-    }
-    else
-    {
-        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
-        DWORD ofs;
-
-        for (ofs = 0; ofs < *len; )
-        {
-            dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
-            if (dataex->Relationship == RelationCache && dataex->u.Cache.GroupMask.Mask == mask &&
-                    dataex->u.Cache.Level == cache->Level && dataex->u.Cache.Type == cache->Type)
-                return TRUE;
-            ofs += dataex->Size;
-        }
-
-        while (ofs + log_proc_ex_size_plus(sizeof(CACHE_RELATIONSHIP)) > *pmax_len)
-        {
-            if (!grow_logical_proc_ex_buf(pdataex, pmax_len)) return FALSE;
-        }
-
-        dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + ofs);
-
-        dataex->Relationship = RelationCache;
-        dataex->Size = log_proc_ex_size_plus(sizeof(CACHE_RELATIONSHIP));
-        dataex->u.Cache.Level = cache->Level;
-        dataex->u.Cache.Associativity = cache->Associativity;
-        dataex->u.Cache.LineSize = cache->LineSize;
-        dataex->u.Cache.CacheSize = cache->Size;
-        dataex->u.Cache.Type = cache->Type;
-        dataex->u.Cache.GroupMask.Mask = mask;
-        dataex->u.Cache.GroupMask.Group = 0;
-
-        *len += dataex->Size;
-    }
-
-    return TRUE;
-}
-
-static BOOL logical_proc_info_add_numa_node( SYSTEM_LOGICAL_PROCESSOR_INFORMATION **pdata,
-                                             SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex, DWORD *len,
-                                             DWORD *pmax_len, ULONG_PTR mask, DWORD node_id )
-{
-    if (pdata)
-    {
-        while (*len == *pmax_len)
-            if (!grow_logical_proc_buf(pdata, pmax_len)) return FALSE;
-
-        (*pdata)[*len].Relationship = RelationNumaNode;
-        (*pdata)[*len].ProcessorMask = mask;
-        (*pdata)[*len].u.NumaNode.NodeNumber = node_id;
-        (*len)++;
-    }
-    else
-    {
-        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
-
-        while (*len + log_proc_ex_size_plus(sizeof(NUMA_NODE_RELATIONSHIP)) > *pmax_len)
-        {
-            if (!grow_logical_proc_ex_buf(pdataex, pmax_len)) return FALSE;
-        }
-
-        dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + *len);
-
-        dataex->Relationship = RelationNumaNode;
-        dataex->Size = log_proc_ex_size_plus(sizeof(NUMA_NODE_RELATIONSHIP));
-        dataex->u.NumaNode.NodeNumber = node_id;
-        dataex->u.NumaNode.GroupMask.Mask = mask;
-        dataex->u.NumaNode.GroupMask.Group = 0;
-
-        *len += dataex->Size;
-    }
-
-    return TRUE;
-}
-
-static BOOL logical_proc_info_add_group( SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **pdataex,
-                                         DWORD *len, DWORD *pmax_len, DWORD num_cpus, ULONG_PTR mask )
-{
-    SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *dataex;
-
-    while (*len + log_proc_ex_size_plus(sizeof(GROUP_RELATIONSHIP)) > *pmax_len)
-        if (!grow_logical_proc_ex_buf(pdataex, pmax_len)) return FALSE;
-
-    dataex = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)(((char *)*pdataex) + *len);
-
-    dataex->Relationship = RelationGroup;
-    dataex->Size = log_proc_ex_size_plus(sizeof(GROUP_RELATIONSHIP));
-    dataex->u.Group.MaximumGroupCount = 1;
-    dataex->u.Group.ActiveGroupCount = 1;
-    dataex->u.Group.GroupInfo[0].MaximumProcessorCount = num_cpus;
-    dataex->u.Group.GroupInfo[0].ActiveProcessorCount = num_cpus;
-    dataex->u.Group.GroupInfo[0].ActiveProcessorMask = mask;
-
-    *len += dataex->Size;
-    return TRUE;
-}
-
-#ifdef linux
-
-/* Helper function for counting bitmap values as commonly used by the Linux kernel
- * for storing CPU masks in sysfs. The format is comma separated lists of hex values
- * each max 32-bit e.g. "00ff" or even "00,00000000,0000ffff".
- *
- * Example files include:
- * - /sys/devices/system/cpu/cpu0/cache/index0/shared_cpu_map
- * - /sys/devices/system/cpu/cpu0/topology/thread_siblings
- */
-static BOOL sysfs_parse_bitmap(const char *filename, ULONG_PTR *mask)
-{
-    FILE *f;
-    DWORD r;
-
-    f = fopen(filename, "r");
-    if (!f) return FALSE;
-
-    while (!feof(f))
-    {
-        char op;
-        if (!fscanf(f, "%x%c ", &r, &op)) break;
-        *mask = (sizeof(ULONG_PTR)>sizeof(int) ? *mask << (8 * sizeof(DWORD)) : 0) + r;
-    }
-    fclose( f );
-    return TRUE;
-}
-
-/* Helper function for counting number of elements in interval lists as used by
- * the Linux kernel. The format is comma separated list of intervals of which
- * each interval has the format of "begin-end" where begin and end are decimal
- * numbers. E.g. "0-7", "0-7,16-23"
- *
- * Example files include:
- * - /sys/devices/system/cpu/online
- * - /sys/devices/system/cpu/cpu0/cache/index0/shared_cpu_list
- * - /sys/devices/system/cpu/cpu0/topology/thread_siblings_list.
- */
-static BOOL sysfs_count_list_elements(const char *filename, DWORD *result)
-{
-    FILE *f;
-
-    f = fopen(filename, "r");
-    if (!f) return FALSE;
-
-    while (!feof(f))
-    {
-        char op;
-        DWORD beg, end;
-
-        if (!fscanf(f, "%u%c ", &beg, &op)) break;
-        if(op == '-')
-            fscanf(f, "%u%c ", &end, &op);
-        else
-            end = beg;
-
-        *result += end - beg + 1;
-    }
-    fclose( f );
-    return TRUE;
-}
-
-/* for 'data', max_len is the array count. for 'dataex', max_len is in bytes */
-static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION **data,
-                                          SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **dataex,
-                                          DWORD *max_len, DWORD relation )
-{
-    static const char core_info[] = "/sys/devices/system/cpu/cpu%u/topology/%s";
-    static const char cache_info[] = "/sys/devices/system/cpu/cpu%u/cache/index%u/%s";
-    static const char numa_info[] = "/sys/devices/system/node/node%u/cpumap";
-
-    FILE *fcpu_list, *fnuma_list, *f;
-    DWORD len = 0, beg, end, i, j, r, num_cpus = 0, max_cpus = 0;
-    char op, name[MAX_PATH];
-    ULONG_PTR all_cpus_mask = 0;
-
-    /* On systems with a large number of CPU cores (32 or 64 depending on 32-bit or 64-bit),
-     * we have issues parsing processor information:
-     * - ULONG_PTR masks as used in data structures can't hold all cores. Requires splitting
-     *   data appropriately into "processor groups". We are hard coding 1.
-     * - Thread affinity code in wineserver and our CPU parsing code here work independently.
-     *   So far the Windows mask applied directly to Linux, but process groups break that.
-     *   (NUMA systems you may have multiple non-full groups.)
-     */
-    if(sysfs_count_list_elements("/sys/devices/system/cpu/present", &max_cpus) && max_cpus > MAXIMUM_PROCESSORS)
-    {
-        FIXME("Improve CPU info reporting: system supports %u logical cores, but only %u supported!\n",
-                max_cpus, MAXIMUM_PROCESSORS);
-    }
-
-    fcpu_list = fopen("/sys/devices/system/cpu/online", "r");
-    if (!fcpu_list) return STATUS_NOT_IMPLEMENTED;
-
-    while (!feof(fcpu_list))
-    {
-        if (!fscanf(fcpu_list, "%u%c ", &beg, &op)) break;
-        if (op == '-') fscanf(fcpu_list, "%u%c ", &end, &op);
-        else end = beg;
-
-        for(i = beg; i <= end; i++)
-        {
-            DWORD phys_core = 0;
-            ULONG_PTR thread_mask = 0;
-
-            if (i > 8*sizeof(ULONG_PTR))
-            {
-                FIXME("skipping logical processor %d\n", i);
-                continue;
-            }
-
-            if (relation == RelationAll || relation == RelationProcessorPackage)
-            {
-                sprintf(name, core_info, i, "physical_package_id");
-                f = fopen(name, "r");
-                if (f)
-                {
-                    fscanf(f, "%u", &r);
-                    fclose(f);
-                }
-                else r = 0;
-                if (!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorPackage, r, (ULONG_PTR)1 << i))
-                {
-                    fclose(fcpu_list);
-                    return STATUS_NO_MEMORY;
-                }
-            }
-
-            /* Sysfs enumerates logical cores (and not physical cores), but Windows enumerates
-             * by physical core. Upon enumerating a logical core in sysfs, we register a physical
-             * core and all its logical cores. In order to not report physical cores multiple
-             * times, we pass a unique physical core ID to logical_proc_info_add_by_id and let
-             * that call figure out any duplication.
-             * Obtain a unique physical core ID from the first element of thread_siblings_list.
-             * This list provides logical cores sharing the same physical core. The IDs are based
-             * on kernel cpu core numbering as opposed to a hardware core ID like provided through
-             * 'core_id', so are suitable as a unique ID.
-             */
-            if(relation == RelationAll || relation == RelationProcessorCore ||
-               relation == RelationNumaNode || relation == RelationGroup)
-            {
-                /* Mask of logical threads sharing same physical core in kernel core numbering. */
-                sprintf(name, core_info, i, "thread_siblings");
-                if(!sysfs_parse_bitmap(name, &thread_mask)) thread_mask = 1<<i;
-
-                /* Needed later for NumaNode and Group. */
-                all_cpus_mask |= thread_mask;
-
-                if (relation == RelationAll || relation == RelationProcessorCore)
-                {
-                    sprintf(name, core_info, i, "thread_siblings_list");
-                    f = fopen(name, "r");
-                    if (f)
-                    {
-                        fscanf(f, "%d%c", &phys_core, &op);
-                        fclose(f);
-                    }
-                    else phys_core = i;
-
-                    if (!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorCore, phys_core, thread_mask))
-                    {
-                        fclose(fcpu_list);
-                        return STATUS_NO_MEMORY;
-                    }
-                }
-            }
-
-            if (relation == RelationAll || relation == RelationCache)
-            {
-                for(j = 0; j < 4; j++)
-                {
-                    CACHE_DESCRIPTOR cache;
-                    ULONG_PTR mask = 0;
-
-                    sprintf(name, cache_info, i, j, "shared_cpu_map");
-                    if(!sysfs_parse_bitmap(name, &mask)) continue;
-
-                    sprintf(name, cache_info, i, j, "level");
-                    f = fopen(name, "r");
-                    if(!f) continue;
-                    fscanf(f, "%u", &r);
-                    fclose(f);
-                    cache.Level = r;
-
-                    sprintf(name, cache_info, i, j, "ways_of_associativity");
-                    f = fopen(name, "r");
-                    if(!f) continue;
-                    fscanf(f, "%u", &r);
-                    fclose(f);
-                    cache.Associativity = r;
-
-                    sprintf(name, cache_info, i, j, "coherency_line_size");
-                    f = fopen(name, "r");
-                    if(!f) continue;
-                    fscanf(f, "%u", &r);
-                    fclose(f);
-                    cache.LineSize = r;
-
-                    sprintf(name, cache_info, i, j, "size");
-                    f = fopen(name, "r");
-                    if(!f) continue;
-                    fscanf(f, "%u%c", &r, &op);
-                    fclose(f);
-                    if(op != 'K')
-                        WARN("unknown cache size %u%c\n", r, op);
-                    cache.Size = (op=='K' ? r*1024 : r);
-
-                    sprintf(name, cache_info, i, j, "type");
-                    f = fopen(name, "r");
-                    if(!f) continue;
-                    fscanf(f, "%s", name);
-                    fclose(f);
-                    if (!memcmp(name, "Data", 5))
-                        cache.Type = CacheData;
-                    else if(!memcmp(name, "Instruction", 11))
-                        cache.Type = CacheInstruction;
-                    else
-                        cache.Type = CacheUnified;
-
-                    if (!logical_proc_info_add_cache(data, dataex, &len, max_len, mask, &cache))
-                    {
-                        fclose(fcpu_list);
-                        return STATUS_NO_MEMORY;
-                    }
-                }
-            }
-        }
-    }
-    fclose(fcpu_list);
-
-    num_cpus = count_bits(all_cpus_mask);
-
-    if(relation == RelationAll || relation == RelationNumaNode)
-    {
-        fnuma_list = fopen("/sys/devices/system/node/online", "r");
-        if (!fnuma_list)
-        {
-            if (!logical_proc_info_add_numa_node(data, dataex, &len, max_len, all_cpus_mask, 0))
-                return STATUS_NO_MEMORY;
-        }
-        else
-        {
-            while (!feof(fnuma_list))
-            {
-                if (!fscanf(fnuma_list, "%u%c ", &beg, &op))
-                    break;
-                if (op == '-') fscanf(fnuma_list, "%u%c ", &end, &op);
-                else end = beg;
-
-                for (i = beg; i <= end; i++)
-                {
-                    ULONG_PTR mask = 0;
-
-                    sprintf(name, numa_info, i);
-                    if (!sysfs_parse_bitmap( name, &mask )) continue;
-
-                    if (!logical_proc_info_add_numa_node(data, dataex, &len, max_len, mask, i))
-                    {
-                        fclose(fnuma_list);
-                        return STATUS_NO_MEMORY;
-                    }
-                }
-            }
-            fclose(fnuma_list);
-        }
-    }
-
-    if(dataex && (relation == RelationAll || relation == RelationGroup))
-        logical_proc_info_add_group(dataex, &len, max_len, num_cpus, all_cpus_mask);
-
-    if(data)
-        *max_len = len * sizeof(**data);
-    else
-        *max_len = len;
-
-    return STATUS_SUCCESS;
-}
-
-#elif defined(__APPLE__)
-
-/* for 'data', max_len is the array count. for 'dataex', max_len is in bytes */
-static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION **data,
-                                          SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **dataex,
-                                          DWORD *max_len, DWORD relation)
-{
-    DWORD pkgs_no, cores_no, lcpu_no, lcpu_per_core, cores_per_package, assoc, len = 0;
-    DWORD cache_ctrs[10] = {0};
-    ULONG_PTR all_cpus_mask = 0;
-    CACHE_DESCRIPTOR cache[10];
-    LONGLONG cache_size, cache_line_size, cache_sharing[10];
-    size_t size;
-    DWORD p,i,j,k;
-
-    if (relation != RelationAll)
-        FIXME("Relationship filtering not implemented: 0x%x\n", relation);
-
-    lcpu_no = NtCurrentTeb()->Peb->NumberOfProcessors;
-
-    size = sizeof(pkgs_no);
-    if (sysctlbyname("hw.packages", &pkgs_no, &size, NULL, 0))
-        pkgs_no = 1;
-
-    size = sizeof(cores_no);
-    if (sysctlbyname("hw.physicalcpu", &cores_no, &size, NULL, 0))
-        cores_no = lcpu_no;
-
-    TRACE("%u logical CPUs from %u physical cores across %u packages\n",
-            lcpu_no, cores_no, pkgs_no);
-
-    lcpu_per_core = lcpu_no / cores_no;
-    cores_per_package = cores_no / pkgs_no;
-
-    memset(cache, 0, sizeof(cache));
-    cache[1].Level = 1;
-    cache[1].Type = CacheInstruction;
-    cache[1].Associativity = 8; /* reasonable default */
-    cache[1].LineSize = 0x40; /* reasonable default */
-    cache[2].Level = 1;
-    cache[2].Type = CacheData;
-    cache[2].Associativity = 8;
-    cache[2].LineSize = 0x40;
-    cache[3].Level = 2;
-    cache[3].Type = CacheUnified;
-    cache[3].Associativity = 8;
-    cache[3].LineSize = 0x40;
-    cache[4].Level = 3;
-    cache[4].Type = CacheUnified;
-    cache[4].Associativity = 12;
-    cache[4].LineSize = 0x40;
-
-    size = sizeof(cache_line_size);
-    if (!sysctlbyname("hw.cachelinesize", &cache_line_size, &size, NULL, 0))
-    {
-        for (i = 1; i < 5; i++) cache[i].LineSize = cache_line_size;
-    }
-
-    /* TODO: set actual associativity for all caches */
-    size = sizeof(assoc);
-    if (!sysctlbyname("machdep.cpu.cache.L2_associativity", &assoc, &size, NULL, 0))
-        cache[3].Associativity = assoc;
-
-    size = sizeof(cache_size);
-    if (!sysctlbyname("hw.l1icachesize", &cache_size, &size, NULL, 0))
-        cache[1].Size = cache_size;
-    size = sizeof(cache_size);
-    if (!sysctlbyname("hw.l1dcachesize", &cache_size, &size, NULL, 0))
-        cache[2].Size = cache_size;
-    size = sizeof(cache_size);
-    if (!sysctlbyname("hw.l2cachesize", &cache_size, &size, NULL, 0))
-        cache[3].Size = cache_size;
-    size = sizeof(cache_size);
-    if (!sysctlbyname("hw.l3cachesize", &cache_size, &size, NULL, 0))
-        cache[4].Size = cache_size;
-
-    size = sizeof(cache_sharing);
-    if (sysctlbyname("hw.cacheconfig", cache_sharing, &size, NULL, 0) < 0)
-    {
-        cache_sharing[1] = lcpu_per_core;
-        cache_sharing[2] = lcpu_per_core;
-        cache_sharing[3] = lcpu_per_core;
-        cache_sharing[4] = lcpu_no;
-    }
-    else
-    {
-        /* in cache[], indexes 1 and 2 are l1 caches */
-        cache_sharing[4] = cache_sharing[3];
-        cache_sharing[3] = cache_sharing[2];
-        cache_sharing[2] = cache_sharing[1];
-    }
-
-    for(p = 0; p < pkgs_no; ++p)
-    {
-        for(j = 0; j < cores_per_package && p * cores_per_package + j < cores_no; ++j)
-        {
-            ULONG_PTR mask = 0;
-            DWORD phys_core;
-
-            for(k = 0; k < lcpu_per_core; ++k) mask |= (ULONG_PTR)1 << (j * lcpu_per_core + k);
-
-            all_cpus_mask |= mask;
-
-            /* add to package */
-            if(!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorPackage, p, mask))
-                return STATUS_NO_MEMORY;
-
-            /* add new core */
-            phys_core = p * cores_per_package + j;
-            if(!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorCore, phys_core, mask))
-                return STATUS_NO_MEMORY;
-
-            for(i = 1; i < 5; ++i)
-            {
-                if(cache_ctrs[i] == 0 && cache[i].Size > 0)
-                {
-                    mask = 0;
-                    for(k = 0; k < cache_sharing[i]; ++k)
-                        mask |= (ULONG_PTR)1 << (j * lcpu_per_core + k);
-
-                    if(!logical_proc_info_add_cache(data, dataex, &len, max_len, mask, &cache[i]))
-                        return STATUS_NO_MEMORY;
-                }
-
-                cache_ctrs[i] += lcpu_per_core;
-                if(cache_ctrs[i] == cache_sharing[i]) cache_ctrs[i] = 0;
-            }
-        }
-    }
-
-    /* OSX doesn't support NUMA, so just make one NUMA node for all CPUs */
-    if(!logical_proc_info_add_numa_node(data, dataex, &len, max_len, all_cpus_mask, 0))
-        return STATUS_NO_MEMORY;
-
-    if(dataex) logical_proc_info_add_group(dataex, &len, max_len, lcpu_no, all_cpus_mask);
-
-    if(data)
-        *max_len = len * sizeof(**data);
-    else
-        *max_len = len;
-
-    return STATUS_SUCCESS;
-}
-
-#else
-
-static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION **data,
-                                          SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX **dataex,
-                                          DWORD *max_len, DWORD relation )
-{
-    FIXME("stub\n");
-    return STATUS_NOT_IMPLEMENTED;
-}
-#endif
-
-#ifdef linux
-
-static void copy_smbios_string( char **buffer, char *s, size_t len )
-{
-    if (!len) return;
-    memcpy(*buffer, s, len + 1);
-    *buffer += len + 1;
-}
-
-static size_t get_smbios_string( const char *path, char *str, size_t size )
-{
-    FILE *file;
-    size_t len;
-
-    if (!(file = fopen(path, "r"))) return 0;
-
-    len = fread( str, 1, size - 1, file );
-    fclose( file );
-
-    if (len >= 1 && str[len - 1] == '\n') len--;
-    str[len] = 0;
-    return len;
-}
-
-static void get_system_uuid( GUID *uuid )
-{
-    static const unsigned char hex[] =
-    {
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x00 */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x10 */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x20 */
-        0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,        /* 0x30 */
-        0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,  /* 0x40 */
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        /* 0x50 */
-        0,10,11,12,13,14,15                     /* 0x60 */
-    };
-    int fd;
-
-    memset( uuid, 0xff, sizeof(*uuid) );
-    if ((fd = open( "/var/lib/dbus/machine-id", O_RDONLY )) != -1)
-    {
-        unsigned char buf[32], *p = buf;
-        if (read( fd, buf, sizeof(buf) ) == sizeof(buf))
-        {
-            uuid->Data1 = hex[p[6]] << 28 | hex[p[7]] << 24 | hex[p[4]] << 20 | hex[p[5]] << 16 |
-                          hex[p[2]] << 12 | hex[p[3]] << 8  | hex[p[0]] << 4  | hex[p[1]];
-
-            uuid->Data2 = hex[p[10]] << 12 | hex[p[11]] << 8 | hex[p[8]]  << 4 | hex[p[9]];
-            uuid->Data3 = hex[p[14]] << 12 | hex[p[15]] << 8 | hex[p[12]] << 4 | hex[p[13]];
-
-            uuid->Data4[0] = hex[p[16]] << 4 | hex[p[17]];
-            uuid->Data4[1] = hex[p[18]] << 4 | hex[p[19]];
-            uuid->Data4[2] = hex[p[20]] << 4 | hex[p[21]];
-            uuid->Data4[3] = hex[p[22]] << 4 | hex[p[23]];
-            uuid->Data4[4] = hex[p[24]] << 4 | hex[p[25]];
-            uuid->Data4[5] = hex[p[26]] << 4 | hex[p[27]];
-            uuid->Data4[6] = hex[p[28]] << 4 | hex[p[29]];
-            uuid->Data4[7] = hex[p[30]] << 4 | hex[p[31]];
-        }
-        close( fd );
-    }
-}
-
-static NTSTATUS get_firmware_info( SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG available_len,
-                                   ULONG *required_len )
-{
-    switch (sfti->ProviderSignature)
-    {
-    case RSMB:
-    {
-        char bios_vendor[128], bios_version[128], bios_date[128];
-        size_t bios_vendor_len, bios_version_len, bios_date_len;
-        char system_vendor[128], system_product[128], system_version[128], system_serial[128];
-        size_t system_vendor_len, system_product_len, system_version_len, system_serial_len;
-        char system_sku[128], system_family[128];
-        size_t system_sku_len, system_family_len;
-        char board_vendor[128], board_product[128], board_version[128], board_serial[128], board_asset_tag[128];
-        size_t board_vendor_len, board_product_len, board_version_len, board_serial_len, board_asset_tag_len;
-        char chassis_vendor[128], chassis_version[128], chassis_serial[128], chassis_asset_tag[128];
-        char chassis_type[11] = "2"; /* unknown */
-        size_t chassis_vendor_len, chassis_version_len, chassis_serial_len, chassis_asset_tag_len;
-        char *buffer = (char*)sfti->TableBuffer;
-        BYTE string_count;
-        BYTE handle_count = 0;
-        struct smbios_prologue *prologue;
-        struct smbios_bios *bios;
-        struct smbios_system *system;
-        struct smbios_board *board;
-        struct smbios_chassis *chassis;
-        struct smbios_boot_info *boot_info;
-        struct smbios_header *end_of_table;
-
-#define S(s) s, sizeof(s)
-        bios_vendor_len = get_smbios_string("/sys/class/dmi/id/bios_vendor", S(bios_vendor));
-        bios_version_len = get_smbios_string("/sys/class/dmi/id/bios_version", S(bios_version));
-        bios_date_len = get_smbios_string("/sys/class/dmi/id/bios_date", S(bios_date));
-        system_vendor_len = get_smbios_string("/sys/class/dmi/id/sys_vendor", S(system_vendor));
-        system_product_len = get_smbios_string("/sys/class/dmi/id/product_name", S(system_product));
-        system_version_len = get_smbios_string("/sys/class/dmi/id/product_version", S(system_version));
-        system_serial_len = get_smbios_string("/sys/class/dmi/id/product_serial", S(system_serial));
-        system_sku_len = get_smbios_string("/sys/class/dmi/id/product_sku", S(system_sku));
-        system_family_len = get_smbios_string("/sys/class/dmi/id/product_family", S(system_family));
-        board_vendor_len = get_smbios_string("/sys/class/dmi/id/board_vendor", S(board_vendor));
-        board_product_len = get_smbios_string("/sys/class/dmi/id/board_name", S(board_product));
-        board_version_len = get_smbios_string("/sys/class/dmi/id/board_version", S(board_version));
-        board_serial_len = get_smbios_string("/sys/class/dmi/id/board_serial", S(board_serial));
-        board_asset_tag_len = get_smbios_string("/sys/class/dmi/id/board_asset_tag", S(board_asset_tag));
-        chassis_vendor_len = get_smbios_string("/sys/class/dmi/id/chassis_vendor", S(chassis_vendor));
-        chassis_version_len = get_smbios_string("/sys/class/dmi/id/chassis_version", S(chassis_version));
-        chassis_serial_len = get_smbios_string("/sys/class/dmi/id/chassis_serial", S(chassis_serial));
-        chassis_asset_tag_len = get_smbios_string("/sys/class/dmi/id/chassis_tag", S(chassis_asset_tag));
-        get_smbios_string("/sys/class/dmi/id/chassis_type", S(chassis_type));
-#undef S
-
-        *required_len = sizeof(struct smbios_prologue);
-
-#define L(l) (l + (l ? 1 : 0))
-        *required_len += sizeof(struct smbios_bios);
-        *required_len += max(L(bios_vendor_len) + L(bios_version_len) + L(bios_date_len) + 1, 2);
-
-        *required_len += sizeof(struct smbios_system);
-        *required_len += max(L(system_vendor_len) + L(system_product_len) + L(system_version_len) +
-                             L(system_serial_len) + L(system_sku_len) + L(system_family_len) + 1, 2);
-
-        *required_len += sizeof(struct smbios_board);
-        *required_len += max(L(board_vendor_len) + L(board_product_len) + L(board_version_len) +
-                             L(board_serial_len) + L(board_asset_tag_len) + 1, 2);
-
-        *required_len += sizeof(struct smbios_chassis);
-        *required_len += max(L(chassis_vendor_len) + L(chassis_version_len) + L(chassis_serial_len) +
-                             L(chassis_asset_tag_len) + 1, 2);
-
-        *required_len += sizeof(struct smbios_boot_info);
-        *required_len += 2;
-
-        *required_len += sizeof(struct smbios_header);
-        *required_len += 2;
-#undef L
-
-        sfti->TableBufferLength = *required_len;
-
-        *required_len += FIELD_OFFSET(SYSTEM_FIRMWARE_TABLE_INFORMATION, TableBuffer);
-
-        if (available_len < *required_len)
-            return STATUS_BUFFER_TOO_SMALL;
-
-        prologue = (struct smbios_prologue*)buffer;
-        prologue->calling_method = 0;
-        prologue->major_version = 2;
-        prologue->minor_version = 4;
-        prologue->revision = 0;
-        prologue->length = sfti->TableBufferLength - sizeof(struct smbios_prologue);
-        buffer += sizeof(struct smbios_prologue);
-
-        string_count = 0;
-        bios = (struct smbios_bios*)buffer;
-        bios->hdr.type = 0;
-        bios->hdr.length = sizeof(struct smbios_bios);
-        bios->hdr.handle = handle_count++;
-        bios->vendor = bios_vendor_len ? ++string_count : 0;
-        bios->version = bios_version_len ? ++string_count : 0;
-        bios->start = 0;
-        bios->date = bios_date_len ? ++string_count : 0;
-        bios->size = 0;
-        bios->characteristics = 0x4; /* not supported */
-        bios->characteristics_ext[0] = 0;
-        bios->characteristics_ext[1] = 0;
-        bios->system_bios_major_release = 0xFF; /* not supported */
-        bios->system_bios_minor_release = 0xFF; /* not supported */
-        bios->ec_firmware_major_release = 0xFF; /* not supported */
-        bios->ec_firmware_minor_release = 0xFF; /* not supported */
-        buffer += sizeof(struct smbios_bios);
-
-        copy_smbios_string(&buffer, bios_vendor, bios_vendor_len);
-        copy_smbios_string(&buffer, bios_version, bios_version_len);
-        copy_smbios_string(&buffer, bios_date, bios_date_len);
-        if (!string_count) *buffer++ = 0;
-        *buffer++ = 0;
-
-        string_count = 0;
-        system = (struct smbios_system*)buffer;
-        system->hdr.type = 1;
-        system->hdr.length = sizeof(struct smbios_system);
-        system->hdr.handle = handle_count++;
-        system->vendor = system_vendor_len ? ++string_count : 0;
-        system->product = system_product_len ? ++string_count : 0;
-        system->version = system_version_len ? ++string_count : 0;
-        system->serial = system_serial_len ? ++string_count : 0;
-        get_system_uuid( (GUID *)system->uuid );
-        system->wake_up_type = 0x02; /* unknown */
-        system->sku_number = system_sku_len ? ++string_count : 0;
-        system->family = system_family_len ? ++string_count : 0;
-        buffer += sizeof(struct smbios_system);
-
-        copy_smbios_string(&buffer, system_vendor, system_vendor_len);
-        copy_smbios_string(&buffer, system_product, system_product_len);
-        copy_smbios_string(&buffer, system_version, system_version_len);
-        copy_smbios_string(&buffer, system_serial, system_serial_len);
-        copy_smbios_string(&buffer, system_sku, system_sku_len);
-        copy_smbios_string(&buffer, system_family, system_family_len);
-        if (!string_count) *buffer++ = 0;
-        *buffer++ = 0;
-
-        string_count = 0;
-        chassis = (struct smbios_chassis*)buffer;
-        chassis->hdr.type = 3;
-        chassis->hdr.length = sizeof(struct smbios_chassis);
-        chassis->hdr.handle = handle_count++;
-        chassis->vendor = chassis_vendor_len ? ++string_count : 0;
-        chassis->type = atoi(chassis_type);
-        chassis->version = chassis_version_len ? ++string_count : 0;
-        chassis->serial = chassis_serial_len ? ++string_count : 0;
-        chassis->asset_tag = chassis_asset_tag_len ? ++string_count : 0;
-        chassis->boot_state = 0x02; /* unknown */
-        chassis->power_supply_state = 0x02; /* unknown */
-        chassis->thermal_state = 0x02; /* unknown */
-        chassis->security_status = 0x02; /* unknown */
-        chassis->oem_defined = 0;
-        chassis->height = 0; /* undefined */
-        chassis->num_power_cords = 0; /* unspecified */
-        chassis->num_contained_elements = 0;
-        chassis->contained_element_rec_length = 3;
-        buffer += sizeof(struct smbios_chassis);
-
-        copy_smbios_string(&buffer, chassis_vendor, chassis_vendor_len);
-        copy_smbios_string(&buffer, chassis_version, chassis_version_len);
-        copy_smbios_string(&buffer, chassis_serial, chassis_serial_len);
-        copy_smbios_string(&buffer, chassis_asset_tag, chassis_asset_tag_len);
-        if (!string_count) *buffer++ = 0;
-        *buffer++ = 0;
-
-        string_count = 0;
-        board = (struct smbios_board*)buffer;
-        board->hdr.type = 2;
-        board->hdr.length = sizeof(struct smbios_board);
-        board->hdr.handle = handle_count++;
-        board->vendor = board_vendor_len ? ++string_count : 0;
-        board->product = board_product_len ? ++string_count : 0;
-        board->version = board_version_len ? ++string_count : 0;
-        board->serial = board_serial_len ? ++string_count : 0;
-        board->asset_tag = board_asset_tag_len ? ++string_count : 0;
-        board->feature_flags = 0x5; /* hosting board, removable */
-        board->location = 0;
-        board->chassis_handle = chassis->hdr.handle;
-        board->board_type = 0xa; /* motherboard */
-        board->num_contained_handles = 0;
-        buffer += sizeof(struct smbios_board);
-
-        copy_smbios_string(&buffer, board_vendor, board_vendor_len);
-        copy_smbios_string(&buffer, board_product, board_product_len);
-        copy_smbios_string(&buffer, board_version, board_version_len);
-        copy_smbios_string(&buffer, board_serial, board_serial_len);
-        copy_smbios_string(&buffer, board_asset_tag, board_asset_tag_len);
-        if (!string_count) *buffer++ = 0;
-        *buffer++ = 0;
-
-        boot_info = (struct smbios_boot_info*)buffer;
-        boot_info->hdr.type = 32;
-        boot_info->hdr.length = sizeof(struct smbios_boot_info);
-        boot_info->hdr.handle = handle_count++;
-        memset(boot_info->reserved, 0, sizeof(boot_info->reserved));
-        memset(boot_info->boot_status, 0, sizeof(boot_info->boot_status)); /* no errors detected */
-        buffer += sizeof(struct smbios_boot_info);
-        *buffer++ = 0;
-        *buffer++ = 0;
-
-        end_of_table = (struct smbios_header*)buffer;
-        end_of_table->type = 127;
-        end_of_table->length = sizeof(struct smbios_header);
-        end_of_table->handle = handle_count++;
-        buffer += sizeof(struct smbios_header);
-        *buffer++ = 0;
-        *buffer++ = 0;
-
-        return STATUS_SUCCESS;
-    }
-    default:
-        FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION provider %08x\n", sfti->ProviderSignature);
-        return STATUS_NOT_IMPLEMENTED;
-    }
-}
-
-#elif defined(__APPLE__)
-
-static NTSTATUS get_firmware_info( SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG available_len,
-                                   ULONG *required_len )
-{
-    switch (sfti->ProviderSignature)
-    {
-    case RSMB:
-    {
-        io_service_t service;
-        CFDataRef data;
-        const UInt8 *ptr;
-        CFIndex len;
-        struct smbios_prologue *prologue;
-        BYTE major_version = 2, minor_version = 0;
-
-        if (!(service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleSMBIOS"))))
-        {
-            WARN("can't find AppleSMBIOS service\n");
-            return STATUS_NO_MEMORY;
-        }
-
-        if (!(data = IORegistryEntryCreateCFProperty(service, CFSTR("SMBIOS-EPS"), kCFAllocatorDefault, 0)))
-        {
-            WARN("can't find SMBIOS entry point\n");
-            IOObjectRelease(service);
-            return STATUS_NO_MEMORY;
-        }
-
-        len = CFDataGetLength(data);
-        ptr = CFDataGetBytePtr(data);
-        if (len >= 8 && !memcmp(ptr, "_SM_", 4))
-        {
-            major_version = ptr[6];
-            minor_version = ptr[7];
-        }
-        CFRelease(data);
-
-        if (!(data = IORegistryEntryCreateCFProperty(service, CFSTR("SMBIOS"), kCFAllocatorDefault, 0)))
-        {
-            WARN("can't find SMBIOS table\n");
-            IOObjectRelease(service);
-            return STATUS_NO_MEMORY;
-        }
-
-        len = CFDataGetLength(data);
-        ptr = CFDataGetBytePtr(data);
-        sfti->TableBufferLength = sizeof(*prologue) + len;
-        *required_len = sfti->TableBufferLength + FIELD_OFFSET(SYSTEM_FIRMWARE_TABLE_INFORMATION, TableBuffer);
-        if (available_len < *required_len)
-        {
-            CFRelease(data);
-            IOObjectRelease(service);
-            return STATUS_BUFFER_TOO_SMALL;
-        }
-
-        prologue = (struct smbios_prologue *)sfti->TableBuffer;
-        prologue->calling_method = 0;
-        prologue->major_version = major_version;
-        prologue->minor_version = minor_version;
-        prologue->revision = 0;
-        prologue->length = sfti->TableBufferLength - sizeof(*prologue);
-
-        memcpy(sfti->TableBuffer + sizeof(*prologue), ptr, len);
-
-        CFRelease(data);
-        IOObjectRelease(service);
-        return STATUS_SUCCESS;
-    }
-    default:
-        FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION provider %08x\n", sfti->ProviderSignature);
-        return STATUS_NOT_IMPLEMENTED;
-    }
-}
-
-#else
-
-static NTSTATUS get_firmware_info( SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG available_len,
-                                   ULONG *required_len )
-{
-    FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION\n");
-    sfti->TableBufferLength = 0;
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-#endif
-
-static void get_performance_info( SYSTEM_PERFORMANCE_INFORMATION *info )
-{
-    unsigned long long totalram = 0, freeram = 0, totalswap = 0, freeswap = 0;
-    FILE *fp;
-
-    memset( info, 0, sizeof(*info) );
-
-    if ((fp = fopen("/proc/uptime", "r")))
-    {
-        double uptime, idle_time;
-
-        fscanf(fp, "%lf %lf", &uptime, &idle_time);
-        fclose(fp);
-        info->IdleTime.QuadPart = 10000000 * idle_time;
-    }
-    else
-    {
-        static ULONGLONG idle;
-        /* many programs expect IdleTime to change so fake change */
-        info->IdleTime.QuadPart = ++idle;
-    }
-
-#ifdef linux
-    if ((fp = fopen("/proc/meminfo", "r")))
-    {
-        unsigned long long value;
-        char line[64];
-
-        while (fgets(line, sizeof(line), fp))
-        {
-            if(sscanf(line, "MemTotal: %llu kB", &value) == 1)
-                totalram += value * 1024;
-            else if(sscanf(line, "MemFree: %llu kB", &value) == 1)
-                freeram += value * 1024;
-            else if(sscanf(line, "SwapTotal: %llu kB", &value) == 1)
-                totalswap += value * 1024;
-            else if(sscanf(line, "SwapFree: %llu kB", &value) == 1)
-                freeswap += value * 1024;
-            else if (sscanf(line, "Buffers: %llu", &value))
-                freeram += value * 1024;
-            else if (sscanf(line, "Cached: %llu", &value))
-                freeram += value * 1024;
-        }
-        fclose(fp);
-    }
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || \
-    defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
-    {
-#ifdef __APPLE__
-        unsigned int val;
-#else
-        unsigned long val;
-#endif
-        int mib[2];
-        size_t size_sys;
-
-        mib[0] = CTL_HW;
-#ifdef HW_MEMSIZE
-        {
-            uint64_t val64;
-            mib[1] = HW_MEMSIZE;
-            size_sys = sizeof(val64);
-            if (!sysctl(mib, 2, &val64, &size_sys, NULL, 0) && size_sys == sizeof(val64)) totalram = val64;
-        }
-#endif
-
-#ifdef HAVE_MACH_MACH_H
-        {
-            host_name_port_t host = mach_host_self();
-            mach_msg_type_number_t count;
-#ifdef HOST_VM_INFO64_COUNT
-            vm_statistics64_data_t vm_stat;
-
-            count = HOST_VM_INFO64_COUNT;
-            if (host_statistics64(host, HOST_VM_INFO64, (host_info64_t)&vm_stat, &count) == KERN_SUCCESS)
-                freeram = (vm_stat.free_count + vm_stat.inactive_count) * (ULONGLONG)page_size;
-#endif
-            if (!totalram)
-            {
-                host_basic_info_data_t info;
-                count = HOST_BASIC_INFO_COUNT;
-                if (host_info(host, HOST_BASIC_INFO, (host_info_t)&info, &count) == KERN_SUCCESS)
-                    totalram = info.max_mem;
-            }
-            mach_port_deallocate(mach_task_self(), host);
-        }
-#endif
-
-        if (!totalram)
-        {
-            mib[1] = HW_PHYSMEM;
-            size_sys = sizeof(val);
-            if (!sysctl(mib, 2, &val, &size_sys, NULL, 0) && size_sys == sizeof(val)) totalram = val;
-        }
-        if (!freeram)
-        {
-            mib[1] = HW_USERMEM;
-            size_sys = sizeof(val);
-            if (!sysctl(mib, 2, &val, &size_sys, NULL, 0) && size_sys == sizeof(val)) freeram = val;
-        }
-#ifdef VM_SWAPUSAGE
-        {
-            struct xsw_usage swap;
-            mib[0] = CTL_VM;
-            mib[1] = VM_SWAPUSAGE;
-            size_sys = sizeof(swap);
-            if (!sysctl(mib, 2, &swap, &size_sys, NULL, 0) && size_sys == sizeof(swap))
-            {
-                totalswap = swap.xsu_total;
-                freeswap = swap.xsu_avail;
-            }
-        }
-#endif
-    }
-#endif
-    info->AvailablePages      = freeram / page_size;
-    info->TotalCommittedPages = (totalram + totalswap - freeram - freeswap) / page_size;
-    info->TotalCommitLimit    = (totalram + totalswap) / page_size;
-}
-
-
-/* calculate the mday of dst change date, so that for instance Sun 5 Oct 2007
- * (last Sunday in October of 2007) becomes Sun Oct 28 2007
- *
- * Note: year, day and month must be in unix format.
- */
-static int weekday_to_mday(int year, int day, int mon, int day_of_week)
-{
-    struct tm date;
-    time_t tmp;
-    int wday, mday;
-
-    /* find first day in the month matching week day of the date */
-    memset(&date, 0, sizeof(date));
-    date.tm_year = year;
-    date.tm_mon = mon;
-    date.tm_mday = -1;
-    date.tm_wday = -1;
-    do
-    {
-        date.tm_mday++;
-        tmp = mktime(&date);
-    } while (date.tm_wday != day_of_week || date.tm_mon != mon);
-
-    mday = date.tm_mday;
-
-    /* find number of week days in the month matching week day of the date */
-    wday = 1; /* 1 - 1st, ...., 5 - last */
-    while (wday < day)
-    {
-        struct tm *tm;
-
-        date.tm_mday += 7;
-        tmp = mktime(&date);
-        tm = localtime(&tmp);
-        if (tm->tm_mon != mon)
-            break;
-        mday = tm->tm_mday;
-        wday++;
-    }
-
-    return mday;
-}
-
-static BOOL match_tz_date( const RTL_SYSTEM_TIME *st, const RTL_SYSTEM_TIME *reg_st )
-{
-    WORD wDay;
-
-    if (st->wMonth != reg_st->wMonth) return FALSE;
-    if (!st->wMonth) return TRUE; /* no transition dates */
-    wDay = reg_st->wDay;
-    if (!reg_st->wYear) /* date in a day-of-week format */
-        wDay = weekday_to_mday(st->wYear - 1900, reg_st->wDay, reg_st->wMonth - 1, reg_st->wDayOfWeek);
-
-    return (st->wDay == wDay &&
-            st->wHour == reg_st->wHour &&
-            st->wMinute == reg_st->wMinute &&
-            st->wSecond == reg_st->wSecond &&
-            st->wMilliseconds == reg_st->wMilliseconds);
-}
-
-static BOOL match_tz_info( const RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi,
-                           const RTL_DYNAMIC_TIME_ZONE_INFORMATION *reg_tzi )
-{
-    return (tzi->Bias == reg_tzi->Bias &&
-            match_tz_date(&tzi->StandardDate, &reg_tzi->StandardDate) &&
-            match_tz_date(&tzi->DaylightDate, &reg_tzi->DaylightDate));
-}
-
-static BOOL match_tz_name( const char *tz_name, const RTL_DYNAMIC_TIME_ZONE_INFORMATION *reg_tzi )
-{
-    static const struct { WCHAR key_name[32]; const char *short_name; } mapping[] =
-    {
-        { {'K','o','r','e','a',' ','S','t','a','n','d','a','r','d',' ','T','i','m','e',0 },
-          "KST" },
-        { {'T','o','k','y','o',' ','S','t','a','n','d','a','r','d',' ','T','i','m','e',0 },
-          "JST" },
-        { {'Y','a','k','u','t','s','k',' ','S','t','a','n','d','a','r','d',' ','T','i','m','e',0 },
-          "+09" }, /* YAKST was used until tzdata 2016f */
-    };
-    unsigned int i;
-
-    if (reg_tzi->DaylightDate.wMonth) return TRUE;
-    for (i = 0; i < ARRAY_SIZE(mapping); i++)
-    {
-        if (!wcscmp( mapping[i].key_name, reg_tzi->TimeZoneKeyName ))
-            return !strcmp( mapping[i].short_name, tz_name );
-    }
-    return TRUE;
-}
-
-static BOOL reg_query_value( HKEY key, LPCWSTR name, DWORD type, void *data, DWORD count )
-{
-    char buf[256];
-    UNICODE_STRING nameW;
-    KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buf;
-
-    if (count > sizeof(buf) - sizeof(KEY_VALUE_PARTIAL_INFORMATION)) return FALSE;
-
-    nameW.Buffer = (WCHAR *)name;
-    nameW.Length = wcslen( name ) * sizeof(WCHAR);
-    if (NtQueryValueKey( key, &nameW, KeyValuePartialInformation, buf, sizeof(buf), &count ))
-        return FALSE;
-
-    if (info->Type != type) return FALSE;
-    memcpy( data, info->Data, info->DataLength );
-    return TRUE;
-}
-
-static void find_reg_tz_info(RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi, const char* tz_name, int year)
-{
-    static const WCHAR stdW[] = { 'S','t','d',0 };
-    static const WCHAR dltW[] = { 'D','l','t',0 };
-    static const WCHAR mui_stdW[] = { 'M','U','I','_','S','t','d',0 };
-    static const WCHAR mui_dltW[] = { 'M','U','I','_','D','l','t',0 };
-    static const WCHAR tziW[] = { 'T','Z','I',0 };
-    static const WCHAR Time_ZonesW[] = { 'M','a','c','h','i','n','e','\\',
-        'S','o','f','t','w','a','r','e','\\',
-        'M','i','c','r','o','s','o','f','t','\\',
-        'W','i','n','d','o','w','s',' ','N','T','\\',
-        'C','u','r','r','e','n','t','V','e','r','s','i','o','n','\\',
-        'T','i','m','e',' ','Z','o','n','e','s',0 };
-    static const WCHAR Dynamic_DstW[] = { 'D','y','n','a','m','i','c',' ','D','S','T',0 };
-    RTL_DYNAMIC_TIME_ZONE_INFORMATION reg_tzi;
-    HANDLE key, subkey, subkey_dyn = 0;
-    ULONG idx, len;
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
-    WCHAR yearW[16];
-    char buffer[128];
-    KEY_BASIC_INFORMATION *info = (KEY_BASIC_INFORMATION *)buffer;
-
-    sprintf( buffer, "%u", year );
-    ascii_to_unicode( yearW, buffer, strlen(buffer) + 1 );
-
-    nameW.Buffer = (WCHAR *)Time_ZonesW;
-    nameW.Length = sizeof(Time_ZonesW) - sizeof(WCHAR);
-    InitializeObjectAttributes( &attr, &nameW, 0, 0, NULL );
-    if (NtOpenKey( &key, KEY_READ, &attr )) return;
-
-    idx = 0;
-    while (!NtEnumerateKey( key, idx++, KeyBasicInformation, buffer, sizeof(buffer), &len ))
-    {
-        struct tz_reg_data
-        {
-            LONG bias;
-            LONG std_bias;
-            LONG dlt_bias;
-            RTL_SYSTEM_TIME std_date;
-            RTL_SYSTEM_TIME dlt_date;
-        } tz_data;
-        BOOL is_dynamic = FALSE;
-
-        nameW.Buffer = info->Name;
-        nameW.Length = info->NameLength;
-        attr.RootDirectory = key;
-        if (NtOpenKey( &subkey, KEY_READ, &attr )) continue;
-
-        memset( &reg_tzi, 0, sizeof(reg_tzi) );
-        memcpy(reg_tzi.TimeZoneKeyName, nameW.Buffer, nameW.Length);
-        reg_tzi.TimeZoneKeyName[nameW.Length/sizeof(WCHAR)] = 0;
-
-        if (!reg_query_value(subkey, mui_stdW, REG_SZ, reg_tzi.StandardName, sizeof(reg_tzi.StandardName)) &&
-            !reg_query_value(subkey, stdW, REG_SZ, reg_tzi.StandardName, sizeof(reg_tzi.StandardName)))
-            goto next;
-
-        if (!reg_query_value(subkey, mui_dltW, REG_SZ, reg_tzi.DaylightName, sizeof(reg_tzi.DaylightName)) &&
-            !reg_query_value(subkey, dltW, REG_SZ, reg_tzi.DaylightName, sizeof(reg_tzi.DaylightName)))
-            goto next;
-
-        /* Check for Dynamic DST entry first */
-        nameW.Buffer = (WCHAR *)Dynamic_DstW;
-        nameW.Length = sizeof(Dynamic_DstW) - sizeof(WCHAR);
-        attr.RootDirectory = subkey;
-        if (!NtOpenKey( &subkey_dyn, KEY_READ, &attr ))
-        {
-            is_dynamic = reg_query_value( subkey_dyn, yearW, REG_BINARY, &tz_data, sizeof(tz_data) );
-            NtClose( subkey_dyn );
-        }
-        if (!is_dynamic && !reg_query_value( subkey, tziW, REG_BINARY, &tz_data, sizeof(tz_data) ))
-            goto next;
-
-        reg_tzi.Bias = tz_data.bias;
-        reg_tzi.StandardBias = tz_data.std_bias;
-        reg_tzi.DaylightBias = tz_data.dlt_bias;
-        reg_tzi.StandardDate = tz_data.std_date;
-        reg_tzi.DaylightDate = tz_data.dlt_date;
-
-        TRACE("%s: bias %d\n", debugstr_us(&nameW), reg_tzi.Bias);
-        TRACE("std (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
-              reg_tzi.StandardDate.wDay, reg_tzi.StandardDate.wMonth,
-              reg_tzi.StandardDate.wYear, reg_tzi.StandardDate.wDayOfWeek,
-              reg_tzi.StandardDate.wHour, reg_tzi.StandardDate.wMinute,
-              reg_tzi.StandardDate.wSecond, reg_tzi.StandardDate.wMilliseconds,
-              reg_tzi.StandardBias);
-        TRACE("dst (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
-              reg_tzi.DaylightDate.wDay, reg_tzi.DaylightDate.wMonth,
-              reg_tzi.DaylightDate.wYear, reg_tzi.DaylightDate.wDayOfWeek,
-              reg_tzi.DaylightDate.wHour, reg_tzi.DaylightDate.wMinute,
-              reg_tzi.DaylightDate.wSecond, reg_tzi.DaylightDate.wMilliseconds,
-              reg_tzi.DaylightBias);
-
-        if (match_tz_info( tzi, &reg_tzi ) && match_tz_name( tz_name, &reg_tzi ))
-        {
-            *tzi = reg_tzi;
-            NtClose( subkey );
-            NtClose( key );
-            return;
-        }
-    next:
-        NtClose( subkey );
-    }
-    NtClose( key );
-
-    if (idx == 1) return;  /* registry info not initialized yet */
-
-    FIXME("Can't find matching timezone information in the registry for "
-          "%s, bias %d, std (d/m/y): %u/%02u/%04u, dlt (d/m/y): %u/%02u/%04u\n",
-          tz_name, tzi->Bias,
-          tzi->StandardDate.wDay, tzi->StandardDate.wMonth, tzi->StandardDate.wYear,
-          tzi->DaylightDate.wDay, tzi->DaylightDate.wMonth, tzi->DaylightDate.wYear);
-}
-
-static time_t find_dst_change(unsigned long min, unsigned long max, int *is_dst)
-{
-    time_t start;
-    struct tm *tm;
-
-    start = min;
-    tm = localtime(&start);
-    *is_dst = !tm->tm_isdst;
-    TRACE("starting date isdst %d, %s", !*is_dst, ctime(&start));
-
-    while (min <= max)
-    {
-        time_t pos = (min + max) / 2;
-        tm = localtime(&pos);
-
-        if (tm->tm_isdst != *is_dst)
-            min = pos + 1;
-        else
-            max = pos - 1;
-    }
-    return min;
-}
-
-static void get_timezone_info( RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi )
-{
-    static pthread_mutex_t tz_mutex = PTHREAD_MUTEX_INITIALIZER;
-    static RTL_DYNAMIC_TIME_ZONE_INFORMATION cached_tzi;
-    static int current_year = -1, current_bias = 65535;
-    struct tm *tm;
-    char tz_name[16];
-    time_t year_start, year_end, tmp, dlt = 0, std = 0;
-    int is_dst, bias;
-
-    pthread_mutex_lock( &tz_mutex );
-
-    year_start = time(NULL);
-    tm = gmtime(&year_start);
-    bias = (LONG)(mktime(tm) - year_start) / 60;
-
-    tm = localtime(&year_start);
-    if (current_year == tm->tm_year && current_bias == bias)
-    {
-        *tzi = cached_tzi;
-        pthread_mutex_unlock( &tz_mutex );
-        return;
-    }
-
-    memset(tzi, 0, sizeof(*tzi));
-    if (!strftime(tz_name, sizeof(tz_name), "%Z", tm)) {
-        /* not enough room or another error */
-        tz_name[0] = '\0';
-    }
-
-    TRACE("tz data will be valid through year %d, bias %d\n", tm->tm_year + 1900, bias);
-    current_year = tm->tm_year;
-    current_bias = bias;
-
-    tzi->Bias = bias;
-
-    tm->tm_isdst = 0;
-    tm->tm_mday = 1;
-    tm->tm_mon = tm->tm_hour = tm->tm_min = tm->tm_sec = tm->tm_wday = tm->tm_yday = 0;
-    year_start = mktime(tm);
-    TRACE("year_start: %s", ctime(&year_start));
-
-    tm->tm_mday = tm->tm_wday = tm->tm_yday = 0;
-    tm->tm_mon = 12;
-    tm->tm_hour = 23;
-    tm->tm_min = tm->tm_sec = 59;
-    year_end = mktime(tm);
-    TRACE("year_end: %s", ctime(&year_end));
-
-    tmp = find_dst_change(year_start, year_end, &is_dst);
-    if (is_dst)
-        dlt = tmp;
-    else
-        std = tmp;
-
-    tmp = find_dst_change(tmp, year_end, &is_dst);
-    if (is_dst)
-        dlt = tmp;
-    else
-        std = tmp;
-
-    TRACE("std: %s", ctime(&std));
-    TRACE("dlt: %s", ctime(&dlt));
-
-    if (dlt == std || !dlt || !std)
-        TRACE("there is no daylight saving rules in this time zone\n");
-    else
-    {
-        tmp = dlt - tzi->Bias * 60;
-        tm = gmtime(&tmp);
-        TRACE("dlt gmtime: %s", asctime(tm));
-
-        tzi->DaylightBias = -60;
-        tzi->DaylightDate.wYear = tm->tm_year + 1900;
-        tzi->DaylightDate.wMonth = tm->tm_mon + 1;
-        tzi->DaylightDate.wDayOfWeek = tm->tm_wday;
-        tzi->DaylightDate.wDay = tm->tm_mday;
-        tzi->DaylightDate.wHour = tm->tm_hour;
-        tzi->DaylightDate.wMinute = tm->tm_min;
-        tzi->DaylightDate.wSecond = tm->tm_sec;
-        tzi->DaylightDate.wMilliseconds = 0;
-
-        TRACE("daylight (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
-            tzi->DaylightDate.wDay, tzi->DaylightDate.wMonth,
-            tzi->DaylightDate.wYear, tzi->DaylightDate.wDayOfWeek,
-            tzi->DaylightDate.wHour, tzi->DaylightDate.wMinute,
-            tzi->DaylightDate.wSecond, tzi->DaylightDate.wMilliseconds,
-            tzi->DaylightBias);
-
-        tmp = std - tzi->Bias * 60 - tzi->DaylightBias * 60;
-        tm = gmtime(&tmp);
-        TRACE("std gmtime: %s", asctime(tm));
-
-        tzi->StandardBias = 0;
-        tzi->StandardDate.wYear = tm->tm_year + 1900;
-        tzi->StandardDate.wMonth = tm->tm_mon + 1;
-        tzi->StandardDate.wDayOfWeek = tm->tm_wday;
-        tzi->StandardDate.wDay = tm->tm_mday;
-        tzi->StandardDate.wHour = tm->tm_hour;
-        tzi->StandardDate.wMinute = tm->tm_min;
-        tzi->StandardDate.wSecond = tm->tm_sec;
-        tzi->StandardDate.wMilliseconds = 0;
-
-        TRACE("standard (d/m/y): %u/%02u/%04u day of week %u %u:%02u:%02u.%03u bias %d\n",
-            tzi->StandardDate.wDay, tzi->StandardDate.wMonth,
-            tzi->StandardDate.wYear, tzi->StandardDate.wDayOfWeek,
-            tzi->StandardDate.wHour, tzi->StandardDate.wMinute,
-            tzi->StandardDate.wSecond, tzi->StandardDate.wMilliseconds,
-            tzi->StandardBias);
-    }
-
-    find_reg_tz_info(tzi, tz_name, current_year + 1900);
-    cached_tzi = *tzi;
-    pthread_mutex_unlock( &tz_mutex );
-}
-
-
-/******************************************************************************
- *              NtQuerySystemInformation  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
-                                          void *info, ULONG size, ULONG *ret_size )
-{
-    NTSTATUS ret = STATUS_SUCCESS;
-    ULONG len = 0;
-
-    TRACE( "(0x%08x,%p,0x%08x,%p)\n", class, info, size, ret_size );
-
-    switch (class)
-    {
-    case SystemBasicInformation:
-    {
-        SYSTEM_BASIC_INFORMATION sbi;
-
-        virtual_get_system_info( &sbi );
-        len = sizeof(sbi);
-        if (size == len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &sbi, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    case SystemCpuInformation:
-        if (size >= (len = sizeof(cpu_info)))
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy(info, &cpu_info, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-
-    case SystemPerformanceInformation:
-    {
-        SYSTEM_PERFORMANCE_INFORMATION spi;
-        static BOOL fixme_written = FALSE;
-
-        get_performance_info( &spi );
-        len = sizeof(spi);
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &spi, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        if(!fixme_written) {
-            FIXME("info_class SYSTEM_PERFORMANCE_INFORMATION\n");
-            fixme_written = TRUE;
-        }
-        break;
-    }
-
-    case SystemTimeOfDayInformation:
-    {
-        struct tm *tm;
-        time_t now;
-        SYSTEM_TIMEOFDAY_INFORMATION sti = {{{ 0 }}};
-
-        sti.BootTime.QuadPart = server_start_time;
-        now = time( NULL );
-        tm = gmtime( &now );
-        sti.TimeZoneBias.QuadPart = mktime( tm ) - now;
-        tm = localtime( &now );
-        if (tm->tm_isdst) sti.TimeZoneBias.QuadPart -= 3600;
-        sti.TimeZoneBias.QuadPart *= TICKSPERSEC;
-        NtQuerySystemTime( &sti.SystemTime );
-
-        if (size <= sizeof(sti))
-        {
-            len = size;
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &sti, size);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    case SystemProcessInformation:
-    {
-        unsigned int process_count, i, j;
-        char *buffer = NULL;
-        unsigned int pos = 0;
-
-        if (size && !(buffer = malloc( size )))
-        {
-            ret = STATUS_NO_MEMORY;
-            break;
-        }
-
-        SERVER_START_REQ( list_processes )
-        {
-            wine_server_set_reply( req, buffer, size );
-            ret = wine_server_call( req );
-            len = reply->info_size;
-            process_count = reply->process_count;
-        }
-        SERVER_END_REQ;
-
-        if (ret)
-        {
-            free( buffer );
-            break;
-        }
-
-        len = 0;
-
-        for (i = 0; i < process_count; i++)
-        {
-            SYSTEM_PROCESS_INFORMATION *nt_process = (SYSTEM_PROCESS_INFORMATION *)((char *)info + len);
-            const struct process_info *server_process;
-            const WCHAR *server_name, *file_part;
-            ULONG proc_len;
-            ULONG name_len = 0;
-
-            pos = (pos + 7) & ~7;
-            server_process = (const struct process_info *)(buffer + pos);
-            pos += sizeof(*server_process);
-
-            server_name = (const WCHAR *)(buffer + pos);
-            file_part = server_name + (server_process->name_len / sizeof(WCHAR));
-            pos += server_process->name_len;
-            while (file_part > server_name && file_part[-1] != '\\')
-            {
-                file_part--;
-                name_len++;
-            }
-
-            proc_len = sizeof(*nt_process) + server_process->thread_count * sizeof(SYSTEM_THREAD_INFORMATION)
-                         + (name_len + 1) * sizeof(WCHAR);
-            len += proc_len;
-
-            if (len <= size)
-            {
-                memset(nt_process, 0, sizeof(*nt_process));
-                if (i < process_count - 1)
-                    nt_process->NextEntryOffset = proc_len;
-                nt_process->CreationTime.QuadPart = server_process->start_time;
-                nt_process->dwThreadCount = server_process->thread_count;
-                nt_process->dwBasePriority = server_process->priority;
-                nt_process->UniqueProcessId = UlongToHandle(server_process->pid);
-                nt_process->ParentProcessId = UlongToHandle(server_process->parent_pid);
-                nt_process->HandleCount = server_process->handle_count;
-                get_thread_times( server_process->unix_pid, -1, &nt_process->KernelTime, &nt_process->UserTime );
-                fill_vm_counters( &nt_process->vmCounters, server_process->unix_pid );
-            }
-
-            pos = (pos + 7) & ~7;
-            for (j = 0; j < server_process->thread_count; j++)
-            {
-                const struct thread_info *server_thread = (const struct thread_info *)(buffer + pos);
-
-                if (len <= size)
-                {
-                    nt_process->ti[j].CreateTime.QuadPart = server_thread->start_time;
-                    nt_process->ti[j].ClientId.UniqueProcess = UlongToHandle(server_process->pid);
-                    nt_process->ti[j].ClientId.UniqueThread = UlongToHandle(server_thread->tid);
-                    nt_process->ti[j].dwCurrentPriority = server_thread->current_priority;
-                    nt_process->ti[j].dwBasePriority = server_thread->base_priority;
-                    get_thread_times( server_process->unix_pid, server_thread->unix_tid,
-                                      &nt_process->ti[j].KernelTime, &nt_process->ti[j].UserTime );
-                }
-
-                pos += sizeof(*server_thread);
-            }
-
-            if (len <= size)
-            {
-                nt_process->ProcessName.Buffer = (WCHAR *)&nt_process->ti[server_process->thread_count];
-                nt_process->ProcessName.Length = name_len * sizeof(WCHAR);
-                nt_process->ProcessName.MaximumLength = (name_len + 1) * sizeof(WCHAR);
-                memcpy(nt_process->ProcessName.Buffer, file_part, name_len * sizeof(WCHAR));
-                nt_process->ProcessName.Buffer[name_len] = 0;
-            }
-        }
-
-        if (len > size) ret = STATUS_INFO_LENGTH_MISMATCH;
-        free( buffer );
-        break;
-    }
-
-    case SystemProcessorPerformanceInformation:
-    {
-        SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *sppi = NULL;
-        unsigned int cpus = 0;
-        int out_cpus = size / sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
-
-        if (out_cpus == 0)
-        {
-            len = 0;
-            ret = STATUS_INFO_LENGTH_MISMATCH;
-            break;
-        }
-        if (!(sppi = calloc( out_cpus, sizeof(*sppi) )))
-        {
-            ret = STATUS_NO_MEMORY;
-            break;
-        }
-        else
-#ifdef __APPLE__
-        {
-            processor_cpu_load_info_data_t *pinfo;
-            mach_msg_type_number_t info_count;
-
-            if (host_processor_info( mach_host_self (),
-                                     PROCESSOR_CPU_LOAD_INFO,
-                                     &cpus,
-                                     (processor_info_array_t*)&pinfo,
-                                     &info_count) == 0)
-            {
-                int i;
-                cpus = min(cpus,out_cpus);
-                for (i = 0; i < cpus; i++)
-                {
-                    sppi[i].IdleTime.QuadPart = pinfo[i].cpu_ticks[CPU_STATE_IDLE];
-                    sppi[i].KernelTime.QuadPart = pinfo[i].cpu_ticks[CPU_STATE_SYSTEM];
-                    sppi[i].UserTime.QuadPart = pinfo[i].cpu_ticks[CPU_STATE_USER];
-                }
-                vm_deallocate (mach_task_self (), (vm_address_t) pinfo, info_count * sizeof(natural_t));
-            }
-        }
-#else
-        {
-            FILE *cpuinfo = fopen("/proc/stat", "r");
-            if (cpuinfo)
-            {
-                unsigned long clk_tck = sysconf(_SC_CLK_TCK);
-                unsigned long usr,nice,sys,idle,remainder[8];
-                int i, count, id;
-                char name[32];
-                char line[255];
-
-                /* first line is combined usage */
-                while (fgets(line,255,cpuinfo))
-                {
-                    count = sscanf(line, "%s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu",
-                                   name, &usr, &nice, &sys, &idle,
-                                   &remainder[0], &remainder[1], &remainder[2], &remainder[3],
-                                   &remainder[4], &remainder[5], &remainder[6], &remainder[7]);
-
-                    if (count < 5 || strncmp( name, "cpu", 3 )) break;
-                    for (i = 0; i + 5 < count; ++i) sys += remainder[i];
-                    sys += idle;
-                    usr += nice;
-                    id = atoi( name + 3 ) + 1;
-                    if (id > out_cpus) break;
-                    if (id > cpus) cpus = id;
-                    sppi[id-1].IdleTime.QuadPart   = (ULONGLONG)idle * 10000000 / clk_tck;
-                    sppi[id-1].KernelTime.QuadPart = (ULONGLONG)sys * 10000000 / clk_tck;
-                    sppi[id-1].UserTime.QuadPart   = (ULONGLONG)usr * 10000000 / clk_tck;
-                }
-                fclose(cpuinfo);
-            }
-        }
-#endif
-        if (cpus == 0)
-        {
-            static int i = 1;
-            unsigned int n;
-            cpus = min(NtCurrentTeb()->Peb->NumberOfProcessors, out_cpus);
-            FIXME("stub info_class SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION\n");
-            /* many programs expect these values to change so fake change */
-            for (n = 0; n < cpus; n++)
-            {
-                sppi[n].KernelTime.QuadPart = 1 * i;
-                sppi[n].UserTime.QuadPart   = 2 * i;
-                sppi[n].IdleTime.QuadPart   = 3 * i;
-            }
-            i++;
-        }
-
-        len = sizeof(*sppi) * cpus;
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, sppi, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-
-        free( sppi );
-        break;
-    }
-
-    case SystemModuleInformation:
-    {
-        /* FIXME: return some fake info for now */
-        static const char *fake_modules[] =
-        {
-            "\\SystemRoot\\system32\\ntoskrnl.exe",
-            "\\SystemRoot\\system32\\hal.dll",
-            "\\SystemRoot\\system32\\drivers\\mountmgr.sys"
-        };
-
-        if (!info) ret = STATUS_ACCESS_VIOLATION;
-        else
-        {
-            ULONG i;
-            SYSTEM_MODULE_INFORMATION *smi = info;
-
-            len = offsetof( SYSTEM_MODULE_INFORMATION, Modules[ARRAY_SIZE(fake_modules)] );
-            if (len <= size)
-            {
-                memset( smi, 0, len );
-                for (i = 0; i < ARRAY_SIZE(fake_modules); i++)
-                {
-                    SYSTEM_MODULE *sm = &smi->Modules[i];
-                    sm->ImageBaseAddress = (char *)0x10000000 + 0x200000 * i;
-                    sm->ImageSize = 0x200000;
-                    sm->LoadOrderIndex = i;
-                    sm->LoadCount = 1;
-                    strcpy( (char *)sm->Name, fake_modules[i] );
-                    sm->NameOffset = strrchr( fake_modules[i], '\\' ) - fake_modules[i] + 1;
-                }
-                smi->ModulesCount = i;
-            }
-            else ret = STATUS_INFO_LENGTH_MISMATCH;
-        }
-        break;
-    }
-
-    case SystemHandleInformation:
-    {
-        struct handle_info *handle_info;
-        DWORD i, num_handles;
-
-        if (size < sizeof(SYSTEM_HANDLE_INFORMATION))
-        {
-            ret = STATUS_INFO_LENGTH_MISMATCH;
-            break;
-        }
-
-        if (!info)
-        {
-            ret = STATUS_ACCESS_VIOLATION;
-            break;
-        }
-
-        num_handles = (size - FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle )) / sizeof(SYSTEM_HANDLE_ENTRY);
-        if (!(handle_info = malloc( sizeof(*handle_info) * num_handles ))) return STATUS_NO_MEMORY;
-
-        SERVER_START_REQ( get_system_handles )
-        {
-            wine_server_set_reply( req, handle_info, sizeof(*handle_info) * num_handles );
-            if (!(ret = wine_server_call( req )))
-            {
-                SYSTEM_HANDLE_INFORMATION *shi = info;
-                shi->Count = wine_server_reply_size( req ) / sizeof(*handle_info);
-                len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle[shi->Count] );
-                for (i = 0; i < shi->Count; i++)
-                {
-                    memset( &shi->Handle[i], 0, sizeof(shi->Handle[i]) );
-                    shi->Handle[i].OwnerPid     = handle_info[i].owner;
-                    shi->Handle[i].HandleValue  = handle_info[i].handle;
-                    shi->Handle[i].AccessMask   = handle_info[i].access;
-                    /* FIXME: Fill out ObjectType, HandleFlags, ObjectPointer */
-                }
-            }
-            else if (ret == STATUS_BUFFER_TOO_SMALL)
-            {
-                len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION, Handle[reply->count] );
-                ret = STATUS_INFO_LENGTH_MISMATCH;
-            }
-        }
-        SERVER_END_REQ;
-
-        free( handle_info );
-        break;
-    }
-
-    case SystemCacheInformation:
-    {
-        SYSTEM_CACHE_INFORMATION sci = { 0 };
-
-        len = sizeof(sci);
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &sci, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        FIXME("info_class SYSTEM_CACHE_INFORMATION\n");
-        break;
-    }
-
-    case SystemInterruptInformation:
-    {
-        SYSTEM_INTERRUPT_INFORMATION sii = {{ 0 }};
-
-        len = sizeof(sii);
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &sii, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        FIXME("info_class SYSTEM_INTERRUPT_INFORMATION\n");
-        break;
-    }
-
-    case SystemTimeAdjustmentInformation:
-    {
-        SYSTEM_TIME_ADJUSTMENT_QUERY query = { 156250, 156250, TRUE };
-
-        len = sizeof(query);
-        if (size == len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &query, len );
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    case SystemKernelDebuggerInformation:
-    {
-        SYSTEM_KERNEL_DEBUGGER_INFORMATION skdi;
-
-        skdi.DebuggerEnabled = FALSE;
-        skdi.DebuggerNotPresent = TRUE;
-        len = sizeof(skdi);
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &skdi, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    case SystemRegistryQuotaInformation:
-    {
-        /* Something to do with the size of the registry             *
-         * Since we don't have a size limitation, fake it            *
-         * This is almost certainly wrong.                           *
-         * This sets each of the three words in the struct to 32 MB, *
-         * which is enough to make the IE 5 installer happy.         */
-        SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;
-
-        srqi.RegistryQuotaAllowed = 0x2000000;
-        srqi.RegistryQuotaUsed = 0x200000;
-        srqi.Reserved1 = (void*)0x200000;
-        len = sizeof(srqi);
-
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else
-            {
-                FIXME("SystemRegistryQuotaInformation: faking max registry size of 32 MB\n");
-                memcpy( info, &srqi, len);
-            }
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    case SystemTimeZoneInformation:
-    {
-        RTL_DYNAMIC_TIME_ZONE_INFORMATION tz;
-
-        get_timezone_info( &tz );
-        len = sizeof(RTL_TIME_ZONE_INFORMATION);
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &tz, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    case SystemLogicalProcessorInformation:
-    {
-        SYSTEM_LOGICAL_PROCESSOR_INFORMATION *buf;
-
-        /* Each logical processor may use up to 7 entries in returned table:
-         * core, numa node, package, L1i, L1d, L2, L3 */
-        len = 7 * NtCurrentTeb()->Peb->NumberOfProcessors;
-        buf = malloc( len * sizeof(*buf) );
-        if (!buf)
-        {
-            ret = STATUS_NO_MEMORY;
-            break;
-        }
-        ret = create_logical_proc_info(&buf, NULL, &len, RelationAll);
-        if (!ret)
-        {
-            if (size >= len)
-            {
-                if (!info) ret = STATUS_ACCESS_VIOLATION;
-                else memcpy( info, buf, len);
-            }
-            else ret = STATUS_INFO_LENGTH_MISMATCH;
-        }
-        free( buf );
-        break;
-    }
-
-    case SystemRecommendedSharedDataAlignment:
-    {
-        len = sizeof(DWORD);
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else
-            {
-#ifdef __arm__
-                *((DWORD *)info) = 32;
-#else
-                *((DWORD *)info) = 64;
-#endif
-            }
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    case SystemFirmwareTableInformation:
-    {
-        SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = info;
-        len = FIELD_OFFSET(SYSTEM_FIRMWARE_TABLE_INFORMATION, TableBuffer);
-        if (size < len)
-        {
-            ret = STATUS_INFO_LENGTH_MISMATCH;
-            break;
-        }
-
-        switch (sfti->Action)
-        {
-        case SystemFirmwareTable_Get:
-            ret = get_firmware_info(sfti, size, &len);
-            break;
-        default:
-            len = 0;
-            ret = STATUS_NOT_IMPLEMENTED;
-            FIXME("info_class SYSTEM_FIRMWARE_TABLE_INFORMATION action %d\n", sfti->Action);
-        }
-        break;
-    }
-
-    case SystemDynamicTimeZoneInformation:
-    {
-        RTL_DYNAMIC_TIME_ZONE_INFORMATION tz;
-
-        get_timezone_info( &tz );
-        len = sizeof(tz);
-        if (size >= len)
-        {
-            if (!info) ret = STATUS_ACCESS_VIOLATION;
-            else memcpy( info, &tz, len);
-        }
-        else ret = STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    }
-
-    default:
-	FIXME( "(0x%08x,%p,0x%08x,%p) stub\n", class, info, size, ret_size );
-
-        /* Several Information Classes are not implemented on Windows and return 2 different values
-         * STATUS_NOT_IMPLEMENTED or STATUS_INVALID_INFO_CLASS
-         * in 95% of the cases it's STATUS_INVALID_INFO_CLASS, so use this as the default
-         */
-        ret = STATUS_INVALID_INFO_CLASS;
-    }
-
-    if (ret_size) *ret_size = len;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtQuerySystemInformationEx  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySystemInformationEx( SYSTEM_INFORMATION_CLASS class,
-                                            void *query, ULONG query_len,
-                                            void *info, ULONG size, ULONG *ret_size )
-{
-    ULONG len = 0;
-    NTSTATUS ret = STATUS_NOT_IMPLEMENTED;
-
-    TRACE( "(0x%08x,%p,%u,%p,%u,%p) stub\n", class, query, query_len, info, size, ret_size );
-
-    switch (class)
-    {
-    case SystemLogicalProcessorInformationEx:
-    {
-        SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *buf;
-
-        if (!query || query_len < sizeof(DWORD))
-        {
-            ret = STATUS_INVALID_PARAMETER;
-            break;
-        }
-
-        len = 3 * sizeof(*buf);
-        if (!(buf = malloc( len )))
-        {
-            ret = STATUS_NO_MEMORY;
-            break;
-        }
-        ret = create_logical_proc_info(NULL, &buf, &len, *(DWORD *)query);
-        if (!ret)
-        {
-            if (size >= len)
-            {
-                if (!info) ret = STATUS_ACCESS_VIOLATION;
-                else memcpy(info, buf, len);
-            }
-            else ret = STATUS_INFO_LENGTH_MISMATCH;
-        }
-        free( buf );
-        break;
-    }
-
-    default:
-        FIXME( "(0x%08x,%p,%u,%p,%u,%p) stub\n", class, query, query_len, info, size, ret_size );
-        break;
-    }
-    if (ret_size) *ret_size = len;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtSetSystemInformation  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetSystemInformation( SYSTEM_INFORMATION_CLASS class, void *info, ULONG length )
-{
-    FIXME( "(0x%08x,%p,0x%08x) stub\n", class, info, length );
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtQuerySystemEnvironmentValue  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySystemEnvironmentValue( UNICODE_STRING *name, WCHAR *buffer, ULONG length,
-                                               ULONG *retlen )
-{
-    FIXME( "(%s, %p, %u, %p), stub\n", debugstr_us(name), buffer, length, retlen );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtQuerySystemEnvironmentValueEx  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySystemEnvironmentValueEx( UNICODE_STRING *name, GUID *vendor, void *buffer,
-                                                 ULONG *retlen, ULONG *attrib )
-{
-    FIXME( "(%s, %s, %p, %p, %p), stub\n", debugstr_us(name),
-           debugstr_guid(vendor), buffer, retlen, attrib );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtSystemDebugControl  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSystemDebugControl( SYSDBG_COMMAND command, void *in_buff, ULONG in_len,
-                                      void *out_buff, ULONG out_len, ULONG *retlen )
-{
-    FIXME( "(%d, %p, %d, %p, %d, %p), stub\n", command, in_buff, in_len, out_buff, out_len, retlen );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtShutdownSystem  (NTDLL.@)
- */
-NTSTATUS WINAPI NtShutdownSystem( SHUTDOWN_ACTION action )
-{
-    FIXME( "%d\n", action );
-    return STATUS_SUCCESS;
-}
-
-
-#ifdef linux
-
-/* Fallback using /proc/cpuinfo for Linux systems without cpufreq. For
- * most distributions on recent enough hardware, this is only likely to
- * happen while running in virtualized environments such as QEMU. */
-static ULONG mhz_from_cpuinfo(void)
-{
-    char line[512];
-    char *s, *value;
-    double cmz = 0;
-    FILE *f = fopen("/proc/cpuinfo", "r");
-    if(f)
-    {
-        while (fgets(line, sizeof(line), f) != NULL)
-        {
-            if (!(value = strchr(line,':'))) continue;
-            s = value - 1;
-            while ((s >= line) && (*s == ' ' || *s == '\t')) s--;
-            s[1] = 0;
-            value++;
-            if (!strcmp( line, "cpu MHz" ))
-            {
-                sscanf(value, " %lf", &cmz);
-                break;
-            }
-        }
-        fclose( f );
-    }
-    return cmz;
-}
-
-static const char * get_sys_str(const char *path, char *s)
-{
-    FILE *f = fopen(path, "r");
-    const char *ret = NULL;
-
-    if (f)
-    {
-        if (fgets(s, 16, f)) ret = s;
-        fclose(f);
-    }
-    return ret;
-}
-
-static int get_sys_int(const char *path, int def)
-{
-    char s[16];
-    return get_sys_str(path, s) ? atoi(s) : def;
-}
-
-static NTSTATUS fill_battery_state( SYSTEM_BATTERY_STATE *bs )
-{
-    char s[16], path[64];
-    unsigned int i = 0;
-    LONG64 voltage; /* microvolts */
-
-    bs->AcOnLine = get_sys_int("/sys/class/power_supply/AC/online", 1);
-
-    for (;;)
-    {
-        sprintf(path, "/sys/class/power_supply/BAT%u/status", i);
-        if (!get_sys_str(path, s)) break;
-        bs->Charging |= (strcmp(s, "Charging\n") == 0);
-        bs->Discharging |= (strcmp(s, "Discharging\n") == 0);
-        bs->BatteryPresent = TRUE;
-        i++;
-    }
-
-    if (bs->BatteryPresent)
-    {
-        voltage = get_sys_int("/sys/class/power_supply/BAT0/voltage_now", 0);
-        bs->MaxCapacity = get_sys_int("/sys/class/power_supply/BAT0/charge_full", 0) * voltage / 1e9;
-        bs->RemainingCapacity = get_sys_int("/sys/class/power_supply/BAT0/charge_now", 0) * voltage / 1e9;
-        bs->Rate = -get_sys_int("/sys/class/power_supply/BAT0/current_now", 0) * voltage / 1e9;
-        if (!bs->Charging && (LONG)bs->Rate < 0)
-            bs->EstimatedTime = 3600 * bs->RemainingCapacity / -(LONG)bs->Rate;
-        else
-            bs->EstimatedTime = ~0u;
-    }
-
-    return STATUS_SUCCESS;
-}
-
-#elif defined(HAVE_IOKIT_IOKITLIB_H)
-
-static NTSTATUS fill_battery_state( SYSTEM_BATTERY_STATE *bs )
-{
-    CFArrayRef batteries;
-    CFDictionaryRef battery;
-    CFNumberRef prop;
-    uint32_t value, voltage;
-    CFTimeInterval remain;
-
-    if (IOPMCopyBatteryInfo( kIOMasterPortDefault, &batteries ) != kIOReturnSuccess)
-        return STATUS_ACCESS_DENIED;
-
-    if (CFArrayGetCount( batteries ) == 0)
-    {
-        /* Just assume we're on AC with no battery. */
-        bs->AcOnLine = TRUE;
-        return STATUS_SUCCESS;
-    }
-    /* Just use the first battery. */
-    battery = CFArrayGetValueAtIndex( batteries, 0 );
-
-    prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryFlagsKey) );
-    CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
-
-    if (value & kIOBatteryInstalled)
-        bs->BatteryPresent = TRUE;
-    else
-        /* Since we are executing code, we must have AC power. */
-        bs->AcOnLine = TRUE;
-    if (value & kIOBatteryChargerConnect)
-    {
-        bs->AcOnLine = TRUE;
-        if (value & kIOBatteryCharge)
-            bs->Charging = TRUE;
-    }
-    else
-        bs->Discharging = TRUE;
-
-    /* We'll need the voltage to be able to interpret the other values. */
-    prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryVoltageKey) );
-    CFNumberGetValue( prop, kCFNumberSInt32Type, &voltage );
-
-    prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryCapacityKey) );
-    CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
-    bs->MaxCapacity = value * voltage;
-    /* Apple uses "estimated time < 10:00" and "22%" for these, but we'll follow
-     * Windows for now (5% and 33%). */
-    bs->DefaultAlert1 = bs->MaxCapacity / 20;
-    bs->DefaultAlert2 = bs->MaxCapacity / 3;
-
-    prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryCurrentChargeKey) );
-    CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
-    bs->RemainingCapacity = value * voltage;
-
-    prop = CFDictionaryGetValue( battery, CFSTR(kIOBatteryAmperageKey) );
-    CFNumberGetValue( prop, kCFNumberSInt32Type, &value );
-    bs->Rate = value * voltage;
-
-    remain = IOPSGetTimeRemainingEstimate();
-    if (remain != kIOPSTimeRemainingUnknown && remain != kIOPSTimeRemainingUnlimited)
-        bs->EstimatedTime = (ULONG)remain;
-
-    CFRelease( batteries );
-    return STATUS_SUCCESS;
-}
-
-#else
-
-static NTSTATUS fill_battery_state( SYSTEM_BATTERY_STATE *bs )
-{
-	FIXME("SystemBatteryState not implemented on this platform\n");
-	return STATUS_NOT_IMPLEMENTED;
-}
-
-#endif
-
-/******************************************************************************
- *              NtPowerInformation  (NTDLL.@)
- */
-NTSTATUS WINAPI NtPowerInformation( POWER_INFORMATION_LEVEL level, void *input, ULONG in_size,
-                                    void *output, ULONG out_size )
-{
-    TRACE( "(%d,%p,%d,%p,%d)\n", level, input, in_size, output, out_size );
-    switch (level)
-    {
-    case SystemPowerCapabilities:
-    {
-        PSYSTEM_POWER_CAPABILITIES PowerCaps = output;
-        FIXME("semi-stub: SystemPowerCapabilities\n");
-        if (out_size < sizeof(SYSTEM_POWER_CAPABILITIES)) return STATUS_BUFFER_TOO_SMALL;
-        /* FIXME: These values are based off a native XP desktop, should probably use APM/ACPI to get the 'real' values */
-        PowerCaps->PowerButtonPresent = TRUE;
-        PowerCaps->SleepButtonPresent = FALSE;
-        PowerCaps->LidPresent = FALSE;
-        PowerCaps->SystemS1 = TRUE;
-        PowerCaps->SystemS2 = FALSE;
-        PowerCaps->SystemS3 = FALSE;
-        PowerCaps->SystemS4 = TRUE;
-        PowerCaps->SystemS5 = TRUE;
-        PowerCaps->HiberFilePresent = TRUE;
-        PowerCaps->FullWake = TRUE;
-        PowerCaps->VideoDimPresent = FALSE;
-        PowerCaps->ApmPresent = FALSE;
-        PowerCaps->UpsPresent = FALSE;
-        PowerCaps->ThermalControl = FALSE;
-        PowerCaps->ProcessorThrottle = FALSE;
-        PowerCaps->ProcessorMinThrottle = 100;
-        PowerCaps->ProcessorMaxThrottle = 100;
-        PowerCaps->DiskSpinDown = TRUE;
-        PowerCaps->SystemBatteriesPresent = FALSE;
-        PowerCaps->BatteriesAreShortTerm = FALSE;
-        PowerCaps->BatteryScale[0].Granularity = 0;
-        PowerCaps->BatteryScale[0].Capacity = 0;
-        PowerCaps->BatteryScale[1].Granularity = 0;
-        PowerCaps->BatteryScale[1].Capacity = 0;
-        PowerCaps->BatteryScale[2].Granularity = 0;
-        PowerCaps->BatteryScale[2].Capacity = 0;
-        PowerCaps->AcOnLineWake = PowerSystemUnspecified;
-        PowerCaps->SoftLidWake = PowerSystemUnspecified;
-        PowerCaps->RtcWake = PowerSystemSleeping1;
-        PowerCaps->MinDeviceWakeState = PowerSystemUnspecified;
-        PowerCaps->DefaultLowLatencyWake = PowerSystemUnspecified;
-        return STATUS_SUCCESS;
-    }
-
-    case SystemBatteryState:
-    {
-        if (out_size < sizeof(SYSTEM_BATTERY_STATE)) return STATUS_BUFFER_TOO_SMALL;
-        memset(output, 0, sizeof(SYSTEM_BATTERY_STATE));
-        return fill_battery_state(output);
-    }
-
-    case SystemExecutionState:
-    {
-        ULONG *state = output;
-        WARN("semi-stub: SystemExecutionState\n"); /* Needed for .NET Framework, but using a FIXME is really noisy. */
-        if (input != NULL) return STATUS_INVALID_PARAMETER;
-        /* FIXME: The actual state should be the value set by SetThreadExecutionState which is not currently implemented. */
-        *state = ES_USER_PRESENT;
-        return STATUS_SUCCESS;
-    }
-
-    case ProcessorInformation:
-    {
-        const int cannedMHz = 1000; /* We fake a 1GHz processor if we can't conjure up real values */
-        PROCESSOR_POWER_INFORMATION* cpu_power = output;
-        int i, out_cpus;
-
-        if ((output == NULL) || (out_size == 0)) return STATUS_INVALID_PARAMETER;
-        out_cpus = NtCurrentTeb()->Peb->NumberOfProcessors;
-        if ((out_size / sizeof(PROCESSOR_POWER_INFORMATION)) < out_cpus) return STATUS_BUFFER_TOO_SMALL;
-#if defined(linux)
-        {
-            char filename[128];
-            FILE* f;
-
-            for(i = 0; i < out_cpus; i++) {
-                sprintf(filename, "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", i);
-                f = fopen(filename, "r");
-                if (f && (fscanf(f, "%d", &cpu_power[i].MaxMhz) == 1)) {
-                    cpu_power[i].MaxMhz /= 1000;
-                    fclose(f);
-                    cpu_power[i].CurrentMhz = cpu_power[i].MaxMhz;
-                }
-                else {
-                    if(i == 0) {
-                        cpu_power[0].CurrentMhz = mhz_from_cpuinfo();
-                        if(cpu_power[0].CurrentMhz == 0)
-                            cpu_power[0].CurrentMhz = cannedMHz;
-                    }
-                    else
-                        cpu_power[i].CurrentMhz = cpu_power[0].CurrentMhz;
-                    cpu_power[i].MaxMhz = cpu_power[i].CurrentMhz;
-                    if(f) fclose(f);
-                }
-
-                sprintf(filename, "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_max_freq", i);
-                f = fopen(filename, "r");
-                if(f && (fscanf(f, "%d", &cpu_power[i].MhzLimit) == 1)) {
-                    cpu_power[i].MhzLimit /= 1000;
-                    fclose(f);
-                }
-                else
-                {
-                    cpu_power[i].MhzLimit = cpu_power[i].MaxMhz;
-                    if(f) fclose(f);
-                }
-
-                cpu_power[i].Number = i;
-                cpu_power[i].MaxIdleState = 0;     /* FIXME */
-                cpu_power[i].CurrentIdleState = 0; /* FIXME */
-            }
-        }
-#elif defined(__FreeBSD__) || defined (__FreeBSD_kernel__) || defined(__DragonFly__)
-        {
-            int num;
-            size_t valSize = sizeof(num);
-            if (sysctlbyname("hw.clockrate", &num, &valSize, NULL, 0))
-                num = cannedMHz;
-            for(i = 0; i < out_cpus; i++) {
-                cpu_power[i].CurrentMhz = num;
-                cpu_power[i].MaxMhz = num;
-                cpu_power[i].MhzLimit = num;
-                cpu_power[i].Number = i;
-                cpu_power[i].MaxIdleState = 0;     /* FIXME */
-                cpu_power[i].CurrentIdleState = 0; /* FIXME */
-            }
-        }
-#elif defined (__APPLE__)
-        {
-            size_t valSize;
-            unsigned long long currentMhz;
-            unsigned long long maxMhz;
-
-            valSize = sizeof(currentMhz);
-            if (!sysctlbyname("hw.cpufrequency", &currentMhz, &valSize, NULL, 0))
-                currentMhz /= 1000000;
-            else
-                currentMhz = cannedMHz;
-
-            valSize = sizeof(maxMhz);
-            if (!sysctlbyname("hw.cpufrequency_max", &maxMhz, &valSize, NULL, 0))
-                maxMhz /= 1000000;
-            else
-                maxMhz = currentMhz;
-
-            for(i = 0; i < out_cpus; i++) {
-                cpu_power[i].CurrentMhz = currentMhz;
-                cpu_power[i].MaxMhz = maxMhz;
-                cpu_power[i].MhzLimit = maxMhz;
-                cpu_power[i].Number = i;
-                cpu_power[i].MaxIdleState = 0;     /* FIXME */
-                cpu_power[i].CurrentIdleState = 0; /* FIXME */
-            }
-        }
-#else
-        for(i = 0; i < out_cpus; i++) {
-            cpu_power[i].CurrentMhz = cannedMHz;
-            cpu_power[i].MaxMhz = cannedMHz;
-            cpu_power[i].MhzLimit = cannedMHz;
-            cpu_power[i].Number = i;
-            cpu_power[i].MaxIdleState = 0; /* FIXME */
-            cpu_power[i].CurrentIdleState = 0; /* FIXME */
-        }
-        WARN("Unable to detect CPU MHz for this platform. Reporting %d MHz.\n", cannedMHz);
-#endif
-        for(i = 0; i < out_cpus; i++) {
-            TRACE("cpu_power[%d] = %u %u %u %u %u %u\n", i, cpu_power[i].Number,
-                  cpu_power[i].MaxMhz, cpu_power[i].CurrentMhz, cpu_power[i].MhzLimit,
-                  cpu_power[i].MaxIdleState, cpu_power[i].CurrentIdleState);
-        }
-        return STATUS_SUCCESS;
-    }
-
-    default:
-        /* FIXME: Needed by .NET Framework */
-        WARN( "Unimplemented NtPowerInformation action: %d\n", level );
-        return STATUS_NOT_IMPLEMENTED;
-    }
-}
-
-
-/******************************************************************************
- *              NtLoadDriver  (NTDLL.@)
- */
-NTSTATUS WINAPI NtLoadDriver( const UNICODE_STRING *name )
-{
-    FIXME( "(%s), stub!\n", debugstr_us(name) );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtUnloadDriver  (NTDLL.@)
- */
-NTSTATUS WINAPI NtUnloadDriver( const UNICODE_STRING *name )
-{
-    FIXME( "(%s), stub!\n", debugstr_us(name) );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtDisplayString  (NTDLL.@)
- */
-NTSTATUS WINAPI NtDisplayString( UNICODE_STRING *string )
-{
-    ERR( "%s\n", debugstr_us(string) );
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************************
- *              NtRaiseHardError  (NTDLL.@)
- */
-NTSTATUS WINAPI NtRaiseHardError( NTSTATUS status, ULONG count,
-                                  UNICODE_STRING *params_mask, void **params,
-                                  HARDERROR_RESPONSE_OPTION option, HARDERROR_RESPONSE *response )
-{
-    FIXME( "%08x stub\n", status );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtInitiatePowerAction  (NTDLL.@)
- */
-NTSTATUS WINAPI NtInitiatePowerAction( POWER_ACTION action, SYSTEM_POWER_STATE state,
-                                       ULONG flags, BOOLEAN async )
-{
-    FIXME( "(%d,%d,0x%08x,%d),stub\n", action, state, flags, async );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtCreatePowerRequest  (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreatePowerRequest( HANDLE *handle, COUNTED_REASON_CONTEXT *context )
-{
-    FIXME( "(%p, %p): stub\n", handle, context );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtSetPowerRequest  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetPowerRequest( HANDLE handle, POWER_REQUEST_TYPE type )
-{
-    FIXME( "(%p, %u): stub\n", handle, type );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtClearPowerRequest  (NTDLL.@)
- */
-NTSTATUS WINAPI NtClearPowerRequest( HANDLE handle, POWER_REQUEST_TYPE type )
-{
-    FIXME( "(%p, %u): stub\n", handle, type );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtSetThreadExecutionState  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetThreadExecutionState( EXECUTION_STATE new_state, EXECUTION_STATE *old_state )
-{
-    static EXECUTION_STATE current = ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED | ES_USER_PRESENT;
-
-    WARN( "(0x%x, %p): stub, harmless.\n", new_state, old_state );
-    *old_state = current;
-    if (!(current & ES_CONTINUOUS) || (new_state & ES_CONTINUOUS)) current = new_state;
-    return STATUS_SUCCESS;
-}
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
deleted file mode 100644
index cb7377017b..0000000000
--- a/dlls/ntdll/unix/thread.c
+++ /dev/null
@@ -1,1300 +0,0 @@
-/*
- * NT threads support
- *
- * Copyright 1996, 2003 Alexandre Julliard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <errno.h>
-#include <limits.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <string.h>
-#include <pthread.h>
-#include <signal.h>
-#include <sys/types.h>
-#ifdef HAVE_SYS_MMAN_H
-#include <sys/mman.h>
-#endif
-#ifdef HAVE_SYS_TIMES_H
-#include <sys/times.h>
-#endif
-#ifdef HAVE_SYS_SYSCALL_H
-#include <sys/syscall.h>
-#endif
-
-#define NONAMELESSUNION
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "winternl.h"
-#include "ddk/wdm.h"
-#include "wine/server.h"
-#include "wine/debug.h"
-#include "wine/exception.h"
-#include "unix_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(seh);
-
-#ifndef PTHREAD_STACK_MIN
-#define PTHREAD_STACK_MIN 16384
-#endif
-
-static int nb_threads = 1;
-
-static inline int get_unix_exit_code( NTSTATUS status )
-{
-    /* prevent a nonzero exit code to end up truncated to zero in unix */
-    if (status && !(status & 0xff)) return 1;
-    return status;
-}
-
-
-/***********************************************************************
- *           pthread_exit_wrapper
- */
-static void pthread_exit_wrapper( int status )
-{
-    close( ntdll_get_thread_data()->wait_fd[0] );
-    close( ntdll_get_thread_data()->wait_fd[1] );
-    close( ntdll_get_thread_data()->reply_fd );
-    close( ntdll_get_thread_data()->request_fd );
-    pthread_exit( UIntToPtr(status) );
-}
-
-
-/***********************************************************************
- *           start_thread
- *
- * Startup routine for a newly created thread.
- */
-static void start_thread( TEB *teb )
-{
-    struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
-    struct debug_info debug_info;
-    BOOL suspend;
-
-    debug_info.str_pos = debug_info.out_pos = 0;
-    thread_data->debug_info = &debug_info;
-    thread_data->pthread_id = pthread_self();
-    signal_init_thread( teb );
-    server_init_thread( thread_data->start, &suspend );
-    signal_start_thread( thread_data->start, thread_data->param, suspend, pRtlUserThreadStart, teb );
-}
-
-
-/***********************************************************************
- *           update_attr_list
- *
- * Update the output attributes.
- */
-static void update_attr_list( PS_ATTRIBUTE_LIST *attr, const CLIENT_ID *id, TEB *teb )
-{
-    SIZE_T i, count = (attr->TotalLength - sizeof(attr->TotalLength)) / sizeof(PS_ATTRIBUTE);
-
-    for (i = 0; i < count; i++)
-    {
-        if (attr->Attributes[i].Attribute == PS_ATTRIBUTE_CLIENT_ID)
-        {
-            SIZE_T size = min( attr->Attributes[i].Size, sizeof(*id) );
-            memcpy( attr->Attributes[i].ValuePtr, id, size );
-            if (attr->Attributes[i].ReturnLength) *attr->Attributes[i].ReturnLength = size;
-        }
-        else if (attr->Attributes[i].Attribute == PS_ATTRIBUTE_TEB_ADDRESS)
-        {
-            SIZE_T size = min( attr->Attributes[i].Size, sizeof(teb) );
-            memcpy( attr->Attributes[i].ValuePtr, &teb, size );
-            if (attr->Attributes[i].ReturnLength) *attr->Attributes[i].ReturnLength = size;
-        }
-    }
-}
-
-
-/***********************************************************************
- *              NtCreateThreadEx   (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
-                                  HANDLE process, PRTL_THREAD_START_ROUTINE start, void *param,
-                                  ULONG flags, SIZE_T zero_bits, SIZE_T stack_commit,
-                                  SIZE_T stack_reserve, PS_ATTRIBUTE_LIST *attr_list )
-{
-    sigset_t sigset;
-    pthread_t pthread_id;
-    pthread_attr_t pthread_attr;
-    data_size_t len;
-    struct object_attributes *objattr;
-    struct ntdll_thread_data *thread_data;
-    DWORD tid = 0;
-    int request_pipe[2];
-    SIZE_T extra_stack = PTHREAD_STACK_MIN;
-    CLIENT_ID client_id;
-    TEB *teb;
-    INITIAL_TEB stack;
-    NTSTATUS status;
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.create_thread.type    = APC_CREATE_THREAD;
-        call.create_thread.flags   = flags;
-        call.create_thread.func    = wine_server_client_ptr( start );
-        call.create_thread.arg     = wine_server_client_ptr( param );
-        call.create_thread.reserve = stack_reserve;
-        call.create_thread.commit  = stack_commit;
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.create_thread.status == STATUS_SUCCESS)
-        {
-            TEB *teb = wine_server_get_ptr( result.create_thread.teb );
-            *handle = wine_server_ptr_handle( result.create_thread.handle );
-            client_id.UniqueProcess = ULongToHandle( result.create_thread.pid );
-            client_id.UniqueThread  = ULongToHandle( result.create_thread.tid );
-            if (attr_list) update_attr_list( attr_list, &client_id, teb );
-        }
-        return result.create_thread.status;
-    }
-
-    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
-
-    if (server_pipe( request_pipe ) == -1)
-    {
-        free( objattr );
-        return STATUS_TOO_MANY_OPENED_FILES;
-    }
-    server_send_fd( request_pipe[0] );
-
-    if (!access) access = THREAD_ALL_ACCESS;
-
-    SERVER_START_REQ( new_thread )
-    {
-        req->process    = wine_server_obj_handle( process );
-        req->access     = access;
-        req->suspend    = flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED;
-        req->request_fd = request_pipe[0];
-        wine_server_add_data( req, objattr, len );
-        if (!(status = wine_server_call( req )))
-        {
-            *handle = wine_server_ptr_handle( reply->handle );
-            tid = reply->tid;
-        }
-        close( request_pipe[0] );
-    }
-    SERVER_END_REQ;
-
-    free( objattr );
-    if (status)
-    {
-        close( request_pipe[1] );
-        return status;
-    }
-
-    pthread_sigmask( SIG_BLOCK, &server_block_set, &sigset );
-
-    if ((status = virtual_alloc_teb( &teb ))) goto done;
-
-    if ((status = virtual_alloc_thread_stack( &stack, stack_reserve, stack_commit, &extra_stack )))
-    {
-        virtual_free_teb( teb );
-        goto done;
-    }
-
-    client_id.UniqueProcess = ULongToHandle( GetCurrentProcessId() );
-    client_id.UniqueThread  = ULongToHandle( tid );
-    teb->ClientId = client_id;
-
-    teb->Tib.StackBase = stack.StackBase;
-    teb->Tib.StackLimit = stack.StackLimit;
-    teb->DeallocationStack = stack.DeallocationStack;
-
-    thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
-    thread_data->request_fd  = request_pipe[1];
-    thread_data->start_stack = (char *)teb->Tib.StackBase;
-    thread_data->start = start;
-    thread_data->param = param;
-
-    pthread_attr_init( &pthread_attr );
-    pthread_attr_setstack( &pthread_attr, teb->DeallocationStack,
-                           (char *)teb->Tib.StackBase + extra_stack - (char *)teb->DeallocationStack );
-    pthread_attr_setguardsize( &pthread_attr, 0 );
-    pthread_attr_setscope( &pthread_attr, PTHREAD_SCOPE_SYSTEM ); /* force creating a kernel thread */
-    InterlockedIncrement( &nb_threads );
-    if (pthread_create( &pthread_id, &pthread_attr, (void * (*)(void *))start_thread, teb ))
-    {
-        InterlockedDecrement( &nb_threads );
-        virtual_free_teb( teb );
-        status = STATUS_NO_MEMORY;
-    }
-    pthread_attr_destroy( &pthread_attr );
-
-done:
-    pthread_sigmask( SIG_SETMASK, &sigset, NULL );
-    if (status)
-    {
-        NtClose( *handle );
-        close( request_pipe[1] );
-        return status;
-    }
-    if (attr_list) update_attr_list( attr_list, &client_id, teb );
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           abort_thread
- */
-void abort_thread( int status )
-{
-    pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
-    if (InterlockedDecrement( &nb_threads ) <= 0) abort_process( status );
-    signal_exit_thread( status, pthread_exit_wrapper );
-}
-
-
-/***********************************************************************
- *           abort_process
- */
-void abort_process( int status )
-{
-    _exit( get_unix_exit_code( status ));
-}
-
-
-/***********************************************************************
- *           exit_thread
- */
-static void exit_thread( int status )
-{
-    static void *prev_teb;
-    TEB *teb;
-
-    pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
-
-    if ((teb = InterlockedExchangePointer( &prev_teb, NtCurrentTeb() )))
-    {
-        struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
-
-        if (thread_data->pthread_id)
-        {
-            pthread_join( thread_data->pthread_id, NULL );
-            virtual_free_teb( teb );
-        }
-    }
-    signal_exit_thread( status, pthread_exit_wrapper );
-}
-
-
-/***********************************************************************
- *           exit_process
- */
-void exit_process( int status )
-{
-    pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
-    signal_exit_thread( get_unix_exit_code( status ), exit );
-}
-
-
-/**********************************************************************
- *           wait_suspend
- *
- * Wait until the thread is no longer suspended.
- */
-void wait_suspend( CONTEXT *context )
-{
-    int saved_errno = errno;
-
-    /* wait with 0 timeout, will only return once the thread is no longer suspended */
-    server_select( NULL, 0, SELECT_INTERRUPTIBLE, 0, context, NULL, NULL );
-    errno = saved_errno;
-}
-
-
-/**********************************************************************
- *           send_debug_event
- *
- * Send an EXCEPTION_DEBUG_EVENT event to the debugger.
- */
-NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
-{
-    NTSTATUS ret;
-    DWORD i;
-    obj_handle_t handle = 0;
-    client_ptr_t params[EXCEPTION_MAXIMUM_PARAMETERS];
-    CONTEXT exception_context = *context;
-    select_op_t select_op;
-    sigset_t old_set;
-
-    if (!NtCurrentTeb()->Peb->BeingDebugged) return 0;  /* no debugger present */
-
-    pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
-
-    for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
-        params[i] = rec->ExceptionInformation[i];
-
-    SERVER_START_REQ( queue_exception_event )
-    {
-        req->first   = first_chance;
-        req->code    = rec->ExceptionCode;
-        req->flags   = rec->ExceptionFlags;
-        req->record  = wine_server_client_ptr( rec->ExceptionRecord );
-        req->address = wine_server_client_ptr( rec->ExceptionAddress );
-        req->len     = i * sizeof(params[0]);
-        wine_server_add_data( req, params, req->len );
-        if (!(ret = wine_server_call( req ))) handle = reply->handle;
-    }
-    SERVER_END_REQ;
-
-    if (handle)
-    {
-        select_op.wait.op = SELECT_WAIT;
-        select_op.wait.handles[0] = handle;
-        server_select( &select_op, offsetof( select_op_t, wait.handles[1] ), SELECT_INTERRUPTIBLE,
-                       TIMEOUT_INFINITE, &exception_context, NULL, NULL );
-
-        SERVER_START_REQ( get_exception_status )
-        {
-            req->handle = handle;
-            ret = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        if (ret >= 0) *context = exception_context;
-    }
-
-    pthread_sigmask( SIG_SETMASK, &old_set, NULL );
-    return ret;
-}
-
-
-/*******************************************************************
- *		NtRaiseException (NTDLL.@)
- */
-NTSTATUS WINAPI NtRaiseException( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
-{
-    NTSTATUS status = send_debug_event( rec, context, first_chance );
-
-    if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
-        NtSetContextThread( GetCurrentThread(), context );
-
-    if (first_chance) call_user_exception_dispatcher( rec, context, pKiUserExceptionDispatcher );
-
-    if (rec->ExceptionFlags & EH_STACK_INVALID)
-        ERR("Exception frame is not in stack limits => unable to dispatch exception.\n");
-    else if (rec->ExceptionCode == STATUS_NONCONTINUABLE_EXCEPTION)
-        ERR("Process attempted to continue execution after noncontinuable exception.\n");
-    else
-        ERR("Unhandled exception code %x flags %x addr %p\n",
-            rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress );
-
-    NtTerminateProcess( NtCurrentProcess(), rec->ExceptionCode );
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *              NtOpenThread   (NTDLL.@)
- */
-NTSTATUS WINAPI NtOpenThread( HANDLE *handle, ACCESS_MASK access,
-                              const OBJECT_ATTRIBUTES *attr, const CLIENT_ID *id )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( open_thread )
-    {
-        req->tid        = HandleToULong(id->UniqueThread);
-        req->access     = access;
-        req->attributes = attr ? attr->Attributes : 0;
-        ret = wine_server_call( req );
-        *handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtSuspendThread   (NTDLL.@)
- */
-NTSTATUS WINAPI NtSuspendThread( HANDLE handle, ULONG *count )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( suspend_thread )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (!(ret = wine_server_call( req )))
-        {
-            if (count) *count = reply->count;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtResumeThread   (NTDLL.@)
- */
-NTSTATUS WINAPI NtResumeThread( HANDLE handle, ULONG *count )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( resume_thread )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (!(ret = wine_server_call( req )))
-        {
-            if (count) *count = reply->count;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtAlertResumeThread   (NTDLL.@)
- */
-NTSTATUS WINAPI NtAlertResumeThread( HANDLE handle, ULONG *count )
-{
-    FIXME( "stub: should alert thread %p\n", handle );
-    return NtResumeThread( handle, count );
-}
-
-
-/******************************************************************************
- *              NtAlertThread   (NTDLL.@)
- */
-NTSTATUS WINAPI NtAlertThread( HANDLE handle )
-{
-    FIXME( "stub: %p\n", handle );
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-
-/******************************************************************************
- *              NtTerminateThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtTerminateThread( HANDLE handle, LONG exit_code )
-{
-    NTSTATUS ret;
-    BOOL self = (handle == GetCurrentThread());
-
-    if (!self || exit_code)
-    {
-        SERVER_START_REQ( terminate_thread )
-        {
-            req->handle    = wine_server_obj_handle( handle );
-            req->exit_code = exit_code;
-            ret = wine_server_call( req );
-            self = !ret && reply->self;
-        }
-        SERVER_END_REQ;
-    }
-    if (self) exit_thread( exit_code );
-    return ret;
-}
-
-
-/******************************************************************************
- *              NtQueueApcThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueueApcThread( HANDLE handle, PNTAPCFUNC func, ULONG_PTR arg1,
-                                  ULONG_PTR arg2, ULONG_PTR arg3 )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( queue_apc )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (func)
-        {
-            req->call.type              = APC_USER;
-            req->call.user.user.func    = wine_server_client_ptr( func );
-            req->call.user.user.args[0] = arg1;
-            req->call.user.user.args[1] = arg2;
-            req->call.user.user.args[2] = arg3;
-        }
-        else req->call.type = APC_NONE;  /* wake up only */
-        ret = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-
-/***********************************************************************
- *              set_thread_context
- */
-NTSTATUS set_thread_context( HANDLE handle, const context_t *context, BOOL *self )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( set_thread_context )
-    {
-        req->handle  = wine_server_obj_handle( handle );
-        wine_server_add_data( req, context, sizeof(*context) );
-        ret = wine_server_call( req );
-        *self = reply->self;
-    }
-    SERVER_END_REQ;
-
-    return ret;
-}
-
-
-/***********************************************************************
- *              get_thread_context
- */
-NTSTATUS get_thread_context( HANDLE handle, context_t *context, unsigned int flags, BOOL *self )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( get_thread_context )
-    {
-        req->handle  = wine_server_obj_handle( handle );
-        req->flags   = flags;
-        wine_server_set_reply( req, context, sizeof(*context) );
-        ret = wine_server_call( req );
-        *self = reply->self;
-        handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    if (ret == STATUS_PENDING)
-    {
-        LARGE_INTEGER timeout;
-        timeout.QuadPart = -1000000;
-        if (NtWaitForSingleObject( handle, FALSE, &timeout ))
-        {
-            NtClose( handle );
-            return STATUS_ACCESS_DENIED;
-        }
-        SERVER_START_REQ( get_thread_context )
-        {
-            req->handle  = wine_server_obj_handle( handle );
-            req->flags   = flags;
-            wine_server_set_reply( req, context, sizeof(*context) );
-            ret = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-    }
-    return ret;
-}
-
-
-#ifdef __x86_64__
-
-/***********************************************************************
- *           wow64_get_server_context_flags
- */
-static unsigned int wow64_get_server_context_flags( DWORD flags )
-{
-    unsigned int ret = 0;
-
-    flags &= ~WOW64_CONTEXT_i386;  /* get rid of CPU id */
-    if (flags & WOW64_CONTEXT_CONTROL) ret |= SERVER_CTX_CONTROL;
-    if (flags & WOW64_CONTEXT_INTEGER) ret |= SERVER_CTX_INTEGER;
-    if (flags & WOW64_CONTEXT_SEGMENTS) ret |= SERVER_CTX_SEGMENTS;
-    if (flags & WOW64_CONTEXT_FLOATING_POINT) ret |= SERVER_CTX_FLOATING_POINT;
-    if (flags & WOW64_CONTEXT_DEBUG_REGISTERS) ret |= SERVER_CTX_DEBUG_REGISTERS;
-    if (flags & WOW64_CONTEXT_EXTENDED_REGISTERS) ret |= SERVER_CTX_EXTENDED_REGISTERS;
-    return ret;
-}
-
-/***********************************************************************
- *           wow64_context_from_server
- */
-static NTSTATUS wow64_context_from_server( WOW64_CONTEXT *to, const context_t *from )
-{
-    if (from->cpu != CPU_x86) return STATUS_INVALID_PARAMETER;
-
-    to->ContextFlags = WOW64_CONTEXT_i386;
-    if (from->flags & SERVER_CTX_CONTROL)
-    {
-        to->ContextFlags |= WOW64_CONTEXT_CONTROL;
-        to->Ebp    = from->ctl.i386_regs.ebp;
-        to->Esp    = from->ctl.i386_regs.esp;
-        to->Eip    = from->ctl.i386_regs.eip;
-        to->SegCs  = from->ctl.i386_regs.cs;
-        to->SegSs  = from->ctl.i386_regs.ss;
-        to->EFlags = from->ctl.i386_regs.eflags;
-    }
-    if (from->flags & SERVER_CTX_INTEGER)
-    {
-        to->ContextFlags |= WOW64_CONTEXT_INTEGER;
-        to->Eax = from->integer.i386_regs.eax;
-        to->Ebx = from->integer.i386_regs.ebx;
-        to->Ecx = from->integer.i386_regs.ecx;
-        to->Edx = from->integer.i386_regs.edx;
-        to->Esi = from->integer.i386_regs.esi;
-        to->Edi = from->integer.i386_regs.edi;
-    }
-    if (from->flags & SERVER_CTX_SEGMENTS)
-    {
-        to->ContextFlags |= WOW64_CONTEXT_SEGMENTS;
-        to->SegDs = from->seg.i386_regs.ds;
-        to->SegEs = from->seg.i386_regs.es;
-        to->SegFs = from->seg.i386_regs.fs;
-        to->SegGs = from->seg.i386_regs.gs;
-    }
-    if (from->flags & SERVER_CTX_FLOATING_POINT)
-    {
-        to->ContextFlags |= WOW64_CONTEXT_FLOATING_POINT;
-        to->FloatSave.ControlWord   = from->fp.i386_regs.ctrl;
-        to->FloatSave.StatusWord    = from->fp.i386_regs.status;
-        to->FloatSave.TagWord       = from->fp.i386_regs.tag;
-        to->FloatSave.ErrorOffset   = from->fp.i386_regs.err_off;
-        to->FloatSave.ErrorSelector = from->fp.i386_regs.err_sel;
-        to->FloatSave.DataOffset    = from->fp.i386_regs.data_off;
-        to->FloatSave.DataSelector  = from->fp.i386_regs.data_sel;
-        to->FloatSave.Cr0NpxState   = from->fp.i386_regs.cr0npx;
-        memcpy( to->FloatSave.RegisterArea, from->fp.i386_regs.regs, sizeof(to->FloatSave.RegisterArea) );
-    }
-    if (from->flags & SERVER_CTX_DEBUG_REGISTERS)
-    {
-        to->ContextFlags |= WOW64_CONTEXT_DEBUG_REGISTERS;
-        to->Dr0 = from->debug.i386_regs.dr0;
-        to->Dr1 = from->debug.i386_regs.dr1;
-        to->Dr2 = from->debug.i386_regs.dr2;
-        to->Dr3 = from->debug.i386_regs.dr3;
-        to->Dr6 = from->debug.i386_regs.dr6;
-        to->Dr7 = from->debug.i386_regs.dr7;
-    }
-    if (from->flags & SERVER_CTX_EXTENDED_REGISTERS)
-    {
-        to->ContextFlags |= WOW64_CONTEXT_EXTENDED_REGISTERS;
-        memcpy( to->ExtendedRegisters, from->ext.i386_regs, sizeof(to->ExtendedRegisters) );
-    }
-    return STATUS_SUCCESS;
-}
-
-/***********************************************************************
- *           wow64_context_to_server
- */
-static void wow64_context_to_server( context_t *to, const WOW64_CONTEXT *from )
-{
-    DWORD flags = from->ContextFlags & ~WOW64_CONTEXT_i386;  /* get rid of CPU id */
-
-    memset( to, 0, sizeof(*to) );
-    to->cpu = CPU_x86;
-
-    if (flags & WOW64_CONTEXT_CONTROL)
-    {
-        to->flags |= SERVER_CTX_CONTROL;
-        to->ctl.i386_regs.ebp    = from->Ebp;
-        to->ctl.i386_regs.esp    = from->Esp;
-        to->ctl.i386_regs.eip    = from->Eip;
-        to->ctl.i386_regs.cs     = from->SegCs;
-        to->ctl.i386_regs.ss     = from->SegSs;
-        to->ctl.i386_regs.eflags = from->EFlags;
-    }
-    if (flags & WOW64_CONTEXT_INTEGER)
-    {
-        to->flags |= SERVER_CTX_INTEGER;
-        to->integer.i386_regs.eax = from->Eax;
-        to->integer.i386_regs.ebx = from->Ebx;
-        to->integer.i386_regs.ecx = from->Ecx;
-        to->integer.i386_regs.edx = from->Edx;
-        to->integer.i386_regs.esi = from->Esi;
-        to->integer.i386_regs.edi = from->Edi;
-    }
-    if (flags & WOW64_CONTEXT_SEGMENTS)
-    {
-        to->flags |= SERVER_CTX_SEGMENTS;
-        to->seg.i386_regs.ds = from->SegDs;
-        to->seg.i386_regs.es = from->SegEs;
-        to->seg.i386_regs.fs = from->SegFs;
-        to->seg.i386_regs.gs = from->SegGs;
-    }
-    if (flags & WOW64_CONTEXT_FLOATING_POINT)
-    {
-        to->flags |= SERVER_CTX_FLOATING_POINT;
-        to->fp.i386_regs.ctrl     = from->FloatSave.ControlWord;
-        to->fp.i386_regs.status   = from->FloatSave.StatusWord;
-        to->fp.i386_regs.tag      = from->FloatSave.TagWord;
-        to->fp.i386_regs.err_off  = from->FloatSave.ErrorOffset;
-        to->fp.i386_regs.err_sel  = from->FloatSave.ErrorSelector;
-        to->fp.i386_regs.data_off = from->FloatSave.DataOffset;
-        to->fp.i386_regs.data_sel = from->FloatSave.DataSelector;
-        to->fp.i386_regs.cr0npx   = from->FloatSave.Cr0NpxState;
-        memcpy( to->fp.i386_regs.regs, from->FloatSave.RegisterArea, sizeof(to->fp.i386_regs.regs) );
-    }
-    if (flags & WOW64_CONTEXT_DEBUG_REGISTERS)
-    {
-        to->flags |= SERVER_CTX_DEBUG_REGISTERS;
-        to->debug.i386_regs.dr0 = from->Dr0;
-        to->debug.i386_regs.dr1 = from->Dr1;
-        to->debug.i386_regs.dr2 = from->Dr2;
-        to->debug.i386_regs.dr3 = from->Dr3;
-        to->debug.i386_regs.dr6 = from->Dr6;
-        to->debug.i386_regs.dr7 = from->Dr7;
-    }
-    if (flags & WOW64_CONTEXT_EXTENDED_REGISTERS)
-    {
-        to->flags |= SERVER_CTX_EXTENDED_REGISTERS;
-        memcpy( to->ext.i386_regs, from->ExtendedRegisters, sizeof(to->ext.i386_regs) );
-    }
-}
-
-#endif /* __x86_64__ */
-
-#ifdef linux
-BOOL get_thread_times(int unix_pid, int unix_tid, LARGE_INTEGER *kernel_time, LARGE_INTEGER *user_time)
-{
-    unsigned long clocks_per_sec = sysconf( _SC_CLK_TCK );
-    unsigned long usr, sys;
-    const char *pos;
-    char buf[512];
-    FILE *f;
-    int i;
-
-    if (unix_tid == -1)
-        sprintf( buf, "/proc/%u/stat", unix_pid );
-    else
-        sprintf( buf, "/proc/%u/task/%u/stat", unix_pid, unix_tid );
-    if (!(f = fopen( buf, "r" )))
-    {
-        WARN("Failed to open %s: %s\n", buf, strerror(errno));
-        return FALSE;
-    }
-
-    pos = fgets( buf, sizeof(buf), f );
-    fclose( f );
-
-    /* the process name is printed unescaped, so we have to skip to the last ')'
-     * to avoid misinterpreting the string */
-    if (pos) pos = strrchr( pos, ')' );
-    if (pos) pos = strchr( pos + 1, ' ' );
-    if (pos) pos++;
-
-    /* skip over the following fields: state, ppid, pgid, sid, tty_nr, tty_pgrp,
-     * task->flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
-    for (i = 0; i < 11 && pos; i++)
-    {
-        pos = strchr( pos + 1, ' ' );
-        if (pos) pos++;
-    }
-
-    /* the next two values are user and system time */
-    if (pos && (sscanf( pos, "%lu %lu", &usr, &sys ) == 2))
-    {
-        kernel_time->QuadPart = (ULONGLONG)sys * 10000000 / clocks_per_sec;
-        user_time->QuadPart = (ULONGLONG)usr * 10000000 / clocks_per_sec;
-        return TRUE;
-    }
-
-    ERR("Failed to parse %s\n", debugstr_a(buf));
-    return FALSE;
-}
-#else
-BOOL get_thread_times(int unix_pid, int unix_tid, LARGE_INTEGER *kernel_time, LARGE_INTEGER *user_time)
-{
-    static int once;
-    if (!once++) FIXME("not implemented on this platform\n");
-    return FALSE;
-}
-#endif
-
-/******************************************************************************
- *              NtQueryInformationThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryInformationThread( HANDLE handle, THREADINFOCLASS class,
-                                          void *data, ULONG length, ULONG *ret_len )
-{
-    NTSTATUS status;
-
-    TRACE("(%p,%d,%p,%x,%p)\n", handle, class, data, length, ret_len);
-
-    switch (class)
-    {
-    case ThreadBasicInformation:
-    {
-        THREAD_BASIC_INFORMATION info;
-        const ULONG_PTR affinity_mask = get_system_affinity_mask();
-
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (!(status = wine_server_call( req )))
-            {
-                info.ExitStatus             = reply->exit_code;
-                info.TebBaseAddress         = wine_server_get_ptr( reply->teb );
-                info.ClientId.UniqueProcess = ULongToHandle(reply->pid);
-                info.ClientId.UniqueThread  = ULongToHandle(reply->tid);
-                info.AffinityMask           = reply->affinity & affinity_mask;
-                info.Priority               = reply->priority;
-                info.BasePriority           = reply->priority;  /* FIXME */
-            }
-        }
-        SERVER_END_REQ;
-        if (status == STATUS_SUCCESS)
-        {
-            if (data) memcpy( data, &info, min( length, sizeof(info) ));
-            if (ret_len) *ret_len = min( length, sizeof(info) );
-        }
-        return status;
-    }
-
-    case ThreadAffinityMask:
-    {
-        const ULONG_PTR affinity_mask = get_system_affinity_mask();
-        ULONG_PTR affinity = 0;
-
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->access = THREAD_QUERY_INFORMATION;
-            if (!(status = wine_server_call( req ))) affinity = reply->affinity & affinity_mask;
-        }
-        SERVER_END_REQ;
-        if (status == STATUS_SUCCESS)
-        {
-            if (data) memcpy( data, &affinity, min( length, sizeof(affinity) ));
-            if (ret_len) *ret_len = min( length, sizeof(affinity) );
-        }
-        return status;
-    }
-
-    case ThreadTimes:
-    {
-        KERNEL_USER_TIMES kusrt;
-        int unix_pid, unix_tid;
-
-        SERVER_START_REQ( get_thread_times )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                kusrt.CreateTime.QuadPart = reply->creation_time;
-                kusrt.ExitTime.QuadPart = reply->exit_time;
-                unix_pid = reply->unix_pid;
-                unix_tid = reply->unix_tid;
-            }
-        }
-        SERVER_END_REQ;
-        if (status == STATUS_SUCCESS)
-        {
-            BOOL ret = FALSE;
-
-            kusrt.KernelTime.QuadPart = kusrt.UserTime.QuadPart = 0;
-            if (unix_pid != -1 && unix_tid != -1)
-                ret = get_thread_times( unix_pid, unix_tid, &kusrt.KernelTime, &kusrt.UserTime );
-            if (!ret && handle == GetCurrentThread())
-            {
-                /* fall back to process times */
-                struct tms time_buf;
-                long clocks_per_sec = sysconf(_SC_CLK_TCK);
-
-                times(&time_buf);
-                kusrt.KernelTime.QuadPart = (ULONGLONG)time_buf.tms_stime * 10000000 / clocks_per_sec;
-                kusrt.UserTime.QuadPart = (ULONGLONG)time_buf.tms_utime * 10000000 / clocks_per_sec;
-            }
-            if (data) memcpy( data, &kusrt, min( length, sizeof(kusrt) ));
-            if (ret_len) *ret_len = min( length, sizeof(kusrt) );
-        }
-        return status;
-    }
-
-    case ThreadDescriptorTableEntry:
-        return get_thread_ldt_entry( handle, data, length, ret_len );
-
-    case ThreadAmILastThread:
-    {
-        if (length != sizeof(ULONG)) return STATUS_INFO_LENGTH_MISMATCH;
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                ULONG last = reply->last;
-                if (data) memcpy( data, &last, sizeof(last) );
-                if (ret_len) *ret_len = sizeof(last);
-            }
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadQuerySetWin32StartAddress:
-    {
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->access = THREAD_QUERY_INFORMATION;
-            status = wine_server_call( req );
-            if (status == STATUS_SUCCESS)
-            {
-                PRTL_THREAD_START_ROUTINE entry = wine_server_get_ptr( reply->entry_point );
-                if (data) memcpy( data, &entry, min( length, sizeof(entry) ) );
-                if (ret_len) *ret_len = min( length, sizeof(entry) );
-            }
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadGroupInformation:
-    {
-        const ULONG_PTR affinity_mask = get_system_affinity_mask();
-        GROUP_AFFINITY affinity;
-
-        memset( &affinity, 0, sizeof(affinity) );
-        affinity.Group = 0; /* Wine only supports max 64 processors */
-
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (!(status = wine_server_call( req ))) affinity.Mask = reply->affinity & affinity_mask;
-        }
-        SERVER_END_REQ;
-        if (status == STATUS_SUCCESS)
-        {
-            if (data) memcpy( data, &affinity, min( length, sizeof(affinity) ));
-            if (ret_len) *ret_len = min( length, sizeof(affinity) );
-        }
-        return status;
-    }
-
-    case ThreadIsIoPending:
-        FIXME( "ThreadIsIoPending info class not supported yet\n" );
-        if (length != sizeof(BOOL)) return STATUS_INFO_LENGTH_MISMATCH;
-        if (!data) return STATUS_ACCESS_DENIED;
-        *(BOOL*)data = FALSE;
-        if (ret_len) *ret_len = sizeof(BOOL);
-        return STATUS_SUCCESS;
-
-    case ThreadSuspendCount:
-        if (length != sizeof(ULONG)) return STATUS_INFO_LENGTH_MISMATCH;
-        if (!data) return STATUS_ACCESS_VIOLATION;
-
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (!(status = wine_server_call( req ))) *(ULONG *)data = reply->suspend_count;
-        }
-        SERVER_END_REQ;
-        return status;
-
-    case ThreadDescription:
-    {
-        THREAD_DESCRIPTION_INFORMATION *info = data;
-        data_size_t len, desc_len = 0;
-        WCHAR *ptr;
-
-        len = length >= sizeof(*info) ? length - sizeof(*info) : 0;
-        ptr = info ? (WCHAR *)(info + 1) : NULL;
-
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (ptr) wine_server_set_reply( req, ptr, len );
-            status = wine_server_call( req );
-            desc_len = reply->desc_len;
-        }
-        SERVER_END_REQ;
-
-        if (!info) status = STATUS_BUFFER_TOO_SMALL;
-        else if (status == STATUS_SUCCESS)
-        {
-            info->Description.Length = info->Description.MaximumLength = desc_len;
-            info->Description.Buffer = ptr;
-        }
-
-        if (ret_len && (status == STATUS_SUCCESS || status == STATUS_BUFFER_TOO_SMALL))
-            *ret_len = sizeof(*info) + desc_len;
-        return status;
-    }
-
-    case ThreadWow64Context:
-    {
-#ifdef __x86_64__
-        BOOL self;
-        WOW64_CONTEXT *context = data;
-        context_t server_context;
-        unsigned int server_flags;
-
-        if (length != sizeof(*context)) return STATUS_INFO_LENGTH_MISMATCH;
-        server_flags = wow64_get_server_context_flags( context->ContextFlags );
-        if ((status = get_thread_context( handle, &server_context, server_flags, &self ))) return status;
-        if (self) return STATUS_INVALID_PARAMETER;
-        status = wow64_context_from_server( context, &server_context );
-        if (ret_len && !status) *ret_len = sizeof(*context);
-        return status;
-#else
-        return STATUS_INVALID_INFO_CLASS;
-#endif
-    }
-
-    case ThreadHideFromDebugger:
-        if (length != sizeof(BOOLEAN)) return STATUS_INFO_LENGTH_MISMATCH;
-        if (!data) return STATUS_ACCESS_VIOLATION;
-        SERVER_START_REQ( get_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->access = THREAD_QUERY_INFORMATION;
-            if ((status = wine_server_call( req ))) return status;
-            *(BOOLEAN*)data = reply->dbg_hidden;
-        }
-        SERVER_END_REQ;
-        if (ret_len) *ret_len = sizeof(BOOLEAN);
-        return STATUS_SUCCESS;
-
-    case ThreadPriority:
-    case ThreadBasePriority:
-    case ThreadImpersonationToken:
-    case ThreadEnableAlignmentFaultFixup:
-    case ThreadEventPair_Reusable:
-    case ThreadZeroTlsCell:
-    case ThreadPerformanceCount:
-    case ThreadIdealProcessor:
-    case ThreadPriorityBoost:
-    case ThreadSetTlsArrayAddress:
-    default:
-        FIXME( "info class %d not supported yet\n", class );
-        return STATUS_NOT_IMPLEMENTED;
-    }
-}
-
-
-/******************************************************************************
- *              NtSetInformationThread  (NTDLL.@)
- */
-NTSTATUS WINAPI NtSetInformationThread( HANDLE handle, THREADINFOCLASS class,
-                                        const void *data, ULONG length )
-{
-    NTSTATUS status;
-
-    TRACE("(%p,%d,%p,%x)\n", handle, class, data, length);
-
-    switch (class)
-    {
-    case ThreadZeroTlsCell:
-        if (handle == GetCurrentThread())
-        {
-            if (length != sizeof(DWORD)) return STATUS_INVALID_PARAMETER;
-            return virtual_clear_tls_index( *(const ULONG *)data );
-        }
-        FIXME( "ZeroTlsCell not supported on other threads\n" );
-        return STATUS_NOT_IMPLEMENTED;
-
-    case ThreadImpersonationToken:
-    {
-        const HANDLE *token = data;
-
-        if (length != sizeof(HANDLE)) return STATUS_INVALID_PARAMETER;
-        TRACE("Setting ThreadImpersonationToken handle to %p\n", *token );
-        SERVER_START_REQ( set_thread_info )
-        {
-            req->handle   = wine_server_obj_handle( handle );
-            req->token    = wine_server_obj_handle( *token );
-            req->mask     = SET_THREAD_INFO_TOKEN;
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadBasePriority:
-    {
-        const DWORD *pprio = data;
-        if (length != sizeof(DWORD)) return STATUS_INVALID_PARAMETER;
-        SERVER_START_REQ( set_thread_info )
-        {
-            req->handle   = wine_server_obj_handle( handle );
-            req->priority = *pprio;
-            req->mask     = SET_THREAD_INFO_PRIORITY;
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadAffinityMask:
-    {
-        const ULONG_PTR affinity_mask = get_system_affinity_mask();
-        ULONG_PTR req_aff;
-
-        if (length != sizeof(ULONG_PTR)) return STATUS_INVALID_PARAMETER;
-        req_aff = *(const ULONG_PTR *)data & affinity_mask;
-        if (!req_aff) return STATUS_INVALID_PARAMETER;
-
-        SERVER_START_REQ( set_thread_info )
-        {
-            req->handle   = wine_server_obj_handle( handle );
-            req->affinity = req_aff;
-            req->mask     = SET_THREAD_INFO_AFFINITY;
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadHideFromDebugger:
-        if (length) return STATUS_INFO_LENGTH_MISMATCH;
-        SERVER_START_REQ( set_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->mask   = SET_THREAD_INFO_DBG_HIDDEN;
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        return status;
-
-    case ThreadQuerySetWin32StartAddress:
-    {
-        const PRTL_THREAD_START_ROUTINE *entry = data;
-        if (length != sizeof(PRTL_THREAD_START_ROUTINE)) return STATUS_INVALID_PARAMETER;
-        SERVER_START_REQ( set_thread_info )
-        {
-            req->handle   = wine_server_obj_handle( handle );
-            req->mask     = SET_THREAD_INFO_ENTRYPOINT;
-            req->entry_point = wine_server_client_ptr( *entry );
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadGroupInformation:
-    {
-        const ULONG_PTR affinity_mask = get_system_affinity_mask();
-        const GROUP_AFFINITY *req_aff;
-
-        if (length != sizeof(*req_aff)) return STATUS_INVALID_PARAMETER;
-        if (!data) return STATUS_ACCESS_VIOLATION;
-        req_aff = data;
-
-        /* On Windows the request fails if the reserved fields are set */
-        if (req_aff->Reserved[0] || req_aff->Reserved[1] || req_aff->Reserved[2])
-            return STATUS_INVALID_PARAMETER;
-
-        /* Wine only supports max 64 processors */
-        if (req_aff->Group) return STATUS_INVALID_PARAMETER;
-        if (req_aff->Mask & ~affinity_mask) return STATUS_INVALID_PARAMETER;
-        if (!req_aff->Mask) return STATUS_INVALID_PARAMETER;
-        SERVER_START_REQ( set_thread_info )
-        {
-            req->handle   = wine_server_obj_handle( handle );
-            req->affinity = req_aff->Mask;
-            req->mask     = SET_THREAD_INFO_AFFINITY;
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadDescription:
-    {
-        const THREAD_DESCRIPTION_INFORMATION *info = data;
-
-        if (length != sizeof(*info)) return STATUS_INFO_LENGTH_MISMATCH;
-        if (!info) return STATUS_ACCESS_VIOLATION;
-        if (info->Description.Length != info->Description.MaximumLength) return STATUS_INVALID_PARAMETER;
-        if (info->Description.Length && !info->Description.Buffer) return STATUS_ACCESS_VIOLATION;
-
-        SERVER_START_REQ( set_thread_info )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            req->mask   = SET_THREAD_INFO_DESCRIPTION;
-            wine_server_add_data( req, info->Description.Buffer, info->Description.Length );
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        return status;
-    }
-
-    case ThreadWow64Context:
-    {
-#ifdef __x86_64__
-        BOOL self;
-        const WOW64_CONTEXT *context = data;
-        context_t server_context;
-
-        if (length != sizeof(*context)) return STATUS_INFO_LENGTH_MISMATCH;
-        wow64_context_to_server( &server_context, context );
-        return set_thread_context( handle, &server_context, &self );
-#else
-        return STATUS_INVALID_INFO_CLASS;
-#endif
-    }
-
-    case ThreadBasicInformation:
-    case ThreadTimes:
-    case ThreadPriority:
-    case ThreadDescriptorTableEntry:
-    case ThreadEnableAlignmentFaultFixup:
-    case ThreadEventPair_Reusable:
-    case ThreadPerformanceCount:
-    case ThreadAmILastThread:
-    case ThreadIdealProcessor:
-    case ThreadPriorityBoost:
-    case ThreadSetTlsArrayAddress:
-    case ThreadIsIoPending:
-    default:
-        FIXME( "info class %d not supported yet\n", class );
-        return STATUS_NOT_IMPLEMENTED;
-    }
-}
-
-
-/******************************************************************************
- *              NtGetCurrentProcessorNumber  (NTDLL.@)
- */
-ULONG WINAPI NtGetCurrentProcessorNumber(void)
-{
-    ULONG processor;
-
-#if defined(__linux__) && defined(__NR_getcpu)
-    int res = syscall(__NR_getcpu, &processor, NULL, NULL);
-    if (res != -1) return processor;
-#endif
-
-    if (NtCurrentTeb()->Peb->NumberOfProcessors > 1)
-    {
-        ULONG_PTR thread_mask, processor_mask;
-
-        if (!NtQueryInformationThread( GetCurrentThread(), ThreadAffinityMask,
-                                       &thread_mask, sizeof(thread_mask), NULL ))
-        {
-            for (processor = 0; processor < NtCurrentTeb()->Peb->NumberOfProcessors; processor++)
-            {
-                processor_mask = (1 << processor);
-                if (thread_mask & processor_mask)
-                {
-                    if (thread_mask != processor_mask)
-                        FIXME( "need multicore support (%d processors)\n",
-                               NtCurrentTeb()->Peb->NumberOfProcessors );
-                    return processor;
-                }
-            }
-        }
-    }
-    /* fallback to the first processor */
-    return 0;
-}
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 397211957b..663036a699 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -21,380 +21,16 @@
 #ifndef __NTDLL_UNIX_PRIVATE_H
 #define __NTDLL_UNIX_PRIVATE_H
 
-#include <pthread.h>
-#include <signal.h>
 #include "unixlib.h"
-#include "wine/list.h"
-
-#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
-#define InterlockedCompareExchange64(dest,xchg,cmp) RtlInterlockedCompareExchange64(dest,xchg,cmp)
-#endif
-
-#ifdef __i386__
-static const enum cpu_type client_cpu = CPU_x86;
-#elif defined(__x86_64__)
-static const enum cpu_type client_cpu = CPU_x86_64;
-#elif defined(__arm__)
-static const enum cpu_type client_cpu = CPU_ARM;
-#elif defined(__aarch64__)
-static const enum cpu_type client_cpu = CPU_ARM64;
-#endif
-
-struct debug_info
-{
-    unsigned int str_pos;       /* current position in strings buffer */
-    unsigned int out_pos;       /* current position in output buffer */
-    char         strings[1024]; /* buffer for temporary strings */
-    char         output[1024];  /* current output line */
-};
-
-/* thread private data, stored in NtCurrentTeb()->GdiTebBatch */
-struct ntdll_thread_data
-{
-    void              *cpu_data[16];  /* reserved for CPU-specific data */
-    struct debug_info *debug_info;    /* info for debugstr functions */
-    void              *start_stack;   /* stack for thread startup */
-    int                request_fd;    /* fd for sending server requests */
-    int                reply_fd;      /* fd for receiving server replies */
-    int                wait_fd[2];    /* fd for sleeping server requests */
-    pthread_t          pthread_id;    /* pthread thread id */
-    struct list        entry;         /* entry in TEB list */
-    PRTL_THREAD_START_ROUTINE start;  /* thread entry point */
-    void              *param;         /* thread entry point parameter */
-};
-
-C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
-
-static inline struct ntdll_thread_data *ntdll_get_thread_data(void)
-{
-    return (struct ntdll_thread_data *)&NtCurrentTeb()->GdiTebBatch;
-}
-
-static const SIZE_T page_size = 0x1000;
-static const SIZE_T signal_stack_mask = 0xffff;
-#ifdef _WIN64
-static const SIZE_T teb_size = 0x2000;
-static const SIZE_T teb_offset = 0;
-static const SIZE_T signal_stack_size = 0x10000 - 0x2000;
-#else
-static const SIZE_T teb_size = 0x3000;  /* TEB64 + TEB */
-static const SIZE_T teb_offset = 0x2000;
-static const SIZE_T signal_stack_size = 0x10000 - 0x3000;
-#endif
-
-/* callbacks to PE ntdll from the Unix side */
-extern void     (WINAPI *pDbgUiRemoteBreakin)( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS (WINAPI *pKiRaiseUserExceptionDispatcher)(void) DECLSPEC_HIDDEN;
-extern void     (WINAPI *pKiUserApcDispatcher)(CONTEXT*,ULONG_PTR,ULONG_PTR,ULONG_PTR,PNTAPCFUNC) DECLSPEC_HIDDEN;
-extern NTSTATUS (WINAPI *pKiUserExceptionDispatcher)(EXCEPTION_RECORD*,CONTEXT*) DECLSPEC_HIDDEN;
-extern void     (WINAPI *pLdrInitializeThunk)(CONTEXT*,void**,ULONG_PTR,ULONG_PTR) DECLSPEC_HIDDEN;
-extern void     (WINAPI *pRtlUserThreadStart)( PRTL_THREAD_START_ROUTINE entry, void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlpWaitForCriticalSection( RTL_CRITICAL_SECTION *crit, int timeout ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlpUnWaitCriticalSection( RTL_CRITICAL_SECTION *crit ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlTryAcquireSRWLockExclusive( RTL_SRWLOCK *lock ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlAcquireSRWLockExclusive( RTL_SRWLOCK *lock ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlTryAcquireSRWLockShared( RTL_SRWLOCK *lock ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlAcquireSRWLockShared( RTL_SRWLOCK *lock ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlReleaseSRWLockExclusive( RTL_SRWLOCK *lock ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlReleaseSRWLockShared( RTL_SRWLOCK *lock ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlSleepConditionVariableSRW( RTL_CONDITION_VARIABLE *variable, RTL_SRWLOCK *lock,
-                                                         const LARGE_INTEGER *timeout, ULONG flags ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlSleepConditionVariableCS( RTL_CONDITION_VARIABLE *variable,
-                                                        RTL_CRITICAL_SECTION *cs,
-                                                        const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL fast_RtlWakeConditionVariable( RTL_CONDITION_VARIABLE *variable, int count ) DECLSPEC_HIDDEN;
-extern LONGLONG CDECL fast_RtlGetSystemTimePrecise(void) DECLSPEC_HIDDEN;
 
 void CDECL mmap_add_reserved_area( void *addr, SIZE_T size ) DECLSPEC_HIDDEN;
 void CDECL mmap_remove_reserved_area( void *addr, SIZE_T size ) DECLSPEC_HIDDEN;
 int  CDECL mmap_is_in_reserved_area( void *addr, SIZE_T size ) DECLSPEC_HIDDEN;
 int  CDECL mmap_enum_reserved_areas( int (CDECL *enum_func)(void *base, SIZE_T size, void *arg), void *arg,
                                      int top_down ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL get_initial_environment( WCHAR **wargv[], WCHAR *env, SIZE_T *size ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL get_startup_info( startup_info_t *info, SIZE_T *total_size, SIZE_T *info_size ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL get_dynamic_environment( WCHAR *env, SIZE_T *size ) DECLSPEC_HIDDEN;
-extern void CDECL get_initial_directory( UNICODE_STRING *dir ) DECLSPEC_HIDDEN;
-extern void CDECL get_initial_console( HANDLE *handle, HANDLE *std_in, HANDLE *std_out, HANDLE *std_err ) DECLSPEC_HIDDEN;
-extern USHORT * CDECL get_unix_codepage_data(void) DECLSPEC_HIDDEN;
-extern void CDECL get_locales( WCHAR *sys, WCHAR *user ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL virtual_map_section( HANDLE handle, PVOID *addr_ptr, unsigned short zero_bits_64, SIZE_T commit_size,
-                                           const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr, ULONG alloc_type,
-                                           ULONG protect, pe_image_info_t *image_info ) DECLSPEC_HIDDEN;
-extern ssize_t CDECL virtual_locked_recvmsg( int fd, struct msghdr *hdr, int flags ) DECLSPEC_HIDDEN;
-extern void CDECL virtual_release_address_space(void) DECLSPEC_HIDDEN;
-
-extern void CDECL server_send_fd( int fd ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL server_fd_to_handle( int fd, unsigned int access, unsigned int attributes,
-                                           HANDLE *handle ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL server_handle_to_fd( HANDLE handle, unsigned int access, int *unix_fd,
-                                           unsigned int *options ) DECLSPEC_HIDDEN;
-extern void CDECL server_release_fd( HANDLE handle, int unix_fd ) DECLSPEC_HIDDEN;
-extern void CDECL server_init_process_done( void *relay ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL exec_process( UNICODE_STRING *path, UNICODE_STRING *cmdline, NTSTATUS status ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL unwind_builtin_dll( ULONG type, struct _DISPATCHER_CONTEXT *dispatch,
-                                          CONTEXT *context ) DECLSPEC_HIDDEN;
-
-extern void CDECL set_show_dot_files( BOOL enable ) DECLSPEC_HIDDEN;
-
-extern const char *home_dir DECLSPEC_HIDDEN;
-extern const char *data_dir DECLSPEC_HIDDEN;
-extern const char *build_dir DECLSPEC_HIDDEN;
-extern const char *config_dir DECLSPEC_HIDDEN;
-extern const char *user_name DECLSPEC_HIDDEN;
-extern const char **dll_paths DECLSPEC_HIDDEN;
-extern USHORT *uctable DECLSPEC_HIDDEN;
-extern USHORT *lctable DECLSPEC_HIDDEN;
-extern SIZE_T startup_info_size DECLSPEC_HIDDEN;
-extern int main_argc DECLSPEC_HIDDEN;
-extern char **main_argv DECLSPEC_HIDDEN;
-extern char **main_envp DECLSPEC_HIDDEN;
-extern unsigned int server_cpus DECLSPEC_HIDDEN;
-extern BOOL is_wow64 DECLSPEC_HIDDEN;
-extern HANDLE keyed_event DECLSPEC_HIDDEN;
-extern timeout_t server_start_time DECLSPEC_HIDDEN;
-extern sigset_t server_block_set DECLSPEC_HIDDEN;
-extern struct _KUSER_SHARED_DATA *user_shared_data DECLSPEC_HIDDEN;
-#ifdef __i386__
-extern struct ldt_copy __wine_ldt_copy DECLSPEC_HIDDEN;
-#endif
-
-extern void init_environment( int argc, char *argv[], char *envp[] ) DECLSPEC_HIDDEN;
-extern DWORD ntdll_umbstowcs( const char *src, DWORD srclen, WCHAR *dst, DWORD dstlen ) DECLSPEC_HIDDEN;
-extern int ntdll_wcstoumbs( const WCHAR *src, DWORD srclen, char *dst, DWORD dstlen, BOOL strict ) DECLSPEC_HIDDEN;
-extern char **build_envp( const WCHAR *envW ) DECLSPEC_HIDDEN;
-extern NTSTATUS exec_wineloader( char **argv, int socketfd, const pe_image_info_t *pe_info ) DECLSPEC_HIDDEN;
-extern void start_server( BOOL debug ) DECLSPEC_HIDDEN;
-extern ULONG_PTR get_image_address(void) DECLSPEC_HIDDEN;
-
-extern unsigned int server_call_unlocked( void *req_ptr ) DECLSPEC_HIDDEN;
-extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
-extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
-extern unsigned int server_select( const select_op_t *select_op, data_size_t size, UINT flags,
-                                   timeout_t abs_timeout, CONTEXT *context, pthread_mutex_t *mutex,
-                                   user_apc_t *user_apc ) DECLSPEC_HIDDEN;
-extern unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT flags,
-                                 const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
-extern unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call,
-                                              apc_result_t *result ) DECLSPEC_HIDDEN;
-extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
-                               int *needs_close, enum server_fd_type *type, unsigned int *options ) DECLSPEC_HIDDEN;
-extern void server_init_process(void) DECLSPEC_HIDDEN;
-extern size_t server_init_thread( void *entry_point, BOOL *suspend ) DECLSPEC_HIDDEN;
-extern int server_pipe( int fd[2] ) DECLSPEC_HIDDEN;
-
-extern NTSTATUS context_to_server( context_t *to, const CONTEXT *from ) DECLSPEC_HIDDEN;
-extern NTSTATUS context_from_server( CONTEXT *to, const context_t *from ) DECLSPEC_HIDDEN;
-extern void DECLSPEC_NORETURN abort_thread( int status ) DECLSPEC_HIDDEN;
-extern void DECLSPEC_NORETURN abort_process( int status ) DECLSPEC_HIDDEN;
-extern void DECLSPEC_NORETURN exit_process( int status ) DECLSPEC_HIDDEN;
-extern void wait_suspend( CONTEXT *context ) DECLSPEC_HIDDEN;
-extern NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance ) DECLSPEC_HIDDEN;
-extern NTSTATUS set_thread_context( HANDLE handle, const context_t *context, BOOL *self ) DECLSPEC_HIDDEN;
-extern NTSTATUS get_thread_context( HANDLE handle, context_t *context, unsigned int flags, BOOL *self ) DECLSPEC_HIDDEN;
-extern NTSTATUS alloc_object_attributes( const OBJECT_ATTRIBUTES *attr, struct object_attributes **ret,
-                                         data_size_t *ret_len ) DECLSPEC_HIDDEN;
 
 extern void virtual_init(void) DECLSPEC_HIDDEN;
-extern NTSTATUS virtual_map_ntdll( int fd, void **module ) DECLSPEC_HIDDEN;
-extern ULONG_PTR get_system_affinity_mask(void) DECLSPEC_HIDDEN;
-extern void virtual_get_system_info( SYSTEM_BASIC_INFORMATION *info ) DECLSPEC_HIDDEN;
-extern NTSTATUS virtual_create_builtin_view( void *module ) DECLSPEC_HIDDEN;
-extern TEB *virtual_alloc_first_teb(void) DECLSPEC_HIDDEN;
-extern NTSTATUS virtual_alloc_teb( TEB **ret_teb ) DECLSPEC_HIDDEN;
-extern void virtual_free_teb( TEB *teb ) DECLSPEC_HIDDEN;
-extern NTSTATUS virtual_clear_tls_index( ULONG index ) DECLSPEC_HIDDEN;
-extern NTSTATUS virtual_alloc_thread_stack( INITIAL_TEB *stack, SIZE_T reserve_size, SIZE_T commit_size,
-                                            SIZE_T *pthread_size ) DECLSPEC_HIDDEN;
-extern void virtual_map_user_shared_data(void) DECLSPEC_HIDDEN;
-extern NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack ) DECLSPEC_HIDDEN;
-extern unsigned int virtual_locked_server_call( void *req_ptr ) DECLSPEC_HIDDEN;
-extern ssize_t virtual_locked_read( int fd, void *addr, size_t size ) DECLSPEC_HIDDEN;
-extern ssize_t virtual_locked_pread( int fd, void *addr, size_t size, off_t offset ) DECLSPEC_HIDDEN;
-extern BOOL virtual_is_valid_code_address( const void *addr, SIZE_T size ) DECLSPEC_HIDDEN;
-extern void *virtual_setup_exception( void *stack_ptr, size_t size, EXCEPTION_RECORD *rec ) DECLSPEC_HIDDEN;
-extern BOOL virtual_check_buffer_for_read( const void *ptr, SIZE_T size ) DECLSPEC_HIDDEN;
-extern BOOL virtual_check_buffer_for_write( void *ptr, SIZE_T size ) DECLSPEC_HIDDEN;
-extern SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size ) DECLSPEC_HIDDEN;
-extern NTSTATUS virtual_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size ) DECLSPEC_HIDDEN;
-extern void virtual_set_force_exec( BOOL enable ) DECLSPEC_HIDDEN;
-extern void virtual_set_large_address_space(void) DECLSPEC_HIDDEN;
-extern void virtual_fill_image_information( const pe_image_info_t *pe_info,
-                                            SECTION_IMAGE_INFORMATION *info ) DECLSPEC_HIDDEN;
-
-extern NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
-extern BOOL get_thread_times( int unix_pid, int unix_tid, LARGE_INTEGER *kernel_time,
-                              LARGE_INTEGER *user_time ) DECLSPEC_HIDDEN;
-extern void signal_init_threading(void) DECLSPEC_HIDDEN;
-extern NTSTATUS signal_alloc_thread( TEB *teb ) DECLSPEC_HIDDEN;
-extern void signal_free_thread( TEB *teb ) DECLSPEC_HIDDEN;
-extern void signal_init_thread( TEB *teb ) DECLSPEC_HIDDEN;
-extern void signal_init_process(void) DECLSPEC_HIDDEN;
-extern void DECLSPEC_NORETURN signal_start_thread( PRTL_THREAD_START_ROUTINE entry, void *arg,
-                                                   BOOL suspend, void *relay, TEB *teb ) DECLSPEC_HIDDEN;
-extern void DECLSPEC_NORETURN signal_exit_thread( int status, void (*func)(int) ) DECLSPEC_HIDDEN;
-extern void __wine_syscall_dispatcher(void) DECLSPEC_HIDDEN;
-extern void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid ) DECLSPEC_HIDDEN;
-
-extern NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                       IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
-                                       ULONG in_size, void *out_buffer, ULONG out_size ) DECLSPEC_HIDDEN;
-extern NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                        IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
-                                        ULONG in_size, void *out_buffer, ULONG out_size ) DECLSPEC_HIDDEN;
-extern NTSTATUS serial_FlushBuffersFile( int fd ) DECLSPEC_HIDDEN;
-extern NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                      IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
-                                      ULONG in_size, void *out_buffer, ULONG out_size ) DECLSPEC_HIDDEN;
-
-extern NTSTATUS errno_to_status( int err ) DECLSPEC_HIDDEN;
-extern NTSTATUS nt_to_unix_file_name( const UNICODE_STRING *nameW, char **name_ret, UINT disposition ) DECLSPEC_HIDDEN;
-extern NTSTATUS unix_to_nt_file_name( const char *name, WCHAR **nt ) DECLSPEC_HIDDEN;
-extern NTSTATUS open_unix_file( HANDLE *handle, const char *unix_name, ACCESS_MASK access,
-                                OBJECT_ATTRIBUTES *attr, ULONG attributes, ULONG sharing, ULONG disposition,
-                                ULONG options, void *ea_buffer, ULONG ea_length ) DECLSPEC_HIDDEN;
-extern void init_files(void) DECLSPEC_HIDDEN;
-extern void init_cpu_info(void) DECLSPEC_HIDDEN;
-
-extern void dbg_init(void) DECLSPEC_HIDDEN;
-
-extern void WINAPI call_user_apc( CONTEXT *context_ptr, ULONG_PTR ctx, ULONG_PTR arg1,
-                                  ULONG_PTR arg2, PNTAPCFUNC func ) DECLSPEC_HIDDEN;
-extern void WINAPI DECLSPEC_NORETURN call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context,
-                                                                     NTSTATUS (WINAPI *dispatcher)(EXCEPTION_RECORD*,CONTEXT*) ) DECLSPEC_HIDDEN;
-extern void WINAPI DECLSPEC_NORETURN call_raise_user_exception_dispatcher( NTSTATUS (WINAPI *dispatcher)(void) ) DECLSPEC_HIDDEN;
-
-#define TICKSPERSEC 10000000
-#define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)86400)
-#define TICKS_1601_TO_1970 (SECS_1601_TO_1970 * TICKSPERSEC)
-
-static inline const char *debugstr_us( const UNICODE_STRING *us )
-{
-    if (!us) return "<null>";
-    return debugstr_wn( us->Buffer, us->Length / sizeof(WCHAR) );
-}
-
-/* convert from straight ASCII to Unicode without depending on the current codepage */
-static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
-{
-    while (len--) *dst++ = (unsigned char)*src++;
-}
-
-static inline IMAGE_NT_HEADERS *get_exe_nt_header(void)
-{
-    IMAGE_DOS_HEADER *module = (IMAGE_DOS_HEADER *)NtCurrentTeb()->Peb->ImageBaseAddress;
-    return (IMAGE_NT_HEADERS *)((char *)module + module->e_lfanew);
-}
-
-static inline void *get_signal_stack(void)
-{
-    return (char *)NtCurrentTeb() + teb_size - teb_offset;
-}
-
-#ifndef _WIN64
-static inline TEB64 *NtCurrentTeb64(void) { return (TEB64 *)NtCurrentTeb()->GdiBatchCount; }
-#endif
-
-static inline size_t ntdll_wcslen( const WCHAR *str )
-{
-    const WCHAR *s = str;
-    while (*s) s++;
-    return s - str;
-}
-
-static inline WCHAR *ntdll_wcscpy( WCHAR *dst, const WCHAR *src )
-{
-    WCHAR *p = dst;
-    while ((*p++ = *src++));
-    return dst;
-}
-
-static inline WCHAR *ntdll_wcscat( WCHAR *dst, const WCHAR *src )
-{
-    ntdll_wcscpy( dst + ntdll_wcslen(dst), src );
-    return dst;
-}
-
-static inline int ntdll_wcscmp( const WCHAR *str1, const WCHAR *str2 )
-{
-    while (*str1 && (*str1 == *str2)) { str1++; str2++; }
-    return *str1 - *str2;
-}
-
-static inline int ntdll_wcsncmp( const WCHAR *str1, const WCHAR *str2, int n )
-{
-    if (n <= 0) return 0;
-    while ((--n > 0) && *str1 && (*str1 == *str2)) { str1++; str2++; }
-    return *str1 - *str2;
-}
-
-static inline WCHAR *ntdll_wcschr( const WCHAR *str, WCHAR ch )
-{
-    do { if (*str == ch) return (WCHAR *)(ULONG_PTR)str; } while (*str++);
-    return NULL;
-}
-
-static inline WCHAR *ntdll_wcsrchr( const WCHAR *str, WCHAR ch )
-{
-    WCHAR *ret = NULL;
-    do { if (*str == ch) ret = (WCHAR *)(ULONG_PTR)str; } while (*str++);
-    return ret;
-}
-
-static inline WCHAR *ntdll_wcspbrk( const WCHAR *str, const WCHAR *accept )
-{
-    for ( ; *str; str++) if (ntdll_wcschr( accept, *str )) return (WCHAR *)(ULONG_PTR)str;
-    return NULL;
-}
-
-static inline WCHAR ntdll_towupper( WCHAR ch )
-{
-    return ch + uctable[uctable[uctable[ch >> 8] + ((ch >> 4) & 0x0f)] + (ch & 0x0f)];
-}
-
-static inline WCHAR ntdll_towlower( WCHAR ch )
-{
-    return ch + lctable[lctable[lctable[ch >> 8] + ((ch >> 4) & 0x0f)] + (ch & 0x0f)];
-}
-
-static inline WCHAR *ntdll_wcsupr( WCHAR *str )
-{
-    WCHAR *ret;
-    for (ret = str; *str; str++) *str = ntdll_towupper(*str);
-    return ret;
-}
-
-static inline int ntdll_wcsicmp( const WCHAR *str1, const WCHAR *str2 )
-{
-    int ret;
-    for (;;)
-    {
-        if ((ret = ntdll_towupper( *str1 ) - ntdll_towupper( *str2 )) || !*str1) return ret;
-        str1++;
-        str2++;
-    }
-}
-
-static inline int ntdll_wcsnicmp( const WCHAR *str1, const WCHAR *str2, int n )
-{
-    int ret;
-    for (ret = 0; n > 0; n--, str1++, str2++)
-        if ((ret = ntdll_towupper(*str1) - ntdll_towupper(*str2)) || !*str1) break;
-    return ret;
-}
 
-#define wcslen(str)        ntdll_wcslen(str)
-#define wcscpy(dst,src)    ntdll_wcscpy(dst,src)
-#define wcscat(dst,src)    ntdll_wcscat(dst,src)
-#define wcscmp(s1,s2)      ntdll_wcscmp(s1,s2)
-#define wcsncmp(s1,s2,n)   ntdll_wcsncmp(s1,s2,n)
-#define wcschr(str,ch)     ntdll_wcschr(str,ch)
-#define wcsrchr(str,ch)    ntdll_wcsrchr(str,ch)
-#define wcspbrk(str,ac)    ntdll_wcspbrk(str,ac)
-#define wcsicmp(s1, s2)    ntdll_wcsicmp(s1,s2)
-#define wcsnicmp(s1, s2,n) ntdll_wcsnicmp(s1,s2,n)
-#define wcsupr(str)        ntdll_wcsupr(str)
-#define towupper(c)        ntdll_towupper(c)
-#define towlower(c)        ntdll_towlower(c)
+extern void CDECL dbg_init(void) DECLSPEC_HIDDEN;
 
 #endif /* __NTDLL_UNIX_PRIVATE_H */
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index a2fea58883..8fa43a40e6 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -1,7 +1,7 @@
 /*
- * Win32 virtual memory functions
+ * Unix interface for virtual memory functions
  *
- * Copyright 1997, 2002, 2020 Alexandre Julliard
+ * Copyright (C) 2020 Alexandre Julliard
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -26,48 +26,26 @@
 #include "wine/port.h"
 
 #include <assert.h>
-#include <errno.h>
 #include <stdarg.h>
-#include <stdio.h>
-#include <signal.h>
-#include <sys/types.h>
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
 #ifdef HAVE_SYS_MMAN_H
 # include <sys/mman.h>
 #endif
-#ifdef HAVE_SYS_SYSINFO_H
-# include <sys/sysinfo.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#ifdef HAVE_VALGRIND_VALGRIND_H
-# include <valgrind/valgrind.h>
-#endif
 #if defined(__APPLE__)
 # include <mach/mach_init.h>
 # include <mach/mach_vm.h>
 #endif
 
+#include <stdio.h>
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
 #include "windef.h"
 #include "winnt.h"
 #include "winternl.h"
-#include "wine/library.h"
-#include "wine/exception.h"
-#include "wine/list.h"
-#include "wine/rbtree.h"
 #include "unix_private.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(virtual);
-WINE_DECLARE_DEBUG_CHANNEL(module);
+#include "wine/list.h"
 
 struct preload_info
 {
@@ -84,89 +62,9 @@ struct reserved_area
 
 static struct list reserved_areas = LIST_INIT(reserved_areas);
 
-struct file_view
-{
-    struct wine_rb_entry entry;  /* entry in global view tree */
-    void         *base;          /* base address */
-    size_t        size;          /* size in bytes */
-    unsigned int  protect;       /* protection for all pages at allocation time and SEC_* flags */
-};
-
-/* per-page protection flags */
-#define VPROT_READ       0x01
-#define VPROT_WRITE      0x02
-#define VPROT_EXEC       0x04
-#define VPROT_WRITECOPY  0x08
-#define VPROT_GUARD      0x10
-#define VPROT_COMMITTED  0x20
-#define VPROT_WRITEWATCH 0x40
-/* per-mapping protection flags */
-#define VPROT_SYSTEM     0x0200  /* system view (underlying mmap not under our control) */
-
-/* Conversion from VPROT_* to Win32 flags */
-static const BYTE VIRTUAL_Win32Flags[16] =
-{
-    PAGE_NOACCESS,              /* 0 */
-    PAGE_READONLY,              /* READ */
-    PAGE_READWRITE,             /* WRITE */
-    PAGE_READWRITE,             /* READ | WRITE */
-    PAGE_EXECUTE,               /* EXEC */
-    PAGE_EXECUTE_READ,          /* READ | EXEC */
-    PAGE_EXECUTE_READWRITE,     /* WRITE | EXEC */
-    PAGE_EXECUTE_READWRITE,     /* READ | WRITE | EXEC */
-    PAGE_WRITECOPY,             /* WRITECOPY */
-    PAGE_WRITECOPY,             /* READ | WRITECOPY */
-    PAGE_WRITECOPY,             /* WRITE | WRITECOPY */
-    PAGE_WRITECOPY,             /* READ | WRITE | WRITECOPY */
-    PAGE_EXECUTE_WRITECOPY,     /* EXEC | WRITECOPY */
-    PAGE_EXECUTE_WRITECOPY,     /* READ | EXEC | WRITECOPY */
-    PAGE_EXECUTE_WRITECOPY,     /* WRITE | EXEC | WRITECOPY */
-    PAGE_EXECUTE_WRITECOPY      /* READ | WRITE | EXEC | WRITECOPY */
-};
-
-static struct wine_rb_tree views_tree;
-static pthread_mutex_t virtual_mutex;
-
-static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
-static const UINT page_shift = 12;
-static const UINT_PTR page_mask = 0xfff;
-static const UINT_PTR granularity_mask = 0xffff;
-
-/* Note: these are Windows limits, you cannot change them. */
-#ifdef __i386__
-static void *address_space_start = (void *)0x110000; /* keep DOS area clear */
-#else
-static void *address_space_start = (void *)0x10000;
-#endif
-
-#ifdef __aarch64__
-static void *address_space_limit = (void *)0xffffffff0000;  /* top of the total available address space */
-#elif defined(_WIN64)
-static void *address_space_limit = (void *)0x7fffffff0000;
-#else
-static void *address_space_limit = (void *)0xc0000000;
-#endif
-
-#ifdef _WIN64
-static void *user_space_limit    = (void *)0x7fffffff0000;  /* top of the user address space */
-static void *working_set_limit   = (void *)0x7fffffff0000;  /* top of the current working set */
-#else
-static void *user_space_limit    = (void *)0x7fff0000;
-static void *working_set_limit   = (void *)0x7fff0000;
-#endif
-
-struct _KUSER_SHARED_DATA *user_shared_data = (void *)0x7ffe0000;
-
-/* TEB allocation blocks */
-static void *teb_block;
-static void **next_free_teb;
-static int teb_block_pos;
-static struct list teb_list = LIST_INIT( teb_list );
-
-#define ROUND_ADDR(addr,mask) ((void *)((UINT_PTR)(addr) & ~(UINT_PTR)(mask)))
-#define ROUND_SIZE(addr,size) (((SIZE_T)(size) + ((UINT_PTR)(addr) & page_mask) + page_mask) & ~page_mask)
+static const unsigned int granularity_mask = 0xffff;  /* reserved areas have 64k granularity */
 
-#define VIRTUAL_DEBUG_DUMP_VIEW(view) do { if (TRACE_ON(virtual)) dump_view(view); } while (0)
+extern IMAGE_NT_HEADERS __wine_spec_nt_header;
 
 #ifndef MAP_NORESERVE
 #define MAP_NORESERVE 0
@@ -174,40 +72,6 @@ static struct list teb_list = LIST_INIT( teb_list );
 #ifndef MAP_TRYFIXED
 #define MAP_TRYFIXED 0
 #endif
-#ifndef MAP_FIXED_NOREPLACE
-#define MAP_FIXED_NOREPLACE 0
-#endif
-
-#ifdef _WIN64  /* on 64-bit the page protection bytes use a 2-level table */
-static const size_t pages_vprot_shift = 20;
-static const size_t pages_vprot_mask = (1 << 20) - 1;
-static size_t pages_vprot_size;
-static BYTE **pages_vprot;
-#else  /* on 32-bit we use a simple array with one byte per page */
-static BYTE *pages_vprot;
-#endif
-
-static struct file_view *view_block_start, *view_block_end, *next_free_view;
-static const size_t view_block_size = 0x100000;
-static void *preload_reserve_start;
-static void *preload_reserve_end;
-static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
-
-struct range_entry
-{
-    void *base;
-    void *end;
-};
-
-static struct range_entry *free_ranges;
-static struct range_entry *free_ranges_end;
-
-
-static inline BOOL is_inside_signal_stack( void *ptr )
-{
-    return ((char *)ptr >= (char *)get_signal_stack() &&
-            (char *)ptr < (char *)get_signal_stack() + signal_stack_size);
-}
 
 
 static void reserve_area( void *addr, void *end )
@@ -295,7 +159,7 @@ static void reserve_area( void *addr, void *end )
 
 static void mmap_init( const struct preload_info *preload_info )
 {
-#ifndef _WIN64
+#ifdef __i386__
 #ifndef __APPLE__
     char stack;
     char * const stack_ptr = &stack;
@@ -338,7 +202,7 @@ static void mmap_init( const struct preload_info *preload_info )
 #endif
         reserve_area( user_space_limit, 0 );
 
-#else
+#elif defined(__x86_64__) || defined(__aarch64__)
 
     if (preload_info) return;
     /* if we don't have a preloader, try to reserve the space now */
@@ -500,4014 +364,14 @@ int CDECL mmap_enum_reserved_areas( int (CDECL *enum_func)(void *base, SIZE_T si
     return ret;
 }
 
-
-/***********************************************************************
- *           free_ranges_lower_bound
- *
- * Returns the first range whose end is not less than addr, or end if there's none.
- */
-static struct range_entry *free_ranges_lower_bound( void *addr )
-{
-    struct range_entry *begin = free_ranges;
-    struct range_entry *end = free_ranges_end;
-    struct range_entry *mid;
-
-    while (begin < end)
-    {
-        mid = begin + (end - begin) / 2;
-        if (mid->end < addr)
-            begin = mid + 1;
-        else
-            end = mid;
-    }
-
-    return begin;
-}
-
-
-/***********************************************************************
- *           free_ranges_insert_view
- *
- * Updates the free_ranges after a new view has been created.
- */
-static void free_ranges_insert_view( struct file_view *view )
-{
-    void *view_base = ROUND_ADDR( view->base, granularity_mask );
-    void *view_end = ROUND_ADDR( (char *)view->base + view->size + granularity_mask, granularity_mask );
-    struct range_entry *range = free_ranges_lower_bound( view_base );
-    struct range_entry *next = range + 1;
-
-    /* free_ranges initial value is such that the view is either inside range or before another one. */
-    assert( range != free_ranges_end );
-    assert( range->end > view_base || next != free_ranges_end );
-
-    /* this happens because virtual_alloc_thread_stack shrinks a view, then creates another one on top,
-     * or because AT_ROUND_TO_PAGE was used with NtMapViewOfSection to force 4kB aligned mapping. */
-    if ((range->end > view_base && range->base >= view_end) ||
-        (range->end == view_base && next->base >= view_end))
-    {
-        /* on Win64, assert that it's correctly aligned so we're not going to be in trouble later */
-        assert( (!is_win64 && !is_wow64) || view->base == view_base );
-        WARN( "range %p - %p is already mapped\n", view_base, view_end );
-        return;
-    }
-
-    /* this should never happen */
-    if (range->base > view_base || range->end < view_end)
-        ERR( "range %p - %p is already partially mapped\n", view_base, view_end );
-    assert( range->base <= view_base && range->end >= view_end );
-
-    /* need to split the range in two */
-    if (range->base < view_base && range->end > view_end)
-    {
-        memmove( next + 1, next, (free_ranges_end - next) * sizeof(struct range_entry) );
-        free_ranges_end += 1;
-        if ((char *)free_ranges_end - (char *)free_ranges > view_block_size)
-            ERR( "Free range sequence is full, trouble ahead!\n" );
-        assert( (char *)free_ranges_end - (char *)free_ranges <= view_block_size );
-
-        next->base = view_end;
-        next->end = range->end;
-        range->end = view_base;
-    }
-    else
-    {
-        /* otherwise we just have to shrink it */
-        if (range->base < view_base)
-            range->end = view_base;
-        else
-            range->base = view_end;
-
-        if (range->base < range->end) return;
-
-        /* and possibly remove it if it's now empty */
-        memmove( range, next, (free_ranges_end - next) * sizeof(struct range_entry) );
-        free_ranges_end -= 1;
-        assert( free_ranges_end - free_ranges > 0 );
-    }
-}
-
-
-/***********************************************************************
- *           free_ranges_remove_view
- *
- * Updates the free_ranges after a view has been destroyed.
- */
-static void free_ranges_remove_view( struct file_view *view )
-{
-    void *view_base = ROUND_ADDR( view->base, granularity_mask );
-    void *view_end = ROUND_ADDR( (char *)view->base + view->size + granularity_mask, granularity_mask );
-    struct range_entry *range = free_ranges_lower_bound( view_base );
-    struct range_entry *next = range + 1;
-
-    /* It's possible to use AT_ROUND_TO_PAGE on 32bit with NtMapViewOfSection to force 4kB alignment,
-     * and this breaks our assumptions. Look at the views around to check if the range is still in use. */
-#ifndef _WIN64
-    struct file_view *prev_view = WINE_RB_ENTRY_VALUE( wine_rb_prev( &view->entry ), struct file_view, entry );
-    struct file_view *next_view = WINE_RB_ENTRY_VALUE( wine_rb_next( &view->entry ), struct file_view, entry );
-    void *prev_view_base = prev_view ? ROUND_ADDR( prev_view->base, granularity_mask ) : NULL;
-    void *prev_view_end = prev_view ? ROUND_ADDR( (char *)prev_view->base + prev_view->size + granularity_mask, granularity_mask ) : NULL;
-    void *next_view_base = next_view ? ROUND_ADDR( next_view->base, granularity_mask ) : NULL;
-    void *next_view_end = next_view ? ROUND_ADDR( (char *)next_view->base + next_view->size + granularity_mask, granularity_mask ) : NULL;
-
-    if ((prev_view_base < view_end && prev_view_end > view_base) ||
-        (next_view_base < view_end && next_view_end > view_base))
-    {
-        WARN( "range %p - %p is still mapped\n", view_base, view_end );
-        return;
-    }
-#endif
-
-    /* free_ranges initial value is such that the view is either inside range or before another one. */
-    assert( range != free_ranges_end );
-    assert( range->end > view_base || next != free_ranges_end );
-
-    /* this should never happen, but we can safely ignore it */
-    if (range->base <= view_base && range->end >= view_end)
-    {
-        WARN( "range %p - %p is already unmapped\n", view_base, view_end );
-        return;
-    }
-
-    /* this should never happen */
-    if (range->base < view_end && range->end > view_base)
-        ERR( "range %p - %p is already partially unmapped\n", view_base, view_end );
-    assert( range->end <= view_base || range->base >= view_end );
-
-    /* merge with next if possible */
-    if (range->end == view_base && next->base == view_end)
-    {
-        range->end = next->end;
-        memmove( next, next + 1, (free_ranges_end - next - 1) * sizeof(struct range_entry) );
-        free_ranges_end -= 1;
-        assert( free_ranges_end - free_ranges > 0 );
-    }
-    /* or try growing the range */
-    else if (range->end == view_base)
-        range->end = view_end;
-    else if (range->base == view_end)
-        range->base = view_base;
-    /* otherwise create a new one */
-    else
-    {
-        memmove( range + 1, range, (free_ranges_end - range) * sizeof(struct range_entry) );
-        free_ranges_end += 1;
-        if ((char *)free_ranges_end - (char *)free_ranges > view_block_size)
-            ERR( "Free range sequence is full, trouble ahead!\n" );
-        assert( (char *)free_ranges_end - (char *)free_ranges <= view_block_size );
-
-        range->base = view_base;
-        range->end = view_end;
-    }
-}
-
-
-static inline int is_view_valloc( const struct file_view *view )
-{
-    return !(view->protect & (SEC_FILE | SEC_RESERVE | SEC_COMMIT));
-}
-
-/***********************************************************************
- *           get_page_vprot
- *
- * Return the page protection byte.
- */
-static BYTE get_page_vprot( const void *addr )
-{
-    size_t idx = (size_t)addr >> page_shift;
-
-#ifdef _WIN64
-    if ((idx >> pages_vprot_shift) >= pages_vprot_size) return 0;
-    if (!pages_vprot[idx >> pages_vprot_shift]) return 0;
-    return pages_vprot[idx >> pages_vprot_shift][idx & pages_vprot_mask];
-#else
-    return pages_vprot[idx];
-#endif
-}
-
-
-/***********************************************************************
- *           set_page_vprot
- *
- * Set a range of page protection bytes.
- */
-static void set_page_vprot( const void *addr, size_t size, BYTE vprot )
-{
-    size_t idx = (size_t)addr >> page_shift;
-    size_t end = ((size_t)addr + size + page_mask) >> page_shift;
-
-#ifdef _WIN64
-    while (idx >> pages_vprot_shift != end >> pages_vprot_shift)
-    {
-        size_t dir_size = pages_vprot_mask + 1 - (idx & pages_vprot_mask);
-        memset( pages_vprot[idx >> pages_vprot_shift] + (idx & pages_vprot_mask), vprot, dir_size );
-        idx += dir_size;
-    }
-    memset( pages_vprot[idx >> pages_vprot_shift] + (idx & pages_vprot_mask), vprot, end - idx );
-#else
-    memset( pages_vprot + idx, vprot, end - idx );
-#endif
-}
-
-
-/***********************************************************************
- *           set_page_vprot_bits
- *
- * Set or clear bits in a range of page protection bytes.
- */
-static void set_page_vprot_bits( const void *addr, size_t size, BYTE set, BYTE clear )
-{
-    size_t idx = (size_t)addr >> page_shift;
-    size_t end = ((size_t)addr + size + page_mask) >> page_shift;
-
-#ifdef _WIN64
-    for ( ; idx < end; idx++)
-    {
-        BYTE *ptr = pages_vprot[idx >> pages_vprot_shift] + (idx & pages_vprot_mask);
-        *ptr = (*ptr & ~clear) | set;
-    }
-#else
-    for ( ; idx < end; idx++) pages_vprot[idx] = (pages_vprot[idx] & ~clear) | set;
-#endif
-}
-
-
-/***********************************************************************
- *           alloc_pages_vprot
- *
- * Allocate the page protection bytes for a given range.
- */
-static BOOL alloc_pages_vprot( const void *addr, size_t size )
-{
-#ifdef _WIN64
-    size_t idx = (size_t)addr >> page_shift;
-    size_t end = ((size_t)addr + size + page_mask) >> page_shift;
-    size_t i;
-    void *ptr;
-
-    assert( end <= pages_vprot_size << pages_vprot_shift );
-    for (i = idx >> pages_vprot_shift; i < (end + pages_vprot_mask) >> pages_vprot_shift; i++)
-    {
-        if (pages_vprot[i]) continue;
-        if ((ptr = wine_anon_mmap( NULL, pages_vprot_mask + 1, PROT_READ | PROT_WRITE, 0 )) == (void *)-1)
-            return FALSE;
-        pages_vprot[i] = ptr;
-    }
-#endif
-    return TRUE;
-}
-
-
-/***********************************************************************
- *           compare_view
- *
- * View comparison function used for the rb tree.
- */
-static int compare_view( const void *addr, const struct wine_rb_entry *entry )
-{
-    struct file_view *view = WINE_RB_ENTRY_VALUE( entry, struct file_view, entry );
-
-    if (addr < view->base) return -1;
-    if (addr > view->base) return 1;
-    return 0;
-}
-
-
-/***********************************************************************
- *           get_prot_str
- */
-static const char *get_prot_str( BYTE prot )
-{
-    static char buffer[6];
-    buffer[0] = (prot & VPROT_COMMITTED) ? 'c' : '-';
-    buffer[1] = (prot & VPROT_GUARD) ? 'g' : ((prot & VPROT_WRITEWATCH) ? 'H' : '-');
-    buffer[2] = (prot & VPROT_READ) ? 'r' : '-';
-    buffer[3] = (prot & VPROT_WRITECOPY) ? 'W' : ((prot & VPROT_WRITE) ? 'w' : '-');
-    buffer[4] = (prot & VPROT_EXEC) ? 'x' : '-';
-    buffer[5] = 0;
-    return buffer;
-}
-
-
-/***********************************************************************
- *           get_unix_prot
- *
- * Convert page protections to protection for mmap/mprotect.
- */
-static int get_unix_prot( BYTE vprot )
-{
-    int prot = 0;
-    if ((vprot & VPROT_COMMITTED) && !(vprot & VPROT_GUARD))
-    {
-        if (vprot & VPROT_READ) prot |= PROT_READ;
-        if (vprot & VPROT_WRITE) prot |= PROT_WRITE | PROT_READ;
-        if (vprot & VPROT_WRITECOPY) prot |= PROT_WRITE | PROT_READ;
-        if (vprot & VPROT_EXEC) prot |= PROT_EXEC | PROT_READ;
-        if (vprot & VPROT_WRITEWATCH) prot &= ~PROT_WRITE;
-    }
-    if (!prot) prot = PROT_NONE;
-    return prot;
-}
-
-
-/***********************************************************************
- *           dump_view
- */
-static void dump_view( struct file_view *view )
-{
-    UINT i, count;
-    char *addr = view->base;
-    BYTE prot = get_page_vprot( addr );
-
-    TRACE( "View: %p - %p", addr, addr + view->size - 1 );
-    if (view->protect & VPROT_SYSTEM)
-        TRACE( " (builtin image)\n" );
-    else if (view->protect & SEC_IMAGE)
-        TRACE( " (image)\n" );
-    else if (view->protect & SEC_FILE)
-        TRACE( " (file)\n" );
-    else if (view->protect & (SEC_RESERVE | SEC_COMMIT))
-        TRACE( " (anonymous)\n" );
-    else
-        TRACE( " (valloc)\n");
-
-    for (count = i = 1; i < view->size >> page_shift; i++, count++)
-    {
-        BYTE next = get_page_vprot( addr + (count << page_shift) );
-        if (next == prot) continue;
-        TRACE( "      %p - %p %s\n",
-                 addr, addr + (count << page_shift) - 1, get_prot_str(prot) );
-        addr += (count << page_shift);
-        prot = next;
-        count = 0;
-    }
-    if (count)
-        TRACE( "      %p - %p %s\n",
-                 addr, addr + (count << page_shift) - 1, get_prot_str(prot) );
-}
-
-
-/***********************************************************************
- *           VIRTUAL_Dump
- */
-#ifdef WINE_VM_DEBUG
-static void VIRTUAL_Dump(void)
-{
-    sigset_t sigset;
-    struct file_view *view;
-
-    TRACE( "Dump of all virtual memory views:\n" );
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    WINE_RB_FOR_EACH_ENTRY( view, &views_tree, struct file_view, entry )
-    {
-        dump_view( view );
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-}
-#endif
-
-
-/***********************************************************************
- *           find_view
- *
- * Find the view containing a given address. virtual_mutex must be held by caller.
- *
- * PARAMS
- *      addr  [I] Address
- *
- * RETURNS
- *	View: Success
- *	NULL: Failure
- */
-static struct file_view *find_view( const void *addr, size_t size )
-{
-    struct wine_rb_entry *ptr = views_tree.root;
-
-    if ((const char *)addr + size < (const char *)addr) return NULL; /* overflow */
-
-    while (ptr)
-    {
-        struct file_view *view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
-
-        if (view->base > addr) ptr = ptr->left;
-        else if ((const char *)view->base + view->size <= (const char *)addr) ptr = ptr->right;
-        else if ((const char *)view->base + view->size < (const char *)addr + size) break;  /* size too large */
-        else return view;
-    }
-    return NULL;
-}
-
-
-/***********************************************************************
- *           zero_bits_win_to_64
- *
- * Convert from Windows hybrid 32bit-based / bitmask to 64bit-based format
- */
-static inline unsigned short zero_bits_win_to_64( ULONG_PTR zero_bits )
-{
-    unsigned short zero_bits_64;
-
-    if (zero_bits == 0) return 0;
-    if (zero_bits < 32) return 32 + zero_bits;
-    zero_bits_64 = 63;
-#ifdef _WIN64
-    if (zero_bits >> 32) { zero_bits_64 -= 32; zero_bits >>= 32; }
-#endif
-    if (zero_bits >> 16) { zero_bits_64 -= 16; zero_bits >>= 16; }
-    if (zero_bits >> 8) { zero_bits_64 -= 8; zero_bits >>= 8; }
-    if (zero_bits >> 4) { zero_bits_64 -= 4; zero_bits >>= 4; }
-    if (zero_bits >> 2) { zero_bits_64 -= 2; zero_bits >>= 2; }
-    if (zero_bits >> 1) { zero_bits_64 -= 1; }
-    return zero_bits_64;
-}
-
-
-/***********************************************************************
- *           get_zero_bits_64_mask
- */
-static inline UINT_PTR get_zero_bits_64_mask( USHORT zero_bits_64 )
-{
-    return (UINT_PTR)((~(UINT64)0) >> zero_bits_64);
-}
-
-
-/***********************************************************************
- *           is_write_watch_range
- */
-static inline BOOL is_write_watch_range( const void *addr, size_t size )
-{
-    struct file_view *view = find_view( addr, size );
-    return view && (view->protect & VPROT_WRITEWATCH);
-}
-
-
-/***********************************************************************
- *           find_view_range
- *
- * Find the first view overlapping at least part of the specified range.
- * virtual_mutex must be held by caller.
- */
-static struct file_view *find_view_range( const void *addr, size_t size )
-{
-    struct wine_rb_entry *ptr = views_tree.root;
-
-    while (ptr)
-    {
-        struct file_view *view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
-
-        if ((const char *)view->base >= (const char *)addr + size) ptr = ptr->left;
-        else if ((const char *)view->base + view->size <= (const char *)addr) ptr = ptr->right;
-        else return view;
-    }
-    return NULL;
-}
-
-
-/***********************************************************************
- *           find_view_inside_range
- *
- * Find first (resp. last, if top_down) view inside a range.
- * virtual_mutex must be held by caller.
- */
-static struct wine_rb_entry *find_view_inside_range( void **base_ptr, void **end_ptr, int top_down )
+void virtual_init(void)
 {
-    struct wine_rb_entry *first = NULL, *ptr = views_tree.root;
-    void *base = *base_ptr, *end = *end_ptr;
-
-    /* find the first (resp. last) view inside the range */
-    while (ptr)
-    {
-        struct file_view *view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
-        if ((char *)view->base + view->size >= (char *)end)
-        {
-            end = min( end, view->base );
-            ptr = ptr->left;
-        }
-        else if (view->base <= base)
-        {
-            base = max( (char *)base, (char *)view->base + view->size );
-            ptr = ptr->right;
-        }
-        else
-        {
-            first = ptr;
-            ptr = top_down ? ptr->right : ptr->left;
-        }
-    }
-
-    *base_ptr = base;
-    *end_ptr = end;
-    return first;
-}
-
+    const struct preload_info **preload_info = dlsym( RTLD_DEFAULT, "wine_main_preload_info" );
+    int i;
 
-/***********************************************************************
- *           try_map_free_area
- *
- * Try mmaping some expected free memory region, eventually stepping and
- * retrying inside it, and return where it actually succeeded, or NULL.
- */
-static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
-                                void *start, size_t size, int unix_prot )
-{
-    void *ptr;
+    if (preload_info && *preload_info)
+        for (i = 0; (*preload_info)[i].size; i++)
+            mmap_add_reserved_area( (*preload_info)[i].addr, (*preload_info)[i].size );
 
-    while (start && base <= start && (char*)start + size <= (char*)end)
-    {
-        if ((ptr = wine_anon_mmap( start, size, unix_prot, MAP_FIXED_NOREPLACE )) == start)
-            return start;
-        TRACE( "Found free area is already mapped, start %p.\n", start );
-
-        if (ptr == (void *)-1 && errno != EEXIST)
-        {
-            ERR( "wine_anon_mmap() error %s, range %p-%p, unix_prot %#x.\n",
-                    strerror(errno), start, (char *)start + size, unix_prot );
-            return NULL;
-        }
-
-        if (ptr != (void *)-1)
-            munmap( ptr, size );
-
-        if ((step > 0 && (char *)end - (char *)start < step) ||
-            (step < 0 && (char *)start - (char *)base < -step) ||
-            step == 0)
-            break;
-        start = (char *)start + step;
-    }
-
-    return NULL;
-}
-
-
-/***********************************************************************
- *           map_free_area
- *
- * Find a free area between views inside the specified range and map it.
- * virtual_mutex must be held by caller.
- */
-static void *map_free_area( void *base, void *end, size_t size, int top_down, int unix_prot )
-{
-    struct wine_rb_entry *first = find_view_inside_range( &base, &end, top_down );
-    ptrdiff_t step = top_down ? -(granularity_mask + 1) : (granularity_mask + 1);
-    void *start;
-
-    if (top_down)
-    {
-        start = ROUND_ADDR( (char *)end - size, granularity_mask );
-        if (start >= end || start < base) return NULL;
-
-        while (first)
-        {
-            struct file_view *view = WINE_RB_ENTRY_VALUE( first, struct file_view, entry );
-            if ((start = try_map_free_area( (char *)view->base + view->size, (char *)start + size, step,
-                                            start, size, unix_prot ))) break;
-            start = ROUND_ADDR( (char *)view->base - size, granularity_mask );
-            /* stop if remaining space is not large enough */
-            if (!start || start >= end || start < base) return NULL;
-            first = wine_rb_prev( first );
-        }
-    }
-    else
-    {
-        start = ROUND_ADDR( (char *)base + granularity_mask, granularity_mask );
-        if (!start || start >= end || (char *)end - (char *)start < size) return NULL;
-
-        while (first)
-        {
-            struct file_view *view = WINE_RB_ENTRY_VALUE( first, struct file_view, entry );
-            if ((start = try_map_free_area( start, view->base, step,
-                                            start, size, unix_prot ))) break;
-            start = ROUND_ADDR( (char *)view->base + view->size + granularity_mask, granularity_mask );
-            /* stop if remaining space is not large enough */
-            if (!start || start >= end || (char *)end - (char *)start < size) return NULL;
-            first = wine_rb_next( first );
-        }
-    }
-
-    if (!first)
-        return try_map_free_area( base, end, step, start, size, unix_prot );
-
-    return start;
-}
-
-
-/***********************************************************************
- *           find_reserved_free_area
- *
- * Find a free area between views inside the specified range.
- * virtual_mutex must be held by caller.
- * The range must be inside the preloader reserved range.
- */
-static void *find_reserved_free_area( void *base, void *end, size_t size, int top_down )
-{
-    struct range_entry *range;
-    void *start;
-
-    base = ROUND_ADDR( (char *)base + granularity_mask, granularity_mask );
-    end = (char *)ROUND_ADDR( (char *)end - size, granularity_mask ) + size;
-
-    if (top_down)
-    {
-        start = (char *)end - size;
-        range = free_ranges_lower_bound( start );
-        assert(range != free_ranges_end && range->end >= start);
-
-        if ((char *)range->end - (char *)start < size) start = ROUND_ADDR( (char *)range->end - size, granularity_mask );
-        do
-        {
-            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
-            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
-            if (--range < free_ranges) return NULL;
-            start = ROUND_ADDR( (char *)range->end - size, granularity_mask );
-        }
-        while (1);
-    }
-    else
-    {
-        start = base;
-        range = free_ranges_lower_bound( start );
-        assert(range != free_ranges_end && range->end >= start);
-
-        if (start < range->base) start = ROUND_ADDR( (char *)range->base + granularity_mask, granularity_mask );
-        do
-        {
-            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
-            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
-            if (++range == free_ranges_end) return NULL;
-            start = ROUND_ADDR( (char *)range->base + granularity_mask, granularity_mask );
-        }
-        while (1);
-    }
-    return start;
-}
-
-
-/***********************************************************************
- *           add_reserved_area
- *
- * Add a reserved area to the list maintained by libwine.
- * virtual_mutex must be held by caller.
- */
-static void add_reserved_area( void *addr, size_t size )
-{
-    TRACE( "adding %p-%p\n", addr, (char *)addr + size );
-
-    if (addr < user_space_limit)
-    {
-        /* unmap the part of the area that is below the limit */
-        assert( (char *)addr + size > (char *)user_space_limit );
-        munmap( addr, (char *)user_space_limit - (char *)addr );
-        size -= (char *)user_space_limit - (char *)addr;
-        addr = user_space_limit;
-    }
-    /* blow away existing mappings */
-    wine_anon_mmap( addr, size, PROT_NONE, MAP_NORESERVE | MAP_FIXED );
-    mmap_add_reserved_area( addr, size );
-}
-
-
-/***********************************************************************
- *           remove_reserved_area
- *
- * Remove a reserved area from the list maintained by libwine.
- * virtual_mutex must be held by caller.
- */
-static void remove_reserved_area( void *addr, size_t size )
-{
-    struct file_view *view;
-
-    TRACE( "removing %p-%p\n", addr, (char *)addr + size );
-    mmap_remove_reserved_area( addr, size );
-
-    /* unmap areas not covered by an existing view */
-    WINE_RB_FOR_EACH_ENTRY( view, &views_tree, struct file_view, entry )
-    {
-        if ((char *)view->base >= (char *)addr + size) break;
-        if ((char *)view->base + view->size <= (char *)addr) continue;
-        if (view->base > addr) munmap( addr, (char *)view->base - (char *)addr );
-        if ((char *)view->base + view->size > (char *)addr + size) return;
-        size = (char *)addr + size - ((char *)view->base + view->size);
-        addr = (char *)view->base + view->size;
-    }
-    munmap( addr, size );
-}
-
-
-struct area_boundary
-{
-    void  *base;
-    size_t size;
-    void  *boundary;
-};
-
-/***********************************************************************
- *           get_area_boundary_callback
- *
- * Get lowest boundary address between reserved area and non-reserved area
- * in the specified region. If no boundaries are found, result is NULL.
- * virtual_mutex must be held by caller.
- */
-static int CDECL get_area_boundary_callback( void *start, SIZE_T size, void *arg )
-{
-    struct area_boundary *area = arg;
-    void *end = (char *)start + size;
-
-    area->boundary = NULL;
-    if (area->base >= end) return 0;
-    if ((char *)start >= (char *)area->base + area->size) return 1;
-    if (area->base >= start)
-    {
-        if ((char *)area->base + area->size > (char *)end)
-        {
-            area->boundary = end;
-            return 1;
-        }
-        return 0;
-    }
-    area->boundary = start;
-    return 1;
-}
-
-
-/***********************************************************************
- *           is_beyond_limit
- *
- * Check if an address range goes beyond a given limit.
- */
-static inline BOOL is_beyond_limit( const void *addr, size_t size, const void *limit )
-{
-    return (addr >= limit || (const char *)addr + size > (const char *)limit);
-}
-
-
-/***********************************************************************
- *           unmap_area
- *
- * Unmap an area, or simply replace it by an empty mapping if it is
- * in a reserved area. virtual_mutex must be held by caller.
- */
-static inline void unmap_area( void *addr, size_t size )
-{
-    switch (mmap_is_in_reserved_area( addr, size ))
-    {
-    case -1: /* partially in a reserved area */
-    {
-        struct area_boundary area;
-        size_t lower_size;
-        area.base = addr;
-        area.size = size;
-        mmap_enum_reserved_areas( get_area_boundary_callback, &area, 0 );
-        assert( area.boundary );
-        lower_size = (char *)area.boundary - (char *)addr;
-        unmap_area( addr, lower_size );
-        unmap_area( area.boundary, size - lower_size );
-        break;
-    }
-    case 1:  /* in a reserved area */
-        wine_anon_mmap( addr, size, PROT_NONE, MAP_NORESERVE | MAP_FIXED );
-        break;
-    default:
-    case 0:  /* not in a reserved area */
-        if (is_beyond_limit( addr, size, user_space_limit ))
-            add_reserved_area( addr, size );
-        else
-            munmap( addr, size );
-        break;
-    }
-}
-
-
-/***********************************************************************
- *           alloc_view
- *
- * Allocate a new view. virtual_mutex must be held by caller.
- */
-static struct file_view *alloc_view(void)
-{
-    if (next_free_view)
-    {
-        struct file_view *ret = next_free_view;
-        next_free_view = *(struct file_view **)ret;
-        return ret;
-    }
-    if (view_block_start == view_block_end)
-    {
-        void *ptr = wine_anon_mmap( NULL, view_block_size, PROT_READ | PROT_WRITE, 0 );
-        if (ptr == (void *)-1) return NULL;
-        view_block_start = ptr;
-        view_block_end = view_block_start + view_block_size / sizeof(*view_block_start);
-    }
-    return view_block_start++;
-}
-
-
-/***********************************************************************
- *           delete_view
- *
- * Deletes a view. virtual_mutex must be held by caller.
- */
-static void delete_view( struct file_view *view ) /* [in] View */
-{
-    if (!(view->protect & VPROT_SYSTEM)) unmap_area( view->base, view->size );
-    set_page_vprot( view->base, view->size, 0 );
-    if (mmap_is_in_reserved_area( view->base, view->size ))
-        free_ranges_remove_view( view );
-    wine_rb_remove( &views_tree, &view->entry );
-    *(struct file_view **)view = next_free_view;
-    next_free_view = view;
-}
-
-
-/***********************************************************************
- *           create_view
- *
- * Create a view. virtual_mutex must be held by caller.
- */
-static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t size, unsigned int vprot )
-{
-    struct file_view *view;
-    int unix_prot = get_unix_prot( vprot );
-
-    assert( !((UINT_PTR)base & page_mask) );
-    assert( !(size & page_mask) );
-
-    /* Check for overlapping views. This can happen if the previous view
-     * was a system view that got unmapped behind our back. In that case
-     * we recover by simply deleting it. */
-
-    while ((view = find_view_range( base, size )))
-    {
-        TRACE( "overlapping view %p-%p for %p-%p\n",
-               view->base, (char *)view->base + view->size, base, (char *)base + size );
-        assert( view->protect & VPROT_SYSTEM );
-        delete_view( view );
-    }
-
-    if (!alloc_pages_vprot( base, size )) return STATUS_NO_MEMORY;
-
-    /* Create the view structure */
-
-    if (!(view = alloc_view()))
-    {
-        FIXME( "out of memory for %p-%p\n", base, (char *)base + size );
-        return STATUS_NO_MEMORY;
-    }
-
-    view->base    = base;
-    view->size    = size;
-    view->protect = vprot;
-    set_page_vprot( base, size, vprot );
-
-    wine_rb_put( &views_tree, view->base, &view->entry );
-    if (mmap_is_in_reserved_area( view->base, view->size ))
-        free_ranges_insert_view( view );
-
-    *view_ret = view;
-
-    if (force_exec_prot && (unix_prot & PROT_READ) && !(unix_prot & PROT_EXEC))
-    {
-        TRACE( "forcing exec permission on %p-%p\n", base, (char *)base + size - 1 );
-        mprotect( base, size, unix_prot | PROT_EXEC );
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           get_win32_prot
- *
- * Convert page protections to Win32 flags.
- */
-static DWORD get_win32_prot( BYTE vprot, unsigned int map_prot )
-{
-    DWORD ret = VIRTUAL_Win32Flags[vprot & 0x0f];
-    if (vprot & VPROT_GUARD) ret |= PAGE_GUARD;
-    if (map_prot & SEC_NOCACHE) ret |= PAGE_NOCACHE;
-    return ret;
-}
-
-
-/***********************************************************************
- *           get_vprot_flags
- *
- * Build page protections from Win32 flags.
- */
-static NTSTATUS get_vprot_flags( DWORD protect, unsigned int *vprot, BOOL image )
-{
-    switch(protect & 0xff)
-    {
-    case PAGE_READONLY:
-        *vprot = VPROT_READ;
-        break;
-    case PAGE_READWRITE:
-        if (image)
-            *vprot = VPROT_READ | VPROT_WRITECOPY;
-        else
-            *vprot = VPROT_READ | VPROT_WRITE;
-        break;
-    case PAGE_WRITECOPY:
-        *vprot = VPROT_READ | VPROT_WRITECOPY;
-        break;
-    case PAGE_EXECUTE:
-        *vprot = VPROT_EXEC;
-        break;
-    case PAGE_EXECUTE_READ:
-        *vprot = VPROT_EXEC | VPROT_READ;
-        break;
-    case PAGE_EXECUTE_READWRITE:
-        if (image)
-            *vprot = VPROT_EXEC | VPROT_READ | VPROT_WRITECOPY;
-        else
-            *vprot = VPROT_EXEC | VPROT_READ | VPROT_WRITE;
-        break;
-    case PAGE_EXECUTE_WRITECOPY:
-        *vprot = VPROT_EXEC | VPROT_READ | VPROT_WRITECOPY;
-        break;
-    case PAGE_NOACCESS:
-        *vprot = 0;
-        break;
-    default:
-        return STATUS_INVALID_PAGE_PROTECTION;
-    }
-    if (protect & PAGE_GUARD) *vprot |= VPROT_GUARD;
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           mprotect_exec
- *
- * Wrapper for mprotect, adds PROT_EXEC if forced by force_exec_prot
- */
-static inline int mprotect_exec( void *base, size_t size, int unix_prot )
-{
-    if (force_exec_prot && (unix_prot & PROT_READ) && !(unix_prot & PROT_EXEC))
-    {
-        TRACE( "forcing exec permission on %p-%p\n", base, (char *)base + size - 1 );
-        if (!mprotect( base, size, unix_prot | PROT_EXEC )) return 0;
-        /* exec + write may legitimately fail, in that case fall back to write only */
-        if (!(unix_prot & PROT_WRITE)) return -1;
-    }
-
-    return mprotect( base, size, unix_prot );
-}
-
-
-/***********************************************************************
- *           mprotect_range
- *
- * Call mprotect on a page range, applying the protections from the per-page byte.
- */
-static void mprotect_range( void *base, size_t size, BYTE set, BYTE clear )
-{
-    size_t i, count;
-    char *addr = ROUND_ADDR( base, page_mask );
-    int prot, next;
-
-    size = ROUND_SIZE( base, size );
-    prot = get_unix_prot( (get_page_vprot( addr ) & ~clear ) | set );
-    for (count = i = 1; i < size >> page_shift; i++, count++)
-    {
-        next = get_unix_prot( (get_page_vprot( addr + (count << page_shift) ) & ~clear) | set );
-        if (next == prot) continue;
-        mprotect_exec( addr, count << page_shift, prot );
-        addr += count << page_shift;
-        prot = next;
-        count = 0;
-    }
-    if (count) mprotect_exec( addr, count << page_shift, prot );
-}
-
-
-/***********************************************************************
- *           set_vprot
- *
- * Change the protection of a range of pages.
- */
-static BOOL set_vprot( struct file_view *view, void *base, size_t size, BYTE vprot )
-{
-    int unix_prot = get_unix_prot(vprot);
-
-    if (view->protect & VPROT_WRITEWATCH)
-    {
-        /* each page may need different protections depending on write watch flag */
-        set_page_vprot_bits( base, size, vprot & ~VPROT_WRITEWATCH, ~vprot & ~VPROT_WRITEWATCH );
-        mprotect_range( base, size, 0, 0 );
-        return TRUE;
-    }
-
-    /* if setting stack guard pages, store the permissions first, as the guard may be
-     * triggered at any point after mprotect and change the permissions again */
-    if ((vprot & VPROT_GUARD) &&
-        (base >= NtCurrentTeb()->DeallocationStack) &&
-        (base < NtCurrentTeb()->Tib.StackBase))
-    {
-        set_page_vprot( base, size, vprot );
-        mprotect( base, size, unix_prot );
-        return TRUE;
-    }
-
-    if (mprotect_exec( base, size, unix_prot )) /* FIXME: last error */
-        return FALSE;
-
-    set_page_vprot( base, size, vprot );
-    return TRUE;
-}
-
-
-/***********************************************************************
- *           set_protection
- *
- * Set page protections on a range of pages
- */
-static NTSTATUS set_protection( struct file_view *view, void *base, SIZE_T size, ULONG protect )
-{
-    unsigned int vprot;
-    NTSTATUS status;
-
-    if ((status = get_vprot_flags( protect, &vprot, view->protect & SEC_IMAGE ))) return status;
-    if (is_view_valloc( view ))
-    {
-        if (vprot & VPROT_WRITECOPY) return STATUS_INVALID_PAGE_PROTECTION;
-    }
-    else
-    {
-        BYTE access = vprot & (VPROT_READ | VPROT_WRITE | VPROT_EXEC);
-        if ((view->protect & access) != access) return STATUS_INVALID_PAGE_PROTECTION;
-    }
-
-    if (!set_vprot( view, base, size, vprot | VPROT_COMMITTED )) return STATUS_ACCESS_DENIED;
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           update_write_watches
- */
-static void update_write_watches( void *base, size_t size, size_t accessed_size )
-{
-    TRACE( "updating watch %p-%p-%p\n", base, (char *)base + accessed_size, (char *)base + size );
-    /* clear write watch flag on accessed pages */
-    set_page_vprot_bits( base, accessed_size, 0, VPROT_WRITEWATCH );
-    /* restore page protections on the entire range */
-    mprotect_range( base, size, 0, 0 );
-}
-
-
-/***********************************************************************
- *           reset_write_watches
- *
- * Reset write watches in a memory range.
- */
-static void reset_write_watches( void *base, SIZE_T size )
-{
-    set_page_vprot_bits( base, size, VPROT_WRITEWATCH, 0 );
-    mprotect_range( base, size, 0, 0 );
-}
-
-
-/***********************************************************************
- *           unmap_extra_space
- *
- * Release the extra memory while keeping the range starting on the granularity boundary.
- */
-static inline void *unmap_extra_space( void *ptr, size_t total_size, size_t wanted_size )
-{
-    if ((ULONG_PTR)ptr & granularity_mask)
-    {
-        size_t extra = granularity_mask + 1 - ((ULONG_PTR)ptr & granularity_mask);
-        munmap( ptr, extra );
-        ptr = (char *)ptr + extra;
-        total_size -= extra;
-    }
-    if (total_size > wanted_size)
-        munmap( (char *)ptr + wanted_size, total_size - wanted_size );
-    return ptr;
-}
-
-
-struct alloc_area
-{
-    size_t size;
-    int    top_down;
-    void  *limit;
-    void  *result;
-};
-
-/***********************************************************************
- *           alloc_reserved_area_callback
- *
- * Try to map some space inside a reserved area. Callback for mmap_enum_reserved_areas.
- */
-static int CDECL alloc_reserved_area_callback( void *start, SIZE_T size, void *arg )
-{
-    struct alloc_area *alloc = arg;
-    void *end = (char *)start + size;
-
-    if (start < address_space_start) start = address_space_start;
-    if (is_beyond_limit( start, size, alloc->limit )) end = alloc->limit;
-    if (start >= end) return 0;
-
-    /* make sure we don't touch the preloader reserved range */
-    if (preload_reserve_end >= start)
-    {
-        if (preload_reserve_end >= end)
-        {
-            if (preload_reserve_start <= start) return 0;  /* no space in that area */
-            if (preload_reserve_start < end) end = preload_reserve_start;
-        }
-        else if (preload_reserve_start <= start) start = preload_reserve_end;
-        else
-        {
-            /* range is split in two by the preloader reservation, try first part */
-            if ((alloc->result = find_reserved_free_area( start, preload_reserve_start, alloc->size,
-                                                          alloc->top_down )))
-                return 1;
-            /* then fall through to try second part */
-            start = preload_reserve_end;
-        }
-    }
-    if ((alloc->result = find_reserved_free_area( start, end, alloc->size, alloc->top_down )))
-        return 1;
-
-    return 0;
-}
-
-/***********************************************************************
- *           map_fixed_area
- *
- * mmap the fixed memory area.
- * virtual_mutex must be held by caller.
- */
-static NTSTATUS map_fixed_area( void *base, size_t size, unsigned int vprot )
-{
-    void *ptr;
-
-    switch (mmap_is_in_reserved_area( base, size ))
-    {
-    case -1: /* partially in a reserved area */
-    {
-        NTSTATUS status;
-        struct area_boundary area;
-        size_t lower_size;
-        area.base = base;
-        area.size = size;
-        mmap_enum_reserved_areas( get_area_boundary_callback, &area, 0 );
-        assert( area.boundary );
-        lower_size = (char *)area.boundary - (char *)base;
-        status = map_fixed_area( base, lower_size, vprot );
-        if (status == STATUS_SUCCESS)
-        {
-            status = map_fixed_area( area.boundary, size - lower_size, vprot);
-            if (status != STATUS_SUCCESS) unmap_area( base, lower_size );
-        }
-        return status;
-    }
-    case 0:  /* not in a reserved area, do a normal allocation */
-        if ((ptr = wine_anon_mmap( base, size, get_unix_prot(vprot), 0 )) == (void *)-1)
-        {
-            if (errno == ENOMEM) return STATUS_NO_MEMORY;
-            return STATUS_INVALID_PARAMETER;
-        }
-        if (ptr != base)
-        {
-            /* We couldn't get the address we wanted */
-            if (is_beyond_limit( ptr, size, user_space_limit )) add_reserved_area( ptr, size );
-            else munmap( ptr, size );
-            return STATUS_CONFLICTING_ADDRESSES;
-        }
-        break;
-
-    default:
-    case 1:  /* in a reserved area, make sure the address is available */
-        if (find_view_range( base, size )) return STATUS_CONFLICTING_ADDRESSES;
-        /* replace the reserved area by our mapping */
-        if ((ptr = wine_anon_mmap( base, size, get_unix_prot(vprot), MAP_FIXED )) != base)
-            return STATUS_INVALID_PARAMETER;
-        break;
-    }
-    if (is_beyond_limit( ptr, size, working_set_limit )) working_set_limit = address_space_limit;
-    return STATUS_SUCCESS;
-}
-
-/***********************************************************************
- *           map_view
- *
- * Create a view and mmap the corresponding memory area.
- * virtual_mutex must be held by caller.
- */
-static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
-                          int top_down, unsigned int vprot, unsigned short zero_bits_64 )
-{
-    void *ptr;
-    NTSTATUS status;
-
-    if (base)
-    {
-        if (is_beyond_limit( base, size, address_space_limit ))
-            return STATUS_WORKING_SET_LIMIT_RANGE;
-        status = map_fixed_area( base, size, vprot );
-        if (status != STATUS_SUCCESS) return status;
-        ptr = base;
-    }
-    else
-    {
-        size_t view_size = size + granularity_mask + 1;
-        struct alloc_area alloc;
-
-        alloc.size = size;
-        alloc.top_down = top_down;
-        alloc.limit = (void*)(get_zero_bits_64_mask( zero_bits_64 ) & (UINT_PTR)user_space_limit);
-
-        if (mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, top_down ))
-        {
-            ptr = alloc.result;
-            TRACE( "got mem in reserved area %p-%p\n", ptr, (char *)ptr + size );
-            if (wine_anon_mmap( ptr, size, get_unix_prot(vprot), MAP_FIXED ) != ptr)
-                return STATUS_INVALID_PARAMETER;
-            goto done;
-        }
-
-        if (zero_bits_64)
-        {
-            if (!(ptr = map_free_area( address_space_start, alloc.limit, size,
-                                       top_down, get_unix_prot(vprot) )))
-                return STATUS_NO_MEMORY;
-            TRACE( "got mem with map_free_area %p-%p\n", ptr, (char *)ptr + size );
-            goto done;
-        }
-
-        for (;;)
-        {
-            if ((ptr = wine_anon_mmap( NULL, view_size, get_unix_prot(vprot), 0 )) == (void *)-1)
-            {
-                if (errno == ENOMEM) return STATUS_NO_MEMORY;
-                return STATUS_INVALID_PARAMETER;
-            }
-            TRACE( "got mem with anon mmap %p-%p\n", ptr, (char *)ptr + size );
-            /* if we got something beyond the user limit, unmap it and retry */
-            if (is_beyond_limit( ptr, view_size, user_space_limit )) add_reserved_area( ptr, view_size );
-            else break;
-        }
-        ptr = unmap_extra_space( ptr, view_size, size );
-    }
-done:
-    status = create_view( view_ret, ptr, size, vprot );
-    if (status != STATUS_SUCCESS) unmap_area( ptr, size );
-    return status;
-}
-
-
-/***********************************************************************
- *           map_file_into_view
- *
- * Wrapper for mmap() to map a file into a view, falling back to read if mmap fails.
- * virtual_mutex must be held by caller.
- */
-static NTSTATUS map_file_into_view( struct file_view *view, int fd, size_t start, size_t size,
-                                    off_t offset, unsigned int vprot, BOOL removable )
-{
-    void *ptr;
-    int prot = get_unix_prot( vprot | VPROT_COMMITTED /* make sure it is accessible */ );
-    unsigned int flags = MAP_FIXED | ((vprot & VPROT_WRITECOPY) ? MAP_PRIVATE : MAP_SHARED);
-
-    assert( start < view->size );
-    assert( start + size <= view->size );
-
-    if (force_exec_prot && (vprot & VPROT_READ))
-    {
-        TRACE( "forcing exec permission on mapping %p-%p\n",
-               (char *)view->base + start, (char *)view->base + start + size - 1 );
-        prot |= PROT_EXEC;
-    }
-
-    /* only try mmap if media is not removable (or if we require write access) */
-    if (!removable || (flags & MAP_SHARED))
-    {
-        if (mmap( (char *)view->base + start, size, prot, flags, fd, offset ) != (void *)-1)
-            goto done;
-
-        switch (errno)
-        {
-        case EINVAL:  /* file offset is not page-aligned, fall back to read() */
-            if (flags & MAP_SHARED) return STATUS_INVALID_PARAMETER;
-            break;
-        case ENOEXEC:
-        case ENODEV:  /* filesystem doesn't support mmap(), fall back to read() */
-            if (vprot & VPROT_WRITE)
-            {
-                ERR( "shared writable mmap not supported, broken filesystem?\n" );
-                return STATUS_NOT_SUPPORTED;
-            }
-            break;
-        case EACCES:
-        case EPERM:  /* noexec filesystem, fall back to read() */
-            if (flags & MAP_SHARED)
-            {
-                if (prot & PROT_EXEC) ERR( "failed to set PROT_EXEC on file map, noexec filesystem?\n" );
-                return STATUS_ACCESS_DENIED;
-            }
-            if (prot & PROT_EXEC) WARN( "failed to set PROT_EXEC on file map, noexec filesystem?\n" );
-            break;
-        default:
-            return STATUS_NO_MEMORY;
-        }
-    }
-
-    /* Reserve the memory with an anonymous mmap */
-    ptr = wine_anon_mmap( (char *)view->base + start, size, PROT_READ | PROT_WRITE, MAP_FIXED );
-    if (ptr == (void *)-1) return STATUS_NO_MEMORY;
-    /* Now read in the file */
-    pread( fd, ptr, size, offset );
-    if (prot != (PROT_READ|PROT_WRITE)) mprotect( ptr, size, prot );  /* Set the right protection */
-done:
-    set_page_vprot( (char *)view->base + start, size, vprot );
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           get_committed_size
- *
- * Get the size of the committed range starting at base.
- * Also return the protections for the first page.
- */
-static SIZE_T get_committed_size( struct file_view *view, void *base, BYTE *vprot )
-{
-    SIZE_T i, start;
-
-    start = ((char *)base - (char *)view->base) >> page_shift;
-    *vprot = get_page_vprot( base );
-
-    if (view->protect & SEC_RESERVE)
-    {
-        SIZE_T ret = 0;
-        SERVER_START_REQ( get_mapping_committed_range )
-        {
-            req->base   = wine_server_client_ptr( view->base );
-            req->offset = start << page_shift;
-            if (!wine_server_call( req ))
-            {
-                ret = reply->size;
-                if (reply->committed)
-                {
-                    *vprot |= VPROT_COMMITTED;
-                    set_page_vprot_bits( base, ret, VPROT_COMMITTED, 0 );
-                }
-            }
-        }
-        SERVER_END_REQ;
-        return ret;
-    }
-    for (i = start + 1; i < view->size >> page_shift; i++)
-        if ((*vprot ^ get_page_vprot( (char *)view->base + (i << page_shift) )) & VPROT_COMMITTED) break;
-    return (i - start) << page_shift;
-}
-
-
-/***********************************************************************
- *           decommit_view
- *
- * Decommit some pages of a given view.
- * virtual_mutex must be held by caller.
- */
-static NTSTATUS decommit_pages( struct file_view *view, size_t start, size_t size )
-{
-    if (wine_anon_mmap( (char *)view->base + start, size, PROT_NONE, MAP_FIXED ) != (void *)-1)
-    {
-        set_page_vprot_bits( (char *)view->base + start, size, 0, VPROT_COMMITTED );
-        return STATUS_SUCCESS;
-    }
-    return STATUS_NO_MEMORY;
-}
-
-
-/***********************************************************************
- *           allocate_dos_memory
- *
- * Allocate the DOS memory range.
- */
-static NTSTATUS allocate_dos_memory( struct file_view **view, unsigned int vprot )
-{
-    size_t size;
-    void *addr = NULL;
-    void * const low_64k = (void *)0x10000;
-    const size_t dosmem_size = 0x110000;
-    int unix_prot = get_unix_prot( vprot );
-
-    /* check for existing view */
-
-    if (find_view_range( 0, dosmem_size )) return STATUS_CONFLICTING_ADDRESSES;
-
-    /* check without the first 64K */
-
-    if (mmap_is_in_reserved_area( low_64k, dosmem_size - 0x10000 ) != 1)
-    {
-        addr = wine_anon_mmap( low_64k, dosmem_size - 0x10000, unix_prot, 0 );
-        if (addr != low_64k)
-        {
-            if (addr != (void *)-1) munmap( addr, dosmem_size - 0x10000 );
-            return map_view( view, NULL, dosmem_size, FALSE, vprot, 0 );
-        }
-    }
-
-    /* now try to allocate the low 64K too */
-
-    if (mmap_is_in_reserved_area( NULL, 0x10000 ) != 1)
-    {
-        addr = wine_anon_mmap( (void *)page_size, 0x10000 - page_size, unix_prot, 0 );
-        if (addr == (void *)page_size)
-        {
-            if (!wine_anon_mmap( NULL, page_size, unix_prot, MAP_FIXED ))
-            {
-                addr = NULL;
-                TRACE( "successfully mapped low 64K range\n" );
-            }
-            else TRACE( "failed to map page 0\n" );
-        }
-        else
-        {
-            if (addr != (void *)-1) munmap( addr, 0x10000 - page_size );
-            addr = low_64k;
-            TRACE( "failed to map low 64K range\n" );
-        }
-    }
-
-    /* now reserve the whole range */
-
-    size = (char *)dosmem_size - (char *)addr;
-    wine_anon_mmap( addr, size, unix_prot, MAP_FIXED );
-    return create_view( view, addr, size, vprot );
-}
-
-
-/***********************************************************************
- *           map_pe_header
- *
- * Map the header of a PE file into memory.
- */
-static NTSTATUS map_pe_header( void *ptr, size_t size, int fd, BOOL *removable )
-{
-    if (!size) return STATUS_INVALID_IMAGE_FORMAT;
-
-    if (!*removable)
-    {
-        if (mmap( ptr, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE, fd, 0 ) != (void *)-1)
-            return STATUS_SUCCESS;
-
-        switch (errno)
-        {
-        case EPERM:
-        case EACCES:
-            WARN( "noexec file system, falling back to read\n" );
-            break;
-        case ENOEXEC:
-        case ENODEV:
-            WARN( "file system doesn't support mmap, falling back to read\n" );
-            break;
-        default:
-            return STATUS_NO_MEMORY;
-        }
-        *removable = TRUE;
-    }
-    pread( fd, ptr, size, 0 );
-    return STATUS_SUCCESS;  /* page protections will be updated later */
-}
-
-
-/***********************************************************************
- *           map_image_into_view
- *
- * Map an executable (PE format) image into an existing view.
- * virtual_mutex must be held by caller.
- */
-static NTSTATUS map_image_into_view( struct file_view *view, int fd, void *orig_base,
-                                     SIZE_T header_size, ULONG image_flags, int shared_fd, BOOL removable )
-{
-    IMAGE_DOS_HEADER *dos;
-    IMAGE_NT_HEADERS *nt;
-    IMAGE_SECTION_HEADER sections[96];
-    IMAGE_SECTION_HEADER *sec;
-    IMAGE_DATA_DIRECTORY *imports;
-    NTSTATUS status = STATUS_CONFLICTING_ADDRESSES;
-    int i;
-    off_t pos;
-    struct stat st;
-    char *header_end, *header_start;
-    char *ptr = view->base;
-    SIZE_T total_size = view->size;
-
-    TRACE_(module)( "mapped PE file at %p-%p\n", ptr, ptr + total_size );
-
-    /* map the header */
-
-    fstat( fd, &st );
-    header_size = min( header_size, st.st_size );
-    if ((status = map_pe_header( view->base, header_size, fd, &removable ))) return status;
-
-    status = STATUS_INVALID_IMAGE_FORMAT;  /* generic error */
-    dos = (IMAGE_DOS_HEADER *)ptr;
-    nt = (IMAGE_NT_HEADERS *)(ptr + dos->e_lfanew);
-    header_end = ptr + ROUND_SIZE( 0, header_size );
-    memset( ptr + header_size, 0, header_end - (ptr + header_size) );
-    if ((char *)(nt + 1) > header_end) return status;
-    header_start = (char*)&nt->OptionalHeader+nt->FileHeader.SizeOfOptionalHeader;
-    if (nt->FileHeader.NumberOfSections > ARRAY_SIZE( sections )) return status;
-    if (header_start + sizeof(*sections) * nt->FileHeader.NumberOfSections > header_end) return status;
-    /* Some applications (e.g. the Steam version of Borderlands) map over the top of the section headers,
-     * copying the headers into local memory is necessary to properly load such applications. */
-    memcpy(sections, header_start, sizeof(*sections) * nt->FileHeader.NumberOfSections);
-    sec = sections;
-
-    imports = nt->OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT;
-    if (!imports->Size || !imports->VirtualAddress) imports = NULL;
-
-    /* check for non page-aligned binary */
-
-    if (image_flags & IMAGE_FLAGS_ImageMappedFlat)
-    {
-        /* unaligned sections, this happens for native subsystem binaries */
-        /* in that case Windows simply maps in the whole file */
-
-        total_size = min( total_size, ROUND_SIZE( 0, st.st_size ));
-        if (map_file_into_view( view, fd, 0, total_size, 0, VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY,
-                                removable ) != STATUS_SUCCESS) return status;
-
-        /* check that all sections are loaded at the right offset */
-        if (nt->OptionalHeader.FileAlignment != nt->OptionalHeader.SectionAlignment) return status;
-        for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
-        {
-            if (sec[i].VirtualAddress != sec[i].PointerToRawData)
-                return status;  /* Windows refuses to load in that case too */
-        }
-
-        /* set the image protections */
-        set_vprot( view, ptr, total_size, VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY | VPROT_EXEC );
-
-        /* no relocations are performed on non page-aligned binaries */
-        return STATUS_SUCCESS;
-    }
-
-
-    /* map all the sections */
-
-    for (i = pos = 0; i < nt->FileHeader.NumberOfSections; i++, sec++)
-    {
-        static const SIZE_T sector_align = 0x1ff;
-        SIZE_T map_size, file_start, file_size, end;
-
-        if (!sec->Misc.VirtualSize)
-            map_size = ROUND_SIZE( 0, sec->SizeOfRawData );
-        else
-            map_size = ROUND_SIZE( 0, sec->Misc.VirtualSize );
-
-        /* file positions are rounded to sector boundaries regardless of OptionalHeader.FileAlignment */
-        file_start = sec->PointerToRawData & ~sector_align;
-        file_size = (sec->SizeOfRawData + (sec->PointerToRawData & sector_align) + sector_align) & ~sector_align;
-        if (file_size > map_size) file_size = map_size;
-
-        /* a few sanity checks */
-        end = sec->VirtualAddress + ROUND_SIZE( sec->VirtualAddress, map_size );
-        if (sec->VirtualAddress > total_size || end > total_size || end < sec->VirtualAddress)
-        {
-            WARN_(module)( "Section %.8s too large (%x+%lx/%lx)\n",
-                           sec->Name, sec->VirtualAddress, map_size, total_size );
-            return status;
-        }
-
-        if ((sec->Characteristics & IMAGE_SCN_MEM_SHARED) &&
-            (sec->Characteristics & IMAGE_SCN_MEM_WRITE))
-        {
-            TRACE_(module)( "mapping shared section %.8s at %p off %x (%x) size %lx (%lx) flags %x\n",
-                            sec->Name, ptr + sec->VirtualAddress,
-                            sec->PointerToRawData, (int)pos, file_size, map_size,
-                            sec->Characteristics );
-            if (map_file_into_view( view, shared_fd, sec->VirtualAddress, map_size, pos,
-                                    VPROT_COMMITTED | VPROT_READ | VPROT_WRITE, FALSE ) != STATUS_SUCCESS)
-            {
-                ERR_(module)( "Could not map shared section %.8s\n", sec->Name );
-                return status;
-            }
-
-            /* check if the import directory falls inside this section */
-            if (imports && imports->VirtualAddress >= sec->VirtualAddress &&
-                imports->VirtualAddress < sec->VirtualAddress + map_size)
-            {
-                UINT_PTR base = imports->VirtualAddress & ~page_mask;
-                UINT_PTR end = base + ROUND_SIZE( imports->VirtualAddress, imports->Size );
-                if (end > sec->VirtualAddress + map_size) end = sec->VirtualAddress + map_size;
-                if (end > base)
-                    map_file_into_view( view, shared_fd, base, end - base,
-                                        pos + (base - sec->VirtualAddress),
-                                        VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY, FALSE );
-            }
-            pos += map_size;
-            continue;
-        }
-
-        TRACE_(module)( "mapping section %.8s at %p off %x size %x virt %x flags %x\n",
-                        sec->Name, ptr + sec->VirtualAddress,
-                        sec->PointerToRawData, sec->SizeOfRawData,
-                        sec->Misc.VirtualSize, sec->Characteristics );
-
-        if (!sec->PointerToRawData || !file_size) continue;
-
-        /* Note: if the section is not aligned properly map_file_into_view will magically
-         *       fall back to read(), so we don't need to check anything here.
-         */
-        end = file_start + file_size;
-        if (sec->PointerToRawData >= st.st_size ||
-            end > ((st.st_size + sector_align) & ~sector_align) ||
-            end < file_start ||
-            map_file_into_view( view, fd, sec->VirtualAddress, file_size, file_start,
-                                VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY,
-                                removable ) != STATUS_SUCCESS)
-        {
-            ERR_(module)( "Could not map section %.8s, file probably truncated\n", sec->Name );
-            return status;
-        }
-
-        if (file_size & page_mask)
-        {
-            end = ROUND_SIZE( 0, file_size );
-            if (end > map_size) end = map_size;
-            TRACE_(module)("clearing %p - %p\n",
-                           ptr + sec->VirtualAddress + file_size,
-                           ptr + sec->VirtualAddress + end );
-            memset( ptr + sec->VirtualAddress + file_size, 0, end - file_size );
-        }
-    }
-
-    /* set the image protections */
-
-    set_vprot( view, ptr, ROUND_SIZE( 0, header_size ), VPROT_COMMITTED | VPROT_READ );
-
-    sec = sections;
-    for (i = 0; i < nt->FileHeader.NumberOfSections; i++, sec++)
-    {
-        SIZE_T size;
-        BYTE vprot = VPROT_COMMITTED;
-
-        if (sec->Misc.VirtualSize)
-            size = ROUND_SIZE( sec->VirtualAddress, sec->Misc.VirtualSize );
-        else
-            size = ROUND_SIZE( sec->VirtualAddress, sec->SizeOfRawData );
-
-        if (sec->Characteristics & IMAGE_SCN_MEM_READ)    vprot |= VPROT_READ;
-        if (sec->Characteristics & IMAGE_SCN_MEM_WRITE)   vprot |= VPROT_WRITECOPY;
-        if (sec->Characteristics & IMAGE_SCN_MEM_EXECUTE) vprot |= VPROT_EXEC;
-
-        /* Dumb game crack lets the AOEP point into a data section. Adjust. */
-        if ((nt->OptionalHeader.AddressOfEntryPoint >= sec->VirtualAddress) &&
-            (nt->OptionalHeader.AddressOfEntryPoint < sec->VirtualAddress + size))
-            vprot |= VPROT_EXEC;
-
-        if (!set_vprot( view, ptr + sec->VirtualAddress, size, vprot ) && (vprot & VPROT_EXEC))
-            ERR( "failed to set %08x protection on section %.8s, noexec filesystem?\n",
-                 sec->Characteristics, sec->Name );
-    }
-
-#ifdef VALGRIND_LOAD_PDB_DEBUGINFO
-    VALGRIND_LOAD_PDB_DEBUGINFO(fd, ptr, total_size, ptr - (char *)orig_base);
-#endif
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *             virtual_map_section
- *
- * Map a file section into memory.
- */
-NTSTATUS CDECL virtual_map_section( HANDLE handle, PVOID *addr_ptr, unsigned short zero_bits_64, SIZE_T commit_size,
-                              const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr, ULONG alloc_type,
-                              ULONG protect, pe_image_info_t *image_info )
-{
-    NTSTATUS res;
-    mem_size_t full_size;
-    ACCESS_MASK access;
-    SIZE_T size;
-    void *base;
-    int unix_handle = -1, needs_close;
-    int shared_fd = -1, shared_needs_close = 0;
-    unsigned int vprot, sec_flags;
-    struct file_view *view;
-    HANDLE shared_file;
-    LARGE_INTEGER offset;
-    sigset_t sigset;
-
-    offset.QuadPart = offset_ptr ? offset_ptr->QuadPart : 0;
-
-    switch(protect)
-    {
-    case PAGE_NOACCESS:
-    case PAGE_READONLY:
-    case PAGE_WRITECOPY:
-        access = SECTION_MAP_READ;
-        break;
-    case PAGE_READWRITE:
-        access = SECTION_MAP_WRITE;
-        break;
-    case PAGE_EXECUTE:
-    case PAGE_EXECUTE_READ:
-    case PAGE_EXECUTE_WRITECOPY:
-        access = SECTION_MAP_READ | SECTION_MAP_EXECUTE;
-        break;
-    case PAGE_EXECUTE_READWRITE:
-        access = SECTION_MAP_WRITE | SECTION_MAP_EXECUTE;
-        break;
-    default:
-        return STATUS_INVALID_PAGE_PROTECTION;
-    }
-
-    SERVER_START_REQ( get_mapping_info )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->access = access;
-        wine_server_set_reply( req, image_info, sizeof(*image_info) );
-        res = wine_server_call( req );
-        sec_flags   = reply->flags;
-        full_size   = reply->size;
-        shared_file = wine_server_ptr_handle( reply->shared_file );
-    }
-    SERVER_END_REQ;
-    if (res) return res;
-
-    if ((res = server_get_unix_fd( handle, 0, &unix_handle, &needs_close, NULL, NULL )))
-    {
-        if (shared_file) NtClose( shared_file );
-        return res;
-    }
-
-    if (shared_file && ((res = server_get_unix_fd( shared_file, FILE_READ_DATA|FILE_WRITE_DATA,
-                                                   &shared_fd, &shared_needs_close, NULL, NULL ))))
-    {
-        NtClose( shared_file );
-        if (needs_close) close( unix_handle );
-        return res;
-    }
-
-    res = STATUS_INVALID_PARAMETER;
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (sec_flags & SEC_IMAGE)
-    {
-        base = wine_server_get_ptr( image_info->base );
-        if ((ULONG_PTR)base != image_info->base) base = NULL;
-        size = image_info->map_size;
-        vprot = SEC_IMAGE | SEC_FILE | VPROT_COMMITTED | VPROT_READ | VPROT_EXEC | VPROT_WRITECOPY;
-
-        if ((char *)base >= (char *)address_space_start)  /* make sure the DOS area remains free */
-            res = map_view( &view, base, size, alloc_type & MEM_TOP_DOWN, vprot, zero_bits_64 );
-
-        if (res) res = map_view( &view, NULL, size, alloc_type & MEM_TOP_DOWN, vprot, zero_bits_64 );
-        if (res) goto done;
-
-        res = map_image_into_view( view, unix_handle, base, image_info->header_size,
-                                   image_info->image_flags, shared_fd, needs_close );
-    }
-    else
-    {
-        base = *addr_ptr;
-        if (offset.QuadPart >= full_size) goto done;
-        if (*size_ptr)
-        {
-            size = *size_ptr;
-            if (size > full_size - offset.QuadPart)
-            {
-                res = STATUS_INVALID_VIEW_SIZE;
-                goto done;
-            }
-        }
-        else
-        {
-            size = full_size - offset.QuadPart;
-            if (size != full_size - offset.QuadPart)  /* truncated */
-            {
-                WARN( "Files larger than 4Gb (%s) not supported on this platform\n",
-                      wine_dbgstr_longlong(full_size) );
-                goto done;
-            }
-        }
-        if (!(size = ROUND_SIZE( 0, size ))) goto done;  /* wrap-around */
-
-        get_vprot_flags( protect, &vprot, FALSE );
-        vprot |= sec_flags;
-        if (!(sec_flags & SEC_RESERVE)) vprot |= VPROT_COMMITTED;
-        res = map_view( &view, base, size, alloc_type & MEM_TOP_DOWN, vprot, zero_bits_64 );
-        if (res) goto done;
-
-        TRACE( "handle=%p size=%lx offset=%x%08x\n", handle, size, offset.u.HighPart, offset.u.LowPart );
-        res = map_file_into_view( view, unix_handle, 0, size, offset.QuadPart, vprot, needs_close );
-        if (res) ERR( "mapping %p %lx %x%08x failed\n",
-                      view->base, size, offset.u.HighPart, offset.u.LowPart );
-    }
-
-    if (res == STATUS_SUCCESS)
-    {
-        SERVER_START_REQ( map_view )
-        {
-            req->mapping = wine_server_obj_handle( handle );
-            req->access  = access;
-            req->base    = wine_server_client_ptr( view->base );
-            req->size    = size;
-            req->start   = offset.QuadPart;
-            res = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-    }
-
-    if (res >= 0)
-    {
-        *addr_ptr = view->base;
-        *size_ptr = size;
-        VIRTUAL_DEBUG_DUMP_VIEW( view );
-    }
-    else delete_view( view );
-
-done:
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    if (needs_close) close( unix_handle );
-    if (shared_needs_close) close( shared_fd );
-    if (shared_file) NtClose( shared_file );
-    return res;
-}
-
-
-struct alloc_virtual_heap
-{
-    void  *base;
-    size_t size;
-};
-
-/* callback for mmap_enum_reserved_areas to allocate space for the virtual heap */
-static int CDECL alloc_virtual_heap( void *base, SIZE_T size, void *arg )
-{
-    struct alloc_virtual_heap *alloc = arg;
-
-    if (is_beyond_limit( base, size, address_space_limit )) address_space_limit = (char *)base + size;
-    if (size < alloc->size) return 0;
-    if (is_win64 && base < (void *)0x80000000) return 0;
-    alloc->base = wine_anon_mmap( (char *)base + size - alloc->size, alloc->size,
-                                  PROT_READ|PROT_WRITE, MAP_FIXED );
-    return (alloc->base != (void *)-1);
-}
-
-/***********************************************************************
- *           virtual_init
- */
-void virtual_init(void)
-{
-    const struct preload_info **preload_info = dlsym( RTLD_DEFAULT, "wine_main_preload_info" );
-    const char *preload = getenv( "WINEPRELOADRESERVE" );
-    struct alloc_virtual_heap alloc_views;
-    size_t size;
-    int i;
-    pthread_mutexattr_t attr;
-
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &virtual_mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
-
-    if (preload_info && *preload_info)
-        for (i = 0; (*preload_info)[i].size; i++)
-            mmap_add_reserved_area( (*preload_info)[i].addr, (*preload_info)[i].size );
-
-    mmap_init( preload_info ? *preload_info : NULL );
-
-    if ((preload = getenv("WINEPRELOADRESERVE")))
-    {
-        unsigned long start, end;
-        if (sscanf( preload, "%lx-%lx", &start, &end ) == 2)
-        {
-            preload_reserve_start = (void *)start;
-            preload_reserve_end = (void *)end;
-            /* some apps start inside the DOS area */
-            if (preload_reserve_start)
-                address_space_start = min( address_space_start, preload_reserve_start );
-        }
-    }
-
-    /* try to find space in a reserved area for the views and pages protection table */
-#ifdef _WIN64
-    pages_vprot_size = ((size_t)address_space_limit >> page_shift >> pages_vprot_shift) + 1;
-    alloc_views.size = 2 * view_block_size + pages_vprot_size * sizeof(*pages_vprot);
-#else
-    alloc_views.size = 2 * view_block_size + (1U << (32 - page_shift));
-#endif
-    if (mmap_enum_reserved_areas( alloc_virtual_heap, &alloc_views, 1 ))
-        mmap_remove_reserved_area( alloc_views.base, alloc_views.size );
-    else
-        alloc_views.base = wine_anon_mmap( NULL, alloc_views.size, PROT_READ | PROT_WRITE, 0 );
-
-    assert( alloc_views.base != (void *)-1 );
-    view_block_start = alloc_views.base;
-    view_block_end = view_block_start + view_block_size / sizeof(*view_block_start);
-    free_ranges = (void *)((char *)alloc_views.base + view_block_size);
-    pages_vprot = (void *)((char *)alloc_views.base + 2 * view_block_size);
-    wine_rb_init( &views_tree, compare_view );
-
-    free_ranges[0].base = (void *)0;
-    free_ranges[0].end = (void *)~0;
-    free_ranges_end = free_ranges + 1;
-
-    /* make the DOS area accessible (except the low 64K) to hide bugs in broken apps like Excel 2003 */
-    size = (char *)address_space_start - (char *)0x10000;
-    if (size && mmap_is_in_reserved_area( (void*)0x10000, size ) == 1)
-        wine_anon_mmap( (void *)0x10000, size, PROT_READ | PROT_WRITE, MAP_FIXED );
-}
-
-
-/***********************************************************************
- *             virtual_map_ntdll
- *
- * Map ntdll, used instead of virtual_map_section() because some things are not initialized yet.
- */
-NTSTATUS virtual_map_ntdll( int fd, void **module )
-{
-    IMAGE_DOS_HEADER dos;
-    IMAGE_NT_HEADERS nt;
-    NTSTATUS status;
-    SIZE_T size;
-    void *base;
-    unsigned int vprot;
-    struct file_view *view;
-
-    /* load the headers */
-
-    size = pread( fd, &dos, sizeof(dos), 0 );
-    if (size < sizeof(dos)) return STATUS_INVALID_IMAGE_FORMAT;
-    if (dos.e_magic != IMAGE_DOS_SIGNATURE) return STATUS_INVALID_IMAGE_FORMAT;
-
-    size = pread( fd, &nt, sizeof(nt), dos.e_lfanew );
-    if (size < sizeof(nt)) return STATUS_INVALID_IMAGE_PROTECT;
-    if (nt.Signature != IMAGE_NT_SIGNATURE) return STATUS_INVALID_IMAGE_FORMAT;
-    if (nt.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) return STATUS_INVALID_IMAGE_FORMAT;
-#ifdef __i386__
-    if (nt.FileHeader.Machine != IMAGE_FILE_MACHINE_I386) return STATUS_INVALID_IMAGE_FORMAT;
-#elif defined(__x86_64__)
-    if (nt.FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) return STATUS_INVALID_IMAGE_FORMAT;
-#elif defined(__arm__)
-    if (nt.FileHeader.Machine != IMAGE_FILE_MACHINE_ARM &&
-        nt.FileHeader.Machine != IMAGE_FILE_MACHINE_THUMB &&
-        nt.FileHeader.Machine != IMAGE_FILE_MACHINE_ARMNT) return STATUS_INVALID_IMAGE_FORMAT;
-#elif defined(__aarch64__)
-    if (nt.FileHeader.Machine != IMAGE_FILE_MACHINE_ARM64) return STATUS_INVALID_IMAGE_FORMAT;
-#endif
-
-    base  = (void *)nt.OptionalHeader.ImageBase;
-    size  = ROUND_SIZE( 0, nt.OptionalHeader.SizeOfImage );
-    vprot = SEC_IMAGE | SEC_FILE | VPROT_COMMITTED | VPROT_READ | VPROT_EXEC | VPROT_WRITECOPY;
-
-    status = map_view( &view, base, size, FALSE, vprot, 0 );
-    if (status == STATUS_CONFLICTING_ADDRESSES)
-        ERR( "couldn't load ntdll at preferred address %p\n", base );
-    if (status) return status;
-    *module = view->base;
-    return map_image_into_view( view, fd, base, nt.OptionalHeader.SizeOfHeaders, 0, -1, FALSE );
-}
-
-
-/***********************************************************************
- *           get_system_affinity_mask
- */
-ULONG_PTR get_system_affinity_mask(void)
-{
-    ULONG num_cpus = NtCurrentTeb()->Peb->NumberOfProcessors;
-    if (num_cpus >= sizeof(ULONG_PTR) * 8) return ~(ULONG_PTR)0;
-    return ((ULONG_PTR)1 << num_cpus) - 1;
-}
-
-/***********************************************************************
- *           virtual_get_system_info
- */
-void virtual_get_system_info( SYSTEM_BASIC_INFORMATION *info )
-{
-#if defined(HAVE_STRUCT_SYSINFO_TOTALRAM) && defined(HAVE_STRUCT_SYSINFO_MEM_UNIT)
-    struct sysinfo sinfo;
-
-    if (!sysinfo(&sinfo))
-    {
-        ULONG64 total = (ULONG64)sinfo.totalram * sinfo.mem_unit;
-        info->MmHighestPhysicalPage = max(1, total / page_size);
-    }
-#elif defined(_SC_PHYS_PAGES)
-    LONG64 phys_pages = sysconf( _SC_PHYS_PAGES );
-
-    info->MmHighestPhysicalPage = max(1, phys_pages);
-#else
-    info->MmHighestPhysicalPage = 0x7fffffff / page_size;
-#endif
-
-    info->unknown                 = 0;
-    info->KeMaximumIncrement      = 0;  /* FIXME */
-    info->PageSize                = page_size;
-    info->MmLowestPhysicalPage    = 1;
-    info->MmNumberOfPhysicalPages = info->MmHighestPhysicalPage - info->MmLowestPhysicalPage;
-    info->AllocationGranularity   = granularity_mask + 1;
-    info->LowestUserAddress       = (void *)0x10000;
-    info->HighestUserAddress      = (char *)user_space_limit - 1;
-    info->ActiveProcessorsAffinityMask = get_system_affinity_mask();
-    info->NumberOfProcessors      = NtCurrentTeb()->Peb->NumberOfProcessors;
-}
-
-
-/***********************************************************************
- *           virtual_create_builtin_view
- */
-NTSTATUS virtual_create_builtin_view( void *module )
-{
-    NTSTATUS status;
-    sigset_t sigset;
-    IMAGE_DOS_HEADER *dos = module;
-    IMAGE_NT_HEADERS *nt = (IMAGE_NT_HEADERS *)((char *)dos + dos->e_lfanew);
-    SIZE_T size = nt->OptionalHeader.SizeOfImage;
-    IMAGE_SECTION_HEADER *sec;
-    struct file_view *view;
-    void *base;
-    int i;
-
-    size = ROUND_SIZE( module, size );
-    base = ROUND_ADDR( module, page_mask );
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    status = create_view( &view, base, size, SEC_IMAGE | SEC_FILE | VPROT_SYSTEM |
-                          VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY | VPROT_EXEC );
-    if (!status)
-    {
-        TRACE( "created %p-%p\n", base, (char *)base + size );
-
-        /* The PE header is always read-only, no write, no execute. */
-        set_page_vprot( base, page_size, VPROT_COMMITTED | VPROT_READ );
-
-        sec = (IMAGE_SECTION_HEADER *)((char *)&nt->OptionalHeader + nt->FileHeader.SizeOfOptionalHeader);
-        for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
-        {
-            BYTE flags = VPROT_COMMITTED;
-
-            if (sec[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) flags |= VPROT_EXEC;
-            if (sec[i].Characteristics & IMAGE_SCN_MEM_READ) flags |= VPROT_READ;
-            if (sec[i].Characteristics & IMAGE_SCN_MEM_WRITE) flags |= VPROT_WRITE;
-            set_page_vprot( (char *)base + sec[i].VirtualAddress, sec[i].Misc.VirtualSize, flags );
-        }
-        VIRTUAL_DEBUG_DUMP_VIEW( view );
-        if (is_beyond_limit( base, size, working_set_limit )) working_set_limit = address_space_limit;
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/* set some initial values in a new TEB */
-static void init_teb( TEB *teb, PEB *peb )
-{
-    struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
-
-#ifndef _WIN64
-    TEB64 *teb64 = (TEB64 *)((char *)teb - teb_offset);
-
-    teb64->Peb = PtrToUlong( (char *)peb + page_size );
-    teb64->Tib.Self = PtrToUlong( teb64 );
-    teb64->Tib.ExceptionList = PtrToUlong( teb );
-    teb64->ActivationContextStackPointer = PtrToUlong( &teb64->ActivationContextStack );
-    teb64->ActivationContextStack.FrameListCache.Flink =
-        teb64->ActivationContextStack.FrameListCache.Blink =
-            PtrToUlong( &teb64->ActivationContextStack.FrameListCache );
-    teb64->StaticUnicodeString.Buffer = PtrToUlong( teb64->StaticUnicodeBuffer );
-    teb64->StaticUnicodeString.MaximumLength = sizeof( teb64->StaticUnicodeBuffer );
-#endif
-    teb->Peb = peb;
-    teb->Tib.Self = &teb->Tib;
-    teb->Tib.ExceptionList = (void *)~0ul;
-    teb->Tib.StackBase = (void *)~0ul;
-    teb->ActivationContextStackPointer = &teb->ActivationContextStack;
-    InitializeListHead( &teb->ActivationContextStack.FrameListCache );
-    teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
-    teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
-    thread_data->request_fd = -1;
-    thread_data->reply_fd   = -1;
-    thread_data->wait_fd[0] = -1;
-    thread_data->wait_fd[1] = -1;
-    list_add_head( &teb_list, &thread_data->entry );
-}
-
-
-/***********************************************************************
- *           virtual_alloc_first_teb
- */
-TEB *virtual_alloc_first_teb(void)
-{
-    TEB *teb;
-    PEB *peb;
-    void *ptr;
-    NTSTATUS status;
-    SIZE_T data_size = page_size;
-    SIZE_T peb_size = page_size * (is_win64 ? 1 : 2);
-    SIZE_T block_size = signal_stack_mask + 1;
-    SIZE_T total = 32 * block_size;
-
-    /* reserve space for shared user data */
-    status = NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&user_shared_data, 0, &data_size,
-                                      MEM_RESERVE | MEM_COMMIT, PAGE_READONLY );
-    if (status)
-    {
-        ERR( "wine: failed to map the shared user data: %08x\n", status );
-        exit(1);
-    }
-
-    NtAllocateVirtualMemory( NtCurrentProcess(), &teb_block, 0, &total,
-                             MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE );
-    teb_block_pos = 30;
-    ptr = ((char *)teb_block + 30 * block_size);
-    teb = (TEB *)((char *)ptr + teb_offset);
-    peb = (PEB *)((char *)teb_block + 32 * block_size - peb_size);
-    NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&ptr, 0, &block_size, MEM_COMMIT, PAGE_READWRITE );
-    NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&peb, 0, &peb_size, MEM_COMMIT, PAGE_READWRITE );
-    init_teb( teb, peb );
-    *(ULONG_PTR *)peb->Reserved = get_image_address();
-    return teb;
-}
-
-
-/***********************************************************************
- *           virtual_alloc_teb
- */
-NTSTATUS virtual_alloc_teb( TEB **ret_teb )
-{
-    sigset_t sigset;
-    TEB *teb;
-    void *ptr = NULL;
-    NTSTATUS status = STATUS_SUCCESS;
-    SIZE_T block_size = signal_stack_mask + 1;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if (next_free_teb)
-    {
-        ptr = next_free_teb;
-        next_free_teb = *(void **)ptr;
-        memset( ptr, 0, teb_size );
-    }
-    else
-    {
-        if (!teb_block_pos)
-        {
-            SIZE_T total = 32 * block_size;
-
-            if ((status = NtAllocateVirtualMemory( NtCurrentProcess(), &ptr, 0, &total,
-                                                   MEM_RESERVE, PAGE_READWRITE )))
-            {
-                server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-                return status;
-            }
-            teb_block = ptr;
-            teb_block_pos = 32;
-        }
-        ptr = ((char *)teb_block + --teb_block_pos * block_size);
-        NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&ptr, 0, &block_size,
-                                 MEM_COMMIT, PAGE_READWRITE );
-    }
-    *ret_teb = teb = (TEB *)((char *)ptr + teb_offset);
-    init_teb( teb, NtCurrentTeb()->Peb );
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if ((status = signal_alloc_thread( teb )))
-    {
-        server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-        *(void **)ptr = next_free_teb;
-        next_free_teb = ptr;
-        server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *           virtual_free_teb
- */
-void virtual_free_teb( TEB *teb )
-{
-    struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
-    void *ptr;
-    SIZE_T size;
-    sigset_t sigset;
-
-    signal_free_thread( teb );
-    if (teb->DeallocationStack)
-    {
-        size = 0;
-        NtFreeVirtualMemory( GetCurrentProcess(), &teb->DeallocationStack, &size, MEM_RELEASE );
-    }
-    if (thread_data->start_stack)
-    {
-        size = 0;
-        NtFreeVirtualMemory( GetCurrentProcess(), &thread_data->start_stack, &size, MEM_RELEASE );
-    }
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    list_remove( &thread_data->entry );
-    ptr = (char *)teb - teb_offset;
-    *(void **)ptr = next_free_teb;
-    next_free_teb = ptr;
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-}
-
-
-/***********************************************************************
- *           virtual_clear_tls_index
- */
-NTSTATUS virtual_clear_tls_index( ULONG index )
-{
-    struct ntdll_thread_data *thread_data;
-    sigset_t sigset;
-
-    if (index < TLS_MINIMUM_AVAILABLE)
-    {
-        server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-        LIST_FOR_EACH_ENTRY( thread_data, &teb_list, struct ntdll_thread_data, entry )
-        {
-            TEB *teb = CONTAINING_RECORD( thread_data, TEB, GdiTebBatch );
-            teb->TlsSlots[index] = 0;
-        }
-        server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    }
-    else
-    {
-        index -= TLS_MINIMUM_AVAILABLE;
-        if (index >= 8 * sizeof(NtCurrentTeb()->Peb->TlsExpansionBitmapBits))
-            return STATUS_INVALID_PARAMETER;
-
-        server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-        LIST_FOR_EACH_ENTRY( thread_data, &teb_list, struct ntdll_thread_data, entry )
-        {
-            TEB *teb = CONTAINING_RECORD( thread_data, TEB, GdiTebBatch );
-            if (teb->TlsExpansionSlots) teb->TlsExpansionSlots[index] = 0;
-        }
-        server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    }
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           virtual_alloc_thread_stack
- */
-NTSTATUS virtual_alloc_thread_stack( INITIAL_TEB *stack, SIZE_T reserve_size, SIZE_T commit_size,
-                                     SIZE_T *pthread_size )
-{
-    struct file_view *view;
-    NTSTATUS status;
-    sigset_t sigset;
-    SIZE_T size, extra_size = 0;
-
-    if (!reserve_size || !commit_size)
-    {
-        IMAGE_NT_HEADERS *nt = get_exe_nt_header();
-        if (!reserve_size) reserve_size = nt->OptionalHeader.SizeOfStackReserve;
-        if (!commit_size) commit_size = nt->OptionalHeader.SizeOfStackCommit;
-    }
-
-    size = max( reserve_size, commit_size );
-    if (size < 1024 * 1024) size = 1024 * 1024;  /* Xlib needs a large stack */
-    size = (size + 0xffff) & ~0xffff;  /* round to 64K boundary */
-    if (pthread_size) *pthread_size = extra_size = max( page_size, ROUND_SIZE( 0, *pthread_size ));
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if ((status = map_view( &view, NULL, size + extra_size, FALSE,
-                            VPROT_READ | VPROT_WRITE | VPROT_COMMITTED, 0 )) != STATUS_SUCCESS)
-        goto done;
-
-#ifdef VALGRIND_STACK_REGISTER
-    VALGRIND_STACK_REGISTER( view->base, (char *)view->base + view->size );
-#endif
-
-    /* setup no access guard page */
-    set_page_vprot( view->base, page_size, VPROT_COMMITTED );
-    set_page_vprot( (char *)view->base + page_size, page_size,
-                    VPROT_READ | VPROT_WRITE | VPROT_COMMITTED | VPROT_GUARD );
-    mprotect_range( view->base, 2 * page_size, 0, 0 );
-    VIRTUAL_DEBUG_DUMP_VIEW( view );
-
-    if (extra_size)
-    {
-        struct file_view *extra_view;
-
-        /* shrink the first view and create a second one for the extra size */
-        /* this allows the app to free the stack without freeing the thread start portion */
-        view->size -= extra_size;
-        status = create_view( &extra_view, (char *)view->base + view->size, extra_size,
-                              VPROT_READ | VPROT_WRITE | VPROT_COMMITTED );
-        if (status != STATUS_SUCCESS)
-        {
-            view->size += extra_size;
-            delete_view( view );
-            goto done;
-        }
-    }
-
-    /* note: limit is lower than base since the stack grows down */
-    stack->OldStackBase = 0;
-    stack->OldStackLimit = 0;
-    stack->DeallocationStack = view->base;
-    stack->StackBase = (char *)view->base + view->size;
-    stack->StackLimit = (char *)view->base + 2 * page_size;
-done:
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/***********************************************************************
- *           virtual_clear_thread_stack
- *
- * Clear the stack contents before calling the main entry point, some broken apps need that.
- */
-void virtual_clear_thread_stack( void *stack_end )
-{
-    void *stack = NtCurrentTeb()->Tib.StackLimit;
-    size_t size = (char *)stack_end - (char *)stack;
-
-    wine_anon_mmap( stack, size, PROT_READ | PROT_WRITE, MAP_FIXED );
-    if (force_exec_prot) mprotect( stack, size, PROT_READ | PROT_WRITE | PROT_EXEC );
-}
-
-
-/***********************************************************************
- *           virtual_map_user_shared_data
- */
-void virtual_map_user_shared_data(void)
-{
-    static const WCHAR nameW[] = {'\\','K','e','r','n','e','l','O','b','j','e','c','t','s',
-                                  '\\','_','_','w','i','n','e','_','u','s','e','r','_','s','h','a','r','e','d','_','d','a','t','a',0};
-    UNICODE_STRING name_str = { sizeof(nameW) - sizeof(WCHAR), sizeof(nameW), (WCHAR *)nameW };
-    OBJECT_ATTRIBUTES attr = { sizeof(attr), 0, &name_str };
-    NTSTATUS status;
-    HANDLE section;
-    int res, fd, needs_close;
-
-    if ((status = NtOpenSection( &section, SECTION_ALL_ACCESS, &attr )))
-    {
-        ERR( "failed to open the USD section: %08x\n", status );
-        exit(1);
-    }
-    if ((res = server_get_unix_fd( section, 0, &fd, &needs_close, NULL, NULL )) ||
-        (user_shared_data != mmap( user_shared_data, page_size, PROT_READ, MAP_SHARED|MAP_FIXED, fd, 0 )))
-    {
-        ERR( "failed to remap the process USD: %d\n", res );
-        exit(1);
-    }
-    if (needs_close) close( fd );
-    NtClose( section );
-}
-
-
-/***********************************************************************
- *           grow_thread_stack
- */
-static NTSTATUS grow_thread_stack( char *page )
-{
-    NTSTATUS ret = 0;
-    size_t guaranteed = max( NtCurrentTeb()->GuaranteedStackBytes, page_size * (is_win64 ? 2 : 1) );
-
-    set_page_vprot_bits( page, page_size, 0, VPROT_GUARD );
-    mprotect_range( page, page_size, 0, 0 );
-    if (page >= (char *)NtCurrentTeb()->DeallocationStack + page_size + guaranteed)
-    {
-        set_page_vprot_bits( page - page_size, page_size, VPROT_COMMITTED | VPROT_GUARD, 0 );
-        mprotect_range( page - page_size, page_size, 0, 0 );
-    }
-    else  /* inside guaranteed space -> overflow exception */
-    {
-        page = (char *)NtCurrentTeb()->DeallocationStack + page_size;
-        set_page_vprot_bits( page, guaranteed, VPROT_COMMITTED, VPROT_GUARD );
-        mprotect_range( page, guaranteed, 0, 0 );
-        ret = STATUS_STACK_OVERFLOW;
-    }
-    NtCurrentTeb()->Tib.StackLimit = page;
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_handle_fault
- */
-NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
-{
-    NTSTATUS ret = STATUS_ACCESS_VIOLATION;
-    char *page = ROUND_ADDR( addr, page_mask );
-    BYTE vprot;
-
-    pthread_mutex_lock( &virtual_mutex );  /* no need for signal masking inside signal handler */
-    vprot = get_page_vprot( page );
-    if (!is_inside_signal_stack( stack ) && (vprot & VPROT_GUARD))
-    {
-        if (page < (char *)NtCurrentTeb()->DeallocationStack ||
-            page >= (char *)NtCurrentTeb()->Tib.StackBase)
-        {
-            set_page_vprot_bits( page, page_size, 0, VPROT_GUARD );
-            mprotect_range( page, page_size, 0, 0 );
-            ret = STATUS_GUARD_PAGE_VIOLATION;
-        }
-        else ret = grow_thread_stack( page );
-    }
-    else if (err & EXCEPTION_WRITE_FAULT)
-    {
-        if (vprot & VPROT_WRITEWATCH)
-        {
-            set_page_vprot_bits( page, page_size, 0, VPROT_WRITEWATCH );
-            mprotect_range( page, page_size, 0, 0 );
-        }
-        /* ignore fault if page is writable now */
-        if (get_unix_prot( get_page_vprot( page )) & PROT_WRITE)
-        {
-            if ((vprot & VPROT_WRITEWATCH) || is_write_watch_range( page, page_size ))
-                ret = STATUS_SUCCESS;
-        }
-    }
-    pthread_mutex_unlock( &virtual_mutex );
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_setup_exception
- */
-void *virtual_setup_exception( void *stack_ptr, size_t size, EXCEPTION_RECORD *rec )
-{
-    char *stack = stack_ptr;
-
-    if (is_inside_signal_stack( stack ))
-    {
-        ERR( "nested exception on signal stack in thread %04x addr %p stack %p (%p-%p-%p)\n",
-             GetCurrentThreadId(), rec->ExceptionAddress, stack, NtCurrentTeb()->DeallocationStack,
-             NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
-        abort_thread(1);
-    }
-
-    if (stack - size > stack || /* check for overflow in subtraction */
-        stack <= (char *)NtCurrentTeb()->DeallocationStack ||
-        stack > (char *)NtCurrentTeb()->Tib.StackBase)
-    {
-        WARN( "exception outside of stack limits in thread %04x addr %p stack %p (%p-%p-%p)\n",
-              GetCurrentThreadId(), rec->ExceptionAddress, stack, NtCurrentTeb()->DeallocationStack,
-              NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
-        return stack - size;
-    }
-
-    stack -= size;
-
-    if (stack < (char *)NtCurrentTeb()->DeallocationStack + 4096)
-    {
-        /* stack overflow on last page, unrecoverable */
-        UINT diff = (char *)NtCurrentTeb()->DeallocationStack + 4096 - stack;
-        ERR( "stack overflow %u bytes in thread %04x addr %p stack %p (%p-%p-%p)\n",
-             diff, GetCurrentThreadId(), rec->ExceptionAddress, stack, NtCurrentTeb()->DeallocationStack,
-             NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
-        abort_thread(1);
-    }
-    else if (stack < (char *)NtCurrentTeb()->Tib.StackLimit)
-    {
-        pthread_mutex_lock( &virtual_mutex );  /* no need for signal masking inside signal handler */
-        if ((get_page_vprot( stack ) & VPROT_GUARD) && grow_thread_stack( ROUND_ADDR( stack, page_mask )))
-        {
-            rec->ExceptionCode = STATUS_STACK_OVERFLOW;
-            rec->NumberParameters = 0;
-        }
-        pthread_mutex_unlock( &virtual_mutex );
-    }
-#if defined(VALGRIND_MAKE_MEM_UNDEFINED)
-    VALGRIND_MAKE_MEM_UNDEFINED( stack, size );
-#elif defined(VALGRIND_MAKE_WRITABLE)
-    VALGRIND_MAKE_WRITABLE( stack, size );
-#endif
-    return stack;
-}
-
-
-/***********************************************************************
- *           check_write_access
- *
- * Check if the memory range is writable, temporarily disabling write watches if necessary.
- */
-static NTSTATUS check_write_access( void *base, size_t size, BOOL *has_write_watch )
-{
-    size_t i;
-    char *addr = ROUND_ADDR( base, page_mask );
-
-    size = ROUND_SIZE( base, size );
-    for (i = 0; i < size; i += page_size)
-    {
-        BYTE vprot = get_page_vprot( addr + i );
-        if (vprot & VPROT_WRITEWATCH) *has_write_watch = TRUE;
-        if (!(get_unix_prot( vprot & ~VPROT_WRITEWATCH ) & PROT_WRITE))
-            return STATUS_INVALID_USER_BUFFER;
-    }
-    if (*has_write_watch)
-        mprotect_range( addr, size, 0, VPROT_WRITEWATCH );  /* temporarily enable write access */
-    return STATUS_SUCCESS;
-}
-
-
-/***********************************************************************
- *           virtual_locked_server_call
- */
-unsigned int virtual_locked_server_call( void *req_ptr )
-{
-    struct __server_request_info * const req = req_ptr;
-    sigset_t sigset;
-    void *addr = req->reply_data;
-    data_size_t size = req->u.req.request_header.reply_size;
-    BOOL has_write_watch = FALSE;
-    unsigned int ret = STATUS_ACCESS_VIOLATION;
-
-    if (!size) return wine_server_call( req_ptr );
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if (!(ret = check_write_access( addr, size, &has_write_watch )))
-    {
-        ret = server_call_unlocked( req );
-        if (has_write_watch) update_write_watches( addr, size, wine_server_reply_size( req ));
-    }
-    else memset( &req->u.reply, 0, sizeof(req->u.reply) );
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_locked_read
- */
-ssize_t virtual_locked_read( int fd, void *addr, size_t size )
-{
-    sigset_t sigset;
-    BOOL has_write_watch = FALSE;
-    int err = EFAULT;
-
-    ssize_t ret = read( fd, addr, size );
-    if (ret != -1 || errno != EFAULT) return ret;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if (!check_write_access( addr, size, &has_write_watch ))
-    {
-        ret = read( fd, addr, size );
-        err = errno;
-        if (has_write_watch) update_write_watches( addr, size, max( 0, ret ));
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    errno = err;
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_locked_pread
- */
-ssize_t virtual_locked_pread( int fd, void *addr, size_t size, off_t offset )
-{
-    sigset_t sigset;
-    BOOL has_write_watch = FALSE;
-    int err = EFAULT;
-
-    ssize_t ret = pread( fd, addr, size, offset );
-    if (ret != -1 || errno != EFAULT) return ret;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if (!check_write_access( addr, size, &has_write_watch ))
-    {
-        ret = pread( fd, addr, size, offset );
-        err = errno;
-        if (has_write_watch) update_write_watches( addr, size, max( 0, ret ));
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    errno = err;
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_locked_recvmsg
- */
-ssize_t CDECL virtual_locked_recvmsg( int fd, struct msghdr *hdr, int flags )
-{
-    sigset_t sigset;
-    size_t i;
-    BOOL has_write_watch = FALSE;
-    int err = EFAULT;
-
-    ssize_t ret = recvmsg( fd, hdr, flags );
-    if (ret != -1 || errno != EFAULT) return ret;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    for (i = 0; i < hdr->msg_iovlen; i++)
-        if (check_write_access( hdr->msg_iov[i].iov_base, hdr->msg_iov[i].iov_len, &has_write_watch ))
-            break;
-    if (i == hdr->msg_iovlen)
-    {
-        ret = recvmsg( fd, hdr, flags );
-        err = errno;
-    }
-    if (has_write_watch)
-        while (i--) update_write_watches( hdr->msg_iov[i].iov_base, hdr->msg_iov[i].iov_len, 0 );
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    errno = err;
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_is_valid_code_address
- */
-BOOL virtual_is_valid_code_address( const void *addr, SIZE_T size )
-{
-    struct file_view *view;
-    BOOL ret = FALSE;
-    sigset_t sigset;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if ((view = find_view( addr, size )))
-        ret = !(view->protect & VPROT_SYSTEM);  /* system views are not visible to the app */
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_check_buffer_for_read
- *
- * Check if a memory buffer can be read, triggering page faults if needed for DIB section access.
- */
-BOOL virtual_check_buffer_for_read( const void *ptr, SIZE_T size )
-{
-    if (!size) return TRUE;
-    if (!ptr) return FALSE;
-
-    __TRY
-    {
-        volatile const char *p = ptr;
-        char dummy __attribute__((unused));
-        SIZE_T count = size;
-
-        while (count > page_size)
-        {
-            dummy = *p;
-            p += page_size;
-            count -= page_size;
-        }
-        dummy = p[0];
-        dummy = p[count - 1];
-    }
-    __EXCEPT_PAGE_FAULT
-    {
-        return FALSE;
-    }
-    __ENDTRY
-    return TRUE;
-}
-
-
-/***********************************************************************
- *           virtual_check_buffer_for_write
- *
- * Check if a memory buffer can be written to, triggering page faults if needed for write watches.
- */
-BOOL virtual_check_buffer_for_write( void *ptr, SIZE_T size )
-{
-    if (!size) return TRUE;
-    if (!ptr) return FALSE;
-
-    __TRY
-    {
-        volatile char *p = ptr;
-        SIZE_T count = size;
-
-        while (count > page_size)
-        {
-            *p |= 0;
-            p += page_size;
-            count -= page_size;
-        }
-        p[0] |= 0;
-        p[count - 1] |= 0;
-    }
-    __EXCEPT_PAGE_FAULT
-    {
-        return FALSE;
-    }
-    __ENDTRY
-    return TRUE;
-}
-
-
-/*************************************************************
- *            IsBadStringPtrA
- *
- * IsBadStringPtrA replacement for ntdll, to catch exception in debug traces.
- */
-BOOL WINAPI IsBadStringPtrA( LPCSTR str, UINT_PTR max )
-{
-    if (!str) return TRUE;
-    __TRY
-    {
-        volatile const char *p = str;
-        while (p != str + max) if (!*p++) break;
-    }
-    __EXCEPT_PAGE_FAULT
-    {
-        return TRUE;
-    }
-    __ENDTRY
-    return FALSE;
-}
-
-
-/*************************************************************
- *            IsBadStringPtrW
- *
- * IsBadStringPtrW replacement for ntdll, to catch exception in debug traces.
- */
-BOOL WINAPI IsBadStringPtrW( LPCWSTR str, UINT_PTR max )
-{
-    if (!str) return TRUE;
-    __TRY
-    {
-        volatile const WCHAR *p = str;
-        while (p != str + max) if (!*p++) break;
-    }
-    __EXCEPT_PAGE_FAULT
-    {
-        return TRUE;
-    }
-    __ENDTRY
-    return FALSE;
-}
-
-
-/***********************************************************************
- *           virtual_uninterrupted_read_memory
- *
- * Similar to NtReadVirtualMemory, but without wineserver calls. Moreover
- * permissions are checked before accessing each page, to ensure that no
- * exceptions can happen.
- */
-SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size )
-{
-    struct file_view *view;
-    sigset_t sigset;
-    SIZE_T bytes_read = 0;
-
-    if (!size) return 0;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if ((view = find_view( addr, size )))
-    {
-        if (!(view->protect & VPROT_SYSTEM))
-        {
-            while (bytes_read < size && (get_unix_prot( get_page_vprot( addr )) & PROT_READ))
-            {
-                SIZE_T block_size = min( size - bytes_read, page_size - ((UINT_PTR)addr & page_mask) );
-                memcpy( buffer, addr, block_size );
-
-                addr   = (const void *)((const char *)addr + block_size);
-                buffer = (void *)((char *)buffer + block_size);
-                bytes_read += block_size;
-            }
-        }
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return bytes_read;
-}
-
-
-/***********************************************************************
- *           virtual_uninterrupted_write_memory
- *
- * Similar to NtWriteVirtualMemory, but without wineserver calls. Moreover
- * permissions are checked before accessing each page, to ensure that no
- * exceptions can happen.
- */
-NTSTATUS virtual_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size )
-{
-    BOOL has_write_watch = FALSE;
-    sigset_t sigset;
-    NTSTATUS ret;
-
-    if (!size) return STATUS_SUCCESS;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if (!(ret = check_write_access( addr, size, &has_write_watch )))
-    {
-        memcpy( addr, buffer, size );
-        if (has_write_watch) update_write_watches( addr, size, size );
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return ret;
-}
-
-
-/***********************************************************************
- *           virtual_set_force_exec
- *
- * Whether to force exec prot on all views.
- */
-void virtual_set_force_exec( BOOL enable )
-{
-    struct file_view *view;
-    sigset_t sigset;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if (!force_exec_prot != !enable)  /* change all existing views */
-    {
-        force_exec_prot = enable;
-
-        WINE_RB_FOR_EACH_ENTRY( view, &views_tree, struct file_view, entry )
-        {
-            /* file mappings are always accessible */
-            BYTE commit = is_view_valloc( view ) ? 0 : VPROT_COMMITTED;
-
-            mprotect_range( view->base, view->size, commit, 0 );
-        }
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-}
-
-struct free_range
-{
-    char *base;
-    char *limit;
-};
-
-/* free reserved areas above the limit; callback for mmap_enum_reserved_areas */
-static int CDECL free_reserved_memory( void *base, SIZE_T size, void *arg )
-{
-    struct free_range *range = arg;
-
-    if ((char *)base >= range->limit) return 0;
-    if ((char *)base + size <= range->base) return 0;
-    if ((char *)base < range->base)
-    {
-        size -= range->base - (char *)base;
-        base = range->base;
-    }
-    if ((char *)base + size > range->limit) size = range->limit - (char *)base;
-    remove_reserved_area( base, size );
-    return 1;  /* stop enumeration since the list has changed */
-}
-
-/***********************************************************************
- *           virtual_release_address_space
- *
- * Release some address space once we have loaded and initialized the app.
- */
-void CDECL virtual_release_address_space(void)
-{
-    struct free_range range;
-    sigset_t sigset;
-
-    if (is_win64) return;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    range.base  = (char *)0x82000000;
-    range.limit = user_space_limit;
-
-    if (range.limit > range.base)
-    {
-        while (mmap_enum_reserved_areas( free_reserved_memory, &range, 1 )) /* nothing */;
-#ifdef __APPLE__
-        /* On macOS, we still want to free some of low memory, for OpenGL resources */
-        range.base  = (char *)0x40000000;
-#else
-        range.base  = NULL;
-#endif
-    }
-    else
-        range.base = (char *)0x20000000;
-
-    if (range.base)
-    {
-        range.limit = (char *)0x7f000000;
-        while (mmap_enum_reserved_areas( free_reserved_memory, &range, 0 )) /* nothing */;
-    }
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-}
-
-
-/***********************************************************************
- *           virtual_set_large_address_space
- *
- * Enable use of a large address space when allowed by the application.
- */
-void virtual_set_large_address_space(void)
-{
-    /* no large address space on win9x */
-    if (NtCurrentTeb()->Peb->OSPlatformId != VER_PLATFORM_WIN32_NT) return;
-
-    user_space_limit = working_set_limit = address_space_limit;
-}
-
-
-/***********************************************************************
- *             NtAllocateVirtualMemory   (NTDLL.@)
- *             ZwAllocateVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG_PTR zero_bits,
-                                         SIZE_T *size_ptr, ULONG type, ULONG protect )
-{
-    void *base;
-    unsigned int vprot;
-    BOOL is_dos_memory = FALSE;
-    struct file_view *view;
-    sigset_t sigset;
-    SIZE_T size = *size_ptr;
-    NTSTATUS status = STATUS_SUCCESS;
-    unsigned short zero_bits_64 = zero_bits_win_to_64( zero_bits );
-
-    TRACE("%p %p %08lx %x %08x\n", process, *ret, size, type, protect );
-
-    if (!size) return STATUS_INVALID_PARAMETER;
-    if (zero_bits > 21 && zero_bits < 32) return STATUS_INVALID_PARAMETER_3;
-    if (!is_win64 && !is_wow64 && zero_bits >= 32) return STATUS_INVALID_PARAMETER_3;
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_alloc.type         = APC_VIRTUAL_ALLOC;
-        call.virtual_alloc.addr         = wine_server_client_ptr( *ret );
-        call.virtual_alloc.size         = *size_ptr;
-        call.virtual_alloc.zero_bits    = zero_bits;
-        call.virtual_alloc.op_type      = type;
-        call.virtual_alloc.prot         = protect;
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_alloc.status == STATUS_SUCCESS)
-        {
-            *ret      = wine_server_get_ptr( result.virtual_alloc.addr );
-            *size_ptr = result.virtual_alloc.size;
-        }
-        return result.virtual_alloc.status;
-    }
-
-    /* Round parameters to a page boundary */
-
-    if (is_beyond_limit( 0, size, working_set_limit )) return STATUS_WORKING_SET_LIMIT_RANGE;
-
-    if (*ret)
-    {
-        if (type & MEM_RESERVE) /* Round down to 64k boundary */
-            base = ROUND_ADDR( *ret, granularity_mask );
-        else
-            base = ROUND_ADDR( *ret, page_mask );
-        size = (((UINT_PTR)*ret + size + page_mask) & ~page_mask) - (UINT_PTR)base;
-
-        /* disallow low 64k, wrap-around and kernel space */
-        if (((char *)base < (char *)0x10000) ||
-            ((char *)base + size < (char *)base) ||
-            is_beyond_limit( base, size, address_space_limit ))
-        {
-            /* address 1 is magic to mean DOS area */
-            if (!base && *ret == (void *)1 && size == 0x110000) is_dos_memory = TRUE;
-            else return STATUS_INVALID_PARAMETER;
-        }
-    }
-    else
-    {
-        base = NULL;
-        size = (size + page_mask) & ~page_mask;
-    }
-
-    /* Compute the alloc type flags */
-
-    if (!(type & (MEM_COMMIT | MEM_RESERVE | MEM_RESET)) ||
-        (type & ~(MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN | MEM_WRITE_WATCH | MEM_RESET)))
-    {
-        WARN("called with wrong alloc type flags (%08x) !\n", type);
-        return STATUS_INVALID_PARAMETER;
-    }
-
-    /* Reserve the memory */
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if ((type & MEM_RESERVE) || !base)
-    {
-        if (!(status = get_vprot_flags( protect, &vprot, FALSE )))
-        {
-            if (type & MEM_COMMIT) vprot |= VPROT_COMMITTED;
-            if (type & MEM_WRITE_WATCH) vprot |= VPROT_WRITEWATCH;
-            if (protect & PAGE_NOCACHE) vprot |= SEC_NOCACHE;
-
-            if (vprot & VPROT_WRITECOPY) status = STATUS_INVALID_PAGE_PROTECTION;
-            else if (is_dos_memory) status = allocate_dos_memory( &view, vprot );
-            else status = map_view( &view, base, size, type & MEM_TOP_DOWN, vprot, zero_bits_64 );
-
-            if (status == STATUS_SUCCESS) base = view->base;
-        }
-    }
-    else if (type & MEM_RESET)
-    {
-        if (!(view = find_view( base, size ))) status = STATUS_NOT_MAPPED_VIEW;
-        else madvise( base, size, MADV_DONTNEED );
-    }
-    else  /* commit the pages */
-    {
-        if (!(view = find_view( base, size ))) status = STATUS_NOT_MAPPED_VIEW;
-        else if (view->protect & SEC_FILE) status = STATUS_ALREADY_COMMITTED;
-        else if (!(status = set_protection( view, base, size, protect )) && (view->protect & SEC_RESERVE))
-        {
-            SERVER_START_REQ( add_mapping_committed_range )
-            {
-                req->base   = wine_server_client_ptr( view->base );
-                req->offset = (char *)base - (char *)view->base;
-                req->size   = size;
-                wine_server_call( req );
-            }
-            SERVER_END_REQ;
-        }
-    }
-
-    if (!status) VIRTUAL_DEBUG_DUMP_VIEW( view );
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (status == STATUS_SUCCESS)
-    {
-        *ret = base;
-        *size_ptr = size;
-    }
-    return status;
-}
-
-
-/***********************************************************************
- *             NtFreeVirtualMemory   (NTDLL.@)
- *             ZwFreeVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtFreeVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr, ULONG type )
-{
-    struct file_view *view;
-    char *base;
-    sigset_t sigset;
-    NTSTATUS status = STATUS_SUCCESS;
-    LPVOID addr = *addr_ptr;
-    SIZE_T size = *size_ptr;
-
-    TRACE("%p %p %08lx %x\n", process, addr, size, type );
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_free.type      = APC_VIRTUAL_FREE;
-        call.virtual_free.addr      = wine_server_client_ptr( addr );
-        call.virtual_free.size      = size;
-        call.virtual_free.op_type   = type;
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_free.status == STATUS_SUCCESS)
-        {
-            *addr_ptr = wine_server_get_ptr( result.virtual_free.addr );
-            *size_ptr = result.virtual_free.size;
-        }
-        return result.virtual_free.status;
-    }
-
-    /* Fix the parameters */
-
-    size = ROUND_SIZE( addr, size );
-    base = ROUND_ADDR( addr, page_mask );
-
-    /* avoid freeing the DOS area when a broken app passes a NULL pointer */
-    if (!base) return STATUS_INVALID_PARAMETER;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (!(view = find_view( base, size )) || !is_view_valloc( view ))
-    {
-        status = STATUS_INVALID_PARAMETER;
-    }
-    else if (type == MEM_RELEASE)
-    {
-        /* Free the pages */
-
-        if (size || (base != view->base)) status = STATUS_INVALID_PARAMETER;
-        else
-        {
-            delete_view( view );
-            *addr_ptr = base;
-            *size_ptr = size;
-        }
-    }
-    else if (type == MEM_DECOMMIT)
-    {
-        status = decommit_pages( view, base - (char *)view->base, size );
-        if (status == STATUS_SUCCESS)
-        {
-            *addr_ptr = base;
-            *size_ptr = size;
-        }
-    }
-    else
-    {
-        WARN("called with wrong free type flags (%08x) !\n", type);
-        status = STATUS_INVALID_PARAMETER;
-    }
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtProtectVirtualMemory   (NTDLL.@)
- *             ZwProtectVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtProtectVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr,
-                                        ULONG new_prot, ULONG *old_prot )
-{
-    struct file_view *view;
-    sigset_t sigset;
-    NTSTATUS status = STATUS_SUCCESS;
-    char *base;
-    BYTE vprot;
-    SIZE_T size = *size_ptr;
-    LPVOID addr = *addr_ptr;
-    DWORD old;
-
-    TRACE("%p %p %08lx %08x\n", process, addr, size, new_prot );
-
-    if (!old_prot)
-        return STATUS_ACCESS_VIOLATION;
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_protect.type = APC_VIRTUAL_PROTECT;
-        call.virtual_protect.addr = wine_server_client_ptr( addr );
-        call.virtual_protect.size = size;
-        call.virtual_protect.prot = new_prot;
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_protect.status == STATUS_SUCCESS)
-        {
-            *addr_ptr = wine_server_get_ptr( result.virtual_protect.addr );
-            *size_ptr = result.virtual_protect.size;
-            *old_prot = result.virtual_protect.prot;
-        }
-        return result.virtual_protect.status;
-    }
-
-    /* Fix the parameters */
-
-    size = ROUND_SIZE( addr, size );
-    base = ROUND_ADDR( addr, page_mask );
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if ((view = find_view( base, size )))
-    {
-        /* Make sure all the pages are committed */
-        if (get_committed_size( view, base, &vprot ) >= size && (vprot & VPROT_COMMITTED))
-        {
-            old = get_win32_prot( vprot, view->protect );
-            status = set_protection( view, base, size, new_prot );
-        }
-        else status = STATUS_NOT_COMMITTED;
-    }
-    else status = STATUS_INVALID_PARAMETER;
-
-    if (!status) VIRTUAL_DEBUG_DUMP_VIEW( view );
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (status == STATUS_SUCCESS)
-    {
-        *addr_ptr = base;
-        *size_ptr = size;
-        *old_prot = old;
-    }
-    return status;
-}
-
-
-/* retrieve state for a free memory area; callback for mmap_enum_reserved_areas */
-static int CDECL get_free_mem_state_callback( void *start, SIZE_T size, void *arg )
-{
-    MEMORY_BASIC_INFORMATION *info = arg;
-    void *end = (char *)start + size;
-
-    if ((char *)info->BaseAddress + info->RegionSize <= (char *)start) return 0;
-
-    if (info->BaseAddress >= end)
-    {
-        if (info->AllocationBase < end) info->AllocationBase = end;
-        return 0;
-    }
-
-    if (info->BaseAddress >= start || start <= address_space_start)
-    {
-        /* it's a real free area */
-        info->State             = MEM_FREE;
-        info->Protect           = PAGE_NOACCESS;
-        info->AllocationBase    = 0;
-        info->AllocationProtect = 0;
-        info->Type              = 0;
-        if ((char *)info->BaseAddress + info->RegionSize > (char *)end)
-            info->RegionSize = (char *)end - (char *)info->BaseAddress;
-    }
-    else /* outside of the reserved area, pretend it's allocated */
-    {
-        info->RegionSize        = (char *)start - (char *)info->BaseAddress;
-        info->State             = MEM_RESERVE;
-        info->Protect           = PAGE_NOACCESS;
-        info->AllocationProtect = PAGE_NOACCESS;
-        info->Type              = MEM_PRIVATE;
-    }
-    return 1;
-}
-
-/* get basic information about a memory block */
-static NTSTATUS get_basic_memory_info( HANDLE process, LPCVOID addr,
-                                       MEMORY_BASIC_INFORMATION *info,
-                                       SIZE_T len, SIZE_T *res_len )
-{
-    struct file_view *view;
-    char *base, *alloc_base = 0, *alloc_end = working_set_limit;
-    struct wine_rb_entry *ptr;
-    sigset_t sigset;
-
-    if (len < sizeof(MEMORY_BASIC_INFORMATION))
-        return STATUS_INFO_LENGTH_MISMATCH;
-
-    if (process != NtCurrentProcess())
-    {
-        NTSTATUS status;
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_query.type = APC_VIRTUAL_QUERY;
-        call.virtual_query.addr = wine_server_client_ptr( addr );
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_query.status == STATUS_SUCCESS)
-        {
-            info->BaseAddress       = wine_server_get_ptr( result.virtual_query.base );
-            info->AllocationBase    = wine_server_get_ptr( result.virtual_query.alloc_base );
-            info->RegionSize        = result.virtual_query.size;
-            info->Protect           = result.virtual_query.prot;
-            info->AllocationProtect = result.virtual_query.alloc_prot;
-            info->State             = (DWORD)result.virtual_query.state << 12;
-            info->Type              = (DWORD)result.virtual_query.alloc_type << 16;
-            if (info->RegionSize != result.virtual_query.size)  /* truncated */
-                return STATUS_INVALID_PARAMETER;  /* FIXME */
-            if (res_len) *res_len = sizeof(*info);
-        }
-        return result.virtual_query.status;
-    }
-
-    base = ROUND_ADDR( addr, page_mask );
-
-    if (is_beyond_limit( base, 1, working_set_limit )) return STATUS_INVALID_PARAMETER;
-
-    /* Find the view containing the address */
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    ptr = views_tree.root;
-    while (ptr)
-    {
-        view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
-        if ((char *)view->base > base)
-        {
-            alloc_end = view->base;
-            ptr = ptr->left;
-        }
-        else if ((char *)view->base + view->size <= base)
-        {
-            alloc_base = (char *)view->base + view->size;
-            ptr = ptr->right;
-        }
-        else
-        {
-            alloc_base = view->base;
-            alloc_end = (char *)view->base + view->size;
-            break;
-        }
-    }
-
-    /* Fill the info structure */
-
-    info->AllocationBase = alloc_base;
-    info->BaseAddress    = base;
-    info->RegionSize     = alloc_end - base;
-
-    if (!ptr)
-    {
-        if (!mmap_enum_reserved_areas( get_free_mem_state_callback, info, 0 ))
-        {
-            /* not in a reserved area at all, pretend it's allocated */
-#ifdef __i386__
-            if (base >= (char *)address_space_start)
-            {
-                info->State             = MEM_RESERVE;
-                info->Protect           = PAGE_NOACCESS;
-                info->AllocationProtect = PAGE_NOACCESS;
-                info->Type              = MEM_PRIVATE;
-            }
-            else
-#endif
-            {
-                info->State             = MEM_FREE;
-                info->Protect           = PAGE_NOACCESS;
-                info->AllocationBase    = 0;
-                info->AllocationProtect = 0;
-                info->Type              = 0;
-            }
-        }
-    }
-    else
-    {
-        BYTE vprot;
-        char *ptr;
-        SIZE_T range_size = get_committed_size( view, base, &vprot );
-
-        info->State = (vprot & VPROT_COMMITTED) ? MEM_COMMIT : MEM_RESERVE;
-        info->Protect = (vprot & VPROT_COMMITTED) ? get_win32_prot( vprot, view->protect ) : 0;
-        info->AllocationProtect = get_win32_prot( view->protect, view->protect );
-        if (view->protect & SEC_IMAGE) info->Type = MEM_IMAGE;
-        else if (view->protect & (SEC_FILE | SEC_RESERVE | SEC_COMMIT)) info->Type = MEM_MAPPED;
-        else info->Type = MEM_PRIVATE;
-        for (ptr = base; ptr < base + range_size; ptr += page_size)
-            if ((get_page_vprot( ptr ) ^ vprot) & ~VPROT_WRITEWATCH) break;
-        info->RegionSize = ptr - base;
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (res_len) *res_len = sizeof(*info);
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS get_working_set_ex( HANDLE process, LPCVOID addr,
-                                    MEMORY_WORKING_SET_EX_INFORMATION *info,
-                                    SIZE_T len, SIZE_T *res_len )
-{
-    FILE *f;
-    MEMORY_WORKING_SET_EX_INFORMATION *p;
-    sigset_t sigset;
-
-    if (process != NtCurrentProcess())
-    {
-        FIXME( "(process=%p,addr=%p) Unimplemented information class: MemoryWorkingSetExInformation\n", process, addr );
-        return STATUS_INVALID_INFO_CLASS;
-    }
-
-    f = fopen( "/proc/self/pagemap", "rb" );
-    if (!f)
-    {
-        static int once;
-        if (!once++) WARN( "unable to open /proc/self/pagemap\n" );
-    }
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    for (p = info; (UINT_PTR)(p + 1) <= (UINT_PTR)info + len; p++)
-    {
-        BYTE vprot;
-        UINT64 pagemap;
-        struct file_view *view;
-
-        memset( &p->VirtualAttributes, 0, sizeof(p->VirtualAttributes) );
-
-        /* If we don't have pagemap information, default to invalid. */
-        if (!f || fseek( f, ((UINT_PTR)p->VirtualAddress >> 12) * sizeof(pagemap), SEEK_SET ) == -1 ||
-                fread( &pagemap, sizeof(pagemap), 1, f ) != 1)
-        {
-            pagemap = 0;
-        }
-
-        if ((view = find_view( p->VirtualAddress, 0 )) &&
-                get_committed_size( view, p->VirtualAddress, &vprot ) &&
-                (vprot & VPROT_COMMITTED))
-        {
-            p->VirtualAttributes.Valid = !(vprot & VPROT_GUARD) && (vprot & 0x0f) && (pagemap >> 63);
-            p->VirtualAttributes.Shared = !is_view_valloc( view ) && ((pagemap >> 61) & 1);
-            if (p->VirtualAttributes.Shared && p->VirtualAttributes.Valid)
-                p->VirtualAttributes.ShareCount = 1; /* FIXME */
-            if (p->VirtualAttributes.Valid)
-                p->VirtualAttributes.Win32Protection = get_win32_prot( vprot, view->protect );
-        }
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (f)
-        fclose( f );
-    if (res_len)
-        *res_len = (UINT_PTR)p - (UINT_PTR)info;
-    return STATUS_SUCCESS;
-}
-
-#define UNIMPLEMENTED_INFO_CLASS(c) \
-    case c: \
-        FIXME("(process=%p,addr=%p) Unimplemented information class: " #c "\n", process, addr); \
-        return STATUS_INVALID_INFO_CLASS
-
-/***********************************************************************
- *             NtQueryVirtualMemory   (NTDLL.@)
- *             ZwQueryVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQueryVirtualMemory( HANDLE process, LPCVOID addr,
-                                      MEMORY_INFORMATION_CLASS info_class,
-                                      PVOID buffer, SIZE_T len, SIZE_T *res_len )
-{
-    TRACE("(%p, %p, info_class=%d, %p, %ld, %p)\n",
-          process, addr, info_class, buffer, len, res_len);
-
-    switch(info_class)
-    {
-        case MemoryBasicInformation:
-            return get_basic_memory_info( process, addr, buffer, len, res_len );
-
-        case MemoryWorkingSetExInformation:
-            return get_working_set_ex( process, addr, buffer, len, res_len );
-
-        UNIMPLEMENTED_INFO_CLASS(MemoryWorkingSetList);
-        UNIMPLEMENTED_INFO_CLASS(MemorySectionName);
-        UNIMPLEMENTED_INFO_CLASS(MemoryBasicVlmInformation);
-
-        default:
-            FIXME("(%p,%p,info_class=%d,%p,%ld,%p) Unknown information class\n",
-                  process, addr, info_class, buffer, len, res_len);
-            return STATUS_INVALID_INFO_CLASS;
-    }
-}
-
-
-/***********************************************************************
- *             NtLockVirtualMemory   (NTDLL.@)
- *             ZwLockVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtLockVirtualMemory( HANDLE process, PVOID *addr, SIZE_T *size, ULONG unknown )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_lock.type = APC_VIRTUAL_LOCK;
-        call.virtual_lock.addr = wine_server_client_ptr( *addr );
-        call.virtual_lock.size = *size;
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_lock.status == STATUS_SUCCESS)
-        {
-            *addr = wine_server_get_ptr( result.virtual_lock.addr );
-            *size = result.virtual_lock.size;
-        }
-        return result.virtual_lock.status;
-    }
-
-    *size = ROUND_SIZE( *addr, *size );
-    *addr = ROUND_ADDR( *addr, page_mask );
-
-    if (mlock( *addr, *size )) status = STATUS_ACCESS_DENIED;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtUnlockVirtualMemory   (NTDLL.@)
- *             ZwUnlockVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtUnlockVirtualMemory( HANDLE process, PVOID *addr, SIZE_T *size, ULONG unknown )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_unlock.type = APC_VIRTUAL_UNLOCK;
-        call.virtual_unlock.addr = wine_server_client_ptr( *addr );
-        call.virtual_unlock.size = *size;
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_unlock.status == STATUS_SUCCESS)
-        {
-            *addr = wine_server_get_ptr( result.virtual_unlock.addr );
-            *size = result.virtual_unlock.size;
-        }
-        return result.virtual_unlock.status;
-    }
-
-    *size = ROUND_SIZE( *addr, *size );
-    *addr = ROUND_ADDR( *addr, page_mask );
-
-    if (munlock( *addr, *size )) status = STATUS_ACCESS_DENIED;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtMapViewOfSection   (NTDLL.@)
- *             ZwMapViewOfSection   (NTDLL.@)
- */
-NTSTATUS WINAPI NtMapViewOfSection( HANDLE handle, HANDLE process, PVOID *addr_ptr, ULONG_PTR zero_bits,
-                                    SIZE_T commit_size, const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr,
-                                    SECTION_INHERIT inherit, ULONG alloc_type, ULONG protect )
-{
-    NTSTATUS res;
-    SIZE_T mask = granularity_mask;
-    pe_image_info_t image_info;
-    LARGE_INTEGER offset;
-    unsigned short zero_bits_64 = zero_bits_win_to_64( zero_bits );
-
-    offset.QuadPart = offset_ptr ? offset_ptr->QuadPart : 0;
-
-    TRACE("handle=%p process=%p addr=%p off=%x%08x size=%lx access=%x\n",
-          handle, process, *addr_ptr, offset.u.HighPart, offset.u.LowPart, *size_ptr, protect );
-
-    /* Check parameters */
-    if (zero_bits > 21 && zero_bits < 32)
-        return STATUS_INVALID_PARAMETER_4;
-    if (!is_win64 && !is_wow64 && zero_bits >= 32)
-        return STATUS_INVALID_PARAMETER_4;
-
-    /* If both addr_ptr and zero_bits are passed, they have match */
-    if (*addr_ptr && zero_bits && zero_bits < 32 &&
-        (((UINT_PTR)*addr_ptr) >> (32 - zero_bits)))
-        return STATUS_INVALID_PARAMETER_4;
-    if (*addr_ptr && zero_bits >= 32 &&
-        (((UINT_PTR)*addr_ptr) & ~zero_bits))
-        return STATUS_INVALID_PARAMETER_4;
-
-#ifndef _WIN64
-    if (!is_wow64 && (alloc_type & AT_ROUND_TO_PAGE))
-    {
-        *addr_ptr = ROUND_ADDR( *addr_ptr, page_mask );
-        mask = page_mask;
-    }
-#endif
-
-    if ((offset.u.LowPart & mask) || (*addr_ptr && ((UINT_PTR)*addr_ptr & mask)))
-        return STATUS_MAPPED_ALIGNMENT;
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.map_view.type         = APC_MAP_VIEW;
-        call.map_view.handle       = wine_server_obj_handle( handle );
-        call.map_view.addr         = wine_server_client_ptr( *addr_ptr );
-        call.map_view.size         = *size_ptr;
-        call.map_view.offset       = offset.QuadPart;
-        call.map_view.zero_bits    = zero_bits;
-        call.map_view.alloc_type   = alloc_type;
-        call.map_view.prot         = protect;
-        res = server_queue_process_apc( process, &call, &result );
-        if (res != STATUS_SUCCESS) return res;
-
-        if ((NTSTATUS)result.map_view.status >= 0)
-        {
-            *addr_ptr = wine_server_get_ptr( result.map_view.addr );
-            *size_ptr = result.map_view.size;
-        }
-        return result.map_view.status;
-    }
-
-    return virtual_map_section( handle, addr_ptr, zero_bits_64, commit_size,
-                                offset_ptr, size_ptr, alloc_type, protect,
-                                &image_info );
-}
-
-
-/***********************************************************************
- *             NtUnmapViewOfSection   (NTDLL.@)
- *             ZwUnmapViewOfSection   (NTDLL.@)
- */
-NTSTATUS WINAPI NtUnmapViewOfSection( HANDLE process, PVOID addr )
-{
-    struct file_view *view;
-    NTSTATUS status = STATUS_NOT_MAPPED_VIEW;
-    sigset_t sigset;
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.unmap_view.type = APC_UNMAP_VIEW;
-        call.unmap_view.addr = wine_server_client_ptr( addr );
-        status = server_queue_process_apc( process, &call, &result );
-        if (status == STATUS_SUCCESS) status = result.unmap_view.status;
-        return status;
-    }
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if ((view = find_view( addr, 0 )) && !is_view_valloc( view ))
-    {
-        if (!(view->protect & VPROT_SYSTEM))
-        {
-            SERVER_START_REQ( unmap_view )
-            {
-                req->base = wine_server_client_ptr( view->base );
-                status = wine_server_call( req );
-            }
-            SERVER_END_REQ;
-            if (!status) delete_view( view );
-            else FIXME( "failed to unmap %p %x\n", view->base, status );
-        }
-        else
-        {
-            delete_view( view );
-            status = STATUS_SUCCESS;
-        }
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/******************************************************************************
- *             virtual_fill_image_information
- *
- * Helper for NtQuerySection.
- */
-void virtual_fill_image_information( const pe_image_info_t *pe_info, SECTION_IMAGE_INFORMATION *info )
-{
-    info->TransferAddress      = wine_server_get_ptr( pe_info->entry_point );
-    info->ZeroBits             = pe_info->zerobits;
-    info->MaximumStackSize     = pe_info->stack_size;
-    info->CommittedStackSize   = pe_info->stack_commit;
-    info->SubSystemType        = pe_info->subsystem;
-    info->SubsystemVersionLow  = pe_info->subsystem_low;
-    info->SubsystemVersionHigh = pe_info->subsystem_high;
-    info->GpValue              = pe_info->gp;
-    info->ImageCharacteristics = pe_info->image_charact;
-    info->DllCharacteristics   = pe_info->dll_charact;
-    info->Machine              = pe_info->machine;
-    info->ImageContainsCode    = pe_info->contains_code;
-    info->ImageFlags           = pe_info->image_flags & ~(IMAGE_FLAGS_WineBuiltin|IMAGE_FLAGS_WineFakeDll);
-    info->LoaderFlags          = pe_info->loader_flags;
-    info->ImageFileSize        = pe_info->file_size;
-    info->CheckSum             = pe_info->checksum;
-#ifndef _WIN64 /* don't return 64-bit values to 32-bit processes */
-    if (pe_info->machine == IMAGE_FILE_MACHINE_AMD64 || pe_info->machine == IMAGE_FILE_MACHINE_ARM64)
-    {
-        info->TransferAddress = (void *)0x81231234;  /* sic */
-        info->MaximumStackSize = 0x100000;
-        info->CommittedStackSize = 0x10000;
-    }
-#endif
-}
-
-/******************************************************************************
- *             NtQuerySection   (NTDLL.@)
- *             ZwQuerySection   (NTDLL.@)
- */
-NTSTATUS WINAPI NtQuerySection( HANDLE handle, SECTION_INFORMATION_CLASS class, void *ptr,
-                                SIZE_T size, SIZE_T *ret_size )
-{
-    NTSTATUS status;
-    pe_image_info_t image_info;
-
-    switch (class)
-    {
-    case SectionBasicInformation:
-        if (size < sizeof(SECTION_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    case SectionImageInformation:
-        if (size < sizeof(SECTION_IMAGE_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
-        break;
-    default:
-	FIXME( "class %u not implemented\n", class );
-	return STATUS_NOT_IMPLEMENTED;
-    }
-    if (!ptr) return STATUS_ACCESS_VIOLATION;
-
-    SERVER_START_REQ( get_mapping_info )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->access = SECTION_QUERY;
-        wine_server_set_reply( req, &image_info, sizeof(image_info) );
-        if (!(status = wine_server_call( req )))
-        {
-            if (class == SectionBasicInformation)
-            {
-                SECTION_BASIC_INFORMATION *info = ptr;
-                info->Attributes    = reply->flags;
-                info->BaseAddress   = NULL;
-                info->Size.QuadPart = reply->size;
-                if (ret_size) *ret_size = sizeof(*info);
-            }
-            else if (reply->flags & SEC_IMAGE)
-            {
-                SECTION_IMAGE_INFORMATION *info = ptr;
-                virtual_fill_image_information( &image_info, info );
-                if (ret_size) *ret_size = sizeof(*info);
-            }
-            else status = STATUS_SECTION_NOT_IMAGE;
-        }
-    }
-    SERVER_END_REQ;
-
-    return status;
-}
-
-
-/***********************************************************************
- *             NtFlushVirtualMemory   (NTDLL.@)
- *             ZwFlushVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtFlushVirtualMemory( HANDLE process, LPCVOID *addr_ptr,
-                                      SIZE_T *size_ptr, ULONG unknown )
-{
-    struct file_view *view;
-    NTSTATUS status = STATUS_SUCCESS;
-    sigset_t sigset;
-    void *addr = ROUND_ADDR( *addr_ptr, page_mask );
-
-    if (process != NtCurrentProcess())
-    {
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_flush.type = APC_VIRTUAL_FLUSH;
-        call.virtual_flush.addr = wine_server_client_ptr( addr );
-        call.virtual_flush.size = *size_ptr;
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_flush.status == STATUS_SUCCESS)
-        {
-            *addr_ptr = wine_server_get_ptr( result.virtual_flush.addr );
-            *size_ptr = result.virtual_flush.size;
-        }
-        return result.virtual_flush.status;
-    }
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-    if (!(view = find_view( addr, *size_ptr ))) status = STATUS_INVALID_PARAMETER;
-    else
-    {
-        if (!*size_ptr) *size_ptr = view->size;
-        *addr_ptr = addr;
-#ifdef MS_ASYNC
-        if (msync( addr, *size_ptr, MS_ASYNC )) status = STATUS_NOT_MAPPED_DATA;
-#endif
-    }
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtGetWriteWatch   (NTDLL.@)
- *             ZwGetWriteWatch   (NTDLL.@)
- */
-NTSTATUS WINAPI NtGetWriteWatch( HANDLE process, ULONG flags, PVOID base, SIZE_T size, PVOID *addresses,
-                                 ULONG_PTR *count, ULONG *granularity )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-    sigset_t sigset;
-
-    size = ROUND_SIZE( base, size );
-    base = ROUND_ADDR( base, page_mask );
-
-    if (!count || !granularity) return STATUS_ACCESS_VIOLATION;
-    if (!*count || !size) return STATUS_INVALID_PARAMETER;
-    if (flags & ~WRITE_WATCH_FLAG_RESET) return STATUS_INVALID_PARAMETER;
-
-    if (!addresses) return STATUS_ACCESS_VIOLATION;
-
-    TRACE( "%p %x %p-%p %p %lu\n", process, flags, base, (char *)base + size,
-           addresses, *count );
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (is_write_watch_range( base, size ))
-    {
-        ULONG_PTR pos = 0;
-        char *addr = base;
-        char *end = addr + size;
-
-        while (pos < *count && addr < end)
-        {
-            if (!(get_page_vprot( addr ) & VPROT_WRITEWATCH)) addresses[pos++] = addr;
-            addr += page_size;
-        }
-        if (flags & WRITE_WATCH_FLAG_RESET) reset_write_watches( base, addr - (char *)base );
-        *count = pos;
-        *granularity = page_size;
-    }
-    else status = STATUS_INVALID_PARAMETER;
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtResetWriteWatch   (NTDLL.@)
- *             ZwResetWriteWatch   (NTDLL.@)
- */
-NTSTATUS WINAPI NtResetWriteWatch( HANDLE process, PVOID base, SIZE_T size )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-    sigset_t sigset;
-
-    size = ROUND_SIZE( base, size );
-    base = ROUND_ADDR( base, page_mask );
-
-    TRACE( "%p %p-%p\n", process, base, (char *)base + size );
-
-    if (!size) return STATUS_INVALID_PARAMETER;
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    if (is_write_watch_range( base, size ))
-        reset_write_watches( base, size );
-    else
-        status = STATUS_INVALID_PARAMETER;
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/***********************************************************************
- *             NtReadVirtualMemory   (NTDLL.@)
- *             ZwReadVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtReadVirtualMemory( HANDLE process, const void *addr, void *buffer,
-                                     SIZE_T size, SIZE_T *bytes_read )
-{
-    NTSTATUS status;
-
-    if (virtual_check_buffer_for_write( buffer, size ))
-    {
-        SERVER_START_REQ( read_process_memory )
-        {
-            req->handle = wine_server_obj_handle( process );
-            req->addr   = wine_server_client_ptr( addr );
-            wine_server_set_reply( req, buffer, size );
-            if ((status = wine_server_call( req ))) size = 0;
-        }
-        SERVER_END_REQ;
-    }
-    else
-    {
-        status = STATUS_ACCESS_VIOLATION;
-        size = 0;
-    }
-    if (bytes_read) *bytes_read = size;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtWriteVirtualMemory   (NTDLL.@)
- *             ZwWriteVirtualMemory   (NTDLL.@)
- */
-NTSTATUS WINAPI NtWriteVirtualMemory( HANDLE process, void *addr, const void *buffer,
-                                      SIZE_T size, SIZE_T *bytes_written )
-{
-    NTSTATUS status;
-
-    if (virtual_check_buffer_for_read( buffer, size ))
-    {
-        SERVER_START_REQ( write_process_memory )
-        {
-            req->handle     = wine_server_obj_handle( process );
-            req->addr       = wine_server_client_ptr( addr );
-            wine_server_add_data( req, buffer, size );
-            if ((status = wine_server_call( req ))) size = 0;
-        }
-        SERVER_END_REQ;
-    }
-    else
-    {
-        status = STATUS_PARTIAL_COPY;
-        size = 0;
-    }
-    if (bytes_written) *bytes_written = size;
-    return status;
-}
-
-
-/***********************************************************************
- *             NtAreMappedFilesTheSame   (NTDLL.@)
- *             ZwAreMappedFilesTheSame   (NTDLL.@)
- */
-NTSTATUS WINAPI NtAreMappedFilesTheSame(PVOID addr1, PVOID addr2)
-{
-    struct file_view *view1, *view2;
-    NTSTATUS status;
-    sigset_t sigset;
-
-    TRACE("%p %p\n", addr1, addr2);
-
-    server_enter_uninterrupted_section( &virtual_mutex, &sigset );
-
-    view1 = find_view( addr1, 0 );
-    view2 = find_view( addr2, 0 );
-
-    if (!view1 || !view2)
-        status = STATUS_INVALID_ADDRESS;
-    else if (is_view_valloc( view1 ) || is_view_valloc( view2 ))
-        status = STATUS_CONFLICTING_ADDRESSES;
-    else if (view1 == view2)
-        status = STATUS_SUCCESS;
-    else if ((view1->protect & VPROT_SYSTEM) || (view2->protect & VPROT_SYSTEM))
-        status = STATUS_NOT_SAME_DEVICE;
-    else
-    {
-        SERVER_START_REQ( is_same_mapping )
-        {
-            req->base1 = wine_server_client_ptr( view1->base );
-            req->base2 = wine_server_client_ptr( view2->base );
-            status = wine_server_call( req );
-        }
-        SERVER_END_REQ;
-    }
-
-    server_leave_uninterrupted_section( &virtual_mutex, &sigset );
-    return status;
-}
-
-
-/**********************************************************************
- *           NtFlushInstructionCache  (NTDLL.@)
- */
-NTSTATUS WINAPI NtFlushInstructionCache( HANDLE handle, const void *addr, SIZE_T size )
-{
-#if defined(__x86_64__) || defined(__i386__)
-    /* no-op */
-#elif defined(HAVE___CLEAR_CACHE)
-    if (handle == GetCurrentProcess())
-    {
-        __clear_cache( (char *)addr, (char *)addr + size );
-    }
-    else
-    {
-        static int once;
-        if (!once++) FIXME( "%p %p %ld other process not supported\n", handle, addr, size );
-    }
-#else
-    static int once;
-    if (!once++) FIXME( "%p %p %ld\n", handle, addr, size );
-#endif
-    return STATUS_SUCCESS;
-}
-
-
-/**********************************************************************
- *           NtFlushProcessWriteBuffers  (NTDLL.@)
- */
-void WINAPI NtFlushProcessWriteBuffers(void)
-{
-    static int once = 0;
-    if (!once++) FIXME( "stub\n" );
-}
-
-
-/**********************************************************************
- *           NtCreatePagingFile  (NTDLL.@)
- */
-NTSTATUS WINAPI NtCreatePagingFile( UNICODE_STRING *name, LARGE_INTEGER *min_size,
-                                    LARGE_INTEGER *max_size, LARGE_INTEGER *actual_size )
-{
-    FIXME( "(%s %p %p %p) stub\n", debugstr_us(name), min_size, max_size, actual_size );
-    return STATUS_SUCCESS;
+    mmap_init( preload_info ? *preload_info : NULL );
 }
diff --git a/dlls/ntdll/unixlib.h b/dlls/ntdll/unixlib.h
index 2f57873671..d8683e17c5 100644
--- a/dlls/ntdll/unixlib.h
+++ b/dlls/ntdll/unixlib.h
@@ -21,107 +21,37 @@
 #ifndef __NTDLL_UNIXLIB_H
 #define __NTDLL_UNIXLIB_H
 
-#include "wine/server.h"
 #include "wine/debug.h"
 
-struct msghdr;
-struct _DISPATCHER_CONTEXT;
-
 /* increment this when you change the function table */
-#define NTDLL_UNIXLIB_VERSION 93
+#define NTDLL_UNIXLIB_VERSION 7
 
 struct unix_funcs
 {
-    /* Nt* functions */
-    TEB *         (WINAPI *NtCurrentTeb)(void);
-
-    /* other Win32 API functions */
-    NTSTATUS      (WINAPI *DbgUiIssueRemoteBreakin)( HANDLE process );
-    LONGLONG      (WINAPI *RtlGetSystemTimePrecise)(void);
-    NTSTATUS      (WINAPI *RtlWaitOnAddress)( const void *addr, const void *cmp, SIZE_T size,
-                                              const LARGE_INTEGER *timeout );
-    void          (WINAPI *RtlWakeAddressAll)( const void *addr );
-    void          (WINAPI *RtlWakeAddressSingle)( const void *addr );
-
-    /* fast locks */
-    NTSTATUS      (CDECL *fast_RtlpWaitForCriticalSection)( RTL_CRITICAL_SECTION *crit, int timeout );
-    NTSTATUS      (CDECL *fast_RtlpUnWaitCriticalSection)( RTL_CRITICAL_SECTION *crit );
-    NTSTATUS      (CDECL *fast_RtlDeleteCriticalSection)( RTL_CRITICAL_SECTION *crit );
-    NTSTATUS      (CDECL *fast_RtlTryAcquireSRWLockExclusive)( RTL_SRWLOCK *lock );
-    NTSTATUS      (CDECL *fast_RtlAcquireSRWLockExclusive)( RTL_SRWLOCK *lock );
-    NTSTATUS      (CDECL *fast_RtlTryAcquireSRWLockShared)( RTL_SRWLOCK *lock );
-    NTSTATUS      (CDECL *fast_RtlAcquireSRWLockShared)( RTL_SRWLOCK *lock );
-    NTSTATUS      (CDECL *fast_RtlReleaseSRWLockExclusive)( RTL_SRWLOCK *lock );
-    NTSTATUS      (CDECL *fast_RtlReleaseSRWLockShared)( RTL_SRWLOCK *lock );
-    NTSTATUS      (CDECL *fast_RtlSleepConditionVariableSRW)( RTL_CONDITION_VARIABLE *variable,
-                                                              RTL_SRWLOCK *lock,
-                                                              const LARGE_INTEGER *timeout, ULONG flags );
-    NTSTATUS      (CDECL *fast_RtlSleepConditionVariableCS)( RTL_CONDITION_VARIABLE *variable,
-                                                             RTL_CRITICAL_SECTION *cs,
-                                                             const LARGE_INTEGER *timeout );
-    NTSTATUS      (CDECL *fast_RtlWakeConditionVariable)( RTL_CONDITION_VARIABLE *variable, int count );
-
-    /* math functions */
-    double        (CDECL *atan)( double d );
-    double        (CDECL *ceil)( double d );
-    double        (CDECL *cos)( double d );
-    double        (CDECL *fabs)( double d );
-    double        (CDECL *floor)( double d );
-    double        (CDECL *log)( double d );
-    double        (CDECL *pow)( double x, double y );
-    double        (CDECL *sin)( double d );
-    double        (CDECL *sqrt)( double d );
-    double        (CDECL *tan)( double d );
-
     /* environment functions */
-    NTSTATUS      (CDECL *get_initial_environment)( WCHAR **wargv[], WCHAR *env, SIZE_T *size );
-    NTSTATUS      (CDECL *get_startup_info)( startup_info_t *info, SIZE_T *total_size, SIZE_T *info_size );
-    NTSTATUS      (CDECL *get_dynamic_environment)( WCHAR *env, SIZE_T *size );
-    void          (CDECL *get_initial_console)( HANDLE *handle, HANDLE *std_in,
-                                                HANDLE *std_out, HANDLE *std_err );
-    void          (CDECL *get_initial_directory)( UNICODE_STRING *dir );
-    USHORT *      (CDECL *get_unix_codepage_data)(void);
-    void          (CDECL *get_locales)( WCHAR *sys, WCHAR *user );
+    void          (CDECL *get_main_args)( int *argc, char **argv[], char **envp[] );
+    void          (CDECL *get_paths)( const char **builddir, const char **datadir, const char **configdir );
+    void          (CDECL *get_dll_path)( const char ***paths, SIZE_T *maxlen );
+    void          (CDECL *get_unix_codepage)( CPTABLEINFO *table );
     const char *  (CDECL *get_version)(void);
     const char *  (CDECL *get_build_id)(void);
     void          (CDECL *get_host_version)( const char **sysname, const char **release );
 
-    /* virtual memory functions */
-    NTSTATUS      (CDECL *virtual_map_section)( HANDLE handle, PVOID *addr_ptr, unsigned short zero_bits_64, SIZE_T commit_size,
-                                                const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr, ULONG alloc_type,
-                                                ULONG protect, pe_image_info_t *image_info );
-    ssize_t       (CDECL *virtual_locked_recvmsg)( int fd, struct msghdr *hdr, int flags );
-    void          (CDECL *virtual_release_address_space)(void);
-
-    /* thread/process functions */
-    NTSTATUS      (CDECL *exec_process)( UNICODE_STRING *path, UNICODE_STRING *cmdline, NTSTATUS status );
-
-    /* server functions */
-    unsigned int  (CDECL *server_call)( void *req_ptr );
-    void          (CDECL *server_send_fd)( int fd );
-    NTSTATUS      (CDECL *server_fd_to_handle)( int fd, unsigned int access, unsigned int attributes,
-                                                HANDLE *handle );
-    NTSTATUS      (CDECL *server_handle_to_fd)( HANDLE handle, unsigned int access, int *unix_fd,
-                                                unsigned int *options );
-    void          (CDECL *server_release_fd)( HANDLE handle, int unix_fd );
-    void          (CDECL *server_init_process_done)( void *relay );
-
-    /* file functions */
-    NTSTATUS      (CDECL *nt_to_unix_file_name)( const UNICODE_STRING *nameW, char *nameA, SIZE_T *size,
-                                                 UINT disposition );
-    NTSTATUS      (CDECL *unix_to_nt_file_name)( const char *name, WCHAR *buffer, SIZE_T *size );
-    void          (CDECL *set_show_dot_files)( BOOL enable );
-
     /* loader functions */
-    NTSTATUS      (CDECL *load_so_dll)( UNICODE_STRING *nt_name, void **module );
-    NTSTATUS      (CDECL *load_builtin_dll)( const WCHAR *name, void **module,
-                                             pe_image_info_t *image_info );
-    NTSTATUS      (CDECL *unload_builtin_dll)( void *module );
-    void          (CDECL *init_builtin_dll)( void *module );
-    NTSTATUS      (CDECL *unwind_builtin_dll)( ULONG type, struct _DISPATCHER_CONTEXT *dispatch,
-                                               CONTEXT *context );
+    NTSTATUS      (CDECL *exec_wineloader)( char **argv, int socketfd, int is_child_64bit,
+                                            ULONGLONG res_start, ULONGLONG res_end );
+    void          (CDECL *start_server)( BOOL debug );
+
+    /* virtual memory functions */
+    NTSTATUS      (CDECL *map_so_dll)( const IMAGE_NT_HEADERS *nt_descr, HMODULE module );
+    void          (CDECL *mmap_add_reserved_area)( void *addr, SIZE_T size );
+    void          (CDECL *mmap_remove_reserved_area)( void *addr, SIZE_T size );
+    int           (CDECL *mmap_is_in_reserved_area)( void *addr, SIZE_T size );
+    int           (CDECL *mmap_enum_reserved_areas)( int (CDECL *enum_func)(void *base, SIZE_T size, void *arg),
+                                                     void *arg, int top_down );
 
     /* debugging functions */
+    void          (CDECL *dbg_init)(void);
     unsigned char (CDECL *dbg_get_channel_flags)( struct __wine_debug_channel *channel );
     const char *  (CDECL *dbg_strdup)( const char *str );
     int           (CDECL *dbg_output)( const char *str );
diff --git a/dlls/ntdll/version.c b/dlls/ntdll/version.c
index 4fef2b5e43..7221037902 100644
--- a/dlls/ntdll/version.c
+++ b/dlls/ntdll/version.c
@@ -21,6 +21,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <string.h>
 #include <stdlib.h>
 #include <stdarg.h>
diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
index 3ba4b8afbc..89857c9701 100644
--- a/dlls/ntdll/virtual.c
+++ b/dlls/ntdll/virtual.c
@@ -18,98 +18,4074 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+
 #include <assert.h>
 #include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <signal.h>
 #include <sys/types.h>
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_MMAN_H
+# include <sys/mman.h>
+#endif
+#ifdef HAVE_SYS_SYSINFO_H
+# include <sys/sysinfo.h>
+#endif
+#ifdef HAVE_VALGRIND_VALGRIND_H
+# include <valgrind/valgrind.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #define NONAMELESSUNION
 #include "windef.h"
 #include "winternl.h"
+#include "wine/library.h"
 #include "wine/server.h"
+#include "wine/exception.h"
+#include "wine/rbtree.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(virtual);
+WINE_DECLARE_DEBUG_CHANNEL(module);
 
+#ifndef MAP_NORESERVE
+#define MAP_NORESERVE 0
+#endif
 
-/**********************************************************************
- *           RtlCreateUserStack (NTDLL.@)
+/* File view */
+struct file_view
+{
+    struct wine_rb_entry entry;  /* entry in global view tree */
+    void         *base;          /* base address */
+    size_t        size;          /* size in bytes */
+    unsigned int  protect;       /* protection for all pages at allocation time and SEC_* flags */
+};
+
+/* per-page protection flags */
+#define VPROT_READ       0x01
+#define VPROT_WRITE      0x02
+#define VPROT_EXEC       0x04
+#define VPROT_WRITECOPY  0x08
+#define VPROT_GUARD      0x10
+#define VPROT_COMMITTED  0x20
+#define VPROT_WRITEWATCH 0x40
+/* per-mapping protection flags */
+#define VPROT_SYSTEM     0x0200  /* system view (underlying mmap not under our control) */
+
+/* Conversion from VPROT_* to Win32 flags */
+static const BYTE VIRTUAL_Win32Flags[16] =
+{
+    PAGE_NOACCESS,              /* 0 */
+    PAGE_READONLY,              /* READ */
+    PAGE_READWRITE,             /* WRITE */
+    PAGE_READWRITE,             /* READ | WRITE */
+    PAGE_EXECUTE,               /* EXEC */
+    PAGE_EXECUTE_READ,          /* READ | EXEC */
+    PAGE_EXECUTE_READWRITE,     /* WRITE | EXEC */
+    PAGE_EXECUTE_READWRITE,     /* READ | WRITE | EXEC */
+    PAGE_WRITECOPY,             /* WRITECOPY */
+    PAGE_WRITECOPY,             /* READ | WRITECOPY */
+    PAGE_WRITECOPY,             /* WRITE | WRITECOPY */
+    PAGE_WRITECOPY,             /* READ | WRITE | WRITECOPY */
+    PAGE_EXECUTE_WRITECOPY,     /* EXEC | WRITECOPY */
+    PAGE_EXECUTE_WRITECOPY,     /* READ | EXEC | WRITECOPY */
+    PAGE_EXECUTE_WRITECOPY,     /* WRITE | EXEC | WRITECOPY */
+    PAGE_EXECUTE_WRITECOPY      /* READ | WRITE | EXEC | WRITECOPY */
+};
+
+static struct wine_rb_tree views_tree;
+
+static RTL_CRITICAL_SECTION csVirtual;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &csVirtual,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": csVirtual") }
+};
+static RTL_CRITICAL_SECTION csVirtual = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+#ifdef __i386__
+static const UINT page_shift = 12;
+static const UINT_PTR page_mask = 0xfff;
+/* Note: these are Windows limits, you cannot change them. */
+static void *address_space_limit = (void *)0xc0000000;  /* top of the total available address space */
+static void *user_space_limit    = (void *)0x7fff0000;  /* top of the user address space */
+static void *working_set_limit   = (void *)0x7fff0000;  /* top of the current working set */
+static void *address_space_start = (void *)0x110000;    /* keep DOS area clear */
+#elif defined(__x86_64__)
+static const UINT page_shift = 12;
+static const UINT_PTR page_mask = 0xfff;
+static void *address_space_limit = (void *)0x7fffffff0000;
+static void *user_space_limit    = (void *)0x7fffffff0000;
+static void *working_set_limit   = (void *)0x7fffffff0000;
+static void *address_space_start = (void *)0x10000;
+#elif defined(__arm__)
+static const UINT page_shift = 12;
+static const UINT_PTR page_mask = 0xfff;
+static void *address_space_limit = (void *)0xc0000000;
+static void *user_space_limit    = (void *)0x7fff0000;
+static void *working_set_limit   = (void *)0x7fff0000;
+static void *address_space_start = (void *)0x10000;
+#elif defined(__aarch64__)
+static const UINT page_shift = 12;
+static const UINT_PTR page_mask = 0xfff;
+static void *address_space_limit = (void *)0xffffffff0000;
+static void *user_space_limit    = (void *)0x7fffffff0000;
+static void *working_set_limit   = (void *)0x7fffffff0000;
+static void *address_space_start = (void *)0x10000;
+#else
+UINT_PTR page_size = 0;
+static UINT page_shift;
+static UINT_PTR page_mask;
+static void *address_space_limit;
+static void *user_space_limit;
+static void *working_set_limit;
+static void *address_space_start = (void *)0x10000;
+#endif  /* __i386__ */
+static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
+static const UINT_PTR granularity_mask = 0xffff;
+
+SIZE_T signal_stack_size = 0;
+SIZE_T signal_stack_mask = 0;
+static SIZE_T signal_stack_align;
+
+/* TEB allocation blocks */
+static TEB *teb_block;
+static TEB *next_free_teb;
+static int teb_block_pos;
+
+#define ROUND_ADDR(addr,mask) \
+   ((void *)((UINT_PTR)(addr) & ~(UINT_PTR)(mask)))
+
+#define ROUND_SIZE(addr,size) \
+   (((SIZE_T)(size) + ((UINT_PTR)(addr) & page_mask) + page_mask) & ~page_mask)
+
+#define VIRTUAL_DEBUG_DUMP_VIEW(view) \
+    do { if (TRACE_ON(virtual)) VIRTUAL_DumpView(view); } while (0)
+
+#ifdef _WIN64  /* on 64-bit the page protection bytes use a 2-level table */
+static const size_t pages_vprot_shift = 20;
+static const size_t pages_vprot_mask = (1 << 20) - 1;
+static size_t pages_vprot_size;
+static BYTE **pages_vprot;
+#else  /* on 32-bit we use a simple array with one byte per page */
+static BYTE *pages_vprot;
+#endif
+
+static struct file_view *view_block_start, *view_block_end, *next_free_view;
+static const size_t view_block_size = 0x100000;
+static void *preload_reserve_start;
+static void *preload_reserve_end;
+static BOOL use_locks;
+static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
+
+struct range_entry
+{
+    void *base;
+    void *end;
+};
+
+static struct range_entry *free_ranges;
+static struct range_entry *free_ranges_end;
+
+
+/***********************************************************************
+ *           free_ranges_lower_bound
+ *
+ * Returns the first range whose end is not less than addr, or end if there's none.
  */
-NTSTATUS WINAPI RtlCreateUserStack( SIZE_T commit, SIZE_T reserve, ULONG zero_bits,
-                                    SIZE_T commit_align, SIZE_T reserve_align, INITIAL_TEB *stack )
+static struct range_entry *free_ranges_lower_bound( void *addr )
 {
-    PROCESS_STACK_ALLOCATION_INFORMATION alloc;
-    NTSTATUS status;
+    struct range_entry *begin = free_ranges;
+    struct range_entry *end = free_ranges_end;
+    struct range_entry *mid;
 
-    TRACE("commit %#lx, reserve %#lx, zero_bits %u, commit_align %#lx, reserve_align %#lx, stack %p\n",
-            commit, reserve, zero_bits, commit_align, reserve_align, stack);
+    while (begin < end)
+    {
+        mid = begin + (end - begin) / 2;
+        if (mid->end < addr)
+            begin = mid + 1;
+        else
+            end = mid;
+    }
 
-    if (!commit_align || !reserve_align)
-        return STATUS_INVALID_PARAMETER;
+    return begin;
+}
 
-    if (!commit || !reserve)
+
+/***********************************************************************
+ *           free_ranges_insert_view
+ *
+ * Updates the free_ranges after a new view has been created.
+ */
+static void free_ranges_insert_view( struct file_view *view )
+{
+    void *view_base = ROUND_ADDR( view->base, granularity_mask );
+    void *view_end = ROUND_ADDR( (char *)view->base + view->size + granularity_mask, granularity_mask );
+    struct range_entry *range = free_ranges_lower_bound( view_base );
+    struct range_entry *next = range + 1;
+
+    /* free_ranges initial value is such that the view is either inside range or before another one. */
+    assert( range != free_ranges_end );
+    assert( range->end > view_base || next != free_ranges_end );
+
+    /* this happens because virtual_alloc_thread_stack shrinks a view, then creates another one on top,
+     * or because AT_ROUND_TO_PAGE was used with NtMapViewOfSection to force 4kB aligned mapping. */
+    if ((range->end > view_base && range->base >= view_end) ||
+        (range->end == view_base && next->base >= view_end))
     {
-        IMAGE_NT_HEADERS *nt = RtlImageNtHeader( NtCurrentTeb()->Peb->ImageBaseAddress );
-        if (!reserve) reserve = nt->OptionalHeader.SizeOfStackReserve;
-        if (!commit) commit = nt->OptionalHeader.SizeOfStackCommit;
+        /* on Win64, assert that it's correctly aligned so we're not going to be in trouble later */
+        assert( (!is_win64 && !is_wow64) || view->base == view_base );
+        WARN( "range %p - %p is already mapped\n", view_base, view_end );
+        return;
     }
 
-    reserve = (reserve + reserve_align - 1) & ~(reserve_align - 1);
-    commit = (commit + commit_align - 1) & ~(commit_align - 1);
+    /* this should never happen */
+    if (range->base > view_base || range->end < view_end)
+        ERR( "range %p - %p is already partially mapped\n", view_base, view_end );
+    assert( range->base <= view_base && range->end >= view_end );
 
-    if (reserve < commit) reserve = commit;
-    if (reserve < 0x100000) reserve = 0x100000;
-    reserve = (reserve + 0xffff) & ~0xffff;  /* round to 64K boundary */
+    /* need to split the range in two */
+    if (range->base < view_base && range->end > view_end)
+    {
+        memmove( next + 1, next, (free_ranges_end - next) * sizeof(struct range_entry) );
+        free_ranges_end += 1;
+        if ((char *)free_ranges_end - (char *)free_ranges > view_block_size)
+            MESSAGE( "Free range sequence is full, trouble ahead!\n" );
+        assert( (char *)free_ranges_end - (char *)free_ranges <= view_block_size );
 
-    alloc.ReserveSize = reserve;
-    alloc.ZeroBits = zero_bits;
-    status = NtSetInformationProcess( GetCurrentProcess(), ProcessThreadStackAllocation,
-                                      &alloc, sizeof(alloc) );
-    if (!status)
+        next->base = view_end;
+        next->end = range->end;
+        range->end = view_base;
+    }
+    else
     {
-        void *addr = alloc.StackBase;
-        SIZE_T size = page_size;
+        /* otherwise we just have to shrink it */
+        if (range->base < view_base)
+            range->end = view_base;
+        else
+            range->base = view_end;
 
-        NtAllocateVirtualMemory( GetCurrentProcess(), &addr, 0, &size, MEM_COMMIT, PAGE_NOACCESS );
-        addr = (char *)alloc.StackBase + page_size;
-        NtAllocateVirtualMemory( GetCurrentProcess(), &addr, 0, &size, MEM_COMMIT, PAGE_READWRITE | PAGE_GUARD );
-        addr = (char *)alloc.StackBase + 2 * page_size;
-        size = reserve - 2 * page_size;
-        NtAllocateVirtualMemory( GetCurrentProcess(), &addr, 0, &size, MEM_COMMIT, PAGE_READWRITE );
+        if (range->base < range->end) return;
 
-        /* note: limit is lower than base since the stack grows down */
-        stack->OldStackBase = 0;
-        stack->OldStackLimit = 0;
-        stack->DeallocationStack = alloc.StackBase;
-        stack->StackBase = (char *)alloc.StackBase + reserve;
-        stack->StackLimit = (char *)alloc.StackBase + 2 * page_size;
+        /* and possibly remove it if it's now empty */
+        memmove( range, next, (free_ranges_end - next) * sizeof(struct range_entry) );
+        free_ranges_end -= 1;
+        assert( free_ranges_end - free_ranges > 0 );
     }
-    return status;
 }
 
 
-/**********************************************************************
- *           RtlFreeUserStack (NTDLL.@)
+/***********************************************************************
+ *           free_ranges_remove_view
+ *
+ * Updates the free_ranges after a view has been destroyed.
  */
-void WINAPI RtlFreeUserStack( void *stack )
+static void free_ranges_remove_view( struct file_view *view )
 {
-    SIZE_T size = 0;
+    void *view_base = ROUND_ADDR( view->base, granularity_mask );
+    void *view_end = ROUND_ADDR( (char *)view->base + view->size + granularity_mask, granularity_mask );
+    struct range_entry *range = free_ranges_lower_bound( view_base );
+    struct range_entry *next = range + 1;
 
-    TRACE("stack %p\n", stack);
+    /* It's possible to use AT_ROUND_TO_PAGE on 32bit with NtMapViewOfSection to force 4kB alignment,
+     * and this breaks our assumptions. Look at the views around to check if the range is still in use. */
+#ifndef _WIN64
+    struct file_view *prev_view = WINE_RB_ENTRY_VALUE( wine_rb_prev( &view->entry ), struct file_view, entry );
+    struct file_view *next_view = WINE_RB_ENTRY_VALUE( wine_rb_next( &view->entry ), struct file_view, entry );
+    void *prev_view_base = prev_view ? ROUND_ADDR( prev_view->base, granularity_mask ) : NULL;
+    void *prev_view_end = prev_view ? ROUND_ADDR( (char *)prev_view->base + prev_view->size + granularity_mask, granularity_mask ) : NULL;
+    void *next_view_base = next_view ? ROUND_ADDR( next_view->base, granularity_mask ) : NULL;
+    void *next_view_end = next_view ? ROUND_ADDR( (char *)next_view->base + next_view->size + granularity_mask, granularity_mask ) : NULL;
 
-    NtFreeVirtualMemory( NtCurrentProcess(), &stack, &size, MEM_RELEASE );
+    if ((prev_view_base < view_end && prev_view_end > view_base) ||
+        (next_view_base < view_end && next_view_end > view_base))
+    {
+        WARN( "range %p - %p is still mapped\n", view_base, view_end );
+        return;
+    }
+#endif
+
+    /* free_ranges initial value is such that the view is either inside range or before another one. */
+    assert( range != free_ranges_end );
+    assert( range->end > view_base || next != free_ranges_end );
+
+    /* this should never happen, but we can safely ignore it */
+    if (range->base <= view_base && range->end >= view_end)
+    {
+        WARN( "range %p - %p is already unmapped\n", view_base, view_end );
+        return;
+    }
+
+    /* this should never happen */
+    if (range->base < view_end && range->end > view_base)
+        ERR( "range %p - %p is already partially unmapped\n", view_base, view_end );
+    assert( range->end <= view_base || range->base >= view_end );
+
+    /* merge with next if possible */
+    if (range->end == view_base && next->base == view_end)
+    {
+        range->end = next->end;
+        memmove( next, next + 1, (free_ranges_end - next - 1) * sizeof(struct range_entry) );
+        free_ranges_end -= 1;
+        assert( free_ranges_end - free_ranges > 0 );
+    }
+    /* or try growing the range */
+    else if (range->end == view_base)
+        range->end = view_end;
+    else if (range->base == view_end)
+        range->base = view_base;
+    /* otherwise create a new one */
+    else
+    {
+        memmove( range + 1, range, (free_ranges_end - range) * sizeof(struct range_entry) );
+        free_ranges_end += 1;
+        if ((char *)free_ranges_end - (char *)free_ranges > view_block_size)
+            MESSAGE( "Free range sequence is full, trouble ahead!\n" );
+        assert( (char *)free_ranges_end - (char *)free_ranges <= view_block_size );
+
+        range->base = view_base;
+        range->end = view_end;
+    }
+}
+
+
+static inline int is_view_valloc( const struct file_view *view )
+{
+    return !(view->protect & (SEC_FILE | SEC_RESERVE | SEC_COMMIT));
 }
 
 /***********************************************************************
- *           __wine_locked_recvmsg
+ *           get_page_vprot
+ *
+ * Return the page protection byte.
  */
-ssize_t CDECL __wine_locked_recvmsg( int fd, struct msghdr *hdr, int flags )
+static BYTE get_page_vprot( const void *addr )
+{
+    size_t idx = (size_t)addr >> page_shift;
+
+#ifdef _WIN64
+    if ((idx >> pages_vprot_shift) >= pages_vprot_size) return 0;
+    if (!pages_vprot[idx >> pages_vprot_shift]) return 0;
+    return pages_vprot[idx >> pages_vprot_shift][idx & pages_vprot_mask];
+#else
+    return pages_vprot[idx];
+#endif
+}
+
+
+/***********************************************************************
+ *           set_page_vprot
+ *
+ * Set a range of page protection bytes.
+ */
+static void set_page_vprot( const void *addr, size_t size, BYTE vprot )
+{
+    size_t idx = (size_t)addr >> page_shift;
+    size_t end = ((size_t)addr + size + page_mask) >> page_shift;
+
+#ifdef _WIN64
+    while (idx >> pages_vprot_shift != end >> pages_vprot_shift)
+    {
+        size_t dir_size = pages_vprot_mask + 1 - (idx & pages_vprot_mask);
+        memset( pages_vprot[idx >> pages_vprot_shift] + (idx & pages_vprot_mask), vprot, dir_size );
+        idx += dir_size;
+    }
+    memset( pages_vprot[idx >> pages_vprot_shift] + (idx & pages_vprot_mask), vprot, end - idx );
+#else
+    memset( pages_vprot + idx, vprot, end - idx );
+#endif
+}
+
+
+/***********************************************************************
+ *           set_page_vprot_bits
+ *
+ * Set or clear bits in a range of page protection bytes.
+ */
+static void set_page_vprot_bits( const void *addr, size_t size, BYTE set, BYTE clear )
+{
+    size_t idx = (size_t)addr >> page_shift;
+    size_t end = ((size_t)addr + size + page_mask) >> page_shift;
+
+#ifdef _WIN64
+    for ( ; idx < end; idx++)
+    {
+        BYTE *ptr = pages_vprot[idx >> pages_vprot_shift] + (idx & pages_vprot_mask);
+        *ptr = (*ptr & ~clear) | set;
+    }
+#else
+    for ( ; idx < end; idx++) pages_vprot[idx] = (pages_vprot[idx] & ~clear) | set;
+#endif
+}
+
+
+/***********************************************************************
+ *           alloc_pages_vprot
+ *
+ * Allocate the page protection bytes for a given range.
+ */
+static BOOL alloc_pages_vprot( const void *addr, size_t size )
+{
+#ifdef _WIN64
+    size_t idx = (size_t)addr >> page_shift;
+    size_t end = ((size_t)addr + size + page_mask) >> page_shift;
+    size_t i;
+    void *ptr;
+
+    assert( end <= pages_vprot_size << pages_vprot_shift );
+    for (i = idx >> pages_vprot_shift; i < (end + pages_vprot_mask) >> pages_vprot_shift; i++)
+    {
+        if (pages_vprot[i]) continue;
+        if ((ptr = wine_anon_mmap( NULL, pages_vprot_mask + 1, PROT_READ | PROT_WRITE, 0 )) == (void *)-1)
+            return FALSE;
+        pages_vprot[i] = ptr;
+    }
+#endif
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           compare_view
+ *
+ * View comparison function used for the rb tree.
+ */
+static int compare_view( const void *addr, const struct wine_rb_entry *entry )
+{
+    struct file_view *view = WINE_RB_ENTRY_VALUE( entry, struct file_view, entry );
+
+    if (addr < view->base) return -1;
+    if (addr > view->base) return 1;
+    return 0;
+}
+
+
+/***********************************************************************
+ *           VIRTUAL_GetProtStr
+ */
+static const char *VIRTUAL_GetProtStr( BYTE prot )
+{
+    static char buffer[6];
+    buffer[0] = (prot & VPROT_COMMITTED) ? 'c' : '-';
+    buffer[1] = (prot & VPROT_GUARD) ? 'g' : ((prot & VPROT_WRITEWATCH) ? 'H' : '-');
+    buffer[2] = (prot & VPROT_READ) ? 'r' : '-';
+    buffer[3] = (prot & VPROT_WRITECOPY) ? 'W' : ((prot & VPROT_WRITE) ? 'w' : '-');
+    buffer[4] = (prot & VPROT_EXEC) ? 'x' : '-';
+    buffer[5] = 0;
+    return buffer;
+}
+
+
+/***********************************************************************
+ *           VIRTUAL_GetUnixProt
+ *
+ * Convert page protections to protection for mmap/mprotect.
+ */
+static int VIRTUAL_GetUnixProt( BYTE vprot )
+{
+    int prot = 0;
+    if ((vprot & VPROT_COMMITTED) && !(vprot & VPROT_GUARD))
+    {
+        if (vprot & VPROT_READ) prot |= PROT_READ;
+        if (vprot & VPROT_WRITE) prot |= PROT_WRITE | PROT_READ;
+        if (vprot & VPROT_WRITECOPY) prot |= PROT_WRITE | PROT_READ;
+        if (vprot & VPROT_EXEC) prot |= PROT_EXEC | PROT_READ;
+        if (vprot & VPROT_WRITEWATCH) prot &= ~PROT_WRITE;
+    }
+    if (!prot) prot = PROT_NONE;
+    return prot;
+}
+
+
+/***********************************************************************
+ *           VIRTUAL_DumpView
+ */
+static void VIRTUAL_DumpView( struct file_view *view )
+{
+    UINT i, count;
+    char *addr = view->base;
+    BYTE prot = get_page_vprot( addr );
+
+    TRACE( "View: %p - %p", addr, addr + view->size - 1 );
+    if (view->protect & VPROT_SYSTEM)
+        TRACE( " (builtin image)\n" );
+    else if (view->protect & SEC_IMAGE)
+        TRACE( " (image)\n" );
+    else if (view->protect & SEC_FILE)
+        TRACE( " (file)\n" );
+    else if (view->protect & (SEC_RESERVE | SEC_COMMIT))
+        TRACE( " (anonymous)\n" );
+    else
+        TRACE( " (valloc)\n");
+
+    for (count = i = 1; i < view->size >> page_shift; i++, count++)
+    {
+        BYTE next = get_page_vprot( addr + (count << page_shift) );
+        if (next == prot) continue;
+        TRACE( "      %p - %p %s\n",
+                 addr, addr + (count << page_shift) - 1, VIRTUAL_GetProtStr(prot) );
+        addr += (count << page_shift);
+        prot = next;
+        count = 0;
+    }
+    if (count)
+        TRACE( "      %p - %p %s\n",
+                 addr, addr + (count << page_shift) - 1, VIRTUAL_GetProtStr(prot) );
+}
+
+
+/***********************************************************************
+ *           VIRTUAL_Dump
+ */
+#ifdef WINE_VM_DEBUG
+static void VIRTUAL_Dump(void)
+{
+    sigset_t sigset;
+    struct file_view *view;
+
+    TRACE( "Dump of all virtual memory views:\n" );
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    WINE_RB_FOR_EACH_ENTRY( view, &views_tree, struct file_view, entry )
+    {
+        VIRTUAL_DumpView( view );
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+}
+#endif
+
+
+/***********************************************************************
+ *           VIRTUAL_FindView
+ *
+ * Find the view containing a given address. The csVirtual section must be held by caller.
+ *
+ * PARAMS
+ *      addr  [I] Address
+ *
+ * RETURNS
+ *	View: Success
+ *	NULL: Failure
+ */
+static struct file_view *VIRTUAL_FindView( const void *addr, size_t size )
+{
+    struct wine_rb_entry *ptr = views_tree.root;
+
+    if ((const char *)addr + size < (const char *)addr) return NULL; /* overflow */
+
+    while (ptr)
+    {
+        struct file_view *view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
+
+        if (view->base > addr) ptr = ptr->left;
+        else if ((const char *)view->base + view->size <= (const char *)addr) ptr = ptr->right;
+        else if ((const char *)view->base + view->size < (const char *)addr + size) break;  /* size too large */
+        else return view;
+    }
+    return NULL;
+}
+
+
+/***********************************************************************
+ *           zero_bits_win_to_64
+ *
+ * Convert from Windows hybrid 32bit-based / bitmask to 64bit-based format
+ */
+static inline unsigned short zero_bits_win_to_64( ULONG_PTR zero_bits )
+{
+    unsigned short zero_bits_64;
+
+    if (zero_bits == 0) return 0;
+    if (zero_bits < 32) return 32 + zero_bits;
+    zero_bits_64 = 63;
+#ifdef _WIN64
+    if (zero_bits >> 32) { zero_bits_64 -= 32; zero_bits >>= 32; }
+#endif
+    if (zero_bits >> 16) { zero_bits_64 -= 16; zero_bits >>= 16; }
+    if (zero_bits >> 8) { zero_bits_64 -= 8; zero_bits >>= 8; }
+    if (zero_bits >> 4) { zero_bits_64 -= 4; zero_bits >>= 4; }
+    if (zero_bits >> 2) { zero_bits_64 -= 2; zero_bits >>= 2; }
+    if (zero_bits >> 1) { zero_bits_64 -= 1; }
+    return zero_bits_64;
+}
+
+
+/***********************************************************************
+ *           get_zero_bits_64_mask
+ */
+static inline UINT_PTR get_zero_bits_64_mask( USHORT zero_bits_64 )
+{
+    return (UINT_PTR)((~(UINT64)0) >> zero_bits_64);
+}
+
+
+/***********************************************************************
+ *           is_write_watch_range
+ */
+static inline BOOL is_write_watch_range( const void *addr, size_t size )
+{
+    struct file_view *view = VIRTUAL_FindView( addr, size );
+    return view && (view->protect & VPROT_WRITEWATCH);
+}
+
+
+/***********************************************************************
+ *           find_view_range
+ *
+ * Find the first view overlapping at least part of the specified range.
+ * The csVirtual section must be held by caller.
+ */
+static struct file_view *find_view_range( const void *addr, size_t size )
+{
+    struct wine_rb_entry *ptr = views_tree.root;
+
+    while (ptr)
+    {
+        struct file_view *view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
+
+        if ((const char *)view->base >= (const char *)addr + size) ptr = ptr->left;
+        else if ((const char *)view->base + view->size <= (const char *)addr) ptr = ptr->right;
+        else return view;
+    }
+    return NULL;
+}
+
+
+/***********************************************************************
+ *           find_view_inside_range
+ *
+ * Find first (resp. last, if top_down) view inside a range.
+ * The csVirtual section must be held by caller.
+ */
+static struct wine_rb_entry *find_view_inside_range( void **base_ptr, void **end_ptr, int top_down )
+{
+    struct wine_rb_entry *first = NULL, *ptr = views_tree.root;
+    void *base = *base_ptr, *end = *end_ptr;
+
+    /* find the first (resp. last) view inside the range */
+    while (ptr)
+    {
+        struct file_view *view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
+        if ((char *)view->base + view->size >= (char *)end)
+        {
+            end = min( end, view->base );
+            ptr = ptr->left;
+        }
+        else if (view->base <= base)
+        {
+            base = max( (char *)base, (char *)view->base + view->size );
+            ptr = ptr->right;
+        }
+        else
+        {
+            first = ptr;
+            ptr = top_down ? ptr->right : ptr->left;
+        }
+    }
+
+    *base_ptr = base;
+    *end_ptr = end;
+    return first;
+}
+
+
+/***********************************************************************
+ *           try_map_free_area
+ *
+ * Try mmaping some expected free memory region, eventually stepping and
+ * retrying inside it, and return where it actually succeeded, or NULL.
+ */
+static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
+                                void *start, size_t size, int unix_prot )
+{
+    void *ptr;
+
+    while (start && base <= start && (char*)start + size <= (char*)end)
+    {
+        if ((ptr = wine_anon_mmap( start, size, unix_prot, 0 )) == start)
+            return start;
+        TRACE( "Found free area is already mapped, start %p.\n", start );
+
+        if (ptr != (void *)-1)
+            munmap( ptr, size );
+
+        if ((step > 0 && (char *)end - (char *)start < step) ||
+            (step < 0 && (char *)start - (char *)base < -step) ||
+            step == 0)
+            break;
+        start = (char *)start + step;
+    }
+
+    return NULL;
+}
+
+
+/***********************************************************************
+ *           map_free_area
+ *
+ * Find a free area between views inside the specified range and map it.
+ * The csVirtual section must be held by caller.
+ */
+static void *map_free_area( void *base, void *end, size_t size, int top_down, int unix_prot )
+{
+    struct wine_rb_entry *first = find_view_inside_range( &base, &end, top_down );
+    ptrdiff_t step = top_down ? -(granularity_mask + 1) : (granularity_mask + 1);
+    void *start;
+
+    if (top_down)
+    {
+        start = ROUND_ADDR( (char *)end - size, granularity_mask );
+        if (start >= end || start < base) return NULL;
+
+        while (first)
+        {
+            struct file_view *view = WINE_RB_ENTRY_VALUE( first, struct file_view, entry );
+            if ((start = try_map_free_area( (char *)view->base + view->size, (char *)start + size, step,
+                                            start, size, unix_prot ))) break;
+            start = ROUND_ADDR( (char *)view->base - size, granularity_mask );
+            /* stop if remaining space is not large enough */
+            if (!start || start >= end || start < base) return NULL;
+            first = wine_rb_prev( first );
+        }
+    }
+    else
+    {
+        start = ROUND_ADDR( (char *)base + granularity_mask, granularity_mask );
+        if (!start || start >= end || (char *)end - (char *)start < size) return NULL;
+
+        while (first)
+        {
+            struct file_view *view = WINE_RB_ENTRY_VALUE( first, struct file_view, entry );
+            if ((start = try_map_free_area( start, view->base, step,
+                                            start, size, unix_prot ))) break;
+            start = ROUND_ADDR( (char *)view->base + view->size + granularity_mask, granularity_mask );
+            /* stop if remaining space is not large enough */
+            if (!start || start >= end || (char *)end - (char *)start < size) return NULL;
+            first = wine_rb_next( first );
+        }
+    }
+
+    if (!first)
+        return try_map_free_area( base, end, step, start, size, unix_prot );
+
+    return start;
+}
+
+
+/***********************************************************************
+ *           find_reserved_free_area
+ *
+ * Find a free area between views inside the specified range.
+ * The csVirtual section must be held by caller.
+ * The range must be inside the preloader reserved range.
+ */
+static void *find_reserved_free_area( void *base, void *end, size_t size, int top_down )
 {
-    return unix_funcs->virtual_locked_recvmsg( fd, hdr, flags );
+    struct range_entry *range;
+    void *start;
+
+    base = ROUND_ADDR( (char *)base + granularity_mask, granularity_mask );
+    end = (char *)ROUND_ADDR( (char *)end - size, granularity_mask ) + size;
+
+    if (top_down)
+    {
+        start = (char *)end - size;
+        range = free_ranges_lower_bound( start );
+        assert(range != free_ranges_end && range->end >= start);
+
+        if ((char *)range->end - (char *)start < size) start = ROUND_ADDR( (char *)range->end - size, granularity_mask );
+        do
+        {
+            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
+            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
+            if (--range < free_ranges) return NULL;
+            start = ROUND_ADDR( (char *)range->end - size, granularity_mask );
+        }
+        while (1);
+    }
+    else
+    {
+        start = base;
+        range = free_ranges_lower_bound( start );
+        assert(range != free_ranges_end && range->end >= start);
+
+        if (start < range->base) start = ROUND_ADDR( (char *)range->base + granularity_mask, granularity_mask );
+        do
+        {
+            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
+            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
+            if (++range == free_ranges_end) return NULL;
+            start = ROUND_ADDR( (char *)range->base + granularity_mask, granularity_mask );
+        }
+        while (1);
+    }
+    return start;
+}
+
+
+/***********************************************************************
+ *           add_reserved_area
+ *
+ * Add a reserved area to the list maintained by libwine.
+ * The csVirtual section must be held by caller.
+ */
+static void add_reserved_area( void *addr, size_t size )
+{
+    TRACE( "adding %p-%p\n", addr, (char *)addr + size );
+
+    if (addr < user_space_limit)
+    {
+        /* unmap the part of the area that is below the limit */
+        assert( (char *)addr + size > (char *)user_space_limit );
+        munmap( addr, (char *)user_space_limit - (char *)addr );
+        size -= (char *)user_space_limit - (char *)addr;
+        addr = user_space_limit;
+    }
+    /* blow away existing mappings */
+    wine_anon_mmap( addr, size, PROT_NONE, MAP_NORESERVE | MAP_FIXED );
+    unix_funcs->mmap_add_reserved_area( addr, size );
+}
+
+
+/***********************************************************************
+ *           remove_reserved_area
+ *
+ * Remove a reserved area from the list maintained by libwine.
+ * The csVirtual section must be held by caller.
+ */
+static void remove_reserved_area( void *addr, size_t size )
+{
+    struct file_view *view;
+
+    TRACE( "removing %p-%p\n", addr, (char *)addr + size );
+    unix_funcs->mmap_remove_reserved_area( addr, size );
+
+    /* unmap areas not covered by an existing view */
+    WINE_RB_FOR_EACH_ENTRY( view, &views_tree, struct file_view, entry )
+    {
+        if ((char *)view->base >= (char *)addr + size) break;
+        if ((char *)view->base + view->size <= (char *)addr) continue;
+        if (view->base > addr) munmap( addr, (char *)view->base - (char *)addr );
+        if ((char *)view->base + view->size > (char *)addr + size) return;
+        size = (char *)addr + size - ((char *)view->base + view->size);
+        addr = (char *)view->base + view->size;
+    }
+    munmap( addr, size );
+}
+
+
+struct area_boundary
+{
+    void  *base;
+    size_t size;
+    void  *boundary;
+};
+
+/***********************************************************************
+ *           get_area_boundary_callback
+ *
+ * Get lowest boundary address between reserved area and non-reserved area
+ * in the specified region. If no boundaries are found, result is NULL.
+ * The csVirtual section must be held by caller.
+ */
+static int CDECL get_area_boundary_callback( void *start, SIZE_T size, void *arg )
+{
+    struct area_boundary *area = arg;
+    void *end = (char *)start + size;
+
+    area->boundary = NULL;
+    if (area->base >= end) return 0;
+    if ((char *)start >= (char *)area->base + area->size) return 1;
+    if (area->base >= start)
+    {
+        if ((char *)area->base + area->size > (char *)end)
+        {
+            area->boundary = end;
+            return 1;
+        }
+        return 0;
+    }
+    area->boundary = start;
+    return 1;
+}
+
+
+/***********************************************************************
+ *           is_beyond_limit
+ *
+ * Check if an address range goes beyond a given limit.
+ */
+static inline BOOL is_beyond_limit( const void *addr, size_t size, const void *limit )
+{
+    return (addr >= limit || (const char *)addr + size > (const char *)limit);
+}
+
+
+/***********************************************************************
+ *           unmap_area
+ *
+ * Unmap an area, or simply replace it by an empty mapping if it is
+ * in a reserved area. The csVirtual section must be held by caller.
+ */
+static inline void unmap_area( void *addr, size_t size )
+{
+    switch (unix_funcs->mmap_is_in_reserved_area( addr, size ))
+    {
+    case -1: /* partially in a reserved area */
+    {
+        struct area_boundary area;
+        size_t lower_size;
+        area.base = addr;
+        area.size = size;
+        unix_funcs->mmap_enum_reserved_areas( get_area_boundary_callback, &area, 0 );
+        assert( area.boundary );
+        lower_size = (char *)area.boundary - (char *)addr;
+        unmap_area( addr, lower_size );
+        unmap_area( area.boundary, size - lower_size );
+        break;
+    }
+    case 1:  /* in a reserved area */
+        wine_anon_mmap( addr, size, PROT_NONE, MAP_NORESERVE | MAP_FIXED );
+        break;
+    default:
+    case 0:  /* not in a reserved area */
+        if (is_beyond_limit( addr, size, user_space_limit ))
+            add_reserved_area( addr, size );
+        else
+            munmap( addr, size );
+        break;
+    }
+}
+
+
+/***********************************************************************
+ *           alloc_view
+ *
+ * Allocate a new view. The csVirtual section must be held by caller.
+ */
+static struct file_view *alloc_view(void)
+{
+    if (next_free_view)
+    {
+        struct file_view *ret = next_free_view;
+        next_free_view = *(struct file_view **)ret;
+        return ret;
+    }
+    if (view_block_start == view_block_end)
+    {
+        void *ptr = wine_anon_mmap( NULL, view_block_size, PROT_READ | PROT_WRITE, 0 );
+        if (ptr == (void *)-1) return NULL;
+        view_block_start = ptr;
+        view_block_end = view_block_start + view_block_size / sizeof(*view_block_start);
+    }
+    return view_block_start++;
+}
+
+
+/***********************************************************************
+ *           delete_view
+ *
+ * Deletes a view. The csVirtual section must be held by caller.
+ */
+static void delete_view( struct file_view *view ) /* [in] View */
+{
+    if (!(view->protect & VPROT_SYSTEM)) unmap_area( view->base, view->size );
+    set_page_vprot( view->base, view->size, 0 );
+    if (unix_funcs->mmap_is_in_reserved_area( view->base, view->size ))
+        free_ranges_remove_view( view );
+    wine_rb_remove( &views_tree, &view->entry );
+    *(struct file_view **)view = next_free_view;
+    next_free_view = view;
+}
+
+
+/***********************************************************************
+ *           create_view
+ *
+ * Create a view. The csVirtual section must be held by caller.
+ */
+static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t size, unsigned int vprot )
+{
+    struct file_view *view;
+    int unix_prot = VIRTUAL_GetUnixProt( vprot );
+
+    assert( !((UINT_PTR)base & page_mask) );
+    assert( !(size & page_mask) );
+
+    /* Check for overlapping views. This can happen if the previous view
+     * was a system view that got unmapped behind our back. In that case
+     * we recover by simply deleting it. */
+
+    while ((view = find_view_range( base, size )))
+    {
+        TRACE( "overlapping view %p-%p for %p-%p\n",
+               view->base, (char *)view->base + view->size, base, (char *)base + size );
+        assert( view->protect & VPROT_SYSTEM );
+        delete_view( view );
+    }
+
+    if (!alloc_pages_vprot( base, size )) return STATUS_NO_MEMORY;
+
+    /* Create the view structure */
+
+    if (!(view = alloc_view()))
+    {
+        FIXME( "out of memory for %p-%p\n", base, (char *)base + size );
+        return STATUS_NO_MEMORY;
+    }
+
+    view->base    = base;
+    view->size    = size;
+    view->protect = vprot;
+    set_page_vprot( base, size, vprot );
+
+    wine_rb_put( &views_tree, view->base, &view->entry );
+    if (unix_funcs->mmap_is_in_reserved_area( view->base, view->size ))
+        free_ranges_insert_view( view );
+
+    *view_ret = view;
+
+    if (force_exec_prot && (unix_prot & PROT_READ) && !(unix_prot & PROT_EXEC))
+    {
+        TRACE( "forcing exec permission on %p-%p\n", base, (char *)base + size - 1 );
+        mprotect( base, size, unix_prot | PROT_EXEC );
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           VIRTUAL_GetWin32Prot
+ *
+ * Convert page protections to Win32 flags.
+ */
+static DWORD VIRTUAL_GetWin32Prot( BYTE vprot, unsigned int map_prot )
+{
+    DWORD ret = VIRTUAL_Win32Flags[vprot & 0x0f];
+    if (vprot & VPROT_GUARD) ret |= PAGE_GUARD;
+    if (map_prot & SEC_NOCACHE) ret |= PAGE_NOCACHE;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           get_vprot_flags
+ *
+ * Build page protections from Win32 flags.
+ *
+ * PARAMS
+ *      protect [I] Win32 protection flags
+ *
+ * RETURNS
+ *	Value of page protection flags
+ */
+static NTSTATUS get_vprot_flags( DWORD protect, unsigned int *vprot, BOOL image )
+{
+    switch(protect & 0xff)
+    {
+    case PAGE_READONLY:
+        *vprot = VPROT_READ;
+        break;
+    case PAGE_READWRITE:
+        if (image)
+            *vprot = VPROT_READ | VPROT_WRITECOPY;
+        else
+            *vprot = VPROT_READ | VPROT_WRITE;
+        break;
+    case PAGE_WRITECOPY:
+        *vprot = VPROT_READ | VPROT_WRITECOPY;
+        break;
+    case PAGE_EXECUTE:
+        *vprot = VPROT_EXEC;
+        break;
+    case PAGE_EXECUTE_READ:
+        *vprot = VPROT_EXEC | VPROT_READ;
+        break;
+    case PAGE_EXECUTE_READWRITE:
+        if (image)
+            *vprot = VPROT_EXEC | VPROT_READ | VPROT_WRITECOPY;
+        else
+            *vprot = VPROT_EXEC | VPROT_READ | VPROT_WRITE;
+        break;
+    case PAGE_EXECUTE_WRITECOPY:
+        *vprot = VPROT_EXEC | VPROT_READ | VPROT_WRITECOPY;
+        break;
+    case PAGE_NOACCESS:
+        *vprot = 0;
+        break;
+    default:
+        return STATUS_INVALID_PAGE_PROTECTION;
+    }
+    if (protect & PAGE_GUARD) *vprot |= VPROT_GUARD;
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           mprotect_exec
+ *
+ * Wrapper for mprotect, adds PROT_EXEC if forced by force_exec_prot
+ */
+static inline int mprotect_exec( void *base, size_t size, int unix_prot )
+{
+    if (force_exec_prot && (unix_prot & PROT_READ) && !(unix_prot & PROT_EXEC))
+    {
+        TRACE( "forcing exec permission on %p-%p\n", base, (char *)base + size - 1 );
+        if (!mprotect( base, size, unix_prot | PROT_EXEC )) return 0;
+        /* exec + write may legitimately fail, in that case fall back to write only */
+        if (!(unix_prot & PROT_WRITE)) return -1;
+    }
+
+    return mprotect( base, size, unix_prot );
+}
+
+
+/***********************************************************************
+ *           mprotect_range
+ *
+ * Call mprotect on a page range, applying the protections from the per-page byte.
+ */
+static void mprotect_range( void *base, size_t size, BYTE set, BYTE clear )
+{
+    size_t i, count;
+    char *addr = ROUND_ADDR( base, page_mask );
+    int prot, next;
+
+    size = ROUND_SIZE( base, size );
+    prot = VIRTUAL_GetUnixProt( (get_page_vprot( addr ) & ~clear ) | set );
+    for (count = i = 1; i < size >> page_shift; i++, count++)
+    {
+        next = VIRTUAL_GetUnixProt( (get_page_vprot( addr + (count << page_shift) ) & ~clear) | set );
+        if (next == prot) continue;
+        mprotect_exec( addr, count << page_shift, prot );
+        addr += count << page_shift;
+        prot = next;
+        count = 0;
+    }
+    if (count) mprotect_exec( addr, count << page_shift, prot );
+}
+
+
+/***********************************************************************
+ *           VIRTUAL_SetProt
+ *
+ * Change the protection of a range of pages.
+ *
+ * RETURNS
+ *	TRUE: Success
+ *	FALSE: Failure
+ */
+static BOOL VIRTUAL_SetProt( struct file_view *view, /* [in] Pointer to view */
+                             void *base,      /* [in] Starting address */
+                             size_t size,     /* [in] Size in bytes */
+                             BYTE vprot )     /* [in] Protections to use */
+{
+    int unix_prot = VIRTUAL_GetUnixProt(vprot);
+
+    if (view->protect & VPROT_WRITEWATCH)
+    {
+        /* each page may need different protections depending on write watch flag */
+        set_page_vprot_bits( base, size, vprot & ~VPROT_WRITEWATCH, ~vprot & ~VPROT_WRITEWATCH );
+        mprotect_range( base, size, 0, 0 );
+        return TRUE;
+    }
+
+    /* if setting stack guard pages, store the permissions first, as the guard may be
+     * triggered at any point after mprotect and change the permissions again */
+    if ((vprot & VPROT_GUARD) &&
+        (base >= NtCurrentTeb()->DeallocationStack) &&
+        (base < NtCurrentTeb()->Tib.StackBase))
+    {
+        set_page_vprot( base, size, vprot );
+        mprotect( base, size, unix_prot );
+        return TRUE;
+    }
+
+    if (mprotect_exec( base, size, unix_prot )) /* FIXME: last error */
+        return FALSE;
+
+    set_page_vprot( base, size, vprot );
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           set_protection
+ *
+ * Set page protections on a range of pages
+ */
+static NTSTATUS set_protection( struct file_view *view, void *base, SIZE_T size, ULONG protect )
+{
+    unsigned int vprot;
+    NTSTATUS status;
+
+    if ((status = get_vprot_flags( protect, &vprot, view->protect & SEC_IMAGE ))) return status;
+    if (is_view_valloc( view ))
+    {
+        if (vprot & VPROT_WRITECOPY) return STATUS_INVALID_PAGE_PROTECTION;
+    }
+    else
+    {
+        BYTE access = vprot & (VPROT_READ | VPROT_WRITE | VPROT_EXEC);
+        if ((view->protect & access) != access) return STATUS_INVALID_PAGE_PROTECTION;
+    }
+
+    if (!VIRTUAL_SetProt( view, base, size, vprot | VPROT_COMMITTED )) return STATUS_ACCESS_DENIED;
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           update_write_watches
+ */
+static void update_write_watches( void *base, size_t size, size_t accessed_size )
+{
+    TRACE( "updating watch %p-%p-%p\n", base, (char *)base + accessed_size, (char *)base + size );
+    /* clear write watch flag on accessed pages */
+    set_page_vprot_bits( base, accessed_size, 0, VPROT_WRITEWATCH );
+    /* restore page protections on the entire range */
+    mprotect_range( base, size, 0, 0 );
+}
+
+
+/***********************************************************************
+ *           reset_write_watches
+ *
+ * Reset write watches in a memory range.
+ */
+static void reset_write_watches( void *base, SIZE_T size )
+{
+    set_page_vprot_bits( base, size, VPROT_WRITEWATCH, 0 );
+    mprotect_range( base, size, 0, 0 );
+}
+
+
+/***********************************************************************
+ *           unmap_extra_space
+ *
+ * Release the extra memory while keeping the range starting on the granularity boundary.
+ */
+static inline void *unmap_extra_space( void *ptr, size_t total_size, size_t wanted_size )
+{
+    if ((ULONG_PTR)ptr & granularity_mask)
+    {
+        size_t extra = granularity_mask + 1 - ((ULONG_PTR)ptr & granularity_mask);
+        munmap( ptr, extra );
+        ptr = (char *)ptr + extra;
+        total_size -= extra;
+    }
+    if (total_size > wanted_size)
+        munmap( (char *)ptr + wanted_size, total_size - wanted_size );
+    return ptr;
+}
+
+
+struct alloc_area
+{
+    size_t size;
+    int    top_down;
+    void  *limit;
+    void  *result;
+};
+
+/***********************************************************************
+ *           alloc_reserved_area_callback
+ *
+ * Try to map some space inside a reserved area. Callback for mmap_enum_reserved_areas.
+ */
+static int CDECL alloc_reserved_area_callback( void *start, SIZE_T size, void *arg )
+{
+    struct alloc_area *alloc = arg;
+    void *end = (char *)start + size;
+
+    if (start < address_space_start) start = address_space_start;
+    if (is_beyond_limit( start, size, alloc->limit )) end = alloc->limit;
+    if (start >= end) return 0;
+
+    /* make sure we don't touch the preloader reserved range */
+    if (preload_reserve_end >= start)
+    {
+        if (preload_reserve_end >= end)
+        {
+            if (preload_reserve_start <= start) return 0;  /* no space in that area */
+            if (preload_reserve_start < end) end = preload_reserve_start;
+        }
+        else if (preload_reserve_start <= start) start = preload_reserve_end;
+        else
+        {
+            /* range is split in two by the preloader reservation, try first part */
+            if ((alloc->result = find_reserved_free_area( start, preload_reserve_start, alloc->size,
+                                                          alloc->top_down )))
+                return 1;
+            /* then fall through to try second part */
+            start = preload_reserve_end;
+        }
+    }
+    if ((alloc->result = find_reserved_free_area( start, end, alloc->size, alloc->top_down )))
+        return 1;
+
+    return 0;
+}
+
+/***********************************************************************
+ *           map_fixed_area
+ *
+ * mmap the fixed memory area.
+ * The csVirtual section must be held by caller.
+ */
+static NTSTATUS map_fixed_area( void *base, size_t size, unsigned int vprot )
+{
+    void *ptr;
+
+    switch (unix_funcs->mmap_is_in_reserved_area( base, size ))
+    {
+    case -1: /* partially in a reserved area */
+    {
+        NTSTATUS status;
+        struct area_boundary area;
+        size_t lower_size;
+        area.base = base;
+        area.size = size;
+        unix_funcs->mmap_enum_reserved_areas( get_area_boundary_callback, &area, 0 );
+        assert( area.boundary );
+        lower_size = (char *)area.boundary - (char *)base;
+        status = map_fixed_area( base, lower_size, vprot );
+        if (status == STATUS_SUCCESS)
+        {
+            status = map_fixed_area( area.boundary, size - lower_size, vprot);
+            if (status != STATUS_SUCCESS) unmap_area( base, lower_size );
+        }
+        return status;
+    }
+    case 0:  /* not in a reserved area, do a normal allocation */
+        if ((ptr = wine_anon_mmap( base, size, VIRTUAL_GetUnixProt(vprot), 0 )) == (void *)-1)
+        {
+            if (errno == ENOMEM) return STATUS_NO_MEMORY;
+            return STATUS_INVALID_PARAMETER;
+        }
+        if (ptr != base)
+        {
+            /* We couldn't get the address we wanted */
+            if (is_beyond_limit( ptr, size, user_space_limit )) add_reserved_area( ptr, size );
+            else munmap( ptr, size );
+            return STATUS_CONFLICTING_ADDRESSES;
+        }
+        break;
+
+    default:
+    case 1:  /* in a reserved area, make sure the address is available */
+        if (find_view_range( base, size )) return STATUS_CONFLICTING_ADDRESSES;
+        /* replace the reserved area by our mapping */
+        if ((ptr = wine_anon_mmap( base, size, VIRTUAL_GetUnixProt(vprot), MAP_FIXED )) != base)
+            return STATUS_INVALID_PARAMETER;
+        break;
+    }
+    if (is_beyond_limit( ptr, size, working_set_limit )) working_set_limit = address_space_limit;
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           map_view
+ *
+ * Create a view and mmap the corresponding memory area.
+ * The csVirtual section must be held by caller.
+ */
+static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
+                          int top_down, unsigned int vprot, unsigned short zero_bits_64 )
+{
+    void *ptr;
+    NTSTATUS status;
+
+    if (base)
+    {
+        if (is_beyond_limit( base, size, address_space_limit ))
+            return STATUS_WORKING_SET_LIMIT_RANGE;
+        status = map_fixed_area( base, size, vprot );
+        if (status != STATUS_SUCCESS) return status;
+        ptr = base;
+    }
+    else
+    {
+        size_t view_size = size + granularity_mask + 1;
+        struct alloc_area alloc;
+
+        alloc.size = size;
+        alloc.top_down = top_down;
+        alloc.limit = (void*)(get_zero_bits_64_mask( zero_bits_64 ) & (UINT_PTR)user_space_limit);
+
+        if (unix_funcs->mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, top_down ))
+        {
+            ptr = alloc.result;
+            TRACE( "got mem in reserved area %p-%p\n", ptr, (char *)ptr + size );
+            if (wine_anon_mmap( ptr, size, VIRTUAL_GetUnixProt(vprot), MAP_FIXED ) != ptr)
+                return STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+
+        if (zero_bits_64)
+        {
+            if (!(ptr = map_free_area( address_space_start, alloc.limit, size,
+                                       top_down, VIRTUAL_GetUnixProt(vprot) )))
+                return STATUS_NO_MEMORY;
+            TRACE( "got mem with map_free_area %p-%p\n", ptr, (char *)ptr + size );
+            goto done;
+        }
+
+        for (;;)
+        {
+            if ((ptr = wine_anon_mmap( NULL, view_size, VIRTUAL_GetUnixProt(vprot), 0 )) == (void *)-1)
+            {
+                if (errno == ENOMEM) return STATUS_NO_MEMORY;
+                return STATUS_INVALID_PARAMETER;
+            }
+            TRACE( "got mem with anon mmap %p-%p\n", ptr, (char *)ptr + size );
+            /* if we got something beyond the user limit, unmap it and retry */
+            if (is_beyond_limit( ptr, view_size, user_space_limit )) add_reserved_area( ptr, view_size );
+            else break;
+        }
+        ptr = unmap_extra_space( ptr, view_size, size );
+    }
+done:
+    status = create_view( view_ret, ptr, size, vprot );
+    if (status != STATUS_SUCCESS) unmap_area( ptr, size );
+    return status;
+}
+
+
+/***********************************************************************
+ *           map_file_into_view
+ *
+ * Wrapper for mmap() to map a file into a view, falling back to read if mmap fails.
+ * The csVirtual section must be held by caller.
+ */
+static NTSTATUS map_file_into_view( struct file_view *view, int fd, size_t start, size_t size,
+                                    off_t offset, unsigned int vprot, BOOL removable )
+{
+    void *ptr;
+    int prot = VIRTUAL_GetUnixProt( vprot | VPROT_COMMITTED /* make sure it is accessible */ );
+    unsigned int flags = MAP_FIXED | ((vprot & VPROT_WRITECOPY) ? MAP_PRIVATE : MAP_SHARED);
+
+    assert( start < view->size );
+    assert( start + size <= view->size );
+
+    if (force_exec_prot && (vprot & VPROT_READ))
+    {
+        TRACE( "forcing exec permission on mapping %p-%p\n",
+               (char *)view->base + start, (char *)view->base + start + size - 1 );
+        prot |= PROT_EXEC;
+    }
+
+    /* only try mmap if media is not removable (or if we require write access) */
+    if (!removable || (flags & MAP_SHARED))
+    {
+        if (mmap( (char *)view->base + start, size, prot, flags, fd, offset ) != (void *)-1)
+            goto done;
+
+        switch (errno)
+        {
+        case EINVAL:  /* file offset is not page-aligned, fall back to read() */
+            if (flags & MAP_SHARED) return STATUS_INVALID_PARAMETER;
+            break;
+        case ENOEXEC:
+        case ENODEV:  /* filesystem doesn't support mmap(), fall back to read() */
+            if (vprot & VPROT_WRITE)
+            {
+                ERR( "shared writable mmap not supported, broken filesystem?\n" );
+                return STATUS_NOT_SUPPORTED;
+            }
+            break;
+        case EACCES:
+        case EPERM:  /* noexec filesystem, fall back to read() */
+            if (flags & MAP_SHARED)
+            {
+                if (prot & PROT_EXEC) ERR( "failed to set PROT_EXEC on file map, noexec filesystem?\n" );
+                return STATUS_ACCESS_DENIED;
+            }
+            if (prot & PROT_EXEC) WARN( "failed to set PROT_EXEC on file map, noexec filesystem?\n" );
+            break;
+        default:
+            return FILE_GetNtStatus();
+        }
+    }
+
+    /* Reserve the memory with an anonymous mmap */
+    ptr = wine_anon_mmap( (char *)view->base + start, size, PROT_READ | PROT_WRITE, MAP_FIXED );
+    if (ptr == (void *)-1) return FILE_GetNtStatus();
+    /* Now read in the file */
+    pread( fd, ptr, size, offset );
+    if (prot != (PROT_READ|PROT_WRITE)) mprotect( ptr, size, prot );  /* Set the right protection */
+done:
+    set_page_vprot( (char *)view->base + start, size, vprot );
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           get_committed_size
+ *
+ * Get the size of the committed range starting at base.
+ * Also return the protections for the first page.
+ */
+static SIZE_T get_committed_size( struct file_view *view, void *base, BYTE *vprot )
+{
+    SIZE_T i, start;
+
+    start = ((char *)base - (char *)view->base) >> page_shift;
+    *vprot = get_page_vprot( base );
+
+    if (view->protect & SEC_RESERVE)
+    {
+        SIZE_T ret = 0;
+        SERVER_START_REQ( get_mapping_committed_range )
+        {
+            req->base   = wine_server_client_ptr( view->base );
+            req->offset = start << page_shift;
+            if (!wine_server_call( req ))
+            {
+                ret = reply->size;
+                if (reply->committed)
+                {
+                    *vprot |= VPROT_COMMITTED;
+                    set_page_vprot_bits( base, ret, VPROT_COMMITTED, 0 );
+                }
+            }
+        }
+        SERVER_END_REQ;
+        return ret;
+    }
+    for (i = start + 1; i < view->size >> page_shift; i++)
+        if ((*vprot ^ get_page_vprot( (char *)view->base + (i << page_shift) )) & VPROT_COMMITTED) break;
+    return (i - start) << page_shift;
+}
+
+
+/***********************************************************************
+ *           decommit_view
+ *
+ * Decommit some pages of a given view.
+ * The csVirtual section must be held by caller.
+ */
+static NTSTATUS decommit_pages( struct file_view *view, size_t start, size_t size )
+{
+    if (wine_anon_mmap( (char *)view->base + start, size, PROT_NONE, MAP_FIXED ) != (void *)-1)
+    {
+        set_page_vprot_bits( (char *)view->base + start, size, 0, VPROT_COMMITTED );
+        return STATUS_SUCCESS;
+    }
+    return FILE_GetNtStatus();
+}
+
+
+/***********************************************************************
+ *           allocate_dos_memory
+ *
+ * Allocate the DOS memory range.
+ */
+static NTSTATUS allocate_dos_memory( struct file_view **view, unsigned int vprot )
+{
+    size_t size;
+    void *addr = NULL;
+    void * const low_64k = (void *)0x10000;
+    const size_t dosmem_size = 0x110000;
+    int unix_prot = VIRTUAL_GetUnixProt( vprot );
+
+    /* check for existing view */
+
+    if (find_view_range( 0, dosmem_size )) return STATUS_CONFLICTING_ADDRESSES;
+
+    /* check without the first 64K */
+
+    if (unix_funcs->mmap_is_in_reserved_area( low_64k, dosmem_size - 0x10000 ) != 1)
+    {
+        addr = wine_anon_mmap( low_64k, dosmem_size - 0x10000, unix_prot, 0 );
+        if (addr != low_64k)
+        {
+            if (addr != (void *)-1) munmap( addr, dosmem_size - 0x10000 );
+            return map_view( view, NULL, dosmem_size, FALSE, vprot, 0 );
+        }
+    }
+
+    /* now try to allocate the low 64K too */
+
+    if (unix_funcs->mmap_is_in_reserved_area( NULL, 0x10000 ) != 1)
+    {
+        addr = wine_anon_mmap( (void *)page_size, 0x10000 - page_size, unix_prot, 0 );
+        if (addr == (void *)page_size)
+        {
+            if (!wine_anon_mmap( NULL, page_size, unix_prot, MAP_FIXED ))
+            {
+                addr = NULL;
+                TRACE( "successfully mapped low 64K range\n" );
+            }
+            else TRACE( "failed to map page 0\n" );
+        }
+        else
+        {
+            if (addr != (void *)-1) munmap( addr, 0x10000 - page_size );
+            addr = low_64k;
+            TRACE( "failed to map low 64K range\n" );
+        }
+    }
+
+    /* now reserve the whole range */
+
+    size = (char *)dosmem_size - (char *)addr;
+    wine_anon_mmap( addr, size, unix_prot, MAP_FIXED );
+    return create_view( view, addr, size, vprot );
+}
+
+
+/***********************************************************************
+ *           map_pe_header
+ *
+ * Map the header of a PE file into memory.
+ */
+static NTSTATUS map_pe_header( void *ptr, size_t size, int fd, BOOL *removable )
+{
+    if (!size) return STATUS_INVALID_IMAGE_FORMAT;
+
+    if (!*removable)
+    {
+        if (mmap( ptr, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE, fd, 0 ) != (void *)-1)
+            return STATUS_SUCCESS;
+
+        switch (errno)
+        {
+        case EPERM:
+        case EACCES:
+            WARN( "noexec file system, falling back to read\n" );
+            break;
+        case ENOEXEC:
+        case ENODEV:
+            WARN( "file system doesn't support mmap, falling back to read\n" );
+            break;
+        default:
+            return FILE_GetNtStatus();
+        }
+        *removable = TRUE;
+    }
+    pread( fd, ptr, size, 0 );
+    return STATUS_SUCCESS;  /* page protections will be updated later */
+}
+
+
+/***********************************************************************
+ *           map_image
+ *
+ * Map an executable (PE format) image into memory.
+ */
+static NTSTATUS map_image( HANDLE hmapping, ACCESS_MASK access, int fd, int top_down, unsigned short zero_bits_64,
+                           pe_image_info_t *image_info, int shared_fd, BOOL removable, PVOID *addr_ptr )
+{
+    IMAGE_DOS_HEADER *dos;
+    IMAGE_NT_HEADERS *nt;
+    IMAGE_SECTION_HEADER sections[96];
+    IMAGE_SECTION_HEADER *sec;
+    IMAGE_DATA_DIRECTORY *imports;
+    NTSTATUS status = STATUS_CONFLICTING_ADDRESSES;
+    SIZE_T header_size, total_size = image_info->map_size;
+    int i;
+    off_t pos;
+    sigset_t sigset;
+    struct stat st;
+    struct file_view *view = NULL;
+    char *ptr, *header_end, *header_start;
+    char *base = wine_server_get_ptr( image_info->base );
+
+    if (total_size != image_info->map_size)  /* truncated */
+    {
+        WARN( "Modules larger than 4Gb (%s) not supported\n", wine_dbgstr_longlong(image_info->map_size) );
+        return STATUS_INVALID_PARAMETER;
+    }
+    if ((ULONG_PTR)base != image_info->base) base = NULL;
+
+    /* zero-map the whole range */
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if (base >= (char *)address_space_start)  /* make sure the DOS area remains free */
+        status = map_view( &view, base, total_size, top_down, SEC_IMAGE | SEC_FILE |
+                           VPROT_COMMITTED | VPROT_READ | VPROT_EXEC | VPROT_WRITECOPY, zero_bits_64 );
+
+    if (status != STATUS_SUCCESS)
+        status = map_view( &view, NULL, total_size, top_down, SEC_IMAGE | SEC_FILE |
+                           VPROT_COMMITTED | VPROT_READ | VPROT_EXEC | VPROT_WRITECOPY, zero_bits_64 );
+
+    if (status != STATUS_SUCCESS) goto error;
+
+    ptr = view->base;
+    TRACE_(module)( "mapped PE file at %p-%p\n", ptr, ptr + total_size );
+
+    /* map the header */
+
+    if (fstat( fd, &st ) == -1)
+    {
+        status = FILE_GetNtStatus();
+        goto error;
+    }
+    header_size = min( image_info->header_size, st.st_size );
+    if ((status = map_pe_header( view->base, header_size, fd, &removable )) != STATUS_SUCCESS) goto error;
+
+    status = STATUS_INVALID_IMAGE_FORMAT;  /* generic error */
+    dos = (IMAGE_DOS_HEADER *)ptr;
+    nt = (IMAGE_NT_HEADERS *)(ptr + dos->e_lfanew);
+    header_end = ptr + ROUND_SIZE( 0, header_size );
+    memset( ptr + header_size, 0, header_end - (ptr + header_size) );
+    if ((char *)(nt + 1) > header_end) goto error;
+    header_start = (char*)&nt->OptionalHeader+nt->FileHeader.SizeOfOptionalHeader;
+    if (nt->FileHeader.NumberOfSections > ARRAY_SIZE( sections )) goto error;
+    if (header_start + sizeof(*sections) * nt->FileHeader.NumberOfSections > header_end) goto error;
+    /* Some applications (e.g. the Steam version of Borderlands) map over the top of the section headers,
+     * copying the headers into local memory is necessary to properly load such applications. */
+    memcpy(sections, header_start, sizeof(*sections) * nt->FileHeader.NumberOfSections);
+    sec = sections;
+
+    imports = nt->OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT;
+    if (!imports->Size || !imports->VirtualAddress) imports = NULL;
+
+    /* check for non page-aligned binary */
+
+    if (image_info->image_flags & IMAGE_FLAGS_ImageMappedFlat)
+    {
+        /* unaligned sections, this happens for native subsystem binaries */
+        /* in that case Windows simply maps in the whole file */
+
+        total_size = min( total_size, ROUND_SIZE( 0, st.st_size ));
+        if (map_file_into_view( view, fd, 0, total_size, 0, VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY,
+                                removable ) != STATUS_SUCCESS) goto error;
+
+        /* check that all sections are loaded at the right offset */
+        if (nt->OptionalHeader.FileAlignment != nt->OptionalHeader.SectionAlignment) goto error;
+        for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
+        {
+            if (sec[i].VirtualAddress != sec[i].PointerToRawData)
+                goto error;  /* Windows refuses to load in that case too */
+        }
+
+        /* set the image protections */
+        VIRTUAL_SetProt( view, ptr, total_size,
+                         VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY | VPROT_EXEC );
+
+        /* no relocations are performed on non page-aligned binaries */
+        goto done;
+    }
+
+
+    /* map all the sections */
+
+    for (i = pos = 0; i < nt->FileHeader.NumberOfSections; i++, sec++)
+    {
+        static const SIZE_T sector_align = 0x1ff;
+        SIZE_T map_size, file_start, file_size, end;
+
+        if (!sec->Misc.VirtualSize)
+            map_size = ROUND_SIZE( 0, sec->SizeOfRawData );
+        else
+            map_size = ROUND_SIZE( 0, sec->Misc.VirtualSize );
+
+        /* file positions are rounded to sector boundaries regardless of OptionalHeader.FileAlignment */
+        file_start = sec->PointerToRawData & ~sector_align;
+        file_size = (sec->SizeOfRawData + (sec->PointerToRawData & sector_align) + sector_align) & ~sector_align;
+        if (file_size > map_size) file_size = map_size;
+
+        /* a few sanity checks */
+        end = sec->VirtualAddress + ROUND_SIZE( sec->VirtualAddress, map_size );
+        if (sec->VirtualAddress > total_size || end > total_size || end < sec->VirtualAddress)
+        {
+            WARN_(module)( "Section %.8s too large (%x+%lx/%lx)\n",
+                           sec->Name, sec->VirtualAddress, map_size, total_size );
+            goto error;
+        }
+
+        if ((sec->Characteristics & IMAGE_SCN_MEM_SHARED) &&
+            (sec->Characteristics & IMAGE_SCN_MEM_WRITE))
+        {
+            TRACE_(module)( "mapping shared section %.8s at %p off %x (%x) size %lx (%lx) flags %x\n",
+                            sec->Name, ptr + sec->VirtualAddress,
+                            sec->PointerToRawData, (int)pos, file_size, map_size,
+                            sec->Characteristics );
+            if (map_file_into_view( view, shared_fd, sec->VirtualAddress, map_size, pos,
+                                    VPROT_COMMITTED | VPROT_READ | VPROT_WRITE, FALSE ) != STATUS_SUCCESS)
+            {
+                ERR_(module)( "Could not map shared section %.8s\n", sec->Name );
+                goto error;
+            }
+
+            /* check if the import directory falls inside this section */
+            if (imports && imports->VirtualAddress >= sec->VirtualAddress &&
+                imports->VirtualAddress < sec->VirtualAddress + map_size)
+            {
+                UINT_PTR base = imports->VirtualAddress & ~page_mask;
+                UINT_PTR end = base + ROUND_SIZE( imports->VirtualAddress, imports->Size );
+                if (end > sec->VirtualAddress + map_size) end = sec->VirtualAddress + map_size;
+                if (end > base)
+                    map_file_into_view( view, shared_fd, base, end - base,
+                                        pos + (base - sec->VirtualAddress),
+                                        VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY, FALSE );
+            }
+            pos += map_size;
+            continue;
+        }
+
+        TRACE_(module)( "mapping section %.8s at %p off %x size %x virt %x flags %x\n",
+                        sec->Name, ptr + sec->VirtualAddress,
+                        sec->PointerToRawData, sec->SizeOfRawData,
+                        sec->Misc.VirtualSize, sec->Characteristics );
+
+        if (!sec->PointerToRawData || !file_size) continue;
+
+        /* Note: if the section is not aligned properly map_file_into_view will magically
+         *       fall back to read(), so we don't need to check anything here.
+         */
+        end = file_start + file_size;
+        if (sec->PointerToRawData >= st.st_size ||
+            end > ((st.st_size + sector_align) & ~sector_align) ||
+            end < file_start ||
+            map_file_into_view( view, fd, sec->VirtualAddress, file_size, file_start,
+                                VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY,
+                                removable ) != STATUS_SUCCESS)
+        {
+            ERR_(module)( "Could not map section %.8s, file probably truncated\n", sec->Name );
+            goto error;
+        }
+
+        if (file_size & page_mask)
+        {
+            end = ROUND_SIZE( 0, file_size );
+            if (end > map_size) end = map_size;
+            TRACE_(module)("clearing %p - %p\n",
+                           ptr + sec->VirtualAddress + file_size,
+                           ptr + sec->VirtualAddress + end );
+            memset( ptr + sec->VirtualAddress + file_size, 0, end - file_size );
+        }
+    }
+
+    /* set the image protections */
+
+    VIRTUAL_SetProt( view, ptr, ROUND_SIZE( 0, header_size ), VPROT_COMMITTED | VPROT_READ );
+
+    sec = sections;
+    for (i = 0; i < nt->FileHeader.NumberOfSections; i++, sec++)
+    {
+        SIZE_T size;
+        BYTE vprot = VPROT_COMMITTED;
+
+        if (sec->Misc.VirtualSize)
+            size = ROUND_SIZE( sec->VirtualAddress, sec->Misc.VirtualSize );
+        else
+            size = ROUND_SIZE( sec->VirtualAddress, sec->SizeOfRawData );
+
+        if (sec->Characteristics & IMAGE_SCN_MEM_READ)    vprot |= VPROT_READ;
+        if (sec->Characteristics & IMAGE_SCN_MEM_WRITE)   vprot |= VPROT_WRITECOPY;
+        if (sec->Characteristics & IMAGE_SCN_MEM_EXECUTE) vprot |= VPROT_EXEC;
+
+        /* Dumb game crack lets the AOEP point into a data section. Adjust. */
+        if ((nt->OptionalHeader.AddressOfEntryPoint >= sec->VirtualAddress) &&
+            (nt->OptionalHeader.AddressOfEntryPoint < sec->VirtualAddress + size))
+            vprot |= VPROT_EXEC;
+
+        if (!VIRTUAL_SetProt( view, ptr + sec->VirtualAddress, size, vprot ) && (vprot & VPROT_EXEC))
+            ERR( "failed to set %08x protection on section %.8s, noexec filesystem?\n",
+                 sec->Characteristics, sec->Name );
+    }
+
+ done:
+
+    SERVER_START_REQ( map_view )
+    {
+        req->mapping = wine_server_obj_handle( hmapping );
+        req->access  = access;
+        req->base    = wine_server_client_ptr( view->base );
+        req->size    = view->size;
+        req->start   = 0;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    if (status) goto error;
+
+    VIRTUAL_DEBUG_DUMP_VIEW( view );
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+
+    *addr_ptr = ptr;
+#ifdef VALGRIND_LOAD_PDB_DEBUGINFO
+    VALGRIND_LOAD_PDB_DEBUGINFO(fd, ptr, total_size, ptr - base);
+#endif
+    if (ptr != base) return STATUS_IMAGE_NOT_AT_BASE;
+    return STATUS_SUCCESS;
+
+ error:
+    if (view) delete_view( view );
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/***********************************************************************
+ *             virtual_map_section
+ *
+ * Map a file section into memory.
+ */
+NTSTATUS virtual_map_section( HANDLE handle, PVOID *addr_ptr, unsigned short zero_bits_64, SIZE_T commit_size,
+                              const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr, ULONG alloc_type,
+                              ULONG protect, pe_image_info_t *image_info )
+{
+    NTSTATUS res;
+    mem_size_t full_size;
+    ACCESS_MASK access;
+    SIZE_T size;
+    int unix_handle = -1, needs_close;
+    unsigned int vprot, sec_flags;
+    struct file_view *view;
+    HANDLE shared_file;
+    LARGE_INTEGER offset;
+    sigset_t sigset;
+
+    offset.QuadPart = offset_ptr ? offset_ptr->QuadPart : 0;
+
+    switch(protect)
+    {
+    case PAGE_NOACCESS:
+    case PAGE_READONLY:
+    case PAGE_WRITECOPY:
+        access = SECTION_MAP_READ;
+        break;
+    case PAGE_READWRITE:
+        access = SECTION_MAP_WRITE;
+        break;
+    case PAGE_EXECUTE:
+    case PAGE_EXECUTE_READ:
+    case PAGE_EXECUTE_WRITECOPY:
+        access = SECTION_MAP_READ | SECTION_MAP_EXECUTE;
+        break;
+    case PAGE_EXECUTE_READWRITE:
+        access = SECTION_MAP_WRITE | SECTION_MAP_EXECUTE;
+        break;
+    default:
+        return STATUS_INVALID_PAGE_PROTECTION;
+    }
+
+    SERVER_START_REQ( get_mapping_info )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->access = access;
+        wine_server_set_reply( req, image_info, sizeof(*image_info) );
+        res = wine_server_call( req );
+        sec_flags   = reply->flags;
+        full_size   = reply->size;
+        shared_file = wine_server_ptr_handle( reply->shared_file );
+    }
+    SERVER_END_REQ;
+    if (res) return res;
+
+    if ((res = server_get_unix_fd( handle, 0, &unix_handle, &needs_close, NULL, NULL ))) goto done;
+
+    if (sec_flags & SEC_IMAGE)
+    {
+        if (shared_file)
+        {
+            int shared_fd, shared_needs_close;
+
+            if ((res = server_get_unix_fd( shared_file, FILE_READ_DATA|FILE_WRITE_DATA,
+                                           &shared_fd, &shared_needs_close, NULL, NULL ))) goto done;
+            res = map_image( handle, access, unix_handle, alloc_type & MEM_TOP_DOWN, zero_bits_64, image_info,
+                             shared_fd, needs_close, addr_ptr );
+            if (shared_needs_close) close( shared_fd );
+            close_handle( shared_file );
+        }
+        else
+        {
+            res = map_image( handle, access, unix_handle, alloc_type & MEM_TOP_DOWN, zero_bits_64, image_info,
+                             -1, needs_close, addr_ptr );
+        }
+        if (needs_close) close( unix_handle );
+        if (res >= 0) *size_ptr = image_info->map_size;
+        return res;
+    }
+
+    res = STATUS_INVALID_PARAMETER;
+    if (offset.QuadPart >= full_size) goto done;
+    if (*size_ptr)
+    {
+        size = *size_ptr;
+        if (size > full_size - offset.QuadPart)
+        {
+            res = STATUS_INVALID_VIEW_SIZE;
+            goto done;
+        }
+    }
+    else
+    {
+        size = full_size - offset.QuadPart;
+        if (size != full_size - offset.QuadPart)  /* truncated */
+        {
+            WARN( "Files larger than 4Gb (%s) not supported on this platform\n",
+                  wine_dbgstr_longlong(full_size) );
+            goto done;
+        }
+    }
+    if (!(size = ROUND_SIZE( 0, size ))) goto done;  /* wrap-around */
+
+    /* Reserve a properly aligned area */
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    get_vprot_flags( protect, &vprot, sec_flags & SEC_IMAGE );
+    vprot |= sec_flags;
+    if (!(sec_flags & SEC_RESERVE)) vprot |= VPROT_COMMITTED;
+    res = map_view( &view, *addr_ptr, size, alloc_type & MEM_TOP_DOWN, vprot, zero_bits_64 );
+    if (res)
+    {
+        server_leave_uninterrupted_section( &csVirtual, &sigset );
+        goto done;
+    }
+
+    /* Map the file */
+
+    TRACE( "handle=%p size=%lx offset=%x%08x\n", handle, size, offset.u.HighPart, offset.u.LowPart );
+
+    res = map_file_into_view( view, unix_handle, 0, size, offset.QuadPart, vprot, needs_close );
+    if (res == STATUS_SUCCESS)
+    {
+        SERVER_START_REQ( map_view )
+        {
+            req->mapping = wine_server_obj_handle( handle );
+            req->access  = access;
+            req->base    = wine_server_client_ptr( view->base );
+            req->size    = size;
+            req->start   = offset.QuadPart;
+            res = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+
+    if (res == STATUS_SUCCESS)
+    {
+        *addr_ptr = view->base;
+        *size_ptr = size;
+        VIRTUAL_DEBUG_DUMP_VIEW( view );
+    }
+    else
+    {
+        ERR( "mapping %p %lx %x%08x failed\n", view->base, size, offset.u.HighPart, offset.u.LowPart );
+        delete_view( view );
+    }
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+
+done:
+    if (needs_close) close( unix_handle );
+    return res;
+}
+
+
+struct alloc_virtual_heap
+{
+    void  *base;
+    size_t size;
+};
+
+/* callback for mmap_enum_reserved_areas to allocate space for the virtual heap */
+static int CDECL alloc_virtual_heap( void *base, SIZE_T size, void *arg )
+{
+    struct alloc_virtual_heap *alloc = arg;
+
+    if (is_beyond_limit( base, size, address_space_limit )) address_space_limit = (char *)base + size;
+    if (size < alloc->size) return 0;
+    if (is_win64 && base < (void *)0x80000000) return 0;
+    alloc->base = wine_anon_mmap( (char *)base + size - alloc->size, alloc->size,
+                                  PROT_READ|PROT_WRITE, MAP_FIXED );
+    return (alloc->base != (void *)-1);
+}
+
+/***********************************************************************
+ *           virtual_init
+ */
+void virtual_init(void)
+{
+    const char *preload;
+    struct alloc_virtual_heap alloc_views;
+    size_t size;
+
+#if !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && !defined(__aarch64__)
+    page_size = sysconf( _SC_PAGESIZE );
+    page_mask = page_size - 1;
+    /* Make sure we have a power of 2 */
+    assert( !(page_size & page_mask) );
+    page_shift = 0;
+    while ((1 << page_shift) != page_size) page_shift++;
+#ifdef _WIN64
+    address_space_limit = (void *)(((1UL << 47) - 1) & ~page_mask);
+#else
+    address_space_limit = (void *)~page_mask;
+#endif
+    user_space_limit = working_set_limit = address_space_limit;
+#endif
+    if ((preload = getenv("WINEPRELOADRESERVE")))
+    {
+        unsigned long start, end;
+        if (sscanf( preload, "%lx-%lx", &start, &end ) == 2)
+        {
+            preload_reserve_start = (void *)start;
+            preload_reserve_end = (void *)end;
+            /* some apps start inside the DOS area */
+            if (preload_reserve_start)
+                address_space_start = min( address_space_start, preload_reserve_start );
+        }
+    }
+
+    size = ROUND_SIZE( 0, sizeof(TEB) ) + max( MINSIGSTKSZ, 8192 );
+    /* find the first power of two not smaller than size */
+    signal_stack_align = page_shift;
+    while ((1u << signal_stack_align) < size) signal_stack_align++;
+    signal_stack_mask = (1 << signal_stack_align) - 1;
+    signal_stack_size = (1 << signal_stack_align) - ROUND_SIZE( 0, sizeof(TEB) );
+
+    /* try to find space in a reserved area for the views and pages protection table */
+#ifdef _WIN64
+    pages_vprot_size = ((size_t)address_space_limit >> page_shift >> pages_vprot_shift) + 1;
+    alloc_views.size = 2 * view_block_size + pages_vprot_size * sizeof(*pages_vprot);
+#else
+    alloc_views.size = 2 * view_block_size + (1U << (32 - page_shift));
+#endif
+    if (unix_funcs->mmap_enum_reserved_areas( alloc_virtual_heap, &alloc_views, 1 ))
+        unix_funcs->mmap_remove_reserved_area( alloc_views.base, alloc_views.size );
+    else
+        alloc_views.base = wine_anon_mmap( NULL, alloc_views.size, PROT_READ | PROT_WRITE, 0 );
+
+    assert( alloc_views.base != (void *)-1 );
+    view_block_start = alloc_views.base;
+    view_block_end = view_block_start + view_block_size / sizeof(*view_block_start);
+    free_ranges = (void *)((char *)alloc_views.base + view_block_size);
+    pages_vprot = (void *)((char *)alloc_views.base + 2 * view_block_size);
+    wine_rb_init( &views_tree, compare_view );
+
+    free_ranges[0].base = (void *)0;
+    free_ranges[0].end = (void *)~0;
+    free_ranges_end = free_ranges + 1;
+
+    /* make the DOS area accessible (except the low 64K) to hide bugs in broken apps like Excel 2003 */
+    size = (char *)address_space_start - (char *)0x10000;
+    if (size && unix_funcs->mmap_is_in_reserved_area( (void*)0x10000, size ) == 1)
+        wine_anon_mmap( (void *)0x10000, size, PROT_READ | PROT_WRITE, MAP_FIXED );
+}
+
+
+/***********************************************************************
+ *           virtual_get_system_info
+ */
+void virtual_get_system_info( SYSTEM_BASIC_INFORMATION *info )
+{
+#ifdef HAVE_SYSINFO
+    struct sysinfo sinfo;
+#endif
+
+    info->unknown                 = 0;
+    info->KeMaximumIncrement      = 0;  /* FIXME */
+    info->PageSize                = page_size;
+    info->MmLowestPhysicalPage    = 1;
+    info->MmHighestPhysicalPage   = 0x7fffffff / page_size;
+#ifdef HAVE_SYSINFO
+    if (!sysinfo(&sinfo))
+    {
+        ULONG64 total = (ULONG64)sinfo.totalram * sinfo.mem_unit;
+        info->MmHighestPhysicalPage = max(1, total / page_size);
+    }
+#endif
+    info->MmNumberOfPhysicalPages = info->MmHighestPhysicalPage - info->MmLowestPhysicalPage;
+    info->AllocationGranularity   = granularity_mask + 1;
+    info->LowestUserAddress       = (void *)0x10000;
+    info->HighestUserAddress      = (char *)user_space_limit - 1;
+    info->ActiveProcessorsAffinityMask = get_system_affinity_mask();
+    info->NumberOfProcessors      = NtCurrentTeb()->Peb->NumberOfProcessors;
+}
+
+
+/***********************************************************************
+ *           virtual_create_builtin_view
+ */
+NTSTATUS virtual_create_builtin_view( void *module )
+{
+    NTSTATUS status;
+    sigset_t sigset;
+    IMAGE_NT_HEADERS *nt = RtlImageNtHeader( module );
+    SIZE_T size = nt->OptionalHeader.SizeOfImage;
+    IMAGE_SECTION_HEADER *sec;
+    struct file_view *view;
+    void *base;
+    int i;
+
+    size = ROUND_SIZE( module, size );
+    base = ROUND_ADDR( module, page_mask );
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    status = create_view( &view, base, size, SEC_IMAGE | SEC_FILE | VPROT_SYSTEM |
+                          VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY | VPROT_EXEC );
+    if (!status)
+    {
+        TRACE( "created %p-%p\n", base, (char *)base + size );
+
+        /* The PE header is always read-only, no write, no execute. */
+        set_page_vprot( base, page_size, VPROT_COMMITTED | VPROT_READ );
+
+        sec = (IMAGE_SECTION_HEADER *)((char *)&nt->OptionalHeader + nt->FileHeader.SizeOfOptionalHeader);
+        for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
+        {
+            BYTE flags = VPROT_COMMITTED;
+
+            if (sec[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) flags |= VPROT_EXEC;
+            if (sec[i].Characteristics & IMAGE_SCN_MEM_READ) flags |= VPROT_READ;
+            if (sec[i].Characteristics & IMAGE_SCN_MEM_WRITE) flags |= VPROT_WRITE;
+            set_page_vprot( (char *)base + sec[i].VirtualAddress, sec[i].Misc.VirtualSize, flags );
+        }
+        VIRTUAL_DEBUG_DUMP_VIEW( view );
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/***********************************************************************
+ *           virtual_alloc_first_teb
+ */
+TEB *virtual_alloc_first_teb(void)
+{
+    TEB *teb;
+    PEB *peb;
+    SIZE_T peb_size = page_size;
+    SIZE_T teb_size = signal_stack_mask + 1;
+    SIZE_T total = 32 * teb_size;
+
+    NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&teb_block, 0, &total,
+                             MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE );
+    teb_block_pos = 30;
+    teb = (TEB *)((char *)teb_block + 30 * teb_size);
+    peb = (PEB *)((char *)teb_block + 32 * teb_size - peb_size);
+    NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&teb, 0, &teb_size, MEM_COMMIT, PAGE_READWRITE );
+    NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&peb, 0, &peb_size, MEM_COMMIT, PAGE_READWRITE );
+
+    teb->Peb = peb;
+    teb->Tib.Self = &teb->Tib;
+    teb->Tib.ExceptionList = (void *)~0ul;
+    teb->Tib.StackBase = (void *)~0ul;
+    teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
+    teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
+    signal_init_threading();
+    signal_alloc_thread( teb );
+    signal_init_thread( teb );
+    use_locks = TRUE;
+    return teb;
+}
+
+
+/***********************************************************************
+ *           virtual_alloc_teb
+ */
+NTSTATUS virtual_alloc_teb( TEB **ret_teb )
+{
+    sigset_t sigset;
+    TEB *teb = NULL;
+    NTSTATUS status = STATUS_SUCCESS;
+    SIZE_T teb_size = signal_stack_mask + 1;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if (next_free_teb)
+    {
+        teb = next_free_teb;
+        next_free_teb = *(TEB **)teb;
+        memset( teb, 0, sizeof(*teb) );
+    }
+    else
+    {
+        if (!teb_block_pos)
+        {
+            void *addr = NULL;
+            SIZE_T total = 32 * teb_size;
+
+            if ((status = NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &total,
+                                                   MEM_RESERVE, PAGE_READWRITE )))
+            {
+                server_leave_uninterrupted_section( &csVirtual, &sigset );
+                return status;
+            }
+            teb_block = addr;
+            teb_block_pos = 32;
+        }
+        teb = (TEB *)((char *)teb_block + --teb_block_pos * teb_size);
+        NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&teb, 0, &teb_size,
+                                 MEM_COMMIT, PAGE_READWRITE );
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+
+    *ret_teb = teb;
+    teb->Peb = NtCurrentTeb()->Peb;
+    teb->Tib.Self = &teb->Tib;
+    teb->Tib.ExceptionList = (void *)~0UL;
+    teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
+    teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
+    if ((status = signal_alloc_thread( teb )))
+    {
+        server_enter_uninterrupted_section( &csVirtual, &sigset );
+        *(TEB **)teb = next_free_teb;
+        next_free_teb = teb;
+        server_leave_uninterrupted_section( &csVirtual, &sigset );
+    }
+    return status;
+}
+
+
+/***********************************************************************
+ *           virtual_free_teb
+ */
+void virtual_free_teb( TEB *teb )
+{
+    struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+    SIZE_T size;
+    sigset_t sigset;
+
+    signal_free_thread( teb );
+    if (teb->DeallocationStack)
+    {
+        size = 0;
+        NtFreeVirtualMemory( GetCurrentProcess(), &teb->DeallocationStack, &size, MEM_RELEASE );
+    }
+    if (thread_data->start_stack)
+    {
+        size = 0;
+        NtFreeVirtualMemory( GetCurrentProcess(), &thread_data->start_stack, &size, MEM_RELEASE );
+    }
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    *(TEB **)teb = next_free_teb;
+    next_free_teb = teb;
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+}
+
+
+/***********************************************************************
+ *           virtual_alloc_thread_stack
+ */
+NTSTATUS virtual_alloc_thread_stack( INITIAL_TEB *stack, SIZE_T reserve_size, SIZE_T commit_size, SIZE_T *pthread_size )
+{
+    struct file_view *view;
+    NTSTATUS status;
+    sigset_t sigset;
+    SIZE_T size, extra_size = 0;
+
+    if (!reserve_size || !commit_size)
+    {
+        IMAGE_NT_HEADERS *nt = RtlImageNtHeader( NtCurrentTeb()->Peb->ImageBaseAddress );
+        if (!reserve_size) reserve_size = nt->OptionalHeader.SizeOfStackReserve;
+        if (!commit_size) commit_size = nt->OptionalHeader.SizeOfStackCommit;
+    }
+
+    size = max( reserve_size, commit_size );
+    if (size < 1024 * 1024) size = 1024 * 1024;  /* Xlib needs a large stack */
+    size = (size + 0xffff) & ~0xffff;  /* round to 64K boundary */
+    if (pthread_size) *pthread_size = extra_size = max( page_size, ROUND_SIZE( 0, *pthread_size ));
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if ((status = map_view( &view, NULL, size + extra_size, FALSE,
+                            VPROT_READ | VPROT_WRITE | VPROT_COMMITTED, 0 )) != STATUS_SUCCESS)
+        goto done;
+
+#ifdef VALGRIND_STACK_REGISTER
+    VALGRIND_STACK_REGISTER( view->base, (char *)view->base + view->size );
+#endif
+
+    /* setup no access guard page */
+    set_page_vprot( view->base, page_size, VPROT_COMMITTED );
+    set_page_vprot( (char *)view->base + page_size, page_size,
+                    VPROT_READ | VPROT_WRITE | VPROT_COMMITTED | VPROT_GUARD );
+    mprotect_range( view->base, 2 * page_size, 0, 0 );
+    VIRTUAL_DEBUG_DUMP_VIEW( view );
+
+    if (extra_size)
+    {
+        struct file_view *extra_view;
+
+        /* shrink the first view and create a second one for the extra size */
+        /* this allows the app to free the stack without freeing the thread start portion */
+        view->size -= extra_size;
+        status = create_view( &extra_view, (char *)view->base + view->size, extra_size,
+                              VPROT_READ | VPROT_WRITE | VPROT_COMMITTED );
+        if (status != STATUS_SUCCESS)
+        {
+            unmap_area( (char *)view->base + view->size, extra_size );
+            delete_view( view );
+            goto done;
+        }
+    }
+
+    /* note: limit is lower than base since the stack grows down */
+    stack->OldStackBase = 0;
+    stack->OldStackLimit = 0;
+    stack->DeallocationStack = view->base;
+    stack->StackBase = (char *)view->base + view->size;
+    stack->StackLimit = (char *)view->base + 2 * page_size;
+done:
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/***********************************************************************
+ *           virtual_clear_thread_stack
+ *
+ * Clear the stack contents before calling the main entry point, some broken apps need that.
+ */
+void virtual_clear_thread_stack( void *stack_end )
+{
+    void *stack = NtCurrentTeb()->Tib.StackLimit;
+    size_t size = (char *)stack_end - (char *)stack;
+
+    wine_anon_mmap( stack, size, PROT_READ | PROT_WRITE, MAP_FIXED );
+    if (force_exec_prot) mprotect( stack, size, PROT_READ | PROT_WRITE | PROT_EXEC );
+}
+
+/**********************************************************************
+ *           RtlCreateUserStack (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlCreateUserStack( SIZE_T commit, SIZE_T reserve, ULONG zero_bits,
+                                    SIZE_T commit_align, SIZE_T reserve_align, INITIAL_TEB *stack )
+{
+    TRACE("commit %#lx, reserve %#lx, zero_bits %u, commit_align %#lx, reserve_align %#lx, stack %p\n",
+            commit, reserve, zero_bits, commit_align, reserve_align, stack);
+
+    if (!commit_align || !reserve_align)
+        return STATUS_INVALID_PARAMETER;
+
+    if (!commit || !reserve)
+    {
+        IMAGE_NT_HEADERS *nt = RtlImageNtHeader( NtCurrentTeb()->Peb->ImageBaseAddress );
+        if (!reserve) reserve = nt->OptionalHeader.SizeOfStackReserve;
+        if (!commit) commit = nt->OptionalHeader.SizeOfStackCommit;
+    }
+
+    reserve = (reserve + reserve_align - 1) & ~(reserve_align - 1);
+    commit = (commit + commit_align - 1) & ~(commit_align - 1);
+
+    return virtual_alloc_thread_stack( stack, reserve, commit, NULL );
+}
+
+/**********************************************************************
+ *           RtlFreeUserStack (NTDLL.@)
+ */
+void WINAPI RtlFreeUserStack( void *stack )
+{
+    SIZE_T size = 0;
+
+    TRACE("stack %p\n", stack);
+
+    NtFreeVirtualMemory( NtCurrentProcess(), &stack, &size, MEM_RELEASE );
+}
+
+/***********************************************************************
+ *           virtual_handle_fault
+ */
+NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack )
+{
+    NTSTATUS ret = STATUS_ACCESS_VIOLATION;
+    void *page = ROUND_ADDR( addr, page_mask );
+    sigset_t sigset;
+    BYTE vprot;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    vprot = get_page_vprot( page );
+    if (!on_signal_stack && (vprot & VPROT_GUARD))
+    {
+        set_page_vprot_bits( page, page_size, 0, VPROT_GUARD );
+        mprotect_range( page, page_size, 0, 0 );
+        ret = STATUS_GUARD_PAGE_VIOLATION;
+    }
+    else if (err & EXCEPTION_WRITE_FAULT)
+    {
+        if (vprot & VPROT_WRITEWATCH)
+        {
+            set_page_vprot_bits( page, page_size, 0, VPROT_WRITEWATCH );
+            mprotect_range( page, page_size, 0, 0 );
+        }
+        /* ignore fault if page is writable now */
+        if (VIRTUAL_GetUnixProt( get_page_vprot( page )) & PROT_WRITE)
+        {
+            if ((vprot & VPROT_WRITEWATCH) || is_write_watch_range( page, page_size ))
+                ret = STATUS_SUCCESS;
+        }
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           check_write_access
+ *
+ * Check if the memory range is writable, temporarily disabling write watches if necessary.
+ */
+static NTSTATUS check_write_access( void *base, size_t size, BOOL *has_write_watch )
+{
+    size_t i;
+    char *addr = ROUND_ADDR( base, page_mask );
+
+    size = ROUND_SIZE( base, size );
+    for (i = 0; i < size; i += page_size)
+    {
+        BYTE vprot = get_page_vprot( addr + i );
+        if (vprot & VPROT_WRITEWATCH) *has_write_watch = TRUE;
+        if (!(VIRTUAL_GetUnixProt( vprot & ~VPROT_WRITEWATCH ) & PROT_WRITE))
+            return STATUS_INVALID_USER_BUFFER;
+    }
+    if (*has_write_watch)
+        mprotect_range( addr, size, 0, VPROT_WRITEWATCH );  /* temporarily enable write access */
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           virtual_locked_server_call
+ */
+unsigned int virtual_locked_server_call( void *req_ptr )
+{
+    struct __server_request_info * const req = req_ptr;
+    sigset_t sigset;
+    void *addr = req->reply_data;
+    data_size_t size = req->u.req.request_header.reply_size;
+    BOOL has_write_watch = FALSE;
+    unsigned int ret = STATUS_ACCESS_VIOLATION;
+
+    if (!size) return wine_server_call( req_ptr );
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if (!(ret = check_write_access( addr, size, &has_write_watch )))
+    {
+        ret = server_call_unlocked( req );
+        if (has_write_watch) update_write_watches( addr, size, wine_server_reply_size( req ));
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           virtual_locked_read
+ */
+ssize_t virtual_locked_read( int fd, void *addr, size_t size )
+{
+    sigset_t sigset;
+    BOOL has_write_watch = FALSE;
+    int err = EFAULT;
+
+    ssize_t ret = read( fd, addr, size );
+    if (ret != -1 || errno != EFAULT) return ret;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if (!check_write_access( addr, size, &has_write_watch ))
+    {
+        ret = read( fd, addr, size );
+        err = errno;
+        if (has_write_watch) update_write_watches( addr, size, max( 0, ret ));
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    errno = err;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           virtual_locked_pread
+ */
+ssize_t virtual_locked_pread( int fd, void *addr, size_t size, off_t offset )
+{
+    sigset_t sigset;
+    BOOL has_write_watch = FALSE;
+    int err = EFAULT;
+
+    ssize_t ret = pread( fd, addr, size, offset );
+    if (ret != -1 || errno != EFAULT) return ret;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if (!check_write_access( addr, size, &has_write_watch ))
+    {
+        ret = pread( fd, addr, size, offset );
+        err = errno;
+        if (has_write_watch) update_write_watches( addr, size, max( 0, ret ));
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    errno = err;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           __wine_locked_recvmsg
+ */
+ssize_t CDECL __wine_locked_recvmsg( int fd, struct msghdr *hdr, int flags )
+{
+    sigset_t sigset;
+    size_t i;
+    BOOL has_write_watch = FALSE;
+    int err = EFAULT;
+
+    ssize_t ret = recvmsg( fd, hdr, flags );
+    if (ret != -1 || errno != EFAULT) return ret;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    for (i = 0; i < hdr->msg_iovlen; i++)
+        if (check_write_access( hdr->msg_iov[i].iov_base, hdr->msg_iov[i].iov_len, &has_write_watch ))
+            break;
+    if (i == hdr->msg_iovlen)
+    {
+        ret = recvmsg( fd, hdr, flags );
+        err = errno;
+    }
+    if (has_write_watch)
+        while (i--) update_write_watches( hdr->msg_iov[i].iov_base, hdr->msg_iov[i].iov_len, 0 );
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    errno = err;
+    return ret;
+}
+
+
+/***********************************************************************
+ *           virtual_is_valid_code_address
+ */
+BOOL virtual_is_valid_code_address( const void *addr, SIZE_T size )
+{
+    struct file_view *view;
+    BOOL ret = FALSE;
+    sigset_t sigset;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if ((view = VIRTUAL_FindView( addr, size )))
+        ret = !(view->protect & VPROT_SYSTEM);  /* system views are not visible to the app */
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           virtual_handle_stack_fault
+ *
+ * Handle an access fault inside the current thread stack.
+ * Return 1 if safely handled, -1 if handled into the overflow space.
+ * Called from inside a signal handler.
+ */
+int virtual_handle_stack_fault( void *addr )
+{
+    int ret = 0;
+
+    if ((char *)addr < (char *)NtCurrentTeb()->DeallocationStack) return 0;
+    if ((char *)addr >= (char *)NtCurrentTeb()->Tib.StackBase) return 0;
+
+    RtlEnterCriticalSection( &csVirtual );  /* no need for signal masking inside signal handler */
+    if (get_page_vprot( addr ) & VPROT_GUARD)
+    {
+        size_t guaranteed = max( NtCurrentTeb()->GuaranteedStackBytes, page_size * (is_win64 ? 2 : 1) );
+        char *page = ROUND_ADDR( addr, page_mask );
+        set_page_vprot_bits( page, page_size, 0, VPROT_GUARD );
+        mprotect_range( page, page_size, 0, 0 );
+        if (page >= (char *)NtCurrentTeb()->DeallocationStack + page_size + guaranteed)
+        {
+            set_page_vprot_bits( page - page_size, page_size, VPROT_COMMITTED | VPROT_GUARD, 0 );
+            mprotect_range( page - page_size, page_size, 0, 0 );
+            ret = 1;
+        }
+        else  /* inside guaranteed space -> overflow exception */
+        {
+            page = (char *)NtCurrentTeb()->DeallocationStack + page_size;
+            set_page_vprot_bits( page, guaranteed, VPROT_COMMITTED, VPROT_GUARD );
+            mprotect_range( page, guaranteed, 0, 0 );
+            ret = -1;
+        }
+        NtCurrentTeb()->Tib.StackLimit = page;
+    }
+    RtlLeaveCriticalSection( &csVirtual );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           virtual_check_buffer_for_read
+ *
+ * Check if a memory buffer can be read, triggering page faults if needed for DIB section access.
+ */
+BOOL virtual_check_buffer_for_read( const void *ptr, SIZE_T size )
+{
+    if (!size) return TRUE;
+    if (!ptr) return FALSE;
+
+    __TRY
+    {
+        volatile const char *p = ptr;
+        char dummy __attribute__((unused));
+        SIZE_T count = size;
+
+        while (count > page_size)
+        {
+            dummy = *p;
+            p += page_size;
+            count -= page_size;
+        }
+        dummy = p[0];
+        dummy = p[count - 1];
+    }
+    __EXCEPT_PAGE_FAULT
+    {
+        return FALSE;
+    }
+    __ENDTRY
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           virtual_check_buffer_for_write
+ *
+ * Check if a memory buffer can be written to, triggering page faults if needed for write watches.
+ */
+BOOL virtual_check_buffer_for_write( void *ptr, SIZE_T size )
+{
+    if (!size) return TRUE;
+    if (!ptr) return FALSE;
+
+    __TRY
+    {
+        volatile char *p = ptr;
+        SIZE_T count = size;
+
+        while (count > page_size)
+        {
+            *p |= 0;
+            p += page_size;
+            count -= page_size;
+        }
+        p[0] |= 0;
+        p[count - 1] |= 0;
+    }
+    __EXCEPT_PAGE_FAULT
+    {
+        return FALSE;
+    }
+    __ENDTRY
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           virtual_uninterrupted_read_memory
+ *
+ * Similar to NtReadVirtualMemory, but without wineserver calls. Moreover
+ * permissions are checked before accessing each page, to ensure that no
+ * exceptions can happen.
+ */
+SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size )
+{
+    struct file_view *view;
+    sigset_t sigset;
+    SIZE_T bytes_read = 0;
+
+    if (!size) return 0;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if ((view = VIRTUAL_FindView( addr, size )))
+    {
+        if (!(view->protect & VPROT_SYSTEM))
+        {
+            while (bytes_read < size && (VIRTUAL_GetUnixProt( get_page_vprot( addr )) & PROT_READ))
+            {
+                SIZE_T block_size = min( size - bytes_read, page_size - ((UINT_PTR)addr & page_mask) );
+                memcpy( buffer, addr, block_size );
+
+                addr   = (const void *)((const char *)addr + block_size);
+                buffer = (void *)((char *)buffer + block_size);
+                bytes_read += block_size;
+            }
+        }
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return bytes_read;
+}
+
+
+/***********************************************************************
+ *           virtual_uninterrupted_write_memory
+ *
+ * Similar to NtWriteVirtualMemory, but without wineserver calls. Moreover
+ * permissions are checked before accessing each page, to ensure that no
+ * exceptions can happen.
+ */
+NTSTATUS virtual_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size )
+{
+    BOOL has_write_watch = FALSE;
+    sigset_t sigset;
+    NTSTATUS ret;
+
+    if (!size) return STATUS_SUCCESS;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if (!(ret = check_write_access( addr, size, &has_write_watch )))
+    {
+        memcpy( addr, buffer, size );
+        if (has_write_watch) update_write_watches( addr, size, size );
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           VIRTUAL_SetForceExec
+ *
+ * Whether to force exec prot on all views.
+ */
+void VIRTUAL_SetForceExec( BOOL enable )
+{
+    struct file_view *view;
+    sigset_t sigset;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if (!force_exec_prot != !enable)  /* change all existing views */
+    {
+        force_exec_prot = enable;
+
+        WINE_RB_FOR_EACH_ENTRY( view, &views_tree, struct file_view, entry )
+        {
+            /* file mappings are always accessible */
+            BYTE commit = is_view_valloc( view ) ? 0 : VPROT_COMMITTED;
+
+            mprotect_range( view->base, view->size, commit, 0 );
+        }
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+}
+
+struct free_range
+{
+    char *base;
+    char *limit;
+};
+
+/* free reserved areas above the limit; callback for mmap_enum_reserved_areas */
+static int CDECL free_reserved_memory( void *base, SIZE_T size, void *arg )
+{
+    struct free_range *range = arg;
+
+    if ((char *)base >= range->limit) return 0;
+    if ((char *)base + size <= range->base) return 0;
+    if ((char *)base < range->base)
+    {
+        size -= range->base - (char *)base;
+        base = range->base;
+    }
+    if ((char *)base + size > range->limit) size = range->limit - (char *)base;
+    remove_reserved_area( base, size );
+    return 1;  /* stop enumeration since the list has changed */
+}
+
+/***********************************************************************
+ *           virtual_release_address_space
+ *
+ * Release some address space once we have loaded and initialized the app.
+ */
+void virtual_release_address_space(void)
+{
+    struct free_range range;
+    sigset_t sigset;
+
+    if (is_win64) return;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    range.base  = (char *)0x82000000;
+    range.limit = user_space_limit;
+
+    if (range.limit > range.base)
+    {
+        while (unix_funcs->mmap_enum_reserved_areas( free_reserved_memory, &range, 1 )) /* nothing */;
+#ifdef __APPLE__
+        /* On macOS, we still want to free some of low memory, for OpenGL resources */
+        range.base  = (char *)0x40000000;
+#else
+        range.base  = NULL;
+#endif
+    }
+    else
+        range.base = (char *)0x20000000;
+
+    if (range.base)
+    {
+        range.limit = (char *)0x7f000000;
+        while (unix_funcs->mmap_enum_reserved_areas( free_reserved_memory, &range, 0 )) /* nothing */;
+    }
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+}
+
+
+/***********************************************************************
+ *           virtual_set_large_address_space
+ *
+ * Enable use of a large address space when allowed by the application.
+ */
+void virtual_set_large_address_space(void)
+{
+    IMAGE_NT_HEADERS *nt = RtlImageNtHeader( NtCurrentTeb()->Peb->ImageBaseAddress );
+
+    if (!(nt->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)) return;
+    /* no large address space on win9x */
+    if (NtCurrentTeb()->Peb->OSPlatformId != VER_PLATFORM_WIN32_NT) return;
+
+    user_space_limit = working_set_limit = address_space_limit;
+}
+
+
+/***********************************************************************
+ *             NtAllocateVirtualMemory   (NTDLL.@)
+ *             ZwAllocateVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG_PTR zero_bits,
+                                         SIZE_T *size_ptr, ULONG type, ULONG protect )
+{
+    SIZE_T size = *size_ptr;
+    NTSTATUS status = STATUS_SUCCESS;
+    unsigned short zero_bits_64 = zero_bits_win_to_64( zero_bits );
+
+    TRACE("%p %p %08lx %x %08x\n", process, *ret, size, type, protect );
+
+    if (!size) return STATUS_INVALID_PARAMETER;
+    if (zero_bits > 21 && zero_bits < 32) return STATUS_INVALID_PARAMETER_3;
+    if (!is_win64 && !is_wow64 && zero_bits >= 32) return STATUS_INVALID_PARAMETER_3;
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_alloc.type         = APC_VIRTUAL_ALLOC;
+        call.virtual_alloc.addr         = wine_server_client_ptr( *ret );
+        call.virtual_alloc.size         = *size_ptr;
+        call.virtual_alloc.zero_bits_64 = zero_bits_64;
+        call.virtual_alloc.op_type      = type;
+        call.virtual_alloc.prot         = protect;
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_alloc.status == STATUS_SUCCESS)
+        {
+            *ret      = wine_server_get_ptr( result.virtual_alloc.addr );
+            *size_ptr = result.virtual_alloc.size;
+        }
+        return result.virtual_alloc.status;
+    }
+
+    return virtual_alloc( ret, zero_bits_64, size_ptr, type, protect );
+}
+
+
+/***********************************************************************
+ *             virtual_alloc   (NTDLL.@)
+ *
+ * Same as NtAllocateVirtualMemory for the current process.
+ */
+NTSTATUS virtual_alloc( PVOID *ret, unsigned short zero_bits_64, SIZE_T *size_ptr,
+                        ULONG type, ULONG protect )
+{
+    void *base;
+    unsigned int vprot;
+    SIZE_T size = *size_ptr;
+    NTSTATUS status = STATUS_SUCCESS;
+    BOOL is_dos_memory = FALSE;
+    struct file_view *view;
+    sigset_t sigset;
+
+    /* Round parameters to a page boundary */
+
+    if (is_beyond_limit( 0, size, working_set_limit )) return STATUS_WORKING_SET_LIMIT_RANGE;
+
+    if (*ret)
+    {
+        if (type & MEM_RESERVE) /* Round down to 64k boundary */
+            base = ROUND_ADDR( *ret, granularity_mask );
+        else
+            base = ROUND_ADDR( *ret, page_mask );
+        size = (((UINT_PTR)*ret + size + page_mask) & ~page_mask) - (UINT_PTR)base;
+
+        /* disallow low 64k, wrap-around and kernel space */
+        if (((char *)base < (char *)0x10000) ||
+            ((char *)base + size < (char *)base) ||
+            is_beyond_limit( base, size, address_space_limit ))
+        {
+            /* address 1 is magic to mean DOS area */
+            if (!base && *ret == (void *)1 && size == 0x110000) is_dos_memory = TRUE;
+            else return STATUS_INVALID_PARAMETER;
+        }
+    }
+    else
+    {
+        base = NULL;
+        size = (size + page_mask) & ~page_mask;
+    }
+
+    /* Compute the alloc type flags */
+
+    if (!(type & (MEM_COMMIT | MEM_RESERVE | MEM_RESET)) ||
+        (type & ~(MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN | MEM_WRITE_WATCH | MEM_RESET)))
+    {
+        WARN("called with wrong alloc type flags (%08x) !\n", type);
+        return STATUS_INVALID_PARAMETER;
+    }
+
+    /* Reserve the memory */
+
+    if (use_locks) server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if ((type & MEM_RESERVE) || !base)
+    {
+        if (!(status = get_vprot_flags( protect, &vprot, FALSE )))
+        {
+            if (type & MEM_COMMIT) vprot |= VPROT_COMMITTED;
+            if (type & MEM_WRITE_WATCH) vprot |= VPROT_WRITEWATCH;
+            if (protect & PAGE_NOCACHE) vprot |= SEC_NOCACHE;
+
+            if (vprot & VPROT_WRITECOPY) status = STATUS_INVALID_PAGE_PROTECTION;
+            else if (is_dos_memory) status = allocate_dos_memory( &view, vprot );
+            else status = map_view( &view, base, size, type & MEM_TOP_DOWN, vprot, zero_bits_64 );
+
+            if (status == STATUS_SUCCESS) base = view->base;
+        }
+    }
+    else if (type & MEM_RESET)
+    {
+        if (!(view = VIRTUAL_FindView( base, size ))) status = STATUS_NOT_MAPPED_VIEW;
+        else madvise( base, size, MADV_DONTNEED );
+    }
+    else  /* commit the pages */
+    {
+        if (!(view = VIRTUAL_FindView( base, size ))) status = STATUS_NOT_MAPPED_VIEW;
+        else if (view->protect & SEC_FILE) status = STATUS_ALREADY_COMMITTED;
+        else if (!(status = set_protection( view, base, size, protect )) && (view->protect & SEC_RESERVE))
+        {
+            SERVER_START_REQ( add_mapping_committed_range )
+            {
+                req->base   = wine_server_client_ptr( view->base );
+                req->offset = (char *)base - (char *)view->base;
+                req->size   = size;
+                wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+    }
+
+    if (!status) VIRTUAL_DEBUG_DUMP_VIEW( view );
+
+    if (use_locks) server_leave_uninterrupted_section( &csVirtual, &sigset );
+
+    if (status == STATUS_SUCCESS)
+    {
+        *ret = base;
+        *size_ptr = size;
+    }
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtFreeVirtualMemory   (NTDLL.@)
+ *             ZwFreeVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtFreeVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr, ULONG type )
+{
+    struct file_view *view;
+    char *base;
+    sigset_t sigset;
+    NTSTATUS status = STATUS_SUCCESS;
+    LPVOID addr = *addr_ptr;
+    SIZE_T size = *size_ptr;
+
+    TRACE("%p %p %08lx %x\n", process, addr, size, type );
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_free.type      = APC_VIRTUAL_FREE;
+        call.virtual_free.addr      = wine_server_client_ptr( addr );
+        call.virtual_free.size      = size;
+        call.virtual_free.op_type   = type;
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_free.status == STATUS_SUCCESS)
+        {
+            *addr_ptr = wine_server_get_ptr( result.virtual_free.addr );
+            *size_ptr = result.virtual_free.size;
+        }
+        return result.virtual_free.status;
+    }
+
+    /* Fix the parameters */
+
+    size = ROUND_SIZE( addr, size );
+    base = ROUND_ADDR( addr, page_mask );
+
+    /* avoid freeing the DOS area when a broken app passes a NULL pointer */
+    if (!base) return STATUS_INVALID_PARAMETER;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if (!(view = VIRTUAL_FindView( base, size )) || !is_view_valloc( view ))
+    {
+        status = STATUS_INVALID_PARAMETER;
+    }
+    else if (type == MEM_RELEASE)
+    {
+        /* Free the pages */
+
+        if (size || (base != view->base)) status = STATUS_INVALID_PARAMETER;
+        else
+        {
+            delete_view( view );
+            *addr_ptr = base;
+            *size_ptr = size;
+        }
+    }
+    else if (type == MEM_DECOMMIT)
+    {
+        status = decommit_pages( view, base - (char *)view->base, size );
+        if (status == STATUS_SUCCESS)
+        {
+            *addr_ptr = base;
+            *size_ptr = size;
+        }
+    }
+    else
+    {
+        WARN("called with wrong free type flags (%08x) !\n", type);
+        status = STATUS_INVALID_PARAMETER;
+    }
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtProtectVirtualMemory   (NTDLL.@)
+ *             ZwProtectVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI DECLSPEC_HOTPATCH NtProtectVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr,
+                                                          ULONG new_prot, ULONG *old_prot )
+{
+    struct file_view *view;
+    sigset_t sigset;
+    NTSTATUS status = STATUS_SUCCESS;
+    char *base;
+    BYTE vprot;
+    SIZE_T size = *size_ptr;
+    LPVOID addr = *addr_ptr;
+    DWORD old;
+
+    TRACE("%p %p %08lx %08x\n", process, addr, size, new_prot );
+
+    if (!old_prot)
+        return STATUS_ACCESS_VIOLATION;
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_protect.type = APC_VIRTUAL_PROTECT;
+        call.virtual_protect.addr = wine_server_client_ptr( addr );
+        call.virtual_protect.size = size;
+        call.virtual_protect.prot = new_prot;
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_protect.status == STATUS_SUCCESS)
+        {
+            *addr_ptr = wine_server_get_ptr( result.virtual_protect.addr );
+            *size_ptr = result.virtual_protect.size;
+            *old_prot = result.virtual_protect.prot;
+        }
+        return result.virtual_protect.status;
+    }
+
+    /* Fix the parameters */
+
+    size = ROUND_SIZE( addr, size );
+    base = ROUND_ADDR( addr, page_mask );
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if ((view = VIRTUAL_FindView( base, size )))
+    {
+        /* Make sure all the pages are committed */
+        if (get_committed_size( view, base, &vprot ) >= size && (vprot & VPROT_COMMITTED))
+        {
+            old = VIRTUAL_GetWin32Prot( vprot, view->protect );
+            status = set_protection( view, base, size, new_prot );
+        }
+        else status = STATUS_NOT_COMMITTED;
+    }
+    else status = STATUS_INVALID_PARAMETER;
+
+    if (!status) VIRTUAL_DEBUG_DUMP_VIEW( view );
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+
+    if (status == STATUS_SUCCESS)
+    {
+        *addr_ptr = base;
+        *size_ptr = size;
+        *old_prot = old;
+    }
+    return status;
+}
+
+
+/* retrieve state for a free memory area; callback for mmap_enum_reserved_areas */
+static int CDECL get_free_mem_state_callback( void *start, SIZE_T size, void *arg )
+{
+    MEMORY_BASIC_INFORMATION *info = arg;
+    void *end = (char *)start + size;
+
+    if ((char *)info->BaseAddress + info->RegionSize <= (char *)start) return 0;
+
+    if (info->BaseAddress >= end)
+    {
+        if (info->AllocationBase < end) info->AllocationBase = end;
+        return 0;
+    }
+
+    if (info->BaseAddress >= start || start <= address_space_start)
+    {
+        /* it's a real free area */
+        info->State             = MEM_FREE;
+        info->Protect           = PAGE_NOACCESS;
+        info->AllocationBase    = 0;
+        info->AllocationProtect = 0;
+        info->Type              = 0;
+        if ((char *)info->BaseAddress + info->RegionSize > (char *)end)
+            info->RegionSize = (char *)end - (char *)info->BaseAddress;
+    }
+    else /* outside of the reserved area, pretend it's allocated */
+    {
+        info->RegionSize        = (char *)start - (char *)info->BaseAddress;
+        info->State             = MEM_RESERVE;
+        info->Protect           = PAGE_NOACCESS;
+        info->AllocationProtect = PAGE_NOACCESS;
+        info->Type              = MEM_PRIVATE;
+    }
+    return 1;
+}
+
+/* get basic information about a memory block */
+static NTSTATUS get_basic_memory_info( HANDLE process, LPCVOID addr,
+                                       MEMORY_BASIC_INFORMATION *info,
+                                       SIZE_T len, SIZE_T *res_len )
+{
+    struct file_view *view;
+    char *base, *alloc_base = 0, *alloc_end = working_set_limit;
+    struct wine_rb_entry *ptr;
+    sigset_t sigset;
+
+    if (len < sizeof(MEMORY_BASIC_INFORMATION))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (process != NtCurrentProcess())
+    {
+        NTSTATUS status;
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_query.type = APC_VIRTUAL_QUERY;
+        call.virtual_query.addr = wine_server_client_ptr( addr );
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_query.status == STATUS_SUCCESS)
+        {
+            info->BaseAddress       = wine_server_get_ptr( result.virtual_query.base );
+            info->AllocationBase    = wine_server_get_ptr( result.virtual_query.alloc_base );
+            info->RegionSize        = result.virtual_query.size;
+            info->Protect           = result.virtual_query.prot;
+            info->AllocationProtect = result.virtual_query.alloc_prot;
+            info->State             = (DWORD)result.virtual_query.state << 12;
+            info->Type              = (DWORD)result.virtual_query.alloc_type << 16;
+            if (info->RegionSize != result.virtual_query.size)  /* truncated */
+                return STATUS_INVALID_PARAMETER;  /* FIXME */
+            if (res_len) *res_len = sizeof(*info);
+        }
+        return result.virtual_query.status;
+    }
+
+    base = ROUND_ADDR( addr, page_mask );
+
+    if (is_beyond_limit( base, 1, working_set_limit )) return STATUS_INVALID_PARAMETER;
+
+    /* Find the view containing the address */
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    ptr = views_tree.root;
+    while (ptr)
+    {
+        view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
+        if ((char *)view->base > base)
+        {
+            alloc_end = view->base;
+            ptr = ptr->left;
+        }
+        else if ((char *)view->base + view->size <= base)
+        {
+            alloc_base = (char *)view->base + view->size;
+            ptr = ptr->right;
+        }
+        else
+        {
+            alloc_base = view->base;
+            alloc_end = (char *)view->base + view->size;
+            break;
+        }
+    }
+
+    /* Fill the info structure */
+
+    info->AllocationBase = alloc_base;
+    info->BaseAddress    = base;
+    info->RegionSize     = alloc_end - base;
+
+    if (!ptr)
+    {
+        if (!unix_funcs->mmap_enum_reserved_areas( get_free_mem_state_callback, info, 0 ))
+        {
+            /* not in a reserved area at all, pretend it's allocated */
+#ifdef __i386__
+            if (base >= (char *)address_space_start)
+            {
+                info->State             = MEM_RESERVE;
+                info->Protect           = PAGE_NOACCESS;
+                info->AllocationProtect = PAGE_NOACCESS;
+                info->Type              = MEM_PRIVATE;
+            }
+            else
+#endif
+            {
+                info->State             = MEM_FREE;
+                info->Protect           = PAGE_NOACCESS;
+                info->AllocationBase    = 0;
+                info->AllocationProtect = 0;
+                info->Type              = 0;
+            }
+        }
+    }
+    else
+    {
+        BYTE vprot;
+        char *ptr;
+        SIZE_T range_size = get_committed_size( view, base, &vprot );
+
+        info->State = (vprot & VPROT_COMMITTED) ? MEM_COMMIT : MEM_RESERVE;
+        info->Protect = (vprot & VPROT_COMMITTED) ? VIRTUAL_GetWin32Prot( vprot, view->protect ) : 0;
+        info->AllocationProtect = VIRTUAL_GetWin32Prot( view->protect, view->protect );
+        if (view->protect & SEC_IMAGE) info->Type = MEM_IMAGE;
+        else if (view->protect & (SEC_FILE | SEC_RESERVE | SEC_COMMIT)) info->Type = MEM_MAPPED;
+        else info->Type = MEM_PRIVATE;
+        for (ptr = base; ptr < base + range_size; ptr += page_size)
+            if ((get_page_vprot( ptr ) ^ vprot) & ~VPROT_WRITEWATCH) break;
+        info->RegionSize = ptr - base;
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+
+    if (res_len) *res_len = sizeof(*info);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS get_working_set_ex( HANDLE process, LPCVOID addr,
+                                    MEMORY_WORKING_SET_EX_INFORMATION *info,
+                                    SIZE_T len, SIZE_T *res_len )
+{
+    FILE *f;
+    MEMORY_WORKING_SET_EX_INFORMATION *p;
+    sigset_t sigset;
+
+    if (process != NtCurrentProcess())
+    {
+        FIXME( "(process=%p,addr=%p) Unimplemented information class: MemoryWorkingSetExInformation\n", process, addr );
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    f = fopen( "/proc/self/pagemap", "rb" );
+    if (!f)
+    {
+        static int once;
+        if (!once++) WARN( "unable to open /proc/self/pagemap\n" );
+    }
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    for (p = info; (UINT_PTR)(p + 1) <= (UINT_PTR)info + len; p++)
+    {
+        BYTE vprot;
+        UINT64 pagemap;
+        struct file_view *view;
+
+        memset( &p->VirtualAttributes, 0, sizeof(p->VirtualAttributes) );
+
+        /* If we don't have pagemap information, default to invalid. */
+        if (!f || fseek( f, ((UINT_PTR)p->VirtualAddress >> 12) * sizeof(pagemap), SEEK_SET ) == -1 ||
+                fread( &pagemap, sizeof(pagemap), 1, f ) != 1)
+        {
+            pagemap = 0;
+        }
+
+        if ((view = VIRTUAL_FindView( p->VirtualAddress, 0 )) &&
+                get_committed_size( view, p->VirtualAddress, &vprot ) &&
+                (vprot & VPROT_COMMITTED))
+        {
+            p->VirtualAttributes.Valid = !(vprot & VPROT_GUARD) && (vprot & 0x0f) && (pagemap >> 63);
+            p->VirtualAttributes.Shared = !is_view_valloc( view ) && ((pagemap >> 61) & 1);
+            if (p->VirtualAttributes.Shared && p->VirtualAttributes.Valid)
+                p->VirtualAttributes.ShareCount = 1; /* FIXME */
+            if (p->VirtualAttributes.Valid)
+                p->VirtualAttributes.Win32Protection = VIRTUAL_GetWin32Prot( vprot, view->protect );
+        }
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+
+    if (f)
+        fclose( f );
+    if (res_len)
+        *res_len = (UINT_PTR)p - (UINT_PTR)info;
+    return STATUS_SUCCESS;
+}
+
+#define UNIMPLEMENTED_INFO_CLASS(c) \
+    case c: \
+        FIXME("(process=%p,addr=%p) Unimplemented information class: " #c "\n", process, addr); \
+        return STATUS_INVALID_INFO_CLASS
+
+/***********************************************************************
+ *             NtQueryVirtualMemory   (NTDLL.@)
+ *             ZwQueryVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryVirtualMemory( HANDLE process, LPCVOID addr,
+                                      MEMORY_INFORMATION_CLASS info_class,
+                                      PVOID buffer, SIZE_T len, SIZE_T *res_len )
+{
+    TRACE("(%p, %p, info_class=%d, %p, %ld, %p)\n",
+          process, addr, info_class, buffer, len, res_len);
+
+    switch(info_class)
+    {
+        case MemoryBasicInformation:
+            return get_basic_memory_info( process, addr, buffer, len, res_len );
+
+        case MemoryWorkingSetExInformation:
+            return get_working_set_ex( process, addr, buffer, len, res_len );
+
+        UNIMPLEMENTED_INFO_CLASS(MemoryWorkingSetList);
+        UNIMPLEMENTED_INFO_CLASS(MemorySectionName);
+        UNIMPLEMENTED_INFO_CLASS(MemoryBasicVlmInformation);
+
+        default:
+            FIXME("(%p,%p,info_class=%d,%p,%ld,%p) Unknown information class\n",
+                  process, addr, info_class, buffer, len, res_len);
+            return STATUS_INVALID_INFO_CLASS;
+    }
+}
+
+
+/***********************************************************************
+ *             NtLockVirtualMemory   (NTDLL.@)
+ *             ZwLockVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtLockVirtualMemory( HANDLE process, PVOID *addr, SIZE_T *size, ULONG unknown )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_lock.type = APC_VIRTUAL_LOCK;
+        call.virtual_lock.addr = wine_server_client_ptr( *addr );
+        call.virtual_lock.size = *size;
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_lock.status == STATUS_SUCCESS)
+        {
+            *addr = wine_server_get_ptr( result.virtual_lock.addr );
+            *size = result.virtual_lock.size;
+        }
+        return result.virtual_lock.status;
+    }
+
+    *size = ROUND_SIZE( *addr, *size );
+    *addr = ROUND_ADDR( *addr, page_mask );
+
+    if (mlock( *addr, *size )) status = STATUS_ACCESS_DENIED;
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtUnlockVirtualMemory   (NTDLL.@)
+ *             ZwUnlockVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtUnlockVirtualMemory( HANDLE process, PVOID *addr, SIZE_T *size, ULONG unknown )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_unlock.type = APC_VIRTUAL_UNLOCK;
+        call.virtual_unlock.addr = wine_server_client_ptr( *addr );
+        call.virtual_unlock.size = *size;
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_unlock.status == STATUS_SUCCESS)
+        {
+            *addr = wine_server_get_ptr( result.virtual_unlock.addr );
+            *size = result.virtual_unlock.size;
+        }
+        return result.virtual_unlock.status;
+    }
+
+    *size = ROUND_SIZE( *addr, *size );
+    *addr = ROUND_ADDR( *addr, page_mask );
+
+    if (munlock( *addr, *size )) status = STATUS_ACCESS_DENIED;
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtCreateSection   (NTDLL.@)
+ *             ZwCreateSection   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+                                 const LARGE_INTEGER *size, ULONG protect,
+                                 ULONG sec_flags, HANDLE file )
+{
+    NTSTATUS ret;
+    unsigned int vprot, file_access = 0;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    if ((ret = get_vprot_flags( protect, &vprot, sec_flags & SEC_IMAGE ))) return ret;
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    if (vprot & VPROT_READ)  file_access |= FILE_READ_DATA;
+    if (vprot & VPROT_WRITE) file_access |= FILE_WRITE_DATA;
+
+    SERVER_START_REQ( create_mapping )
+    {
+        req->access      = access;
+        req->flags       = sec_flags;
+        req->file_handle = wine_server_obj_handle( file );
+        req->file_access = file_access;
+        req->size        = size ? size->QuadPart : 0;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+
+/***********************************************************************
+ *             NtOpenSection   (NTDLL.@)
+ *             ZwOpenSection   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtOpenSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+
+    if ((ret = validate_open_object_attributes( attr ))) return ret;
+
+    SERVER_START_REQ( open_mapping )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/***********************************************************************
+ *             NtMapViewOfSection   (NTDLL.@)
+ *             ZwMapViewOfSection   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtMapViewOfSection( HANDLE handle, HANDLE process, PVOID *addr_ptr, ULONG_PTR zero_bits,
+                                    SIZE_T commit_size, const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr,
+                                    SECTION_INHERIT inherit, ULONG alloc_type, ULONG protect )
+{
+    NTSTATUS res;
+    SIZE_T mask = granularity_mask;
+    pe_image_info_t image_info;
+    LARGE_INTEGER offset;
+    unsigned short zero_bits_64 = zero_bits_win_to_64( zero_bits );
+
+    offset.QuadPart = offset_ptr ? offset_ptr->QuadPart : 0;
+
+    TRACE("handle=%p process=%p addr=%p off=%x%08x size=%lx access=%x\n",
+          handle, process, *addr_ptr, offset.u.HighPart, offset.u.LowPart, *size_ptr, protect );
+
+    /* Check parameters */
+    if (zero_bits > 21 && zero_bits < 32)
+        return STATUS_INVALID_PARAMETER_4;
+    if (!is_win64 && !is_wow64 && zero_bits >= 32)
+        return STATUS_INVALID_PARAMETER_4;
+
+    /* If both addr_ptr and zero_bits are passed, they have match */
+    if (*addr_ptr && zero_bits && zero_bits < 32 &&
+        (((UINT_PTR)*addr_ptr) >> (32 - zero_bits)))
+        return STATUS_INVALID_PARAMETER_4;
+    if (*addr_ptr && zero_bits >= 32 &&
+        (((UINT_PTR)*addr_ptr) & ~zero_bits))
+        return STATUS_INVALID_PARAMETER_4;
+
+#ifndef _WIN64
+    if (!is_wow64 && (alloc_type & AT_ROUND_TO_PAGE))
+    {
+        *addr_ptr = ROUND_ADDR( *addr_ptr, page_mask );
+        mask = page_mask;
+    }
+#endif
+
+    if ((offset.u.LowPart & mask) || (*addr_ptr && ((UINT_PTR)*addr_ptr & mask)))
+        return STATUS_MAPPED_ALIGNMENT;
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.map_view.type         = APC_MAP_VIEW;
+        call.map_view.handle       = wine_server_obj_handle( handle );
+        call.map_view.addr         = wine_server_client_ptr( *addr_ptr );
+        call.map_view.size         = *size_ptr;
+        call.map_view.offset       = offset.QuadPart;
+        call.map_view.zero_bits_64 = zero_bits_64;
+        call.map_view.alloc_type   = alloc_type;
+        call.map_view.prot         = protect;
+        res = server_queue_process_apc( process, &call, &result );
+        if (res != STATUS_SUCCESS) return res;
+
+        if ((NTSTATUS)result.map_view.status >= 0)
+        {
+            *addr_ptr = wine_server_get_ptr( result.map_view.addr );
+            *size_ptr = result.map_view.size;
+        }
+        return result.map_view.status;
+    }
+
+    return virtual_map_section( handle, addr_ptr, zero_bits_64, commit_size,
+                                offset_ptr, size_ptr, alloc_type, protect,
+                                &image_info );
+}
+
+
+/***********************************************************************
+ *             NtUnmapViewOfSection   (NTDLL.@)
+ *             ZwUnmapViewOfSection   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtUnmapViewOfSection( HANDLE process, PVOID addr )
+{
+    struct file_view *view;
+    NTSTATUS status = STATUS_NOT_MAPPED_VIEW;
+    sigset_t sigset;
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.unmap_view.type = APC_UNMAP_VIEW;
+        call.unmap_view.addr = wine_server_client_ptr( addr );
+        status = server_queue_process_apc( process, &call, &result );
+        if (status == STATUS_SUCCESS) status = result.unmap_view.status;
+        return status;
+    }
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if ((view = VIRTUAL_FindView( addr, 0 )) && !is_view_valloc( view ))
+    {
+        if (!(view->protect & VPROT_SYSTEM))
+        {
+            SERVER_START_REQ( unmap_view )
+            {
+                req->base = wine_server_client_ptr( view->base );
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+            if (!status) delete_view( view );
+            else FIXME( "failed to unmap %p %x\n", view->base, status );
+        }
+        else
+        {
+            delete_view( view );
+            status = STATUS_SUCCESS;
+        }
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/******************************************************************************
+ *             virtual_fill_image_information
+ *
+ * Helper for NtQuerySection.
+ */
+void virtual_fill_image_information( const pe_image_info_t *pe_info, SECTION_IMAGE_INFORMATION *info )
+{
+    info->TransferAddress      = wine_server_get_ptr( pe_info->entry_point );
+    info->ZeroBits             = pe_info->zerobits;
+    info->MaximumStackSize     = pe_info->stack_size;
+    info->CommittedStackSize   = pe_info->stack_commit;
+    info->SubSystemType        = pe_info->subsystem;
+    info->SubsystemVersionLow  = pe_info->subsystem_low;
+    info->SubsystemVersionHigh = pe_info->subsystem_high;
+    info->GpValue              = pe_info->gp;
+    info->ImageCharacteristics = pe_info->image_charact;
+    info->DllCharacteristics   = pe_info->dll_charact;
+    info->Machine              = pe_info->machine;
+    info->ImageContainsCode    = pe_info->contains_code;
+    info->u.ImageFlags         = pe_info->image_flags & ~(IMAGE_FLAGS_WineBuiltin|IMAGE_FLAGS_WineFakeDll);
+    info->LoaderFlags          = pe_info->loader_flags;
+    info->ImageFileSize        = pe_info->file_size;
+    info->CheckSum             = pe_info->checksum;
+#ifndef _WIN64 /* don't return 64-bit values to 32-bit processes */
+    if (pe_info->machine == IMAGE_FILE_MACHINE_AMD64 || pe_info->machine == IMAGE_FILE_MACHINE_ARM64)
+    {
+        info->TransferAddress = (void *)0x81231234;  /* sic */
+        info->MaximumStackSize = 0x100000;
+        info->CommittedStackSize = 0x10000;
+    }
+#endif
+}
+
+/******************************************************************************
+ *             NtQuerySection   (NTDLL.@)
+ *             ZwQuerySection   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQuerySection( HANDLE handle, SECTION_INFORMATION_CLASS class, void *ptr,
+                                SIZE_T size, SIZE_T *ret_size )
+{
+    NTSTATUS status;
+    pe_image_info_t image_info;
+
+    switch (class)
+    {
+    case SectionBasicInformation:
+        if (size < sizeof(SECTION_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case SectionImageInformation:
+        if (size < sizeof(SECTION_IMAGE_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    default:
+	FIXME( "class %u not implemented\n", class );
+	return STATUS_NOT_IMPLEMENTED;
+    }
+    if (!ptr) return STATUS_ACCESS_VIOLATION;
+
+    SERVER_START_REQ( get_mapping_info )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->access = SECTION_QUERY;
+        wine_server_set_reply( req, &image_info, sizeof(image_info) );
+        if (!(status = wine_server_call( req )))
+        {
+            if (class == SectionBasicInformation)
+            {
+                SECTION_BASIC_INFORMATION *info = ptr;
+                info->Attributes    = reply->flags;
+                info->BaseAddress   = NULL;
+                info->Size.QuadPart = reply->size;
+                if (ret_size) *ret_size = sizeof(*info);
+            }
+            else if (reply->flags & SEC_IMAGE)
+            {
+                SECTION_IMAGE_INFORMATION *info = ptr;
+                virtual_fill_image_information( &image_info, info );
+                if (ret_size) *ret_size = sizeof(*info);
+            }
+            else status = STATUS_SECTION_NOT_IMAGE;
+        }
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtFlushVirtualMemory   (NTDLL.@)
+ *             ZwFlushVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtFlushVirtualMemory( HANDLE process, LPCVOID *addr_ptr,
+                                      SIZE_T *size_ptr, ULONG unknown )
+{
+    struct file_view *view;
+    NTSTATUS status = STATUS_SUCCESS;
+    sigset_t sigset;
+    void *addr = ROUND_ADDR( *addr_ptr, page_mask );
+
+    if (process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_flush.type = APC_VIRTUAL_FLUSH;
+        call.virtual_flush.addr = wine_server_client_ptr( addr );
+        call.virtual_flush.size = *size_ptr;
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_flush.status == STATUS_SUCCESS)
+        {
+            *addr_ptr = wine_server_get_ptr( result.virtual_flush.addr );
+            *size_ptr = result.virtual_flush.size;
+        }
+        return result.virtual_flush.status;
+    }
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+    if (!(view = VIRTUAL_FindView( addr, *size_ptr ))) status = STATUS_INVALID_PARAMETER;
+    else
+    {
+        if (!*size_ptr) *size_ptr = view->size;
+        *addr_ptr = addr;
+#ifdef MS_ASYNC
+        if (msync( addr, *size_ptr, MS_ASYNC )) status = STATUS_NOT_MAPPED_DATA;
+#endif
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtGetWriteWatch   (NTDLL.@)
+ *             ZwGetWriteWatch   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtGetWriteWatch( HANDLE process, ULONG flags, PVOID base, SIZE_T size, PVOID *addresses,
+                                 ULONG_PTR *count, ULONG *granularity )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+    sigset_t sigset;
+
+    size = ROUND_SIZE( base, size );
+    base = ROUND_ADDR( base, page_mask );
+
+    if (!count || !granularity) return STATUS_ACCESS_VIOLATION;
+    if (!*count || !size) return STATUS_INVALID_PARAMETER;
+    if (flags & ~WRITE_WATCH_FLAG_RESET) return STATUS_INVALID_PARAMETER;
+
+    if (!addresses) return STATUS_ACCESS_VIOLATION;
+
+    TRACE( "%p %x %p-%p %p %lu\n", process, flags, base, (char *)base + size,
+           addresses, *count );
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if (is_write_watch_range( base, size ))
+    {
+        ULONG_PTR pos = 0;
+        char *addr = base;
+        char *end = addr + size;
+
+        while (pos < *count && addr < end)
+        {
+            if (!(get_page_vprot( addr ) & VPROT_WRITEWATCH)) addresses[pos++] = addr;
+            addr += page_size;
+        }
+        if (flags & WRITE_WATCH_FLAG_RESET) reset_write_watches( base, addr - (char *)base );
+        *count = pos;
+        *granularity = page_size;
+    }
+    else status = STATUS_INVALID_PARAMETER;
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtResetWriteWatch   (NTDLL.@)
+ *             ZwResetWriteWatch   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtResetWriteWatch( HANDLE process, PVOID base, SIZE_T size )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+    sigset_t sigset;
+
+    size = ROUND_SIZE( base, size );
+    base = ROUND_ADDR( base, page_mask );
+
+    TRACE( "%p %p-%p\n", process, base, (char *)base + size );
+
+    if (!size) return STATUS_INVALID_PARAMETER;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if (is_write_watch_range( base, size ))
+        reset_write_watches( base, size );
+    else
+        status = STATUS_INVALID_PARAMETER;
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtReadVirtualMemory   (NTDLL.@)
+ *             ZwReadVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtReadVirtualMemory( HANDLE process, const void *addr, void *buffer,
+                                     SIZE_T size, SIZE_T *bytes_read )
+{
+    NTSTATUS status;
+
+    if (virtual_check_buffer_for_write( buffer, size ))
+    {
+        SERVER_START_REQ( read_process_memory )
+        {
+            req->handle = wine_server_obj_handle( process );
+            req->addr   = wine_server_client_ptr( addr );
+            wine_server_set_reply( req, buffer, size );
+            if ((status = wine_server_call( req ))) size = 0;
+        }
+        SERVER_END_REQ;
+    }
+    else
+    {
+        status = STATUS_ACCESS_VIOLATION;
+        size = 0;
+    }
+    if (bytes_read) *bytes_read = size;
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtWriteVirtualMemory   (NTDLL.@)
+ *             ZwWriteVirtualMemory   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtWriteVirtualMemory( HANDLE process, void *addr, const void *buffer,
+                                      SIZE_T size, SIZE_T *bytes_written )
+{
+    NTSTATUS status;
+
+    if (virtual_check_buffer_for_read( buffer, size ))
+    {
+        SERVER_START_REQ( write_process_memory )
+        {
+            req->handle     = wine_server_obj_handle( process );
+            req->addr       = wine_server_client_ptr( addr );
+            wine_server_add_data( req, buffer, size );
+            if ((status = wine_server_call( req ))) size = 0;
+        }
+        SERVER_END_REQ;
+    }
+    else
+    {
+        status = STATUS_PARTIAL_COPY;
+        size = 0;
+    }
+    if (bytes_written) *bytes_written = size;
+    return status;
+}
+
+
+/***********************************************************************
+ *             NtAreMappedFilesTheSame   (NTDLL.@)
+ *             ZwAreMappedFilesTheSame   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAreMappedFilesTheSame(PVOID addr1, PVOID addr2)
+{
+    struct file_view *view1, *view2;
+    NTSTATUS status;
+    sigset_t sigset;
+
+    TRACE("%p %p\n", addr1, addr2);
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    view1 = VIRTUAL_FindView( addr1, 0 );
+    view2 = VIRTUAL_FindView( addr2, 0 );
+
+    if (!view1 || !view2)
+        status = STATUS_INVALID_ADDRESS;
+    else if (is_view_valloc( view1 ) || is_view_valloc( view2 ))
+        status = STATUS_CONFLICTING_ADDRESSES;
+    else if (view1 == view2)
+        status = STATUS_SUCCESS;
+    else if ((view1->protect & VPROT_SYSTEM) || (view2->protect & VPROT_SYSTEM))
+        status = STATUS_NOT_SAME_DEVICE;
+    else
+    {
+        SERVER_START_REQ( is_same_mapping )
+        {
+            req->base1 = wine_server_client_ptr( view1->base );
+            req->base2 = wine_server_client_ptr( view2->base );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return status;
 }
diff --git a/dlls/ntdll/wcstring.c b/dlls/ntdll/wcstring.c
index eee856b21d..1a6d9c1c97 100644
--- a/dlls/ntdll/wcstring.c
+++ b/dlls/ntdll/wcstring.c
@@ -20,6 +20,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
@@ -88,7 +90,7 @@ static const unsigned short wctypes[256] =
 /*********************************************************************
  *           _wcsicmp    (NTDLL.@)
  */
-int __cdecl _wcsicmp( LPCWSTR str1, LPCWSTR str2 )
+int __cdecl NTDLL__wcsicmp( LPCWSTR str1, LPCWSTR str2 )
 {
     for (;;)
     {
@@ -104,7 +106,7 @@ int __cdecl _wcsicmp( LPCWSTR str1, LPCWSTR str2 )
 /*********************************************************************
  *           _wcslwr    (NTDLL.@)
  */
-LPWSTR __cdecl _wcslwr( LPWSTR str )
+LPWSTR __cdecl NTDLL__wcslwr( LPWSTR str )
 {
     WCHAR *ret = str;
 
@@ -121,7 +123,7 @@ LPWSTR __cdecl _wcslwr( LPWSTR str )
 /*********************************************************************
  *           _wcsnicmp    (NTDLL.@)
  */
-int __cdecl _wcsnicmp( LPCWSTR str1, LPCWSTR str2, size_t n )
+int __cdecl NTDLL__wcsnicmp( LPCWSTR str1, LPCWSTR str2, size_t n )
 {
     int ret = 0;
     for ( ; n > 0; n--, str1++, str2++)
@@ -137,7 +139,7 @@ int __cdecl _wcsnicmp( LPCWSTR str1, LPCWSTR str2, size_t n )
 /*********************************************************************
  *           _wcsupr    (NTDLL.@)
  */
-LPWSTR __cdecl _wcsupr( LPWSTR str )
+LPWSTR __cdecl NTDLL__wcsupr( LPWSTR str )
 {
     WCHAR *ret = str;
 
@@ -154,7 +156,7 @@ LPWSTR __cdecl _wcsupr( LPWSTR str )
 /***********************************************************************
  *           wcscpy    (NTDLL.@)
  */
-LPWSTR __cdecl wcscpy( LPWSTR dst, LPCWSTR src )
+LPWSTR __cdecl NTDLL_wcscpy( LPWSTR dst, LPCWSTR src )
 {
     WCHAR *p = dst;
     while ((*p++ = *src++));
@@ -165,7 +167,7 @@ LPWSTR __cdecl wcscpy( LPWSTR dst, LPCWSTR src )
 /***********************************************************************
  *           wcslen    (NTDLL.@)
  */
-size_t __cdecl wcslen( LPCWSTR str )
+size_t __cdecl NTDLL_wcslen( LPCWSTR str )
 {
     const WCHAR *s = str;
     while (*s) s++;
@@ -176,9 +178,9 @@ size_t __cdecl wcslen( LPCWSTR str )
 /***********************************************************************
  *           wcscat    (NTDLL.@)
  */
-LPWSTR __cdecl wcscat( LPWSTR dst, LPCWSTR src )
+LPWSTR __cdecl NTDLL_wcscat( LPWSTR dst, LPCWSTR src )
 {
-    wcscpy( dst + wcslen(dst), src );
+    NTDLL_wcscpy( dst + NTDLL_wcslen(dst), src );
     return dst;
 }
 
@@ -186,7 +188,7 @@ LPWSTR __cdecl wcscat( LPWSTR dst, LPCWSTR src )
 /*********************************************************************
  *           wcschr    (NTDLL.@)
  */
-LPWSTR __cdecl wcschr( LPCWSTR str, WCHAR ch )
+LPWSTR __cdecl NTDLL_wcschr( LPCWSTR str, WCHAR ch )
 {
     do { if (*str == ch) return (WCHAR *)(ULONG_PTR)str; } while (*str++);
     return NULL;
@@ -196,7 +198,7 @@ LPWSTR __cdecl wcschr( LPCWSTR str, WCHAR ch )
 /*********************************************************************
  *           wcscmp    (NTDLL.@)
  */
-int __cdecl wcscmp( LPCWSTR str1, LPCWSTR str2 )
+int __cdecl NTDLL_wcscmp( LPCWSTR str1, LPCWSTR str2 )
 {
     while (*str1 && (*str1 == *str2)) { str1++; str2++; }
     return *str1 - *str2;
@@ -206,10 +208,10 @@ int __cdecl wcscmp( LPCWSTR str1, LPCWSTR str2 )
 /*********************************************************************
  *           wcscspn    (NTDLL.@)
  */
-size_t __cdecl wcscspn( LPCWSTR str, LPCWSTR reject )
+size_t __cdecl NTDLL_wcscspn( LPCWSTR str, LPCWSTR reject )
 {
     const WCHAR *ptr;
-    for (ptr = str; *ptr; ptr++) if (wcschr( reject, *ptr )) break;
+    for (ptr = str; *ptr; ptr++) if (NTDLL_wcschr( reject, *ptr )) break;
     return ptr - str;
 }
 
@@ -217,7 +219,7 @@ size_t __cdecl wcscspn( LPCWSTR str, LPCWSTR reject )
 /*********************************************************************
  *           wcsncat    (NTDLL.@)
  */
-LPWSTR __cdecl wcsncat( LPWSTR s1, LPCWSTR s2, size_t n )
+LPWSTR __cdecl NTDLL_wcsncat( LPWSTR s1, LPCWSTR s2, size_t n )
 {
     LPWSTR ret = s1;
     while (*s1) s1++;
@@ -230,7 +232,7 @@ LPWSTR __cdecl wcsncat( LPWSTR s1, LPCWSTR s2, size_t n )
 /*********************************************************************
  *           wcsncmp    (NTDLL.@)
  */
-int __cdecl wcsncmp( LPCWSTR str1, LPCWSTR str2, size_t n )
+int __cdecl NTDLL_wcsncmp( LPCWSTR str1, LPCWSTR str2, size_t n )
 {
     if (n <= 0) return 0;
     while ((--n > 0) && *str1 && (*str1 == *str2)) { str1++; str2++; }
@@ -241,11 +243,11 @@ int __cdecl wcsncmp( LPCWSTR str1, LPCWSTR str2, size_t n )
 /*********************************************************************
  *           wcsncpy    (NTDLL.@)
  */
-LPWSTR __cdecl wcsncpy( LPWSTR s1, LPCWSTR s2, size_t n )
+LPWSTR __cdecl NTDLL_wcsncpy( LPWSTR s1, LPCWSTR s2, size_t n )
 {
     WCHAR *ret = s1;
-    for ( ; n; n--) if (!(*s1++ = *s2++)) break;
-    for ( ; n; n--) *s1++ = 0;
+    while (n-- > 0) if (!(*s1++ = *s2++)) break;
+    while (n-- > 0) *s1++ = 0;
     return ret;
 }
 
@@ -253,9 +255,9 @@ LPWSTR __cdecl wcsncpy( LPWSTR s1, LPCWSTR s2, size_t n )
 /*********************************************************************
  *           wcspbrk    (NTDLL.@)
  */
-LPWSTR __cdecl wcspbrk( LPCWSTR str, LPCWSTR accept )
+LPWSTR __cdecl NTDLL_wcspbrk( LPCWSTR str, LPCWSTR accept )
 {
-    for ( ; *str; str++) if (wcschr( accept, *str )) return (WCHAR *)(ULONG_PTR)str;
+    for ( ; *str; str++) if (NTDLL_wcschr( accept, *str )) return (WCHAR *)(ULONG_PTR)str;
     return NULL;
 }
 
@@ -263,7 +265,7 @@ LPWSTR __cdecl wcspbrk( LPCWSTR str, LPCWSTR accept )
 /*********************************************************************
  *           wcsrchr    (NTDLL.@)
  */
-LPWSTR __cdecl wcsrchr( LPCWSTR str, WCHAR ch )
+LPWSTR __cdecl NTDLL_wcsrchr( LPCWSTR str, WCHAR ch )
 {
     WCHAR *ret = NULL;
     do { if (*str == ch) ret = (WCHAR *)(ULONG_PTR)str; } while (*str++);
@@ -274,10 +276,10 @@ LPWSTR __cdecl wcsrchr( LPCWSTR str, WCHAR ch )
 /*********************************************************************
  *           wcsspn    (NTDLL.@)
  */
-size_t __cdecl wcsspn( LPCWSTR str, LPCWSTR accept )
+size_t __cdecl NTDLL_wcsspn( LPCWSTR str, LPCWSTR accept )
 {
     const WCHAR *ptr;
-    for (ptr = str; *ptr; ptr++) if (!wcschr( accept, *ptr )) break;
+    for (ptr = str; *ptr; ptr++) if (!NTDLL_wcschr( accept, *ptr )) break;
     return ptr - str;
 }
 
@@ -285,7 +287,7 @@ size_t __cdecl wcsspn( LPCWSTR str, LPCWSTR accept )
 /*********************************************************************
  *           wcsstr    (NTDLL.@)
  */
-LPWSTR __cdecl wcsstr( LPCWSTR str, LPCWSTR sub )
+LPWSTR __cdecl NTDLL_wcsstr( LPCWSTR str, LPCWSTR sub )
 {
     while (*str)
     {
@@ -301,7 +303,7 @@ LPWSTR __cdecl wcsstr( LPCWSTR str, LPCWSTR sub )
 /*********************************************************************
  *           wcstok    (NTDLL.@)
  */
-LPWSTR __cdecl wcstok( LPWSTR str, LPCWSTR delim )
+LPWSTR __cdecl NTDLL_wcstok( LPWSTR str, LPCWSTR delim )
 {
     static LPWSTR next = NULL;
     LPWSTR ret;
@@ -309,10 +311,10 @@ LPWSTR __cdecl wcstok( LPWSTR str, LPCWSTR delim )
     if (!str)
         if (!(str = next)) return NULL;
 
-    while (*str && wcschr( delim, *str )) str++;
+    while (*str && NTDLL_wcschr( delim, *str )) str++;
     if (!*str) return NULL;
     ret = str++;
-    while (*str && !wcschr( delim, *str )) str++;
+    while (*str && !NTDLL_wcschr( delim, *str )) str++;
     if (*str) *str++ = 0;
     next = str;
     return ret;
@@ -322,19 +324,19 @@ LPWSTR __cdecl wcstok( LPWSTR str, LPCWSTR delim )
 /*********************************************************************
  *           wcstombs    (NTDLL.@)
  */
-size_t __cdecl wcstombs( char *dst, const WCHAR *src, size_t n )
+INT __cdecl NTDLL_wcstombs( LPSTR dst, LPCWSTR src, INT n )
 {
     DWORD len;
 
     if (!dst)
     {
-        RtlUnicodeToMultiByteSize( &len, src, wcslen(src) * sizeof(WCHAR) );
+        RtlUnicodeToMultiByteSize( &len, src, NTDLL_wcslen(src) * sizeof(WCHAR) );
         return len;
     }
     else
     {
         if (n <= 0) return 0;
-        RtlUnicodeToMultiByteN( dst, n, &len, src, wcslen(src) * sizeof(WCHAR) );
+        RtlUnicodeToMultiByteN( dst, n, &len, src, NTDLL_wcslen(src) * sizeof(WCHAR) );
         if (len < n) dst[len] = 0;
     }
     return len;
@@ -344,7 +346,7 @@ size_t __cdecl wcstombs( char *dst, const WCHAR *src, size_t n )
 /*********************************************************************
  *           mbstowcs    (NTDLL.@)
  */
-size_t __cdecl mbstowcs( WCHAR *dst, const char *src, size_t n )
+INT __cdecl NTDLL_mbstowcs( LPWSTR dst, LPCSTR src, INT n )
 {
     DWORD len;
 
@@ -365,7 +367,7 @@ size_t __cdecl mbstowcs( WCHAR *dst, const char *src, size_t n )
 /*********************************************************************
  *           iswctype    (NTDLL.@)
  */
-INT __cdecl iswctype( WCHAR wc, unsigned short type )
+INT __cdecl NTDLL_iswctype( WCHAR wc, unsigned short type )
 {
     if (wc >= 256) return 0;
     return wctypes[wc] & type;
@@ -375,7 +377,7 @@ INT __cdecl iswctype( WCHAR wc, unsigned short type )
 /*********************************************************************
  *           iswalpha    (NTDLL.@)
  */
-INT __cdecl iswalpha( WCHAR wc )
+INT __cdecl NTDLL_iswalpha( WCHAR wc )
 {
     if (wc >= 256) return 0;
     return wctypes[wc] & (C1_ALPHA | C1_UPPER | C1_LOWER);
@@ -391,7 +393,7 @@ INT __cdecl iswalpha( WCHAR wc )
  *  TRUE: The unicode char wc is a digit.
  *  FALSE: Otherwise
  */
-INT __cdecl iswdigit( WCHAR wc )
+INT __cdecl NTDLL_iswdigit( WCHAR wc )
 {
     if (wc >= 256) return 0;
     return wctypes[wc] & C1_DIGIT;
@@ -407,7 +409,7 @@ INT __cdecl iswdigit( WCHAR wc )
  *  TRUE: The unicode char wc is a lower case letter.
  *  FALSE: Otherwise
  */
-INT __cdecl iswlower( WCHAR wc )
+INT __cdecl NTDLL_iswlower( WCHAR wc )
 {
     if (wc >= 256) return 0;
     return wctypes[wc] & C1_LOWER;
@@ -423,7 +425,7 @@ INT __cdecl iswlower( WCHAR wc )
  *  TRUE: The unicode char wc is a white space character.
  *  FALSE: Otherwise
  */
-INT __cdecl iswspace( WCHAR wc )
+INT __cdecl NTDLL_iswspace( WCHAR wc )
 {
     if (wc >= 256) return 0;
     return wctypes[wc] & C1_SPACE;
@@ -439,7 +441,7 @@ INT __cdecl iswspace( WCHAR wc )
  *  TRUE: The unicode char wc is an extended digit.
  *  FALSE: Otherwise
  */
-INT __cdecl iswxdigit( WCHAR wc )
+INT __cdecl NTDLL_iswxdigit( WCHAR wc )
 {
     if (wc >= 256) return 0;
     return wctypes[wc] & C1_XDIGIT;
@@ -469,14 +471,14 @@ static int wctoint( WCHAR c )
 /*********************************************************************
  *                  wcstol  (NTDLL.@)
  */
-__msvcrt_long __cdecl wcstol(LPCWSTR s, LPWSTR *end, INT base)
+LONG __cdecl NTDLL_wcstol(LPCWSTR s, LPWSTR *end, INT base)
 {
     BOOL negative = FALSE, empty = TRUE;
     LONG ret = 0;
 
     if (base < 0 || base == 1 || base > 36) return 0;
     if (end) *end = (WCHAR *)s;
-    while (iswspace(*s)) s++;
+    while (NTDLL_iswspace(*s)) s++;
 
     if (*s == '-')
     {
@@ -516,14 +518,14 @@ __msvcrt_long __cdecl wcstol(LPCWSTR s, LPWSTR *end, INT base)
 /*********************************************************************
  *                  wcstoul  (NTDLL.@)
  */
-__msvcrt_ulong __cdecl wcstoul(LPCWSTR s, LPWSTR *end, INT base)
+ULONG __cdecl NTDLL_wcstoul(LPCWSTR s, LPWSTR *end, INT base)
 {
     BOOL negative = FALSE, empty = TRUE;
     ULONG ret = 0;
 
     if (base < 0 || base == 1 || base > 36) return 0;
     if (end) *end = (WCHAR *)s;
-    while (iswspace(*s)) s++;
+    while (NTDLL_iswspace(*s)) s++;
 
     if (*s == '-')
     {
@@ -571,7 +573,10 @@ __msvcrt_ulong __cdecl wcstoul(LPCWSTR s, LPWSTR *end, INT base)
  *  Does not check if radix is in the range of 2 to 36.
  *  If str is NULL it just returns NULL.
  */
-LPWSTR __cdecl _ultow( __msvcrt_ulong value, LPWSTR str, INT radix )
+LPWSTR __cdecl _ultow(
+    ULONG value,         /* [I] Value to be converted */
+    LPWSTR str,          /* [O] Destination for the converted value */
+    INT radix)           /* [I] Number base for conversion */
 {
     WCHAR buffer[33];
     PWCHAR pos;
@@ -612,7 +617,10 @@ LPWSTR __cdecl _ultow( __msvcrt_ulong value, LPWSTR str, INT radix )
  *  Does not check if radix is in the range of 2 to 36.
  *  If str is NULL it just returns NULL.
  */
-LPWSTR __cdecl _ltow( __msvcrt_long value, LPWSTR str, INT radix )
+LPWSTR __cdecl _ltow(
+    LONG value, /* [I] Value to be converted */
+    LPWSTR str, /* [O] Destination for the converted value */
+    INT radix)  /* [I] Number base for conversion */
 {
     ULONG val;
     int negative;
@@ -811,12 +819,12 @@ LPWSTR __cdecl _i64tow(
  *  No check is made for value overflow, only the lower 32 bits are assigned.
  *  If str is NULL it crashes, as the native function does.
  */
-__msvcrt_long __cdecl _wtol( LPCWSTR str )
+LONG __cdecl _wtol( LPCWSTR str )
 {
     ULONG RunningTotal = 0;
     BOOL bMinus = FALSE;
 
-    while (iswspace(*str)) str++;
+    while (NTDLL_iswspace(*str)) str++;
 
     if (*str == '+') {
 	str++;
@@ -877,7 +885,7 @@ LONGLONG  __cdecl _wtoi64( LPCWSTR str )
     ULONGLONG RunningTotal = 0;
     BOOL bMinus = FALSE;
 
-    while (iswspace(*str)) str++;
+    while (NTDLL_iswspace(*str)) str++;
 
     if (*str == '+') {
 	str++;
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index e94feabc82..686d594c15 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -1591,19 +1591,17 @@ NTSTATUS WINAPI IoCreateSymbolicLink( UNICODE_STRING *name, UNICODE_STRING *targ
 {
     HANDLE handle;
     OBJECT_ATTRIBUTES attr;
-    NTSTATUS ret;
 
     attr.Length                   = sizeof(attr);
     attr.RootDirectory            = 0;
     attr.ObjectName               = name;
-    attr.Attributes               = OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT;
+    attr.Attributes               = OBJ_CASE_INSENSITIVE | OBJ_OPENIF;
     attr.SecurityDescriptor       = NULL;
     attr.SecurityQualityOfService = NULL;
 
     TRACE( "%s -> %s\n", debugstr_us(name), debugstr_us(target) );
-    if (!(ret = NtCreateSymbolicLinkObject( &handle, SYMBOLIC_LINK_ALL_ACCESS, &attr, target )))
-        NtClose( handle );
-    return ret;
+    /* FIXME: store handle somewhere */
+    return NtCreateSymbolicLinkObject( &handle, SYMBOLIC_LINK_ALL_ACCESS, &attr, target );
 }
 
 
@@ -1614,19 +1612,17 @@ NTSTATUS WINAPI IoCreateUnprotectedSymbolicLink( UNICODE_STRING *name, UNICODE_S
 {
     HANDLE handle;
     OBJECT_ATTRIBUTES attr;
-    NTSTATUS ret;
 
     attr.Length                   = sizeof(attr);
     attr.RootDirectory            = 0;
     attr.ObjectName               = name;
-    attr.Attributes               = OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT;
+    attr.Attributes               = OBJ_CASE_INSENSITIVE | OBJ_OPENIF;
     attr.SecurityDescriptor       = NULL;
     attr.SecurityQualityOfService = NULL;
 
     TRACE( "%s -> %s\n", debugstr_us(name), debugstr_us(target) );
-    if (!(ret = NtCreateSymbolicLinkObject( &handle, SYMBOLIC_LINK_ALL_ACCESS, &attr, target )))
-        NtClose( handle );
-    return ret;
+    /* FIXME: store handle somewhere */
+    return NtCreateSymbolicLinkObject( &handle, SYMBOLIC_LINK_ALL_ACCESS, &attr, target );
 }
 
 
@@ -1648,7 +1644,12 @@ NTSTATUS WINAPI IoDeleteSymbolicLink( UNICODE_STRING *name )
 
     if (!(status = NtOpenSymbolicLinkObject( &handle, 0, &attr )))
     {
-        NtMakeTemporaryObject( handle );
+        SERVER_START_REQ( unlink_object )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
         NtClose( handle );
     }
     return status;
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 4d39f8eea2..d3f9bbdd86 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -1380,7 +1380,7 @@
 @ stdcall ZwClose(long) NtClose
 @ stub ZwCloseObjectAuditAlarm
 @ stdcall -private ZwConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr) NtConnectPort
-@ stdcall ZwCreateDirectoryObject(ptr long ptr) NtCreateDirectoryObject
+@ stdcall -private ZwCreateDirectoryObject(ptr long ptr) NtCreateDirectoryObject
 @ stdcall ZwCreateEvent(ptr long ptr long long) NtCreateEvent
 @ stdcall ZwCreateFile(ptr long ptr ptr ptr long long long long ptr long) NtCreateFile
 @ stdcall -private ZwCreateIoCompletion(ptr long ptr long) NtCreateIoCompletion
@@ -1414,11 +1414,11 @@
 @ stdcall -private ZwLoadKey(ptr ptr) NtLoadKey
 @ stdcall -private ZwLockFile(long long ptr ptr ptr ptr ptr ptr long long) NtLockFile
 @ stdcall -private ZwLockVirtualMemory(long ptr ptr long) NtLockVirtualMemory
-@ stdcall ZwMakeTemporaryObject(long) NtMakeTemporaryObject
+@ stdcall -private ZwMakeTemporaryObject(long) NtMakeTemporaryObject
 @ stdcall -private ZwMapViewOfSection(long long ptr long long ptr ptr long long long) NtMapViewOfSection
 @ stdcall -private ZwNotifyChangeDirectoryFile(long long ptr ptr ptr ptr long long long) NtNotifyChangeDirectoryFile
 @ stdcall -private ZwNotifyChangeKey(long long ptr ptr ptr long long ptr long long) NtNotifyChangeKey
-@ stdcall ZwOpenDirectoryObject(ptr long ptr) NtOpenDirectoryObject
+@ stdcall -private ZwOpenDirectoryObject(ptr long ptr) NtOpenDirectoryObject
 @ stdcall -private ZwOpenEvent(ptr long ptr) NtOpenEvent
 @ stdcall ZwOpenFile(ptr long ptr ptr long long) NtOpenFile
 @ stdcall -private ZwOpenJobObject(ptr long ptr) NtOpenJobObject
diff --git a/dlls/ntoskrnl.exe/tests/driver.c b/dlls/ntoskrnl.exe/tests/driver.c
index dfc742eec3..30a95926c4 100644
--- a/dlls/ntoskrnl.exe/tests/driver.c
+++ b/dlls/ntoskrnl.exe/tests/driver.c
@@ -2055,54 +2055,6 @@ static void test_process_memory(const struct test_input *test_input)
     ObDereferenceObject(process);
 }
 
-static void test_permanence(void)
-{
-    OBJECT_ATTRIBUTES attr;
-    HANDLE handle, handle2;
-    UNICODE_STRING str;
-    NTSTATUS status;
-
-    RtlInitUnicodeString(&str, L"\\BaseNamedObjects\\wine_test_dir");
-    InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
-    status = ZwCreateDirectoryObject( &handle, GENERIC_ALL, &attr );
-    ok(!status, "got %#x\n", status);
-    status = ZwClose( handle );
-    ok(!status, "got %#x\n", status);
-    status = ZwOpenDirectoryObject( &handle, 0, &attr );
-    ok(status == STATUS_OBJECT_NAME_NOT_FOUND, "got %#x\n", status);
-
-    attr.Attributes = OBJ_PERMANENT;
-    status = ZwCreateDirectoryObject( &handle, GENERIC_ALL, &attr );
-    ok(!status, "got %#x\n", status);
-    status = ZwClose( handle );
-    ok(!status, "got %#x\n", status);
-
-    attr.Attributes = 0;
-    status = ZwOpenDirectoryObject( &handle, 0, &attr );
-    ok(!status, "got %#x\n", status);
-    status = ZwMakeTemporaryObject( handle );
-    ok(!status, "got %#x\n", status);
-    status = ZwMakeTemporaryObject( handle );
-    ok(!status, "got %#x\n", status);
-    status = ZwClose( handle );
-    ok(!status, "got %#x\n", status);
-    status = ZwOpenDirectoryObject( &handle, 0, &attr );
-    ok(status == STATUS_OBJECT_NAME_NOT_FOUND, "got %#x\n", status);
-
-    status = ZwCreateDirectoryObject( &handle, GENERIC_ALL, &attr );
-    ok(!status, "got %#x\n", status);
-    attr.Attributes = OBJ_PERMANENT;
-    status = ZwOpenDirectoryObject( &handle2, 0, &attr );
-    ok(status == STATUS_SUCCESS, "got %#x\n", status);
-    status = ZwClose( handle2 );
-    ok(!status, "got %#x\n", status);
-    status = ZwClose( handle );
-    ok(!status, "got %#x\n", status);
-    attr.Attributes = 0;
-    status = ZwOpenDirectoryObject( &handle, 0, &attr );
-    ok(status == STATUS_OBJECT_NAME_NOT_FOUND, "got %#x\n", status);
-}
-
 static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *stack)
 {
     ULONG length = stack->Parameters.DeviceIoControl.OutputBufferLength;
@@ -2159,7 +2111,6 @@ static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *st
     test_affinity();
     test_dpc();
     test_process_memory(test_input);
-    test_permanence();
 
     if (main_test_work_item) return STATUS_UNEXPECTED_IO_ERROR;
 
diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index aadec28b55..c5c7db667c 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2271,11 +2271,12 @@ static void send_parent_notify( HWND hwnd, WORD event, WORD idChild, POINT pt )
  * Tell the server we have passed the message to the app
  * (even though we may end up dropping it later on)
  */
-static void accept_hardware_message( UINT hw_id )
+static void accept_hardware_message( UINT hw_id, BOOL remove )
 {
     SERVER_START_REQ( accept_hardware_message )
     {
-        req->hw_id = hw_id;
+        req->hw_id   = hw_id;
+        req->remove  = remove;
         if (wine_server_call( req ))
             FIXME("Failed to reply to MSG_HARDWARE message. Message may not be removed from queue.\n");
     }
@@ -2283,14 +2284,13 @@ static void accept_hardware_message( UINT hw_id )
 }
 
 
-static BOOL process_rawinput_message( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data )
+static BOOL process_rawinput_message( MSG *msg, const struct hardware_msg_data *msg_data )
 {
-    struct rawinput_thread_data *thread_data = rawinput_thread_data();
-    if (!rawinput_from_hardware_message( thread_data->buffer, msg_data ))
+    RAWINPUT *rawinput = rawinput_thread_data();
+    if (!rawinput_from_hardware_message(rawinput, msg_data))
         return FALSE;
 
-    thread_data->hw_id = hw_id;
-    msg->lParam = (LPARAM)hw_id;
+    msg->lParam = (LPARAM)rawinput;
     msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
     return TRUE;
 }
@@ -2363,10 +2363,10 @@ static BOOL process_keyboard_message( MSG *msg, UINT hw_id, HWND hwnd_filter,
     {
         /* skip this message */
         HOOK_CallHooks( WH_CBT, HCBT_KEYSKIPPED, LOWORD(msg->wParam), msg->lParam, TRUE );
-        accept_hardware_message( hw_id );
+        accept_hardware_message( hw_id, TRUE );
         return FALSE;
     }
-    if (remove) accept_hardware_message( hw_id );
+    accept_hardware_message( hw_id, remove );
     msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
 
     if ( remove && msg->message == WM_KEYDOWN )
@@ -2421,7 +2421,7 @@ static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, H
 
     if (!msg->hwnd || !WIN_IsCurrentThread( msg->hwnd ))
     {
-        accept_hardware_message( hw_id );
+        accept_hardware_message( hw_id, TRUE );
         return FALSE;
     }
 
@@ -2517,7 +2517,7 @@ static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, H
         hook.s.dwExtraInfo  = extra_info;
         hook.mouseData      = msg->wParam;
         HOOK_CallHooks( WH_CBT, HCBT_CLICKSKIPPED, message, (LPARAM)&hook, TRUE );
-        accept_hardware_message( hw_id );
+        accept_hardware_message( hw_id, TRUE );
         return FALSE;
     }
 
@@ -2525,11 +2525,11 @@ static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, H
     {
         SendMessageW( msg->hwnd, WM_SETCURSOR, (WPARAM)msg->hwnd,
                       MAKELONG( hittest, msg->message ));
-        accept_hardware_message( hw_id );
+        accept_hardware_message( hw_id, TRUE );
         return FALSE;
     }
 
-    if (remove) accept_hardware_message( hw_id );
+    accept_hardware_message( hw_id, remove );
 
     if (!remove || info.hwndCapture)
     {
@@ -2611,7 +2611,7 @@ static BOOL process_hardware_message( MSG *msg, UINT hw_id, const struct hardwar
     context = SetThreadDpiAwarenessContext( DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE );
 
     if (msg->message == WM_INPUT)
-        ret = process_rawinput_message( msg, hw_id, msg_data );
+        ret = process_rawinput_message( msg, msg_data );
     else if (is_keyboard_message( msg->message ))
         ret = process_keyboard_message( msg, hw_id, hwnd_filter, first, last, remove );
     else if (is_mouse_message( msg->message ))
diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 751dc3cae7..14564f42ee 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -223,14 +223,12 @@ static void find_devices(void)
 }
 
 
-struct rawinput_thread_data *rawinput_thread_data(void)
+RAWINPUT *rawinput_thread_data(void)
 {
     struct user_thread_info *thread_info = get_user_thread_info();
-    struct rawinput_thread_data *data = thread_info->rawinput;
-    if (data) return data;
-    data = thread_info->rawinput = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY,
-                                              RAWINPUT_BUFFER_SIZE + sizeof(struct user_thread_info) );
-    return data;
+    RAWINPUT *rawinput = thread_info->rawinput;
+    if (!rawinput) rawinput = thread_info->rawinput = HeapAlloc( GetProcessHeap(), 0, RAWINPUT_BUFFER_SIZE );
+    return rawinput;
 }
 
 
@@ -455,151 +453,53 @@ BOOL WINAPI DECLSPEC_HOTPATCH RegisterRawInputDevices(RAWINPUTDEVICE *devices, U
  */
 UINT WINAPI GetRawInputData(HRAWINPUT rawinput, UINT command, void *data, UINT *data_size, UINT header_size)
 {
-    struct rawinput_thread_data *thread_data = rawinput_thread_data();
-    UINT size;
+    RAWINPUT *ri = (RAWINPUT *)rawinput;
+    UINT s;
 
     TRACE("rawinput %p, command %#x, data %p, data_size %p, header_size %u.\n",
             rawinput, command, data, data_size, header_size);
 
-    if (!rawinput || thread_data->hw_id != (UINT_PTR)rawinput)
-    {
-        SetLastError(ERROR_INVALID_HANDLE);
+    if (!ri || !ri->header.dwSize)
         return ~0U;
-    }
 
     if (header_size != sizeof(RAWINPUTHEADER))
     {
         WARN("Invalid structure size %u.\n", header_size);
-        SetLastError(ERROR_INVALID_PARAMETER);
         return ~0U;
     }
 
     switch (command)
     {
     case RID_INPUT:
-        size = thread_data->buffer->header.dwSize;
+        s = ri->header.dwSize;
         break;
     case RID_HEADER:
-        size = sizeof(RAWINPUTHEADER);
+        s = sizeof(RAWINPUTHEADER);
         break;
     default:
-        SetLastError(ERROR_INVALID_PARAMETER);
         return ~0U;
     }
 
     if (!data)
     {
-        *data_size = size;
+        *data_size = s;
         return 0;
     }
 
-    if (*data_size < size)
-    {
-        SetLastError(ERROR_INSUFFICIENT_BUFFER);
-        return ~0U;
-    }
-    memcpy(data, thread_data->buffer, size);
-    return size;
+    if (*data_size < s) return ~0U;
+    memcpy(data, ri, s);
+    ri->header.dwSize = 0;
+    return s;
 }
 
-#ifdef _WIN64
-typedef RAWINPUT RAWINPUT64;
-#else
-typedef struct
-{
-    RAWINPUTHEADER header;
-    char pad[8];
-    union {
-        RAWMOUSE    mouse;
-        RAWKEYBOARD keyboard;
-        RAWHID      hid;
-    } data;
-} RAWINPUT64;
-#endif
-
 /***********************************************************************
  *              GetRawInputBuffer   (USER32.@)
  */
 UINT WINAPI DECLSPEC_HOTPATCH GetRawInputBuffer(RAWINPUT *data, UINT *data_size, UINT header_size)
 {
-    struct hardware_msg_data *msg_data;
-    struct rawinput_thread_data *thread_data;
-    RAWINPUT *rawinput;
-    UINT count = 0, rawinput_size, next_size, overhead;
-    BOOL is_wow64;
-    int i;
-
-    if (IsWow64Process( GetCurrentProcess(), &is_wow64 ) && is_wow64)
-        rawinput_size = sizeof(RAWINPUT64);
-    else
-        rawinput_size = sizeof(RAWINPUT);
-    overhead = rawinput_size - sizeof(RAWINPUT);
-
-    if (header_size != sizeof(RAWINPUTHEADER))
-    {
-        WARN("Invalid structure size %u.\n", header_size);
-        SetLastError(ERROR_INVALID_PARAMETER);
-        return ~0U;
-    }
-
-    if (!data_size)
-    {
-        SetLastError(ERROR_INVALID_PARAMETER);
-        return ~0U;
-    }
-
-    if (!data)
-    {
-        TRACE("data %p, data_size %p (%u), header_size %u\n", data, data_size, *data_size, header_size);
-        SERVER_START_REQ( get_rawinput_buffer )
-        {
-            req->rawinput_size = rawinput_size;
-            req->buffer_size = 0;
-            if (wine_server_call( req )) return ~0U;
-            *data_size = reply->next_size;
-        }
-        SERVER_END_REQ;
-        return 0;
-    }
-
-    if (!(thread_data = rawinput_thread_data())) return ~0U;
-    rawinput = thread_data->buffer;
-
-    /* first RAWINPUT block in the buffer is used for WM_INPUT message data */
-    msg_data = (struct hardware_msg_data *)NEXTRAWINPUTBLOCK(rawinput);
-    SERVER_START_REQ( get_rawinput_buffer )
-    {
-        req->rawinput_size = rawinput_size;
-        req->buffer_size = *data_size;
-        wine_server_set_reply( req, msg_data, RAWINPUT_BUFFER_SIZE - rawinput->header.dwSize );
-        if (wine_server_call( req )) return ~0U;
-        next_size = reply->next_size;
-        count = reply->count;
-    }
-    SERVER_END_REQ;
-
-    for (i = 0; i < count; ++i)
-    {
-        rawinput_from_hardware_message(data, msg_data);
-        if (overhead) memmove((char *)&data->data + overhead, &data->data,
-                              data->header.dwSize - sizeof(RAWINPUTHEADER));
-        data->header.dwSize += overhead;
-        data = NEXTRAWINPUTBLOCK(data);
-        msg_data++;
-    }
-
-    if (count == 0 && next_size == 0) *data_size = 0;
-    else if (next_size == 0) next_size = rawinput_size;
-
-    if (next_size && *data_size <= next_size)
-    {
-        SetLastError(ERROR_INSUFFICIENT_BUFFER);
-        *data_size = next_size;
-        count = ~0U;
-    }
+    FIXME("data %p, data_size %p, header_size %u stub!\n", data, data_size, header_size);
 
-    if (count) TRACE("data %p, data_size %p (%u), header_size %u, count %u\n", data, data_size, *data_size, header_size, count);
-    return count;
+    return 0;
 }
 
 /***********************************************************************
@@ -745,60 +645,14 @@ UINT WINAPI GetRawInputDeviceInfoW(HANDLE handle, UINT command, void *data, UINT
     return *data_size;
 }
 
-static int compare_raw_input_devices(const void *ap, const void *bp)
-{
-    const RAWINPUTDEVICE a = *(const RAWINPUTDEVICE *)ap;
-    const RAWINPUTDEVICE b = *(const RAWINPUTDEVICE *)bp;
-
-    if (a.usUsagePage != b.usUsagePage) return a.usUsagePage - b.usUsagePage;
-    if (a.usUsage != b.usUsage) return a.usUsage - b.usUsage;
-    return 0;
-}
-
 /***********************************************************************
  *              GetRegisteredRawInputDevices   (USER32.@)
  */
 UINT WINAPI DECLSPEC_HOTPATCH GetRegisteredRawInputDevices(RAWINPUTDEVICE *devices, UINT *device_count, UINT size)
 {
-    struct rawinput_device *buffer = NULL;
-    unsigned int i, status, count = ~0U, buffer_size;
-
-    TRACE("devices %p, device_count %p, size %u\n", devices, device_count, size);
-
-    if (size != sizeof(RAWINPUTDEVICE) || !device_count || (devices && !*device_count))
-    {
-        SetLastError(ERROR_INVALID_PARAMETER);
-        return ~0U;
-    }
+    FIXME("devices %p, device_count %p, size %u stub!\n", devices, device_count, size);
 
-    buffer_size = *device_count * sizeof(*buffer);
-    if (devices && !(buffer = HeapAlloc(GetProcessHeap(), 0, buffer_size)))
-        return ~0U;
-
-    SERVER_START_REQ(get_rawinput_devices)
-    {
-        if (buffer) wine_server_set_reply(req, buffer, buffer_size);
-        status = wine_server_call_err(req);
-        *device_count = reply->device_count;
-    }
-    SERVER_END_REQ;
-
-    if (buffer && !status)
-    {
-        for (i = 0, count = *device_count; i < count; ++i)
-        {
-            devices[i].usUsagePage = buffer[i].usage_page;
-            devices[i].usUsage = buffer[i].usage;
-            devices[i].dwFlags = buffer[i].flags;
-            devices[i].hwndTarget = wine_server_ptr_handle(buffer[i].target);
-        }
-
-        qsort(devices, count, sizeof(*devices), compare_raw_input_devices);
-    }
-
-    if (buffer) HeapFree(GetProcessHeap(), 0, buffer);
-    else count = 0;
-    return count;
+    return 0;
 }
 
 
diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
index 1809c147cb..3e2deb48c2 100644
--- a/dlls/user32/tests/input.c
+++ b/dlls/user32/tests/input.c
@@ -1760,6 +1760,7 @@ static void test_GetRawInputData(void)
     SetLastError(0xdeadbeef);
     ret = GetRawInputData(NULL, RID_INPUT, NULL, &size, sizeof(RAWINPUTHEADER));
     ok(ret == ~0U, "Expect ret %u, got %u\n", ~0U, ret);
+    todo_wine
     ok(GetLastError() == ERROR_INVALID_HANDLE, "GetRawInputData returned %08x\n", GetLastError());
 }
 
@@ -1796,20 +1797,25 @@ static void test_RegisterRawInputDevices(void)
 
     SetLastError(0xdeadbeef);
     count = GetRegisteredRawInputDevices(NULL, NULL, 0);
+    todo_wine
     ok(count == ~0U, "GetRegisteredRawInputDevices returned %u\n", count);
+    todo_wine
     ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRegisteredRawInputDevices unexpected error %08x\n", GetLastError());
 
     SetLastError(0xdeadbeef);
     raw_devices_count = 0;
     count = GetRegisteredRawInputDevices(NULL, &raw_devices_count, 0);
+    todo_wine
     ok(count == ~0U, "GetRegisteredRawInputDevices returned %u\n", count);
     ok(raw_devices_count == 0, "Unexpected registered devices count: %u\n", raw_devices_count);
+    todo_wine
     ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRegisteredRawInputDevices unexpected error %08x\n", GetLastError());
 
     SetLastError(0xdeadbeef);
     raw_devices_count = 0;
     count = GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
     ok(count == 0, "GetRegisteredRawInputDevices returned %u\n", count);
+    todo_wine
     ok(raw_devices_count == 2, "Unexpected registered devices count: %u\n", raw_devices_count);
     ok(GetLastError() == 0xdeadbeef, "GetRegisteredRawInputDevices unexpected error %08x\n", GetLastError());
 
@@ -1820,28 +1826,38 @@ static void test_RegisterRawInputDevices(void)
         win_skip("Ignoring GetRegisteredRawInputDevices success\n");
     else
     {
+        todo_wine
         ok(count == ~0U, "GetRegisteredRawInputDevices returned %u\n", count);
         ok(raw_devices_count == 0, "Unexpected registered devices count: %u\n", raw_devices_count);
+        todo_wine
         ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRegisteredRawInputDevices unexpected error %08x\n", GetLastError());
     }
 
     SetLastError(0xdeadbeef);
     raw_devices_count = 1;
     count = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+    todo_wine
     ok(count == ~0U, "GetRegisteredRawInputDevices returned %u\n", count);
+    todo_wine
     ok(raw_devices_count == 2, "Unexpected registered devices count: %u\n", raw_devices_count);
+    todo_wine
     ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER, "GetRegisteredRawInputDevices unexpected error %08x\n", GetLastError());
 
     SetLastError(0xdeadbeef);
     memset(raw_devices, 0, sizeof(raw_devices));
     raw_devices_count = ARRAY_SIZE(raw_devices);
     count = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
+    todo_wine
     ok(count == 2, "GetRegisteredRawInputDevices returned %u\n", count);
     ok(raw_devices_count == 2, "Unexpected registered devices count: %u\n", raw_devices_count);
     ok(GetLastError() == 0xdeadbeef, "GetRegisteredRawInputDevices unexpected error %08x\n", GetLastError());
+    todo_wine
     ok(raw_devices[0].usUsagePage == 0x01, "Unexpected usage page: %x\n", raw_devices[0].usUsagePage);
+    todo_wine
     ok(raw_devices[0].usUsage == 0x04, "Unexpected usage: %x\n", raw_devices[0].usUsage);
+    todo_wine
     ok(raw_devices[1].usUsagePage == 0x01, "Unexpected usage page: %x\n", raw_devices[1].usUsagePage);
+    todo_wine
     ok(raw_devices[1].usUsage == 0x05, "Unexpected usage: %x\n", raw_devices[1].usUsage);
 
     /* RIDEV_REMOVE requires hwndTarget == NULL */
@@ -1922,20 +1938,26 @@ static LRESULT CALLBACK rawinputbuffer_wndproc(HWND hwnd, UINT msg, WPARAM wpara
     if (msg == WM_INPUT)
     {
         count = GetRawInputBuffer(NULL, NULL, sizeof(RAWINPUTHEADER));
+        todo_wine
         ok(count == ~0U, "GetRawInputBuffer succeeded\n");
 
         size = sizeof(buffer);
         count = GetRawInputBuffer(NULL, &size, sizeof(RAWINPUTHEADER));
         ok(count == 0, "GetRawInputBuffer returned %u\n", count);
+        todo_wine
         ok(size == rawinput_size, "GetRawInputBuffer returned unexpected size: %u\n", size);
 
         size = sizeof(buffer);
         memset(buffer, 0, sizeof(buffer));
         count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
+        todo_wine
         ok(count == 3, "GetRawInputBuffer returned %u\n", count);
         ok(size == sizeof(buffer), "GetRawInputBuffer returned unexpected size: %u\n", size);
+        todo_wine
         ok(rawinput_buffer_mouse_x(buffer, 0) == 2, "Unexpected rawinput data: %d\n", rawinput_buffer_mouse_x(buffer, 0));
+        todo_wine
         ok(rawinput_buffer_mouse_x(buffer, 1) == 3, "Unexpected rawinput data: %d\n", rawinput_buffer_mouse_x(buffer, 1));
+        todo_wine
         ok(rawinput_buffer_mouse_x(buffer, 2) == 4, "Unexpected rawinput data: %d\n", rawinput_buffer_mouse_x(buffer, 2));
 
         /* the first event should be removed by the next GetRawInputBuffer call
@@ -1953,7 +1975,9 @@ static LRESULT CALLBACK rawinputbuffer_wndproc(HWND hwnd, UINT msg, WPARAM wpara
             size = rawinput_size + 1;
             memset(buffer, 0, sizeof(buffer));
             count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
+            todo_wine
             ok(count == 1, "GetRawInputBuffer returned %u\n", count);
+            todo_wine
             ok(rawinput_buffer_mouse_x(buffer, 0) == 5, "Unexpected rawinput data: %d\n", rawinput_buffer_mouse_x(buffer, 0));
 
             /* peek the messages now, they should still arrive in the correct order */
@@ -1971,30 +1995,36 @@ static LRESULT CALLBACK rawinputbuffer_wndproc(HWND hwnd, UINT msg, WPARAM wpara
             SetLastError(0xdeadbeef);
             count = GetRawInputData((HRAWINPUT)lparam, RID_INPUT, &ri, &size, 0);
             ok(count == ~0U, "GetRawInputData succeeded\n");
+            todo_wine
             ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRawInputData returned %08x\n", GetLastError());
 
             SetLastError(0xdeadbeef);
             size = 0;
             count = GetRawInputData((HRAWINPUT)lparam, RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER));
             ok(count == ~0U, "GetRawInputData succeeded\n");
+            todo_wine
             ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER, "GetRawInputData returned %08x\n", GetLastError());
 
             SetLastError(0xdeadbeef);
             size = sizeof(ri);
             count = GetRawInputData((HRAWINPUT)lparam, 0, &ri, &size, sizeof(RAWINPUTHEADER));
             ok(count == ~0U, "GetRawInputData succeeded\n");
+            todo_wine
             ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRawInputData returned %08x\n", GetLastError());
 
             SetLastError(0xdeadbeef);
             size = sizeof(ri);
             count = GetRawInputData((HRAWINPUT)lparam, RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER));
+            todo_wine
             ok(count == sizeof(ri), "GetRawInputData failed\n");
+            todo_wine
             ok(ri.data.mouse.lLastX == 6, "Unexpected rawinput data: %d\n", ri.data.mouse.lLastX);
             ok(GetLastError() == 0xdeadbeef, "GetRawInputData returned %08x\n", GetLastError());
         }
         else
         {
             ok(count == ~0U, "GetRawInputData succeeded\n");
+            todo_wine
             ok(GetLastError() == ERROR_INVALID_HANDLE, "GetRawInputData returned %08x\n", GetLastError());
         }
 
@@ -2033,12 +2063,15 @@ static void test_GetRawInputBuffer(void)
 
     SetLastError(0xdeadbeef);
     count = GetRawInputBuffer(NULL, NULL, sizeof(RAWINPUTHEADER));
+    todo_wine
     ok(count == ~0U, "GetRawInputBuffer succeeded\n");
+    todo_wine
     ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRawInputBuffer returned %08x\n", GetLastError());
 
     size = sizeof(buffer);
     count = GetRawInputBuffer(NULL, &size, sizeof(RAWINPUTHEADER));
     ok(count == 0U, "GetRawInputBuffer returned %u\n", count);
+    todo_wine
     ok(size == 0U, "GetRawInputBuffer returned unexpected size: %u\n", size);
 
     size = 0;
@@ -2049,12 +2082,15 @@ static void test_GetRawInputBuffer(void)
     SetLastError(0xdeadbeef);
     size = sizeof(buffer);
     count = GetRawInputBuffer((RAWINPUT*)buffer, &size, 0);
+    todo_wine
     ok(count == ~0U, "GetRawInputBuffer succeeded\n");
+    todo_wine
     ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRawInputBuffer returned %08x\n", GetLastError());
 
     size = sizeof(buffer);
     count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
     ok(count == 0U, "GetRawInputBuffer returned %u\n", count);
+    todo_wine
     ok(size == 0U, "GetRawInputBuffer returned unexpected size: %u\n", size);
 
     mouse_event(MOUSEEVENTF_MOVE, 5, 0, 0, 0);
@@ -2062,26 +2098,34 @@ static void test_GetRawInputBuffer(void)
     SetLastError(0xdeadbeef);
     size = 0;
     count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
+    todo_wine
     ok(count == ~0U, "GetRawInputBuffer succeeded\n");
+    todo_wine
     ok(size == rawinput_size, "GetRawInputBuffer returned unexpected size: %u\n", size);
+    todo_wine
     ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER, "GetRawInputBuffer returned %08x\n", GetLastError());
 
     size = 0;
     count = GetRawInputBuffer(NULL, &size, sizeof(RAWINPUTHEADER));
     ok(count == 0, "GetRawInputBuffer returned %u\n", count);
+    todo_wine
     ok(size == rawinput_size, "GetRawInputBuffer returned unexpected size: %u\n", size);
 
     SetLastError(0xdeadbeef);
     size = sizeof(buffer);
     count = GetRawInputBuffer((RAWINPUT*)buffer, &size, 0);
+    todo_wine
     ok(count == ~0U, "GetRawInputBuffer succeeded\n");
+    todo_wine
     ok(GetLastError() == ERROR_INVALID_PARAMETER, "GetRawInputBuffer returned %08x\n", GetLastError());
 
     size = sizeof(buffer);
     memset(buffer, 0, sizeof(buffer));
     count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
+    todo_wine
     ok(count == 1U, "GetRawInputBuffer returned %u\n", count);
     ok(size == sizeof(buffer), "GetRawInputBuffer returned unexpected size: %u\n", size);
+    todo_wine
     ok(rawinput_buffer_mouse_x(buffer, 0) == 5, "Unexpected rawinput data: %d\n", rawinput_buffer_mouse_x(buffer, 0));
 
 
@@ -2093,8 +2137,11 @@ static void test_GetRawInputBuffer(void)
     size = rawinput_size;
     memset(buffer, 0, sizeof(buffer));
     count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
+    todo_wine
     ok(count == ~0U, "GetRawInputBuffer succeeded\n");
+    todo_wine
     ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER, "GetRawInputBuffer returned %08x\n", GetLastError());
+    todo_wine
     ok(rawinput_buffer_mouse_x(buffer, 0) == 5, "Unexpected rawinput data: %d\n", rawinput_buffer_mouse_x(buffer, 0));
 
     size = sizeof(buffer);
@@ -2108,6 +2155,7 @@ static void test_GetRawInputBuffer(void)
     mouse_event(MOUSEEVENTF_MOVE, 3, 0, 0, 0);
     mouse_event(MOUSEEVENTF_MOVE, 4, 0, 0, 0);
     empty_message_queue();
+    todo_wine
     ok(rawinputbuffer_wndproc_count == 2, "Spurious WM_INPUT messages\n");
 
     raw_devices[0].dwFlags = RIDEV_REMOVE;
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 8fa54b9229..d7f4741ebe 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -173,12 +173,6 @@ struct wm_char_mapping_data
 /* hold up to 10s of 1kHz mouse rawinput events */
 #define RAWINPUT_BUFFER_SIZE (512*1024)
 
-struct rawinput_thread_data
-{
-    UINT     hw_id;     /* current rawinput message id */
-    RAWINPUT buffer[1]; /* rawinput message data buffer */
-};
-
 /* this is the structure stored in TEB->Win32ClientInfo */
 /* no attempt is made to keep the layout compatible with the Windows one */
 struct user_thread_info
@@ -202,7 +196,7 @@ struct user_thread_info
     struct user_key_state_info   *key_state;              /* Cache of global key state */
     HWND                          top_window;             /* Desktop window */
     HWND                          msg_window;             /* HWND_MESSAGE parent window */
-    struct rawinput_thread_data  *rawinput;               /* RawInput thread local data / buffer */
+    RAWINPUT                     *rawinput;               /* Rawinput buffer */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
@@ -242,7 +236,7 @@ struct tagWND;
 
 struct hardware_msg_data;
 extern BOOL rawinput_from_hardware_message(RAWINPUT *rawinput, const struct hardware_msg_data *msg_data);
-extern struct rawinput_thread_data *rawinput_thread_data(void);
+extern RAWINPUT *rawinput_thread_data(void);
 
 extern void CLIPBOARD_ReleaseOwner( HWND hwnd ) DECLSPEC_HIDDEN;
 extern BOOL FOCUS_MouseActivate( HWND hwnd ) DECLSPEC_HIDDEN;
diff --git a/dlls/wbemprox/builtin.c b/dlls/wbemprox/builtin.c
index 4326822193..5f8c99c996 100644
--- a/dlls/wbemprox/builtin.c
+++ b/dlls/wbemprox/builtin.c
@@ -3286,7 +3286,7 @@ static WCHAR *get_lastbootuptime(void)
     if (!(ret = heap_alloc( 26 * sizeof(WCHAR) ))) return NULL;
 
     NtQuerySystemInformation( SystemTimeOfDayInformation, &ti, sizeof(ti), NULL );
-    RtlTimeToTimeFields( &ti.BootTime, &tf );
+    RtlTimeToTimeFields( &ti.liKeBootTime, &tf );
     swprintf( ret, 26, L"%04u%02u%02u%02u%02u%02u.%06u+000", tf.Year, tf.Month, tf.Day, tf.Hour, tf.Minute,
               tf.Second, tf.Milliseconds * 1000 );
     return ret;
diff --git a/include/config.h.in b/include/config.h.in
index 5a21875f66..19a01bbfb9 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -957,12 +957,6 @@
 /* Define to 1 if `__st_birthtime' is a member of `struct stat'. */
 #undef HAVE_STRUCT_STAT___ST_BIRTHTIME
 
-/* Define to 1 if `mem_unit' is a member of `struct sysinfo'. */
-#undef HAVE_STRUCT_SYSINFO_MEM_UNIT
-
-/* Define to 1 if `totalram' is a member of `struct sysinfo'. */
-#undef HAVE_STRUCT_SYSINFO_TOTALRAM
-
 /* Define to 1 if `tcps_connattempt' is a member of `struct tcpstat'. */
 #undef HAVE_STRUCT_TCPSTAT_TCPS_CONNATTEMPT
 
diff --git a/include/ddk/wdm.h b/include/ddk/wdm.h
index 9fcb138701..6527c25579 100644
--- a/include/ddk/wdm.h
+++ b/include/ddk/wdm.h
@@ -1253,7 +1253,6 @@ typedef struct _KUSER_SHARED_DATA {
     ULONG SuiteMask;                                       /* 0x2d0 */
     BOOLEAN KdDebuggerEnabled;                             /* 0x2d4 */
     UCHAR NXSupportPolicy;                                 /* 0x2d5 */
-    USHORT CyclesPerYield;                                 /* 0x2d6 */
     volatile ULONG ActiveConsoleId;                        /* 0x2d8 */
     volatile ULONG DismountCount;                          /* 0x2dc */
     ULONG ComPlusPackage;                                  /* 0x2e0 */
@@ -1261,43 +1260,16 @@ typedef struct _KUSER_SHARED_DATA {
     ULONG NumberOfPhysicalPages;                           /* 0x2e8 */
     BOOLEAN SafeBootMode;                                  /* 0x2ec */
     UCHAR VirtualizationFlags;                             /* 0x2ed */
-    union {
-        ULONG SharedDataFlags;                             /* 0x2f0 */
-        struct {
-            ULONG DbgErrorPortPresent       : 1;
-            ULONG DbgElevationEnabed        : 1;
-            ULONG DbgVirtEnabled            : 1;
-            ULONG DbgInstallerDetectEnabled : 1;
-            ULONG DbgLkgEnabled             : 1;
-            ULONG DbgDynProcessorEnabled    : 1;
-            ULONG DbgConsoleBrokerEnabled   : 1;
-            ULONG DbgSecureBootEnabled      : 1;
-            ULONG DbgMultiSessionSku        : 1;
-            ULONG DbgMultiUsersInSessionSku : 1;
-            ULONG DbgStateSeparationEnabled : 1;
-            ULONG SpareBits                 : 21;
-        } DUMMYSTRUCTNAME2;
-    } DUMMYUNIONNAME2;
-    ULONG DataFlagsPad[1];                                 /* 0x2f4 */
+    ULONG TraceLogging;                                    /* 0x2f0 */
     ULONGLONG TestRetInstruction;                          /* 0x2f8 */
-    LONGLONG QpcFrequency;                                 /* 0x300 */
-    ULONG SystemCall;                                      /* 0x308 */
-    union {
-        ULONG AllFlags;                                    /* 0x30c */
-        struct {
-            ULONG Win32Process            : 1;
-            ULONG Sgx2Enclave             : 1;
-            ULONG VbsBasicEnclave         : 1;
-            ULONG SpareBits               : 29;
-        } DUMMYSTRUCTNAME;
-    } UserCetAvailableEnvironments;
-    ULONGLONG SystemCallPad[2];                            /* 0x310 */
+    ULONG SystemCall;                                      /* 0x300 */
+    ULONG SystemCallReturn;                                /* 0x304 */
+    ULONGLONG SystemCallPad[3];                            /* 0x308 */
     union {
         volatile KSYSTEM_TIME TickCount;                   /* 0x320 */
         volatile ULONG64 TickCountQuad;
     } DUMMYUNIONNAME;
     ULONG Cookie;                                          /* 0x330 */
-    ULONG CookiePad[1];                                    /* 0x334 */
     LONGLONG ConsoleSessionForegroundProcessId;            /* 0x338 */
     ULONGLONG TimeUpdateLock;                              /* 0x340 */
     ULONGLONG BaselineSystemTimeQpc;                       /* 0x348 */
diff --git a/include/wine/condrv.h b/include/wine/condrv.h
deleted file mode 100644
index c898b094cf..0000000000
--- a/include/wine/condrv.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Console driver ioctls
- *
- * Copyright 2020 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#ifndef _INC_CONDRV
-#define _INC_CONDRV
-
-#include "winioctl.h"
-#include "wincon.h"
-
-/* common console input and output ioctls */
-#define IOCTL_CONDRV_GET_MODE              CTL_CODE(FILE_DEVICE_CONSOLE,  0, METHOD_BUFFERED, FILE_READ_PROPERTIES)
-#define IOCTL_CONDRV_SET_MODE              CTL_CODE(FILE_DEVICE_CONSOLE,  1, METHOD_BUFFERED, FILE_WRITE_PROPERTIES)
-
-/* console input ioctls */
-#define IOCTL_CONDRV_READ_INPUT            CTL_CODE(FILE_DEVICE_CONSOLE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
-#define IOCTL_CONDRV_WRITE_INPUT           CTL_CODE(FILE_DEVICE_CONSOLE, 11, METHOD_BUFFERED, FILE_WRITE_PROPERTIES)
-#define IOCTL_CONDRV_PEEK                  CTL_CODE(FILE_DEVICE_CONSOLE, 12, METHOD_BUFFERED, FILE_READ_ACCESS)
-#define IOCTL_CONDRV_GET_INPUT_INFO        CTL_CODE(FILE_DEVICE_CONSOLE, 13, METHOD_BUFFERED, FILE_READ_PROPERTIES)
-#define IOCTL_CONDRV_SET_INPUT_INFO        CTL_CODE(FILE_DEVICE_CONSOLE, 14, METHOD_BUFFERED, FILE_WRITE_PROPERTIES)
-#define IOCTL_CONDRV_GET_TITLE             CTL_CODE(FILE_DEVICE_CONSOLE, 15, METHOD_BUFFERED, FILE_READ_PROPERTIES)
-#define IOCTL_CONDRV_SET_TITLE             CTL_CODE(FILE_DEVICE_CONSOLE, 16, METHOD_BUFFERED, FILE_WRITE_PROPERTIES)
-
-/* console output ioctls */
-#define IOCTL_CONDRV_READ_OUTPUT           CTL_CODE(FILE_DEVICE_CONSOLE, 30, METHOD_BUFFERED, FILE_READ_DATA)
-#define IOCTL_CONDRV_WRITE_OUTPUT          CTL_CODE(FILE_DEVICE_CONSOLE, 31, METHOD_BUFFERED, FILE_WRITE_DATA)
-#define IOCTL_CONDRV_GET_OUTPUT_INFO       CTL_CODE(FILE_DEVICE_CONSOLE, 32, METHOD_BUFFERED, FILE_READ_PROPERTIES)
-#define IOCTL_CONDRV_SET_OUTPUT_INFO       CTL_CODE(FILE_DEVICE_CONSOLE, 33, METHOD_BUFFERED, FILE_WRITE_PROPERTIES)
-#define IOCTL_CONDRV_ACTIVATE              CTL_CODE(FILE_DEVICE_CONSOLE, 34, METHOD_BUFFERED, FILE_WRITE_DATA)
-#define IOCTL_CONDRV_FILL_OUTPUT           CTL_CODE(FILE_DEVICE_CONSOLE, 35, METHOD_BUFFERED, FILE_WRITE_DATA)
-#define IOCTL_CONDRV_SCROLL                CTL_CODE(FILE_DEVICE_CONSOLE, 36, METHOD_BUFFERED, FILE_WRITE_DATA)
-
-/* console renderer ioctls */
-#define IOCTL_CONDRV_GET_RENDERER_EVENTS   CTL_CODE(FILE_DEVICE_CONSOLE, 70, METHOD_BUFFERED, FILE_READ_PROPERTIES)
-#define IOCTL_CONDRV_ATTACH_RENDERER       CTL_CODE(FILE_DEVICE_CONSOLE, 71, METHOD_BUFFERED, FILE_READ_PROPERTIES)
-
-/* console handle type */
-typedef unsigned int condrv_handle_t;
-
-/* convert an object handle to a server handle */
-static inline condrv_handle_t condrv_handle( HANDLE handle )
-{
-    if ((int)(INT_PTR)handle != (INT_PTR)handle) return 0xfffffff0;  /* some invalid handle */
-    return (INT_PTR)handle;
-}
-
-/* structure for console char/attribute info */
-typedef struct
-{
-    WCHAR          ch;
-    unsigned short attr;
-} char_info_t;
-
-/* IOCTL_CONDRV_GET_INPUT_INFO result */
-struct condrv_input_info
-{
-    unsigned int  input_cp;       /* console input codepage */
-    unsigned int  output_cp;      /* console output codepage */
-    unsigned int  history_mode;   /* whether we duplicate lines in history */
-    unsigned int  history_size;   /* number of lines in history */
-    unsigned int  history_index;  /* number of used lines in history */
-    unsigned int  edition_mode;   /* index to the edition mode flavors */
-    unsigned int  input_count;    /* number of available input records */
-    condrv_handle_t win;          /* renderer window handle */
-};
-
-/* IOCTL_CONDRV_SET_INPUT_INFO params */
-struct condrv_input_info_params
-{
-    unsigned int  mask;               /* setting mask */
-    struct condrv_input_info info;    /* input_info */
-};
-
-/* IOCTL_CONDRV_WRITE_OUTPUT and IOCTL_CONDRV_READ_OUTPUT params */
-struct condrv_output_params
-{
-    unsigned int  x;                  /* destination position */
-    unsigned int  y;
-    unsigned int  mode;               /* char info mode */
-    unsigned int  width;              /* width of output rectangle, 0 for wrapped mode */
-    /* followed by an array of data with type depending on mode */
-};
-
-enum char_info_mode
-{
-    CHAR_INFO_MODE_TEXT,              /* characters only */
-    CHAR_INFO_MODE_ATTR,              /* attributes only */
-    CHAR_INFO_MODE_TEXTATTR,          /* both characters and attributes */
-    CHAR_INFO_MODE_TEXTSTDATTR,       /* characters but use standard attributes */
-};
-
-/* IOCTL_CONDRV_GET_OUTPUT_INFO result */
-struct condrv_output_info
-{
-    short int     cursor_size;        /* size of cursor (percentage filled) */
-    short int     cursor_visible;     /* cursor visibility flag */
-    short int     cursor_x;           /* position of cursor (x, y) */
-    short int     cursor_y;
-    short int     width;              /* width of the screen buffer */
-    short int     height;             /* height of the screen buffer */
-    short int     attr;               /* default fill attributes (screen colors) */
-    short int     popup_attr;         /* pop-up color attributes */
-    short int     win_left;           /* window actually displayed by renderer */
-    short int     win_top;            /* the rect area is expressed within the */
-    short int     win_right;          /* boundaries of the screen buffer */
-    short int     win_bottom;
-    short int     max_width;          /* maximum size (width x height) for the window */
-    short int     max_height;
-    short int     font_width;         /* font size (width x height) */
-    short int     font_height;
-    short int     font_weight;        /* font weight */
-    short int     font_pitch_family;  /* font pitch & family */
-    unsigned int  color_map[16];      /* color table */
-};
-
-/* IOCTL_CONDRV_SET_OUTPUT_INFO params */
-struct condrv_output_info_params
-{
-    unsigned int  mask;               /* setting mask */
-    struct condrv_output_info info;   /* output info */
-};
-
-#define SET_CONSOLE_OUTPUT_INFO_CURSOR_GEOM     0x0001
-#define SET_CONSOLE_OUTPUT_INFO_CURSOR_POS      0x0002
-#define SET_CONSOLE_OUTPUT_INFO_SIZE            0x0004
-#define SET_CONSOLE_OUTPUT_INFO_ATTR            0x0008
-#define SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW  0x0010
-#define SET_CONSOLE_OUTPUT_INFO_MAX_SIZE        0x0020
-#define SET_CONSOLE_OUTPUT_INFO_FONT            0x0040
-#define SET_CONSOLE_OUTPUT_INFO_COLORTABLE      0x0080
-#define SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR      0x0100
-
-/* IOCTL_CONDRV_FILL_OUTPUT params */
-struct condrv_fill_output_params
-{
-    int            x;                 /* position where to start writing */
-    int            y;
-    int            mode;              /* char info mode */
-    int            count;             /* number to write */
-    int            wrap;              /* wrap around at end of line? */
-    WCHAR          ch;                /* character to write */
-    unsigned short attr;              /* attribute to write */
-};
-
-/* IOCTL_CONDRV_SCROLL params */
-struct condrv_scroll_params
-{
-    SMALL_RECT   scroll;              /* source rectangle */
-    COORD        origin;              /* destination coordinates */
-    SMALL_RECT   clip;                /* clipping rectangle */
-    char_info_t  fill;                /* empty character info */
-};
-
-/* IOCTL_CONDRV_GET_RENDERER_EVENTS result */
-struct condrv_renderer_event
-{
-    short event;
-    union
-    {
-        struct
-        {
-            short top;
-            short bottom;
-        } update;
-        struct
-        {
-            short width;
-            short height;
-        } resize;
-        struct
-        {
-            short x;
-            short y;
-        } cursor_pos;
-        struct
-        {
-            short visible;
-            short size;
-        } cursor_geom;
-        struct
-        {
-            short left;
-            short top;
-            short width;
-            short height;
-        } display;
-    } u;
-};
-
-enum condrv_renderer_event_type
-{
-    CONSOLE_RENDERER_NONE_EVENT,
-    CONSOLE_RENDERER_TITLE_EVENT,
-    CONSOLE_RENDERER_SB_RESIZE_EVENT,
-    CONSOLE_RENDERER_UPDATE_EVENT,
-    CONSOLE_RENDERER_CURSOR_POS_EVENT,
-    CONSOLE_RENDERER_CURSOR_GEOM_EVENT,
-    CONSOLE_RENDERER_DISPLAY_EVENT,
-    CONSOLE_RENDERER_EXIT_EVENT,
-};
-
-#endif /* _INC_CONDRV */
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 472ed6ab93..1fb345bc5f 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -353,6 +353,13 @@ typedef union
 } message_data_t;
 
 
+typedef struct
+{
+    WCHAR          ch;
+    unsigned short attr;
+} char_info_t;
+
+
 struct filesystem_event
 {
     int         action;
@@ -486,7 +493,7 @@ typedef union
         unsigned int     op_type;
         client_ptr_t     addr;
         mem_size_t       size;
-        mem_size_t       zero_bits;
+        unsigned int     zero_bits_64;
         unsigned int     prot;
     } virtual_alloc;
     struct
@@ -537,9 +544,9 @@ typedef union
         client_ptr_t     addr;
         mem_size_t       size;
         file_pos_t       offset;
-        mem_size_t       zero_bits;
         unsigned int     alloc_type;
-        unsigned int     prot;
+        unsigned short   zero_bits_64;
+        unsigned short   prot;
     } map_view;
     struct
     {
@@ -550,7 +557,7 @@ typedef union
     struct
     {
         enum apc_type    type;
-        unsigned int     flags;
+        int              suspend;
         client_ptr_t     func;
         client_ptr_t     arg;
         mem_size_t       reserve;
@@ -638,9 +645,7 @@ typedef union
     {
         enum apc_type    type;
         unsigned int     status;
-        process_id_t     pid;
         thread_id_t      tid;
-        client_ptr_t     teb;
         obj_handle_t     handle;
     } create_thread;
     struct
@@ -867,6 +872,8 @@ struct init_process_done_request
     mod_handle_t module;
     client_ptr_t ldt_copy;
     client_ptr_t entry;
+    obj_handle_t usd_handle;
+    char __pad_44[4];
 };
 struct init_process_done_reply
 {
@@ -999,7 +1006,7 @@ struct get_thread_info_request
 {
     struct request_header __header;
     obj_handle_t handle;
-    unsigned int access;
+    thread_id_t  tid_in;
     char __pad_20[4];
 };
 struct get_thread_info_reply
@@ -1014,9 +1021,9 @@ struct get_thread_info_reply
     int          priority;
     int          last;
     int          suspend_count;
-    int          dbg_hidden;
     data_size_t  desc_len;
     /* VARARG(desc,unicode_str); */
+    char __pad_60[4];
 };
 
 
@@ -1031,8 +1038,6 @@ struct get_thread_times_reply
     struct reply_header __header;
     timeout_t    creation_time;
     timeout_t    exit_time;
-    int          unix_pid;
-    int          unix_tid;
 };
 
 
@@ -1058,7 +1063,6 @@ struct set_thread_info_reply
 #define SET_THREAD_INFO_TOKEN       0x04
 #define SET_THREAD_INFO_ENTRYPOINT  0x08
 #define SET_THREAD_INFO_DESCRIPTION 0x10
-#define SET_THREAD_INFO_DBG_HIDDEN  0x20
 
 
 
@@ -1218,18 +1222,6 @@ struct dup_handle_reply
 
 
 
-struct make_temporary_request
-{
-    struct request_header __header;
-    obj_handle_t handle;
-};
-struct make_temporary_reply
-{
-    struct reply_header __header;
-};
-
-
-
 struct open_process_request
 {
     struct request_header __header;
@@ -1280,7 +1272,7 @@ struct select_reply
     apc_call_t   call;
     obj_handle_t apc_handle;
     /* VARARG(context,context); */
-    char __pad_60[4];
+    char __pad_52[4];
 };
 #define SELECT_ALERTABLE     1
 #define SELECT_INTERRUPTIBLE 2
@@ -1833,7 +1825,7 @@ struct alloc_console_reply
 {
     struct reply_header __header;
     obj_handle_t handle_in;
-    char __pad_12[4];
+    obj_handle_t event;
 };
 
 
@@ -1849,6 +1841,82 @@ struct free_console_reply
 };
 
 
+#define CONSOLE_RENDERER_NONE_EVENT        0x00
+#define CONSOLE_RENDERER_TITLE_EVENT       0x01
+#define CONSOLE_RENDERER_ACTIVE_SB_EVENT   0x02
+#define CONSOLE_RENDERER_SB_RESIZE_EVENT   0x03
+#define CONSOLE_RENDERER_UPDATE_EVENT      0x04
+#define CONSOLE_RENDERER_CURSOR_POS_EVENT  0x05
+#define CONSOLE_RENDERER_CURSOR_GEOM_EVENT 0x06
+#define CONSOLE_RENDERER_DISPLAY_EVENT     0x07
+#define CONSOLE_RENDERER_EXIT_EVENT        0x08
+struct console_renderer_event
+{
+    short event;
+    union
+    {
+        struct
+        {
+            short top;
+            short bottom;
+        } update;
+        struct
+        {
+            short width;
+            short height;
+        } resize;
+        struct
+        {
+            short x;
+            short y;
+        } cursor_pos;
+        struct
+        {
+            short visible;
+            short size;
+        } cursor_geom;
+        struct
+        {
+            short left;
+            short top;
+            short width;
+            short height;
+        } display;
+    } u;
+};
+
+
+struct get_console_renderer_events_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_console_renderer_events_reply
+{
+    struct reply_header __header;
+    /* VARARG(data,bytes); */
+};
+
+
+
+struct open_console_request
+{
+    struct request_header __header;
+    obj_handle_t from;
+
+    unsigned int access;
+    unsigned int attributes;
+    int          share;
+    char __pad_28[4];
+};
+struct open_console_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
+};
+
+
 
 struct attach_console_request
 {
@@ -1858,6 +1926,10 @@ struct attach_console_request
 struct attach_console_reply
 {
     struct reply_header __header;
+    obj_handle_t std_in;
+    obj_handle_t std_out;
+    obj_handle_t std_err;
+    char __pad_20[4];
 };
 
 
@@ -1875,6 +1947,33 @@ struct get_console_wait_event_reply
 };
 
 
+struct get_console_mode_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_console_mode_reply
+{
+    struct reply_header __header;
+    int          mode;
+    char __pad_12[4];
+};
+
+
+
+struct set_console_mode_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          mode;
+    char __pad_20[4];
+};
+struct set_console_mode_reply
+{
+    struct reply_header __header;
+};
+
+
 
 struct set_console_input_info_request
 {
@@ -1894,6 +1993,7 @@ struct set_console_input_info_reply
 {
     struct reply_header __header;
 };
+#define SET_CONSOLE_INPUT_INFO_ACTIVE_SB        0x01
 #define SET_CONSOLE_INPUT_INFO_TITLE            0x02
 #define SET_CONSOLE_INPUT_INFO_HISTORY_MODE     0x04
 #define SET_CONSOLE_INPUT_INFO_HISTORY_SIZE     0x08
@@ -1904,6 +2004,27 @@ struct set_console_input_info_reply
 
 
 
+struct get_console_input_info_request
+{
+    struct request_header __header;
+    obj_handle_t  handle;
+};
+struct get_console_input_info_reply
+{
+    struct reply_header __header;
+    int           history_mode;
+    int           history_size;
+    int           history_index;
+    int           edition_mode;
+    int           input_cp;
+    int           output_cp;
+    user_handle_t win;
+    /* VARARG(title,unicode_str); */
+    char __pad_36[4];
+};
+
+
+
 struct append_console_input_history_request
 {
     struct request_header __header;
@@ -1952,6 +2073,198 @@ struct create_console_output_reply
 
 
 
+struct set_console_output_info_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          mask;
+    short int    cursor_size;
+    short int    cursor_visible;
+    short int    cursor_x;
+    short int    cursor_y;
+    short int    width;
+    short int    height;
+    short int    attr;
+    short int    popup_attr;
+    short int    win_left;
+    short int    win_top;
+    short int    win_right;
+    short int    win_bottom;
+    short int    max_width;
+    short int    max_height;
+    short int    font_width;
+    short int    font_height;
+    short int    font_weight;
+    short int    font_pitch_family;
+    /* VARARG(colors,uints,64); */
+    /* VARARG(face_name,unicode_str); */
+};
+struct set_console_output_info_reply
+{
+    struct reply_header __header;
+};
+#define SET_CONSOLE_OUTPUT_INFO_CURSOR_GEOM     0x0001
+#define SET_CONSOLE_OUTPUT_INFO_CURSOR_POS      0x0002
+#define SET_CONSOLE_OUTPUT_INFO_SIZE            0x0004
+#define SET_CONSOLE_OUTPUT_INFO_ATTR            0x0008
+#define SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW  0x0010
+#define SET_CONSOLE_OUTPUT_INFO_MAX_SIZE        0x0020
+#define SET_CONSOLE_OUTPUT_INFO_FONT            0x0040
+#define SET_CONSOLE_OUTPUT_INFO_COLORTABLE      0x0080
+#define SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR      0x0100
+
+
+
+struct get_console_output_info_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_console_output_info_reply
+{
+    struct reply_header __header;
+    short int    cursor_size;
+    short int    cursor_visible;
+    short int    cursor_x;
+    short int    cursor_y;
+    short int    width;
+    short int    height;
+    short int    attr;
+    short int    popup_attr;
+    short int    win_left;
+    short int    win_top;
+    short int    win_right;
+    short int    win_bottom;
+    short int    max_width;
+    short int    max_height;
+    short int    font_width;
+    short int    font_height;
+    short int    font_weight;
+    short int    font_pitch_family;
+    /* VARARG(colors,uints,64); */
+    /* VARARG(face_name,unicode_str); */
+    char __pad_44[4];
+};
+
+
+struct write_console_input_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    /* VARARG(rec,input_records); */
+};
+struct write_console_input_reply
+{
+    struct reply_header __header;
+    int          written;
+    char __pad_12[4];
+};
+
+
+
+struct read_console_input_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          flush;
+    char __pad_20[4];
+};
+struct read_console_input_reply
+{
+    struct reply_header __header;
+    int          read;
+    /* VARARG(rec,input_records); */
+    char __pad_12[4];
+};
+
+
+
+struct write_console_output_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          x;
+    int          y;
+    int          mode;
+    int          wrap;
+    /* VARARG(data,bytes); */
+};
+struct write_console_output_reply
+{
+    struct reply_header __header;
+    int          written;
+    int          width;
+    int          height;
+    char __pad_20[4];
+};
+enum char_info_mode
+{
+    CHAR_INFO_MODE_TEXT,
+    CHAR_INFO_MODE_ATTR,
+    CHAR_INFO_MODE_TEXTATTR,
+    CHAR_INFO_MODE_TEXTSTDATTR
+};
+
+
+
+struct fill_console_output_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          x;
+    int          y;
+    int          mode;
+    int          count;
+    int          wrap;
+    char_info_t  data;
+};
+struct fill_console_output_reply
+{
+    struct reply_header __header;
+    int          written;
+    char __pad_12[4];
+};
+
+
+
+struct read_console_output_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          x;
+    int          y;
+    int          mode;
+    int          wrap;
+};
+struct read_console_output_reply
+{
+    struct reply_header __header;
+    int          width;
+    int          height;
+    /* VARARG(data,bytes); */
+};
+
+
+
+struct move_console_output_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    short int    x_src;
+    short int    y_src;
+    short int    x_dst;
+    short int    y_dst;
+    short int    w;
+    short int    h;
+    char __pad_28[4];
+};
+struct move_console_output_reply
+{
+    struct reply_header __header;
+};
+
+
+
 struct send_console_signal_request
 {
     struct request_header __header;
@@ -2123,42 +2436,64 @@ struct is_same_mapping_reply
 };
 
 
-struct thread_info
+#define SNAP_PROCESS    0x00000001
+#define SNAP_THREAD     0x00000002
+
+struct create_snapshot_request
 {
-    timeout_t       start_time;
-    thread_id_t     tid;
-    int             base_priority;
-    int             current_priority;
-    int             unix_tid;
+    struct request_header __header;
+    unsigned int attributes;
+    unsigned int flags;
+    char __pad_20[4];
 };
-
-struct process_info
+struct create_snapshot_reply
 {
-    timeout_t       start_time;
-    data_size_t     name_len;
-    int             thread_count;
-    int             priority;
-    process_id_t    pid;
-    process_id_t    parent_pid;
-    int             handle_count;
-    int             unix_pid;
-    int             __pad;
+    struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
+};
 
 
+
+struct next_process_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          reset;
+    char __pad_20[4];
+};
+struct next_process_reply
+{
+    struct reply_header __header;
+    int          count;
+    process_id_t pid;
+    process_id_t ppid;
+    int          threads;
+    int          priority;
+    int          handles;
+    int          unix_pid;
+    /* VARARG(filename,unicode_str); */
+    char __pad_36[4];
 };
 
 
-struct list_processes_request
+
+struct next_thread_request
 {
     struct request_header __header;
-    char __pad_12[4];
+    obj_handle_t handle;
+    int          reset;
+    char __pad_20[4];
 };
-struct list_processes_reply
+struct next_thread_reply
 {
     struct reply_header __header;
-    data_size_t     info_size;
-    int             process_count;
-    /* VARARG(data,process_info,info_size); */
+    int          count;
+    process_id_t pid;
+    thread_id_t  tid;
+    int          base_pri;
+    int          delta_pri;
+    char __pad_28[4];
 };
 
 
@@ -2903,6 +3238,8 @@ struct accept_hardware_message_request
 {
     struct request_header __header;
     unsigned int    hw_id;
+    int             remove;
+    char __pad_20[4];
 };
 struct accept_hardware_message_reply
 {
@@ -4847,6 +5184,18 @@ struct get_object_type_reply
 
 
 
+struct unlink_object_request
+{
+    struct request_header __header;
+    obj_handle_t   handle;
+};
+struct unlink_object_reply
+{
+    struct reply_header __header;
+};
+
+
+
 struct get_token_impersonation_level_request
 {
     struct request_header __header;
@@ -5294,22 +5643,6 @@ struct set_cursor_reply
 
 
 
-struct get_rawinput_buffer_request
-{
-    struct request_header __header;
-    data_size_t rawinput_size;
-    data_size_t buffer_size;
-    char __pad_20[4];
-};
-struct get_rawinput_buffer_reply
-{
-    struct reply_header __header;
-    data_size_t next_size;
-    unsigned int count;
-    /* VARARG(data,bytes); */
-};
-
-
 struct update_rawinput_devices_request
 {
     struct request_header __header;
@@ -5322,19 +5655,6 @@ struct update_rawinput_devices_reply
 };
 
 
-struct get_rawinput_devices_request
-{
-    struct request_header __header;
-    char __pad_12[4];
-};
-struct get_rawinput_devices_reply
-{
-    struct reply_header __header;
-    unsigned int device_count;
-    /* VARARG(devices,rawinput_devices); */
-    char __pad_12[4];
-};
-
 
 struct create_job_request
 {
@@ -5425,20 +5745,6 @@ struct set_job_completion_port_reply
 
 
 
-struct get_job_info_request
-{
-    struct request_header __header;
-    obj_handle_t handle;
-};
-struct get_job_info_reply
-{
-    struct reply_header __header;
-    int total_processes;
-    int active_processes;
-};
-
-
-
 struct terminate_job_request
 {
     struct request_header __header;
@@ -5503,7 +5809,6 @@ enum request
     REQ_close_handle,
     REQ_set_handle_info,
     REQ_dup_handle,
-    REQ_make_temporary,
     REQ_open_process,
     REQ_open_thread,
     REQ_select,
@@ -5542,12 +5847,25 @@ enum request
     REQ_set_socket_deferred,
     REQ_alloc_console,
     REQ_free_console,
+    REQ_get_console_renderer_events,
+    REQ_open_console,
     REQ_attach_console,
     REQ_get_console_wait_event,
+    REQ_get_console_mode,
+    REQ_set_console_mode,
     REQ_set_console_input_info,
+    REQ_get_console_input_info,
     REQ_append_console_input_history,
     REQ_get_console_input_history,
     REQ_create_console_output,
+    REQ_set_console_output_info,
+    REQ_get_console_output_info,
+    REQ_write_console_input,
+    REQ_read_console_input,
+    REQ_write_console_output,
+    REQ_fill_console_output,
+    REQ_read_console_output,
+    REQ_move_console_output,
     REQ_send_console_signal,
     REQ_read_directory_changes,
     REQ_read_change,
@@ -5559,7 +5877,9 @@ enum request
     REQ_get_mapping_committed_range,
     REQ_add_mapping_committed_range,
     REQ_is_same_mapping,
-    REQ_list_processes,
+    REQ_create_snapshot,
+    REQ_next_process,
+    REQ_next_thread,
     REQ_wait_debug_event,
     REQ_queue_exception_event,
     REQ_get_exception_status,
@@ -5720,6 +6040,7 @@ enum request
     REQ_query_symlink,
     REQ_get_object_info,
     REQ_get_object_type,
+    REQ_unlink_object,
     REQ_get_token_impersonation_level,
     REQ_allocate_locally_unique_id,
     REQ_create_device_manager,
@@ -5748,16 +6069,13 @@ enum request
     REQ_alloc_user_handle,
     REQ_free_user_handle,
     REQ_set_cursor,
-    REQ_get_rawinput_buffer,
     REQ_update_rawinput_devices,
-    REQ_get_rawinput_devices,
     REQ_create_job,
     REQ_open_job,
     REQ_assign_job,
     REQ_process_in_job,
     REQ_set_job_limits,
     REQ_set_job_completion_port,
-    REQ_get_job_info,
     REQ_terminate_job,
     REQ_suspend_process,
     REQ_resume_process,
@@ -5793,7 +6111,6 @@ union generic_request
     struct close_handle_request close_handle_request;
     struct set_handle_info_request set_handle_info_request;
     struct dup_handle_request dup_handle_request;
-    struct make_temporary_request make_temporary_request;
     struct open_process_request open_process_request;
     struct open_thread_request open_thread_request;
     struct select_request select_request;
@@ -5832,12 +6149,25 @@ union generic_request
     struct set_socket_deferred_request set_socket_deferred_request;
     struct alloc_console_request alloc_console_request;
     struct free_console_request free_console_request;
+    struct get_console_renderer_events_request get_console_renderer_events_request;
+    struct open_console_request open_console_request;
     struct attach_console_request attach_console_request;
     struct get_console_wait_event_request get_console_wait_event_request;
+    struct get_console_mode_request get_console_mode_request;
+    struct set_console_mode_request set_console_mode_request;
     struct set_console_input_info_request set_console_input_info_request;
+    struct get_console_input_info_request get_console_input_info_request;
     struct append_console_input_history_request append_console_input_history_request;
     struct get_console_input_history_request get_console_input_history_request;
     struct create_console_output_request create_console_output_request;
+    struct set_console_output_info_request set_console_output_info_request;
+    struct get_console_output_info_request get_console_output_info_request;
+    struct write_console_input_request write_console_input_request;
+    struct read_console_input_request read_console_input_request;
+    struct write_console_output_request write_console_output_request;
+    struct fill_console_output_request fill_console_output_request;
+    struct read_console_output_request read_console_output_request;
+    struct move_console_output_request move_console_output_request;
     struct send_console_signal_request send_console_signal_request;
     struct read_directory_changes_request read_directory_changes_request;
     struct read_change_request read_change_request;
@@ -5849,7 +6179,9 @@ union generic_request
     struct get_mapping_committed_range_request get_mapping_committed_range_request;
     struct add_mapping_committed_range_request add_mapping_committed_range_request;
     struct is_same_mapping_request is_same_mapping_request;
-    struct list_processes_request list_processes_request;
+    struct create_snapshot_request create_snapshot_request;
+    struct next_process_request next_process_request;
+    struct next_thread_request next_thread_request;
     struct wait_debug_event_request wait_debug_event_request;
     struct queue_exception_event_request queue_exception_event_request;
     struct get_exception_status_request get_exception_status_request;
@@ -6010,6 +6342,7 @@ union generic_request
     struct query_symlink_request query_symlink_request;
     struct get_object_info_request get_object_info_request;
     struct get_object_type_request get_object_type_request;
+    struct unlink_object_request unlink_object_request;
     struct get_token_impersonation_level_request get_token_impersonation_level_request;
     struct allocate_locally_unique_id_request allocate_locally_unique_id_request;
     struct create_device_manager_request create_device_manager_request;
@@ -6038,16 +6371,13 @@ union generic_request
     struct alloc_user_handle_request alloc_user_handle_request;
     struct free_user_handle_request free_user_handle_request;
     struct set_cursor_request set_cursor_request;
-    struct get_rawinput_buffer_request get_rawinput_buffer_request;
     struct update_rawinput_devices_request update_rawinput_devices_request;
-    struct get_rawinput_devices_request get_rawinput_devices_request;
     struct create_job_request create_job_request;
     struct open_job_request open_job_request;
     struct assign_job_request assign_job_request;
     struct process_in_job_request process_in_job_request;
     struct set_job_limits_request set_job_limits_request;
     struct set_job_completion_port_request set_job_completion_port_request;
-    struct get_job_info_request get_job_info_request;
     struct terminate_job_request terminate_job_request;
     struct suspend_process_request suspend_process_request;
     struct resume_process_request resume_process_request;
@@ -6081,7 +6411,6 @@ union generic_reply
     struct close_handle_reply close_handle_reply;
     struct set_handle_info_reply set_handle_info_reply;
     struct dup_handle_reply dup_handle_reply;
-    struct make_temporary_reply make_temporary_reply;
     struct open_process_reply open_process_reply;
     struct open_thread_reply open_thread_reply;
     struct select_reply select_reply;
@@ -6120,12 +6449,25 @@ union generic_reply
     struct set_socket_deferred_reply set_socket_deferred_reply;
     struct alloc_console_reply alloc_console_reply;
     struct free_console_reply free_console_reply;
+    struct get_console_renderer_events_reply get_console_renderer_events_reply;
+    struct open_console_reply open_console_reply;
     struct attach_console_reply attach_console_reply;
     struct get_console_wait_event_reply get_console_wait_event_reply;
+    struct get_console_mode_reply get_console_mode_reply;
+    struct set_console_mode_reply set_console_mode_reply;
     struct set_console_input_info_reply set_console_input_info_reply;
+    struct get_console_input_info_reply get_console_input_info_reply;
     struct append_console_input_history_reply append_console_input_history_reply;
     struct get_console_input_history_reply get_console_input_history_reply;
     struct create_console_output_reply create_console_output_reply;
+    struct set_console_output_info_reply set_console_output_info_reply;
+    struct get_console_output_info_reply get_console_output_info_reply;
+    struct write_console_input_reply write_console_input_reply;
+    struct read_console_input_reply read_console_input_reply;
+    struct write_console_output_reply write_console_output_reply;
+    struct fill_console_output_reply fill_console_output_reply;
+    struct read_console_output_reply read_console_output_reply;
+    struct move_console_output_reply move_console_output_reply;
     struct send_console_signal_reply send_console_signal_reply;
     struct read_directory_changes_reply read_directory_changes_reply;
     struct read_change_reply read_change_reply;
@@ -6137,7 +6479,9 @@ union generic_reply
     struct get_mapping_committed_range_reply get_mapping_committed_range_reply;
     struct add_mapping_committed_range_reply add_mapping_committed_range_reply;
     struct is_same_mapping_reply is_same_mapping_reply;
-    struct list_processes_reply list_processes_reply;
+    struct create_snapshot_reply create_snapshot_reply;
+    struct next_process_reply next_process_reply;
+    struct next_thread_reply next_thread_reply;
     struct wait_debug_event_reply wait_debug_event_reply;
     struct queue_exception_event_reply queue_exception_event_reply;
     struct get_exception_status_reply get_exception_status_reply;
@@ -6298,6 +6642,7 @@ union generic_reply
     struct query_symlink_reply query_symlink_reply;
     struct get_object_info_reply get_object_info_reply;
     struct get_object_type_reply get_object_type_reply;
+    struct unlink_object_reply unlink_object_reply;
     struct get_token_impersonation_level_reply get_token_impersonation_level_reply;
     struct allocate_locally_unique_id_reply allocate_locally_unique_id_reply;
     struct create_device_manager_reply create_device_manager_reply;
@@ -6326,16 +6671,13 @@ union generic_reply
     struct alloc_user_handle_reply alloc_user_handle_reply;
     struct free_user_handle_reply free_user_handle_reply;
     struct set_cursor_reply set_cursor_reply;
-    struct get_rawinput_buffer_reply get_rawinput_buffer_reply;
     struct update_rawinput_devices_reply update_rawinput_devices_reply;
-    struct get_rawinput_devices_reply get_rawinput_devices_reply;
     struct create_job_reply create_job_reply;
     struct open_job_reply open_job_reply;
     struct assign_job_reply assign_job_reply;
     struct process_in_job_reply process_in_job_reply;
     struct set_job_limits_reply set_job_limits_reply;
     struct set_job_completion_port_reply set_job_completion_port_reply;
-    struct get_job_info_reply get_job_info_reply;
     struct terminate_job_reply terminate_job_reply;
     struct suspend_process_reply suspend_process_reply;
     struct resume_process_reply resume_process_reply;
@@ -6343,7 +6685,7 @@ union generic_reply
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 636
+#define SERVER_PROTOCOL_VERSION 605
 
 /* ### protocol_version end ### */
 
diff --git a/include/winternl.h b/include/winternl.h
index 8efdaf3119..f71c8136ce 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -233,11 +233,10 @@ typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME
 
 typedef struct _ACTIVATION_CONTEXT_STACK
 {
-    RTL_ACTIVATION_CONTEXT_STACK_FRAME *ActiveFrame;
-    LIST_ENTRY                          FrameListCache;
     ULONG                               Flags;
     ULONG                               NextCookieSequenceNumber;
-    ULONG_PTR                           StackId;
+    RTL_ACTIVATION_CONTEXT_STACK_FRAME *ActiveFrame;
+    LIST_ENTRY                          FrameListCache;
 } ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;
 
 typedef struct _TEB_ACTIVE_FRAME_CONTEXT
@@ -341,18 +340,6 @@ typedef struct _PEB
     LIST_ENTRY                   FlsListHead;                       /* 210/328 */
     PRTL_BITMAP                  FlsBitmap;                         /* 218/338 */
     ULONG                        FlsBitmapBits[4];                  /* 21c/340 */
-    ULONG                        FlsHighIndex;                      /* 22c/350 */
-    PVOID                        WerRegistrationData;               /* 230/358 */
-    PVOID                        WerShipAssertPtr;                  /* 234/360 */
-    PVOID                        pUnused;                           /* 238/368 */
-    PVOID                        pImageHeaderHash;                  /* 23c/370 */
-    ULONG                        TracingFlags;                      /* 240/378 */
-    ULONGLONG                    CsrServerReadOnlySharedMemoryBase; /* 248/380 */
-    ULONG                        TppWorkerpListLock;                /* 250/388 */
-    LIST_ENTRY                   TppWorkerpList;                    /* 254/390 */
-    PVOID                        WaitOnAddressHashTable [0x80];     /* 25c/3a0 */
-    PVOID                        TelemetryCoverageHeader;           /* 45c/7a0 */
-    ULONG                        CloudFileFlags;                    /* 460/7a8 */
 } PEB, *PPEB;
 
 
@@ -371,44 +358,27 @@ typedef struct _TEB
     ULONG                        CountOfOwnedCriticalSections;      /* 038/006c */
     PVOID                        CsrClientThread;                   /* 03c/0070 */
     PVOID                        Win32ThreadInfo;                   /* 040/0078 */
-    ULONG                        User32Reserved[26];                /* 044/0080 */
-    ULONG                        UserReserved[5];                   /* 0ac/00e8 */
+    ULONG                        Win32ClientInfo[31];               /* 044/0080 used for user32 private data in Wine */
     PVOID                        WOW32Reserved;                     /* 0c0/0100 */
     ULONG                        CurrentLocale;                     /* 0c4/0108 */
     ULONG                        FpSoftwareStatusRegister;          /* 0c8/010c */
-    PVOID                        ReservedForDebuggerInstrumentation[16]; /* 0cc/0110 */
-#ifdef _WIN64
-    PVOID                        SystemReserved1[30];               /*    /0190 */
-#else
-    PVOID                        SystemReserved1[26];               /* 10c/     used for krnl386 private data in Wine */
-#endif
-    char                         PlaceholderCompatibilityMode;      /* 174/0280 */
-    char                         PlaceholderReserved[11];           /* 175/0281 */
-    DWORD                        ProxiedProcessId;                  /* 180/028c */
-    ACTIVATION_CONTEXT_STACK     ActivationContextStack;            /* 184/0290 */
-    UCHAR                        WorkingOnBehalfOfTicket[8];        /* 19c/02b8 */
+    PVOID                        SystemReserved1[54];               /* 0cc/0110 used for kernel32 private data in Wine */
     LONG                         ExceptionCode;                     /* 1a4/02c0 */
-    ACTIVATION_CONTEXT_STACK    *ActivationContextStackPointer;     /* 1a8/02c8 */
-    ULONG_PTR                    InstrumentationCallbackSp;         /* 1ac/02d0 */
-    ULONG_PTR                    InstrumentationCallbackPreviousPc; /* 1b0/02d8 */
-    ULONG_PTR                    InstrumentationCallbackPreviousSp; /* 1b4/02e0 */
-#ifdef _WIN64
-    ULONG                        TxFsContext;                       /*    /02e8 */
-    BOOLEAN                      InstrumentationCallbackDisabled;   /*    /02ec */
-#else
-    BOOLEAN                      InstrumentationCallbackDisabled;   /* 1b8/     */
-    BYTE                         SpareBytes1[23];                   /* 1b9/     */
-    ULONG                        TxFsContext;                       /* 1d0/     */
-#endif
-    GDI_TEB_BATCH                GdiTebBatch;                       /* 1d4/02f0 used for ntdll private data in Wine */
-    CLIENT_ID                    RealClientId;                      /* 6b4/07d8 */
-    HANDLE                       GdiCachedProcessHandle;            /* 6bc/07e8 */
-    ULONG                        GdiClientPID;                      /* 6c0/07f0 */
-    ULONG                        GdiClientTID;                      /* 6c4/07f4 */
-    PVOID                        GdiThreadLocaleInfo;               /* 6c8/07f8 */
-    ULONG_PTR                    Win32ClientInfo[62];               /* 6cc/0800 used for user32 private data in Wine */
-    PVOID                        glDispatchTable[233];              /* 7c4/09f0 */
-    PVOID                        glReserved1[29];                   /* b68/1138 */
+    ACTIVATION_CONTEXT_STACK     ActivationContextStack;            /* 1a8/02c8 */
+    BYTE                         SpareBytes1[24];                   /* 1bc/02e8 */
+    PVOID                        SystemReserved2[10];               /* 1d4/0300 used for ntdll platform-specific private data in Wine */
+    GDI_TEB_BATCH                GdiTebBatch;                       /* 1fc/0350 used for ntdll private data in Wine */
+    HANDLE                       gdiRgn;                            /* 6dc/0838 */
+    HANDLE                       gdiPen;                            /* 6e0/0840 */
+    HANDLE                       gdiBrush;                          /* 6e4/0848 */
+    CLIENT_ID                    RealClientId;                      /* 6e8/0850 */
+    HANDLE                       GdiCachedProcessHandle;            /* 6f0/0860 */
+    ULONG                        GdiClientPID;                      /* 6f4/0868 */
+    ULONG                        GdiClientTID;                      /* 6f8/086c */
+    PVOID                        GdiThreadLocaleInfo;               /* 6fc/0870 */
+    ULONG                        UserReserved[5];                   /* 700/0878 */
+    PVOID                        glDispatchTable[280];              /* 714/0890 */
+    PVOID                        glReserved1[26];                   /* b74/1150 */
     PVOID                        glReserved2;                       /* bdc/1220 */
     PVOID                        glSectionInfo;                     /* be0/1228 */
     PVOID                        glSection;                         /* be4/1230 */
@@ -416,8 +386,8 @@ typedef struct _TEB
     PVOID                        glCurrentRC;                       /* bec/1240 */
     PVOID                        glContext;                         /* bf0/1248 */
     ULONG                        LastStatusValue;                   /* bf4/1250 */
-    UNICODE_STRING               StaticUnicodeString;               /* bf8/1258 */
-    WCHAR                        StaticUnicodeBuffer[261];          /* c00/1268 */
+    UNICODE_STRING               StaticUnicodeString;               /* bf8/1258 used by advapi32 */
+    WCHAR                        StaticUnicodeBuffer[261];          /* c00/1268 used by advapi32 */
     PVOID                        DeallocationStack;                 /* e0c/1478 */
     PVOID                        TlsSlots[64];                      /* e10/1480 */
     LIST_ENTRY                   TlsLinks;                          /* f10/1680 */
@@ -447,21 +417,6 @@ typedef struct _TEB
     PVOID                        CurrentTransactionHandle;          /* fac/17b8 */
     TEB_ACTIVE_FRAME            *ActiveFrame;                       /* fb0/17c0 */
     PVOID                       *FlsSlots;                          /* fb4/17c8 */
-    PVOID                        PreferredLanguages;                /* fb8/17d0 */
-    PVOID                        UserPrefLanguages;                 /* fbc/17d8 */
-    PVOID                        MergedPrefLanguages;               /* fc0/17e0 */
-    ULONG                        MuiImpersonation;                  /* fc4/17e8 */
-    USHORT                       CrossTebFlags;                     /* fc8/17ec */
-    USHORT                       SameTebFlags;                      /* fca/17ee */
-    PVOID                        TxnScopeEnterCallback;             /* fcc/17f0 */
-    PVOID                        TxnScopeExitCallback;              /* fd0/17f8 */
-    PVOID                        TxnScopeContext;                   /* fd4/1800 */
-    ULONG                        LockCount;                         /* fd8/1808 */
-    LONG                         WowTebOffset;                      /* fdc/180c */
-    PVOID                        ResourceRetValue;                  /* fe0/1810 */
-    PVOID                        ReservedForWdf;                    /* fe4/1818 */
-    ULONGLONG                    ReservedForCrt;                    /* fe8/1820 */
-    GUID                         EffectiveContainerId;              /* ff0/1828 */
 } TEB, *PTEB;
 
 
@@ -686,9 +641,6 @@ typedef struct _TEB64
     GUID                         EffectiveContainerId;              /* 1828 */
 } TEB64;
 
-/* reserved TEB64 TLS slots for Wow64 */
-#define WOW64_TLS_FILESYSREDIR 8
-
 #endif  /* _WIN64 */
 
 /***********************************************************************
@@ -1016,21 +968,6 @@ typedef struct _FILE_PIPE_LOCAL_INFORMATION {
 #define FILE_PIPE_CONNECTED_STATE           0x00000003
 #define FILE_PIPE_CLOSING_STATE             0x00000004
 
-typedef struct _FILE_OBJECTID_BUFFER
-{
-    BYTE ObjectId[16];
-    union
-    {
-        struct
-        {
-            BYTE BirthVolumeId[16];
-            BYTE BirthObjectId[16];
-            BYTE DomainId[16];
-        } DUMMYSTRUCTNAME;
-        BYTE ExtendedInfo[48];
-    } DUMMYUNIONNAME;
-} FILE_OBJECTID_BUFFER, *PFILE_OBJECTID_BUFFER;
-
 typedef struct _FILE_OBJECTID_INFORMATION {
     LONGLONG FileReference;
     UCHAR ObjectId[16];
@@ -1258,7 +1195,6 @@ typedef enum _SYSTEM_INFORMATION_CLASS {
     SystemSuperfetchInformation = 79,
     SystemMemoryListInformation = 80,
     SystemFileCacheInformationEx = 81,
-    SystemDynamicTimeZoneInformation = 102,
     SystemLogicalProcessorInformationEx = 107,
     SystemInformationClassMax
 } SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;
@@ -1585,22 +1521,6 @@ typedef struct _PROCESS_PRIORITY_CLASS {
     UCHAR       PriorityClass;
 } PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;
 
-typedef struct _PROCESS_STACK_ALLOCATION_INFORMATION
-{
-    SIZE_T ReserveSize;
-    SIZE_T ZeroBits;
-    PVOID  StackBase;
-} PROCESS_STACK_ALLOCATION_INFORMATION, *PPROCESS_STACK_ALLOCATION_INFORMATION;
-
-typedef struct _PROCESS_STACK_ALLOCATION_INFORMATION_EX
-{
-    ULONG PreferredNode;
-    ULONG Reserved0;
-    ULONG Reserved1;
-    ULONG Reserved2;
-    PROCESS_STACK_ALLOCATION_INFORMATION AllocInfo;
-} PROCESS_STACK_ALLOCATION_INFORMATION_EX, *PPROCESS_STACK_ALLOCATION_INFORMATION_EX;
-
 typedef struct _RTL_HEAP_DEFINITION {
     ULONG Length; /* = sizeof(RTL_HEAP_DEFINITION) */
 
@@ -1771,10 +1691,10 @@ typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
 
 typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
 #ifdef __WINESRC__
-    LARGE_INTEGER BootTime;
-    LARGE_INTEGER SystemTime;
-    LARGE_INTEGER TimeZoneBias;
-    ULONG TimeZoneId;
+    LARGE_INTEGER liKeBootTime;
+    LARGE_INTEGER liKeSystemTime;
+    LARGE_INTEGER liExpTimeZoneBias;
+    ULONG uCurrentTimeZoneId;
     ULONG Reserved;
     ULONGLONG BootTimeBias;
     ULONGLONG SleepTimeBias;
@@ -1872,26 +1792,12 @@ typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
 	BOOLEAN  DebuggerNotPresent;
 } SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;
 
-typedef struct _VM_COUNTERS
-{
-    SIZE_T PeakVirtualSize;
-    SIZE_T VirtualSize;
-    ULONG PageFaultCount;
-    SIZE_T PeakWorkingSetSize;
-    SIZE_T WorkingSetSize;
-    SIZE_T QuotaPeakPagedPoolUsage;
-    SIZE_T QuotaPagedPoolUsage;
-    SIZE_T QuotaPeakNonPagedPoolUsage;
-    SIZE_T QuotaNonPagedPoolUsage;
-    SIZE_T PagefileUsage;
-    SIZE_T PeakPagefileUsage;
-} VM_COUNTERS, *PVM_COUNTERS;
+/* System Information Class 0x05 */
 
-typedef struct _VM_COUNTERS_EX
-{
+typedef struct _VM_COUNTERS_ {
     SIZE_T PeakVirtualSize;
     SIZE_T VirtualSize;
-    ULONG PageFaultCount;
+    ULONG  PageFaultCount;
     SIZE_T PeakWorkingSetSize;
     SIZE_T WorkingSetSize;
     SIZE_T QuotaPeakPagedPoolUsage;
@@ -1900,8 +1806,8 @@ typedef struct _VM_COUNTERS_EX
     SIZE_T QuotaNonPagedPoolUsage;
     SIZE_T PagefileUsage;
     SIZE_T PeakPagefileUsage;
-    SIZE_T PrivateUsage;
-} VM_COUNTERS_EX, *PVM_COUNTERS_EX;
+    SIZE_T PrivatePageCount;
+} VM_COUNTERS, *PVM_COUNTERS;
 
 typedef struct _SYSTEM_PROCESS_INFORMATION {
 #ifdef __WINESRC__                  /* win32/win64 */
@@ -1918,7 +1824,7 @@ typedef struct _SYSTEM_PROCESS_INFORMATION {
     ULONG HandleCount;                 /* 4c/60 */
     ULONG SessionId;                   /* 50/64 */
     DWORD dwUnknown4;                  /* 54/68 */
-    VM_COUNTERS_EX vmCounters;         /* 58/70 */
+    VM_COUNTERS vmCounters;            /* 58/70 */
     IO_COUNTERS ioCounters;            /* 88/d0 */
     SYSTEM_THREAD_INFORMATION ti[1];   /* b8/100 */
 #else
@@ -2760,18 +2666,6 @@ typedef struct _SYSTEM_MODULE_INFORMATION
     SYSTEM_MODULE       Modules[1]; /* FIXME: should be Modules[0] */
 } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
 
-#define PROCESS_CREATE_FLAGS_BREAKAWAY              0x00000001
-#define PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT       0x00000002
-#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES        0x00000004
-#define PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00000008
-#define PROCESS_CREATE_FLAGS_LARGE_PAGES            0x00000010
-#define PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL  0x00000020
-#define PROCESS_CREATE_FLAGS_PROTECTED_PROCESS      0x00000040
-#define PROCESS_CREATE_FLAGS_CREATE_SESSION         0x00000080
-#define PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT    0x00000100
-#define PROCESS_CREATE_FLAGS_SUSPENDED              0x00000200
-#define PROCESS_CREATE_FLAGS_EXTENDED_UNKNOWN       0x00000400
-
 #define THREAD_CREATE_FLAGS_CREATE_SUSPENDED        0x00000001
 #define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH      0x00000002
 #define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
@@ -2783,164 +2677,6 @@ typedef LONG (CALLBACK *PRTL_EXCEPTION_FILTER)(PEXCEPTION_POINTERS);
 
 typedef void (CALLBACK *PTP_IO_CALLBACK)(PTP_CALLBACK_INSTANCE,void*,void*,IO_STATUS_BLOCK*,PTP_IO);
 
-#define PS_ATTRIBUTE_THREAD   0x00010000
-#define PS_ATTRIBUTE_INPUT    0x00020000
-#define PS_ATTRIBUTE_ADDITIVE 0x00040000
-
-typedef enum _PS_ATTRIBUTE_NUM
-{
-    PsAttributeParentProcess,
-    PsAttributeDebugPort,
-    PsAttributeToken,
-    PsAttributeClientId,
-    PsAttributeTebAddress,
-    PsAttributeImageName,
-    PsAttributeImageInfo,
-    PsAttributeMemoryReserve,
-    PsAttributePriorityClass,
-    PsAttributeErrorMode,
-    PsAttributeStdHandleInfo,
-    PsAttributeHandleList,
-    PsAttributeGroupAffinity,
-    PsAttributePreferredNode,
-    PsAttributeIdealProcessor,
-    PsAttributeUmsThread,
-    PsAttributeMitigationOptions,
-    PsAttributeProtectionLevel,
-    PsAttributeSecureProcess,
-    PsAttributeJobList,
-    PsAttributeChildProcessPolicy,
-    PsAttributeAllApplicationPackagesPolicy,
-    PsAttributeWin32kFilter,
-    PsAttributeSafeOpenPromptOriginClaim,
-    PsAttributeBnoIsolation,
-    PsAttributeDesktopAppPolicy,
-    PsAttributeChpe,
-    PsAttributeMax
-} PS_ATTRIBUTE_NUM;
-
-#define PS_ATTRIBUTE_PARENT_PROCESS     (PsAttributeParentProcess | PS_ATTRIBUTE_INPUT | PS_ATTRIBUTE_ADDITIVE)
-#define PS_ATTRIBUTE_DEBUG_PORT         (PsAttributeDebugPort | PS_ATTRIBUTE_INPUT | PS_ATTRIBUTE_ADDITIVE)
-#define PS_ATTRIBUTE_TOKEN              (PsAttributeToken | PS_ATTRIBUTE_INPUT | PS_ATTRIBUTE_ADDITIVE)
-#define PS_ATTRIBUTE_CLIENT_ID          (PsAttributeClientId | PS_ATTRIBUTE_THREAD)
-#define PS_ATTRIBUTE_TEB_ADDRESS        (PsAttributeTebAddress | PS_ATTRIBUTE_THREAD)
-#define PS_ATTRIBUTE_IMAGE_NAME         (PsAttributeImageName | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_IMAGE_INFO         (PsAttributeImageInfo)
-#define PS_ATTRIBUTE_MEMORY_RESERVE     (PsAttributeMemoryReserve | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_PRIORITY_CLASS     (PsAttributePriorityClass | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_ERROR_MODE         (PsAttributeErrorMode | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_STD_HANDLE_INFO    (PsAttributeStdHandleInfo | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_HANDLE_LIST        (PsAttributeHandleList | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_GROUP_AFFINITY     (PsAttributeGroupAffinity | PS_ATTRIBUTE_THREAD | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_PREFERRED_NODE     (PsAttributePreferredNode | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_IDEAL_PROCESSOR    (PsAttributeIdealProcessor | PS_ATTRIBUTE_THREAD | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_MITIGATION_OPTIONS (PsAttributeMitigationOptions | PS_ATTRIBUTE_INPUT | PS_ATTRIBUTE_UNKNOWN)
-#define PS_ATTRIBUTE_PROTECTION_LEVEL   (PsAttributeProtectionLevel | PS_ATTRIBUTE_INPUT | PS_ATTRIBUTE_UNKNOWN)
-#define PS_ATTRIBUTE_SECURE_PROCESS     (PsAttributeSecureProcess | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_JOB_LIST           (PsAttributeJobList | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY (PsAttributeChildProcessPolicy | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY (PsAttributeAllApplicationPackagesPolicy | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_WIN32K_FILTER      (PsAttributeWin32kFilter | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM (PsAttributeSafeOpenPromptOriginClaim | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_BNO_ISOLATION      (PsAttributeBnoIsolation | PS_ATTRIBUTE_INPUT)
-#define PS_ATTRIBUTE_DESKTOP_APP_POLICY (PsAttributeDesktopAppPolicy | PS_ATTRIBUTE_INPUT)
-
-typedef struct _PS_ATTRIBUTE
-{
-    ULONG_PTR Attribute;
-    SIZE_T    Size;
-    union
-    {
-        ULONG_PTR Value;
-        void     *ValuePtr;
-    };
-    SIZE_T *ReturnLength;
-} PS_ATTRIBUTE;
-
-typedef struct _PS_ATTRIBUTE_LIST
-{
-    SIZE_T       TotalLength;
-    PS_ATTRIBUTE Attributes[1];
-} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;
-
-typedef enum _PS_CREATE_STATE
-{
-    PsCreateInitialState,
-    PsCreateFailOnFileOpen,
-    PsCreateFailOnSectionCreate,
-    PsCreateFailExeFormat,
-    PsCreateFailMachineMismatch,
-    PsCreateFailExeName,
-    PsCreateSuccess,
-    PsCreateMaximumStates
-} PS_CREATE_STATE;
-
-typedef struct _PS_CREATE_INFO
-{
-    SIZE_T Size;
-    PS_CREATE_STATE State;
-    union
-    {
-        struct
-        {
-            union
-            {
-                ULONG InitFlags;
-                struct
-                {
-                    UCHAR WriteOutputOnExit : 1;
-                    UCHAR DetectManifest : 1;
-                    UCHAR IFEOSkipDebugger : 1;
-                    UCHAR IFEODoNotPropagateKeyState : 1;
-                    UCHAR SpareBits1 : 4;
-                    UCHAR SpareBits2 : 8;
-                    USHORT ProhibitedImageCharacteristics : 16;
-                };
-            };
-            ACCESS_MASK AdditionalFileAccess;
-        } InitState;
-        struct
-        {
-            HANDLE FileHandle;
-        } FailSection;
-        struct
-        {
-            USHORT DllCharacteristics;
-        } ExeFormat;
-        struct
-        {
-            HANDLE IFEOKey;
-        } ExeName;
-        struct
-        {
-            union
-            {
-                ULONG OutputFlags;
-                struct
-                {
-                    UCHAR ProtectedProcess : 1;
-                    UCHAR AddressSpaceOverride : 1;
-                    UCHAR DevOverrideEnabled : 1;
-                    UCHAR ManifestDetected : 1;
-                    UCHAR ProtectedProcessLight : 1;
-                    UCHAR SpareBits1 : 3;
-                    UCHAR SpareBits2 : 8;
-                    USHORT SpareBits3 : 16;
-                };
-            };
-            HANDLE FileHandle;
-            HANDLE SectionHandle;
-            ULONGLONG UserProcessParametersNative;
-            ULONG UserProcessParametersWow64;
-            ULONG CurrentParameterFlags;
-            ULONGLONG PebAddressNative;
-            ULONG PebAddressWow64;
-            ULONGLONG ManifestAddress;
-            ULONG ManifestSize;
-        } SuccessState;
-    };
-} PS_CREATE_INFO, *PPS_CREATE_INFO;
-
 /***********************************************************************
  * Function declarations
  */
@@ -3021,10 +2757,8 @@ NTSYSAPI NTSTATUS  WINAPI NtCreateSection(HANDLE*,ACCESS_MASK,const OBJECT_ATTRI
 NTSYSAPI NTSTATUS  WINAPI NtCreateSemaphore(PHANDLE,ACCESS_MASK,const OBJECT_ATTRIBUTES*,LONG,LONG);
 NTSYSAPI NTSTATUS  WINAPI NtCreateSymbolicLinkObject(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,PUNICODE_STRING);
 NTSYSAPI NTSTATUS  WINAPI NtCreateThread(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,HANDLE,PCLIENT_ID,PCONTEXT,PINITIAL_TEB,BOOLEAN);
-NTSYSAPI NTSTATUS  WINAPI NtCreateThreadEx(HANDLE*,ACCESS_MASK,OBJECT_ATTRIBUTES*,HANDLE,PRTL_THREAD_START_ROUTINE,void*,ULONG,SIZE_T,SIZE_T,SIZE_T,PS_ATTRIBUTE_LIST*);
 NTSYSAPI NTSTATUS  WINAPI NtCreateTimer(HANDLE*, ACCESS_MASK, const OBJECT_ATTRIBUTES*, TIMER_TYPE);
 NTSYSAPI NTSTATUS  WINAPI NtCreateToken(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,TOKEN_TYPE,PLUID,PLARGE_INTEGER,PTOKEN_USER,PTOKEN_GROUPS,PTOKEN_PRIVILEGES,PTOKEN_OWNER,PTOKEN_PRIMARY_GROUP,PTOKEN_DEFAULT_DACL,PTOKEN_SOURCE);
-NTSYSAPI NTSTATUS  WINAPI NtCreateUserProcess(HANDLE*,HANDLE*,ACCESS_MASK,ACCESS_MASK,OBJECT_ATTRIBUTES*,OBJECT_ATTRIBUTES*,ULONG,ULONG,RTL_USER_PROCESS_PARAMETERS*,PS_CREATE_INFO*,PS_ATTRIBUTE_LIST*);
 NTSYSAPI NTSTATUS  WINAPI NtDelayExecution(BOOLEAN,const LARGE_INTEGER*);
 NTSYSAPI NTSTATUS  WINAPI NtDeleteAtom(RTL_ATOM);
 NTSYSAPI NTSTATUS  WINAPI NtDeleteFile(POBJECT_ATTRIBUTES);
@@ -3041,7 +2775,6 @@ NTSYSAPI NTSTATUS  WINAPI NtFindAtom(const WCHAR*,ULONG,RTL_ATOM*);
 NTSYSAPI NTSTATUS  WINAPI NtFlushBuffersFile(HANDLE,IO_STATUS_BLOCK*);
 NTSYSAPI NTSTATUS  WINAPI NtFlushInstructionCache(HANDLE,LPCVOID,SIZE_T);
 NTSYSAPI NTSTATUS  WINAPI NtFlushKey(HANDLE);
-NTSYSAPI void      WINAPI NtFlushProcessWriteBuffers(void);
 NTSYSAPI NTSTATUS  WINAPI NtFlushVirtualMemory(HANDLE,LPCVOID*,SIZE_T*,ULONG);
 NTSYSAPI NTSTATUS  WINAPI NtFlushWriteBuffer(VOID);
 NTSYSAPI NTSTATUS  WINAPI NtFreeVirtualMemory(HANDLE,PVOID*,SIZE_T*,ULONG);
@@ -3159,7 +2892,6 @@ NTSYSAPI NTSTATUS  WINAPI NtRequestWaitReplyPort(HANDLE,PLPC_MESSAGE,PLPC_MESSAG
 NTSYSAPI NTSTATUS  WINAPI NtResetEvent(HANDLE,LONG*);
 NTSYSAPI NTSTATUS  WINAPI NtResetWriteWatch(HANDLE,PVOID,SIZE_T);
 NTSYSAPI NTSTATUS  WINAPI NtRestoreKey(HANDLE,HANDLE,ULONG);
-NTSYSAPI NTSTATUS  WINAPI NtResumeProcess(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtResumeThread(HANDLE,PULONG);
 NTSYSAPI NTSTATUS  WINAPI NtSaveKey(HANDLE,HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtSecureConnectPort(PHANDLE,PUNICODE_STRING,PSECURITY_QUALITY_OF_SERVICE,PLPC_SECTION_WRITE,PSID,PLPC_SECTION_READ,PULONG,PVOID,PULONG);
@@ -3200,7 +2932,6 @@ NTSYSAPI NTSTATUS  WINAPI NtSignalAndWaitForSingleObject(HANDLE,HANDLE,BOOLEAN,c
 NTSYSAPI NTSTATUS  WINAPI NtShutdownSystem(SHUTDOWN_ACTION);
 NTSYSAPI NTSTATUS  WINAPI NtStartProfile(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtStopProfile(HANDLE);
-NTSYSAPI NTSTATUS  WINAPI NtSuspendProcess(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtSuspendThread(HANDLE,PULONG);
 NTSYSAPI NTSTATUS  WINAPI NtSystemDebugControl(SYSDBG_COMMAND,PVOID,ULONG,PVOID,ULONG,PULONG);
 NTSYSAPI NTSTATUS  WINAPI NtTerminateJobObject(HANDLE,NTSTATUS);
@@ -3232,7 +2963,6 @@ NTSYSAPI BYTE      WINAPI RtlAcquireResourceShared(LPRTL_RWLOCK,BYTE);
 NTSYSAPI void      WINAPI RtlAcquireSRWLockExclusive(RTL_SRWLOCK*);
 NTSYSAPI void      WINAPI RtlAcquireSRWLockShared(RTL_SRWLOCK*);
 NTSYSAPI NTSTATUS  WINAPI RtlActivateActivationContext(DWORD,HANDLE,ULONG_PTR*);
-NTSYSAPI NTSTATUS  WINAPI RtlActivateActivationContextEx(ULONG,TEB*,HANDLE,ULONG_PTR*);
 NTSYSAPI NTSTATUS  WINAPI RtlAddAce(PACL,DWORD,DWORD,PACE_HEADER,DWORD);
 NTSYSAPI NTSTATUS  WINAPI RtlAddAccessAllowedAce(PACL,DWORD,DWORD,PSID);
 NTSYSAPI NTSTATUS  WINAPI RtlAddAccessAllowedAceEx(PACL,DWORD,DWORD,DWORD,PSID);
@@ -3568,7 +3298,6 @@ NTSYSAPI NTSTATUS  WINAPI RtlUpcaseUnicodeToOemN(LPSTR,DWORD,LPDWORD,LPCWSTR,DWO
 NTSYSAPI NTSTATUS  WINAPI RtlUpdateTimer(HANDLE, HANDLE, DWORD, DWORD);
 NTSYSAPI CHAR      WINAPI RtlUpperChar(CHAR);
 NTSYSAPI void      WINAPI RtlUpperString(STRING *,const STRING *);
-NTSYSAPI void      WINAPI RtlUserThreadStart(PRTL_THREAD_START_ROUTINE,void*);
 NTSYSAPI NTSTATUS  WINAPI RtlValidSecurityDescriptor(PSECURITY_DESCRIPTOR);
 NTSYSAPI BOOLEAN   WINAPI RtlValidRelativeSecurityDescriptor(PSECURITY_DESCRIPTOR,ULONG,SECURITY_INFORMATION);
 NTSYSAPI BOOLEAN   WINAPI RtlValidAcl(PACL);
@@ -3660,9 +3389,9 @@ NTSYSAPI void      WINAPI TpWaitForWork(TP_WORK *,BOOL);
 
 /* Wine internal functions */
 
-NTSYSAPI NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, char *nameA, SIZE_T *size,
-                                                   UINT disposition );
-NTSYSAPI NTSTATUS CDECL wine_unix_to_nt_file_name( const char *name, WCHAR *buffer, SIZE_T *size );
+NTSYSAPI NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRING *unix_name_ret,
+                                                   UINT disposition, BOOLEAN check_case );
+NTSYSAPI NTSTATUS CDECL wine_unix_to_nt_file_name( const ANSI_STRING *name, UNICODE_STRING *nt );
 
 
 /***********************************************************************
diff --git a/programs/taskmgr/perfdata.c b/programs/taskmgr/perfdata.c
index d81ab10248..3b5997d759 100644
--- a/programs/taskmgr/perfdata.c
+++ b/programs/taskmgr/perfdata.c
@@ -199,7 +199,7 @@ void PerfDataRefresh(void)
         /*  CurrentValue = NewValue - OldValue */
         dbIdleTime = Li2Double(SysPerfInfo.IdleTime) - Li2Double(liOldIdleTime);
         dbKernelTime = CurrentKernelTime - OldKernelTime;
-        dbSystemTime = Li2Double(SysTimeInfo.SystemTime) - Li2Double(liOldSystemTime);
+        dbSystemTime = Li2Double(SysTimeInfo.liKeSystemTime) - Li2Double(liOldSystemTime);
 
         /*  CurrentCpuIdle = IdleTime / SystemTime */
         dbIdleTime = dbIdleTime / dbSystemTime;
@@ -212,7 +212,7 @@ void PerfDataRefresh(void)
 
     /* Store new CPU's idle and system time */
     liOldIdleTime = SysPerfInfo.IdleTime;
-    liOldSystemTime = SysTimeInfo.SystemTime;
+    liOldSystemTime = SysTimeInfo.liKeSystemTime;
     OldKernelTime = CurrentKernelTime;
 
     /* Determine the process count
diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index 21be0f55fb..09925bfa23 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -60,12 +60,8 @@
 #include <intrin.h>
 #include <sys/stat.h>
 #include <unistd.h>
-
-#include <ntstatus.h>
-#define WIN32_NO_STATUS
 #include <windows.h>
 #include <winternl.h>
-#include <ddk/wdm.h>
 #include <sddl.h>
 #include <wine/svcctl.h>
 #include <wine/asm.h>
@@ -191,89 +187,6 @@ static DWORD set_reg_value_dword( HKEY hkey, const WCHAR *name, DWORD value )
     return RegSetValueExW( hkey, name, 0, REG_DWORD, (const BYTE *)&value, sizeof(value) );
 }
 
-static void create_user_shared_data(void)
-{
-    struct _KUSER_SHARED_DATA *data;
-    RTL_OSVERSIONINFOEXW version;
-    SYSTEM_CPU_INFORMATION sci;
-    SYSTEM_BASIC_INFORMATION sbi;
-    BOOLEAN *features;
-    OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    UNICODE_STRING name;
-    NTSTATUS status;
-    HANDLE handle;
-
-    RtlInitUnicodeString( &name, L"\\KernelObjects\\__wine_user_shared_data" );
-    InitializeObjectAttributes( &attr, &name, OBJ_OPENIF, NULL, NULL );
-    if ((status = NtOpenSection( &handle, SECTION_ALL_ACCESS, &attr )))
-    {
-        ERR( "cannot open __wine_user_shared_data: %x\n", status );
-        return;
-    }
-    data = MapViewOfFile( handle, FILE_MAP_WRITE, 0, 0, sizeof(*data) );
-    CloseHandle( handle );
-    if (!data)
-    {
-        ERR( "cannot map __wine_user_shared_data\n" );
-        return;
-    }
-
-    version.dwOSVersionInfoSize = sizeof(version);
-    RtlGetVersion( &version );
-    NtQuerySystemInformation( SystemBasicInformation, &sbi, sizeof(sbi), NULL );
-    NtQuerySystemInformation( SystemCpuInformation, &sci, sizeof(sci), NULL );
-
-    data->TickCountMultiplier         = 1 << 24;
-    data->LargePageMinimum            = 2 * 1024 * 1024;
-    data->NtBuildNumber               = version.dwBuildNumber;
-    data->NtProductType               = version.wProductType;
-    data->ProductTypeIsValid          = TRUE;
-    data->NativeProcessorArchitecture = sci.Architecture;
-    data->NtMajorVersion              = version.dwMajorVersion;
-    data->NtMinorVersion              = version.dwMinorVersion;
-    data->SuiteMask                   = version.wSuiteMask;
-    data->NumberOfPhysicalPages       = sbi.MmNumberOfPhysicalPages;
-    wcscpy( data->NtSystemRoot, L"C:\\windows" );
-
-    features = data->ProcessorFeatures;
-    switch (sci.Architecture)
-    {
-    case PROCESSOR_ARCHITECTURE_INTEL:
-    case PROCESSOR_ARCHITECTURE_AMD64:
-        features[PF_COMPARE_EXCHANGE_DOUBLE]              = !!(sci.FeatureSet & CPU_FEATURE_CX8);
-        features[PF_MMX_INSTRUCTIONS_AVAILABLE]           = !!(sci.FeatureSet & CPU_FEATURE_MMX);
-        features[PF_XMMI_INSTRUCTIONS_AVAILABLE]          = !!(sci.FeatureSet & CPU_FEATURE_SSE);
-        features[PF_3DNOW_INSTRUCTIONS_AVAILABLE]         = !!(sci.FeatureSet & CPU_FEATURE_3DNOW);
-        features[PF_RDTSC_INSTRUCTION_AVAILABLE]          = !!(sci.FeatureSet & CPU_FEATURE_TSC);
-        features[PF_PAE_ENABLED]                          = !!(sci.FeatureSet & CPU_FEATURE_PAE);
-        features[PF_XMMI64_INSTRUCTIONS_AVAILABLE]        = !!(sci.FeatureSet & CPU_FEATURE_SSE2);
-        features[PF_SSE3_INSTRUCTIONS_AVAILABLE]          = !!(sci.FeatureSet & CPU_FEATURE_SSE3);
-        features[PF_XSAVE_ENABLED]                        = !!(sci.FeatureSet & CPU_FEATURE_XSAVE);
-        features[PF_COMPARE_EXCHANGE128]                  = !!(sci.FeatureSet & CPU_FEATURE_CX128);
-        features[PF_SSE_DAZ_MODE_AVAILABLE]               = !!(sci.FeatureSet & CPU_FEATURE_DAZ);
-        features[PF_NX_ENABLED]                           = !!(sci.FeatureSet & CPU_FEATURE_NX);
-        features[PF_SECOND_LEVEL_ADDRESS_TRANSLATION]     = !!(sci.FeatureSet & CPU_FEATURE_2NDLEV);
-        features[PF_VIRT_FIRMWARE_ENABLED]                = !!(sci.FeatureSet & CPU_FEATURE_VIRT);
-        features[PF_RDWRFSGSBASE_AVAILABLE]               = !!(sci.FeatureSet & CPU_FEATURE_RDFS);
-        features[PF_FASTFAIL_AVAILABLE]                   = TRUE;
-        break;
-    case PROCESSOR_ARCHITECTURE_ARM:
-        features[PF_ARM_VFP_32_REGISTERS_AVAILABLE]       = !!(sci.FeatureSet & CPU_FEATURE_ARM_VFP_32);
-        features[PF_ARM_NEON_INSTRUCTIONS_AVAILABLE]      = !!(sci.FeatureSet & CPU_FEATURE_ARM_NEON);
-        features[PF_ARM_V8_INSTRUCTIONS_AVAILABLE]        = (sci.Level >= 8);
-        break;
-    case PROCESSOR_ARCHITECTURE_ARM64:
-        features[PF_ARM_V8_INSTRUCTIONS_AVAILABLE]        = TRUE;
-        features[PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE]  = !!(sci.FeatureSet & CPU_FEATURE_ARM_V8_CRC32);
-        features[PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE] = !!(sci.FeatureSet & CPU_FEATURE_ARM_V8_CRYPTO);
-        break;
-    }
-    data->ActiveProcessorCount = NtCurrentTeb()->Peb->NumberOfProcessors;
-    data->ActiveGroupCount = 1;
-
-    UnmapViewOfFile( data );
-}
-
 #if defined(__i386__) || defined(__x86_64__)
 
 static void regs_to_str( int *regs, unsigned int len, WCHAR *buffer )
@@ -1589,7 +1502,6 @@ int __cdecl main( int argc, char *argv[] )
 
     ResetEvent( event );  /* in case this is a restart */
 
-    create_user_shared_data();
     create_hardware_registry_keys();
     create_dynamic_registry_keys();
     create_environment_registry_keys();
diff --git a/programs/wineconsole/curses.c b/programs/wineconsole/curses.c
index 3ddd22387f..6fa669d150 100644
--- a/programs/wineconsole/curses.c
+++ b/programs/wineconsole/curses.c
@@ -324,7 +324,7 @@ static void	WCCURSES_ComputePositions(struct inner_data* data)
                   data->curcfg.win_width, data->curcfg.win_height, x, y);
         pos.Left = pos.Top = 0;
         pos.Right = x - 1; pos.Bottom = y - 1;
-        SetConsoleWindowInfo(data->console, FALSE, &pos);
+        SetConsoleWindowInfo(data->hConOut, FALSE, &pos);
         return; /* we'll get called again upon event for new window size */
     }
     if (PRIVATE(data)->pad) WCCURSES_PosCursor(data);
@@ -339,7 +339,7 @@ static void	WCCURSES_SetTitle(const struct inner_data* data)
 {
     WCHAR   wbuf[256];
 
-    if (WINECON_GetConsoleTitle(data->console, wbuf, ARRAY_SIZE(wbuf)))
+    if (WINECON_GetConsoleTitle(data->hConIn, wbuf, ARRAY_SIZE(wbuf)))
     {
         char        buffer[256];
 
@@ -965,7 +965,7 @@ static DWORD CALLBACK input_thread( void *arg )
             else
                 numEvent = WCCURSES_FillSimpleChar(ir, inchar);
 
-            if (numEvent) WriteConsoleInputW(data->console, ir, numEvent, &n);
+            if (numEvent) WriteConsoleInputW(data->hConIn, ir, numEvent, &n);
         }
         LeaveCriticalSection(&PRIVATE(data)->lock);
     }
@@ -1020,7 +1020,7 @@ static int WCCURSES_MainLoop(struct inner_data* data)
     if (pipe( PRIVATE(data)->sync_pipe ) == -1) return 1;
     PRIVATE(data)->input_thread = CreateThread( NULL, 0, input_thread, data, 0, &id );
 
-    while (!data->dying && WaitForSingleObject(data->overlapped.hEvent, INFINITE) == WAIT_OBJECT_0)
+    while (!data->dying && WaitForSingleObject(data->hSynchro, INFINITE) == WAIT_OBJECT_0)
     {
         EnterCriticalSection(&PRIVATE(data)->lock);
         WINECON_GrabChanges(data);
diff --git a/programs/wineconsole/user.c b/programs/wineconsole/user.c
index bbaffd3c2a..de3f4ae98c 100644
--- a/programs/wineconsole/user.c
+++ b/programs/wineconsole/user.c
@@ -267,7 +267,7 @@ static void	WCUSER_SetTitle(const struct inner_data* data)
 {
     WCHAR	buffer[256];
 
-    if (WINECON_GetConsoleTitle(data->console, buffer, sizeof(buffer)))
+    if (WINECON_GetConsoleTitle(data->hConIn, buffer, sizeof(buffer)))
         SetWindowTextW(data->hWnd, buffer);
 }
 
@@ -687,7 +687,7 @@ static void	WCUSER_CopySelectionToClipboard(const struct inner_data* data)
 	    LPWSTR end;
 	    DWORD count;
 
-	    ReadConsoleOutputCharacterW(data->console, p, w - 1, c, &count);
+	    ReadConsoleOutputCharacterW(data->hConOut, p, w - 1, c, &count);
 
 	    /* strip spaces from the end of the line */
 	    end = p + w - 1;
@@ -738,7 +738,7 @@ static void	WCUSER_PasteFromClipboard(struct inner_data* data)
 	    ir[1] = ir[0];
 	    ir[1].Event.KeyEvent.bKeyDown = FALSE;
 
-            WriteConsoleInputW(data->console, ir, 2, &n);
+            WriteConsoleInputW(data->hConIn, ir, 2, &n);
 	}
 	GlobalUnlock(h);
     }
@@ -1052,7 +1052,7 @@ static void    WCUSER_GenerateKeyInputRecord(struct inner_data* data, BOOL down,
     ir.Event.KeyEvent.uChar.UnicodeChar = last; /* FIXME: HACKY... and buggy because it should be a stack, not a single value */
     if (!down) last = 0;
 
-    WriteConsoleInputW(data->console, &ir, 1, &n);
+    WriteConsoleInputW(data->hConIn, &ir, 1, &n);
 }
 
 /******************************************************************
@@ -1068,7 +1068,7 @@ static void    WCUSER_GenerateMouseInputRecord(struct inner_data* data, COORD c,
     DWORD               mode, n;
 
     /* MOUSE_EVENTs shouldn't be sent unless ENABLE_MOUSE_INPUT is active */
-    if (!GetConsoleMode(data->console, &mode) || !(mode & ENABLE_MOUSE_INPUT))
+    if (!GetConsoleMode(data->hConIn, &mode) || !(mode & ENABLE_MOUSE_INPUT))
         return;
 
     ir.EventType = MOUSE_EVENT;
@@ -1083,7 +1083,7 @@ static void    WCUSER_GenerateMouseInputRecord(struct inner_data* data, COORD c,
     ir.Event.MouseEvent.dwControlKeyState = WCUSER_GetCtrlKeyState(keyState);
     ir.Event.MouseEvent.dwEventFlags = event;
 
-    WriteConsoleInputW(data->console, &ir, 1, &n);
+    WriteConsoleInputW(data->hConIn, &ir, 1, &n);
 }
 
 /******************************************************************
@@ -1365,7 +1365,7 @@ static int WCUSER_MainLoop(struct inner_data* data)
     ShowWindow(data->hWnd, data->nCmdShow);
     while (!data->dying || !data->curcfg.exit_on_die)
     {
-	switch (MsgWaitForMultipleObjects(1, &data->overlapped.hEvent, FALSE, INFINITE, QS_ALLINPUT))
+	switch (MsgWaitForMultipleObjects(1, &data->hSynchro, FALSE, INFINITE, QS_ALLINPUT))
 	{
 	case WAIT_OBJECT_0:
 	    WINECON_GrabChanges(data);
diff --git a/programs/wineconsole/winecon_private.h b/programs/wineconsole/winecon_private.h
index 736cf7824e..54d8782a2a 100644
--- a/programs/wineconsole/winecon_private.h
+++ b/programs/wineconsole/winecon_private.h
@@ -22,7 +22,6 @@
 #include <windef.h>
 #include <winbase.h>
 #include <wincon.h>
-#include <wine/condrv.h>
 
 #include "wineconsole_res.h"
 
@@ -60,7 +59,9 @@ struct inner_data {
 
     COORD		cursor;		/* position in cells of cursor */
 
-    HANDLE		console;	/* console renderer handle */
+    HANDLE		hConIn;		/* console input handle */
+    HANDLE		hConOut;	/* screen buffer handle: has to be changed when active sb changes */
+    HANDLE		hSynchro;	/* waitable handle signalled by server when something in server has been modified */
     HANDLE              hProcess;       /* handle to the child process or NULL */
     HWND		hWnd;           /* handle of 'user' window or NULL for 'curses' */
     INT                 nCmdShow;       /* argument of WinMain */
@@ -68,9 +69,6 @@ struct inner_data {
     BOOL                in_grab_changes;/* to handle re-entrant calls to WINECON_GrabChanges */
     BOOL                dying;          /* to TRUE when we've been notified by server that child has died */
 
-    OVERLAPPED          overlapped;
-    struct condrv_renderer_event events[256];
-
     int			(*fnMainLoop)(struct inner_data* data);
     void		(*fnPosCursor)(const struct inner_data* data);
     void		(*fnShapeCursor)(struct inner_data* data, int size, int vis, BOOL force);
diff --git a/programs/wineconsole/wineconsole.c b/programs/wineconsole/wineconsole.c
index 1104963f0f..38a8c71163 100644
--- a/programs/wineconsole/wineconsole.c
+++ b/programs/wineconsole/wineconsole.c
@@ -66,12 +66,19 @@ static void WINECON_Usage(void)
  */
 static void WINECON_FetchCells(struct inner_data* data, int upd_tp, int upd_bm)
 {
-    SMALL_RECT region = { 0, upd_tp, data->curcfg.sb_width - 1, upd_bm };
-    COORD size = { data->curcfg.sb_width, data->curcfg.sb_height };
-    COORD coord = { 0, upd_tp };
-
-    if (ReadConsoleOutputW(data->console, data->cells, size, coord, &region))
-        data->fnRefresh(data, upd_tp, upd_bm);
+    SERVER_START_REQ( read_console_output )
+    {
+        req->handle = wine_server_obj_handle( data->hConOut );
+        req->x      = 0;
+        req->y      = upd_tp;
+        req->mode   = CHAR_INFO_MODE_TEXTATTR;
+        req->wrap   = TRUE;
+        wine_server_set_reply( req, &data->cells[upd_tp * data->curcfg.sb_width],
+                               (upd_bm-upd_tp+1) * data->curcfg.sb_width * sizeof(CHAR_INFO) );
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    data->fnRefresh(data, upd_tp, upd_bm);
 }
 
 /******************************************************************
@@ -109,9 +116,17 @@ void WINECON_ResizeWithContainer(struct inner_data* data, int width, int height)
  */
 static BOOL WINECON_SetHistorySize(HANDLE hConIn, int size)
 {
-    struct condrv_input_info_params params = { SET_CONSOLE_INPUT_INFO_HISTORY_SIZE };
-    params.info.history_size = size;
-    return DeviceIoControl(hConIn, IOCTL_CONDRV_SET_INPUT_INFO, &params, sizeof(params), NULL, 0, NULL, NULL);
+    BOOL	ret;
+
+    SERVER_START_REQ(set_console_input_info)
+    {
+	req->handle = wine_server_obj_handle( hConIn );
+	req->mask = SET_CONSOLE_INPUT_INFO_HISTORY_SIZE;
+	req->history_size = size;
+	ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 /******************************************************************
@@ -121,9 +136,17 @@ static BOOL WINECON_SetHistorySize(HANDLE hConIn, int size)
  */
 static BOOL WINECON_SetHistoryMode(HANDLE hConIn, int mode)
 {
-    struct condrv_input_info_params params = { SET_CONSOLE_INPUT_INFO_HISTORY_MODE };
-    params.info.history_mode = mode;
-    return DeviceIoControl(hConIn, IOCTL_CONDRV_SET_INPUT_INFO, &params, sizeof(params), NULL, 0, NULL, NULL);
+    BOOL	ret;
+
+    SERVER_START_REQ(set_console_input_info)
+    {
+	req->handle = wine_server_obj_handle( hConIn );
+	req->mask = SET_CONSOLE_INPUT_INFO_HISTORY_MODE;
+	req->history_mode = mode;
+	ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 /******************************************************************
@@ -150,13 +173,22 @@ static void WINECON_SetInsertMode(HANDLE hConIn, unsigned int enable)
  */
 BOOL WINECON_GetConsoleTitle(HANDLE hConIn, WCHAR* buffer, size_t len)
 {
-    DWORD size;
+    BOOL ret;
 
-    if (!DeviceIoControl(hConIn, IOCTL_CONDRV_GET_TITLE, NULL, 0, buffer, len - sizeof(WCHAR), &size, NULL))
-        return FALSE;
+    if (len < sizeof(WCHAR)) return FALSE;
 
-    buffer[size / sizeof(WCHAR)] = 0;
-    return TRUE;
+    SERVER_START_REQ( get_console_input_info )
+    {
+        req->handle = wine_server_obj_handle( hConIn );
+        wine_server_set_reply( req, buffer, len - sizeof(WCHAR) );
+        if ((ret = !wine_server_call_err( req )))
+        {
+            len = wine_server_reply_size( reply );
+            buffer[len / sizeof(WCHAR)] = 0;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 /******************************************************************
@@ -166,9 +198,17 @@ BOOL WINECON_GetConsoleTitle(HANDLE hConIn, WCHAR* buffer, size_t len)
  */
 static BOOL WINECON_SetEditionMode(HANDLE hConIn, int edition_mode)
 {
-    struct condrv_input_info_params params = { SET_CONSOLE_INPUT_INFO_EDITION_MODE };
-    params.info.edition_mode = edition_mode;
-    return DeviceIoControl(hConIn, IOCTL_CONDRV_SET_INPUT_INFO, &params, sizeof(params), NULL, 0, NULL, NULL);
+    BOOL ret;
+
+    SERVER_START_REQ( set_console_input_info )
+    {
+        req->handle = wine_server_obj_handle( hConIn );
+        req->mask = SET_CONSOLE_INPUT_INFO_EDITION_MODE;
+        req->edition_mode = edition_mode;
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 /******************************************************************
@@ -178,15 +218,20 @@ static BOOL WINECON_SetEditionMode(HANDLE hConIn, int edition_mode)
  */
 static void WINECON_SetColors(struct inner_data *data, const struct config_data* cfg)
 {
-    struct condrv_output_info_params params =
-        { SET_CONSOLE_OUTPUT_INFO_COLORTABLE | SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR };
+    size_t color_map_size = sizeof(data->curcfg.color_map);
 
-    memcpy(data->curcfg.color_map, cfg->color_map, sizeof(data->curcfg.color_map));
+    memcpy(data->curcfg.color_map, cfg->color_map, color_map_size);
     data->curcfg.popup_attr = cfg->popup_attr;
 
-    params.info.popup_attr = cfg->popup_attr;
-    memcpy(params.info.color_map, cfg->color_map, sizeof(cfg->color_map));
-    DeviceIoControl(data->console, IOCTL_CONDRV_SET_OUTPUT_INFO, &params, sizeof(params), NULL, 0, NULL, NULL);
+    SERVER_START_REQ( set_console_output_info )
+    {
+        req->handle = wine_server_obj_handle( data->hConOut );
+        req->mask = SET_CONSOLE_OUTPUT_INFO_COLORTABLE | SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR;
+        req->popup_attr = cfg->popup_attr;
+        wine_server_add_data( req, cfg->color_map, color_map_size );
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
 }
 
 /******************************************************************
@@ -196,20 +241,21 @@ static void WINECON_SetColors(struct inner_data *data, const struct config_data*
  */
 void	WINECON_GrabChanges(struct inner_data* data)
 {
-    struct condrv_renderer_event *evts = data->events;
-    int i, ev_found;
-    DWORD num;
+    struct console_renderer_event	evts[256];
+    int	i, num, ev_found;
+    HANDLE h;
 
     if (data->in_grab_changes) return;
 
-    if (!GetOverlappedResult(data->console, &data->overlapped, &num, FALSE))
+    SERVER_START_REQ( get_console_renderer_events )
     {
-        if (GetLastError() == ERROR_IO_INCOMPLETE) return;
-        ERR( "failed to get renderer events: %u\n", GetLastError() );
-        data->dying = TRUE;
-        return;
+        wine_server_set_reply( req, evts, sizeof(evts) );
+        req->handle = wine_server_obj_handle( data->hSynchro );
+        if (!wine_server_call_err( req )) num = wine_server_reply_size(reply) / sizeof(evts[0]);
+        else num = 0;
     }
-    num /= sizeof(data->events[0]);
+    SERVER_END_REQ;
+    if (!num) {WINE_WARN("hmm renderer signaled but no events available\n"); return;}
     WINE_TRACE( "got %u events\n", num );
 
     /* FIXME: should do some event compression here (cursor pos, update) */
@@ -266,6 +312,23 @@ void	WINECON_GrabChanges(struct inner_data* data)
 	    WINE_TRACE("%u/%u: title()\n", i+1, num);
 	    data->fnSetTitle(data);
 	    break;
+	case CONSOLE_RENDERER_ACTIVE_SB_EVENT:
+	    SERVER_START_REQ( open_console )
+	    {
+                req->from       = wine_server_obj_handle( data->hConIn );
+                req->access     = GENERIC_READ | GENERIC_WRITE;
+                req->attributes = 0;
+                req->share      = FILE_SHARE_READ | FILE_SHARE_WRITE;
+                h = wine_server_call_err( req ) ? 0 : wine_server_ptr_handle(reply->handle);
+	    }
+	    SERVER_END_REQ;
+	    WINE_TRACE("%u/%u: active(%p)\n", i+1, num, h);
+	    if (h)
+	    {
+		CloseHandle(data->hConOut);
+		data->hConOut = h;
+	    }
+	    break;
 	case CONSOLE_RENDERER_SB_RESIZE_EVENT:
 	    if (data->curcfg.sb_width != evts[i].u.resize.width ||
 		data->curcfg.sb_height != evts[i].u.resize.height)
@@ -336,13 +399,6 @@ void	WINECON_GrabChanges(struct inner_data* data)
 	}
     }
     data->in_grab_changes = FALSE;
-
-    if (!DeviceIoControl(data->console, IOCTL_CONDRV_GET_RENDERER_EVENTS, NULL, 0, data->events,
-                         sizeof(data->events), NULL, &data->overlapped) && GetLastError() != ERROR_IO_PENDING)
-    {
-        ERR("failed to get renderer events: %u\n", GetLastError());
-        data->dying = TRUE;
-    }
 }
 
 /******************************************************************
@@ -365,26 +421,26 @@ void     WINECON_SetConfig(struct inner_data* data, const struct config_data* cf
          * (no notification is sent when invariant operation is requested)
          */
         cinfo.bVisible = !cfg->cursor_visible;
-        SetConsoleCursorInfo(data->console, &cinfo);
+        SetConsoleCursorInfo(data->hConOut, &cinfo);
         /* </FIXME> */
         cinfo.bVisible = cfg->cursor_visible;
         /* this shall update (through notif) curcfg */
-        SetConsoleCursorInfo(data->console, &cinfo);
+        SetConsoleCursorInfo(data->hConOut, &cinfo);
     }
     if (data->curcfg.history_size != cfg->history_size)
     {
         data->curcfg.history_size = cfg->history_size;
-        WINECON_SetHistorySize(data->console, cfg->history_size);
+        WINECON_SetHistorySize(data->hConIn, cfg->history_size);
     }
     if (data->curcfg.history_nodup != cfg->history_nodup)
     {
         data->curcfg.history_nodup = cfg->history_nodup;
-        WINECON_SetHistoryMode(data->console, cfg->history_nodup);
+        WINECON_SetHistoryMode(data->hConIn, cfg->history_nodup);
     }
     if (data->curcfg.insert_mode != cfg->insert_mode)
     {
         data->curcfg.insert_mode = cfg->insert_mode;
-        WINECON_SetInsertMode(data->console, cfg->insert_mode);
+        WINECON_SetInsertMode(data->hConIn, cfg->insert_mode);
     }
     data->curcfg.menu_mask = cfg->menu_mask;
     data->curcfg.quick_edit = cfg->quick_edit;
@@ -392,24 +448,23 @@ void     WINECON_SetConfig(struct inner_data* data, const struct config_data* cf
         data->curcfg.cell_height != cfg->cell_height || data->curcfg.font_pitch_family != cfg->font_pitch_family ||
         data->curcfg.font_weight != cfg->font_weight)
     {
-        struct condrv_output_info_params *params;
-        size_t len = lstrlenW(cfg->face_name);
         RECT r;
         data->fnSetFont(data, cfg->face_name, cfg->cell_height, cfg->font_weight);
         SystemParametersInfoW(SPI_GETWORKAREA, 0, &r, 0);
-        if ((params = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*params) + len * sizeof(WCHAR))))
+        SERVER_START_REQ(set_console_output_info)
         {
-            params->mask = SET_CONSOLE_OUTPUT_INFO_MAX_SIZE | SET_CONSOLE_OUTPUT_INFO_FONT;
-            params->info.max_width  = (r.right - r.left) / cfg->cell_width;
-            params->info.max_height = (r.bottom - r.top - GetSystemMetrics(SM_CYCAPTION)) / cfg->cell_height;
-            params->info.font_width = cfg->cell_width;
-            params->info.font_height = cfg->cell_height;
-            params->info.font_weight = cfg->font_weight;
-            params->info.font_pitch_family = cfg->font_pitch_family;
-            memcpy(params + 1, cfg->face_name, len * sizeof(WCHAR));
-            DeviceIoControl(data->console, IOCTL_CONDRV_SET_OUTPUT_INFO, params, sizeof(*params) + len * sizeof(WCHAR),
-                            NULL, 0, NULL, NULL);
+            req->handle = wine_server_obj_handle( data->hConOut );
+            req->mask = SET_CONSOLE_OUTPUT_INFO_MAX_SIZE | SET_CONSOLE_OUTPUT_INFO_FONT;
+            req->max_width  = (r.right - r.left) / cfg->cell_width;
+            req->max_height = (r.bottom - r.top - GetSystemMetrics(SM_CYCAPTION)) / cfg->cell_height;
+            req->font_width = cfg->cell_width;
+            req->font_height = cfg->cell_height;
+            req->font_weight = cfg->font_weight;
+            req->font_pitch_family = cfg->font_pitch_family;
+            wine_server_add_data( req, cfg->face_name, lstrlenW(cfg->face_name) * sizeof(WCHAR) );
+            wine_server_call( req );
         }
+        SERVER_END_REQ;
     }
     if (data->curcfg.def_attr != cfg->def_attr)
     {
@@ -418,8 +473,8 @@ void     WINECON_SetConfig(struct inner_data* data, const struct config_data* cf
 
         data->curcfg.def_attr = cfg->def_attr;
         screen_size = cfg->win_width * (cfg->win_height + 1);
-        FillConsoleOutputAttribute(data->console, cfg->def_attr, screen_size, top_left, &written);
-        SetConsoleTextAttribute(data->console, cfg->def_attr);
+        FillConsoleOutputAttribute(data->hConOut, cfg->def_attr, screen_size, top_left, &written);
+        SetConsoleTextAttribute(data->hConOut, cfg->def_attr);
     }
     WINECON_SetColors(data, cfg);
     /* now let's look at the window / sb size changes...
@@ -436,13 +491,13 @@ void     WINECON_SetConfig(struct inner_data* data, const struct config_data* cf
 
 #define ChgSBfWidth()   do {c.X = cfg->sb_width; \
                             c.Y = data->curcfg.sb_height;\
-                            SetConsoleScreenBufferSize(data->console, c);\
+                            SetConsoleScreenBufferSize(data->hConOut, c);\
                         } while (0)
 #define ChgWinHPos()    do {pos.Left = cfg->win_pos.X - data->curcfg.win_pos.X; \
                             pos.Top = 0; \
                             pos.Right = pos.Left + cfg->win_width - data->curcfg.win_width; \
                             pos.Bottom = 0; \
-                            SetConsoleWindowInfo(data->console, FALSE, &pos);\
+                            SetConsoleWindowInfo(data->hConOut, FALSE, &pos);\
                         } while (0)
 #define TstSBfHeight()  (data->curcfg.sb_height != cfg->sb_height)
 #define TstWinVPos()    (data->curcfg.win_height != cfg->win_height || data->curcfg.win_pos.Y != cfg->win_pos.Y)
@@ -450,13 +505,13 @@ void     WINECON_SetConfig(struct inner_data* data, const struct config_data* cf
 /* since we're going to apply height after width is done, we use width as defined 
  * in cfg, and not in data->curcfg because if won't be updated yet */
 #define ChgSBfHeight()  do {c.X = cfg->sb_width; c.Y = cfg->sb_height; \
-                            SetConsoleScreenBufferSize(data->console, c); \
+                            SetConsoleScreenBufferSize(data->hConOut, c); \
                         } while (0)
 #define ChgWinVPos()    do {pos.Left = 0; \
                             pos.Top = cfg->win_pos.Y - data->curcfg.win_pos.Y; \
                             pos.Right = 0; \
                             pos.Bottom = pos.Top + cfg->win_height - data->curcfg.win_height; \
-                            SetConsoleWindowInfo(data->console, FALSE, &pos);\
+                            SetConsoleWindowInfo(data->hConOut, FALSE, &pos);\
                         } while (0)
 
     do
@@ -511,7 +566,7 @@ void     WINECON_SetConfig(struct inner_data* data, const struct config_data* cf
     if (data->curcfg.edition_mode != cfg->edition_mode)
     {
         data->curcfg.edition_mode = cfg->edition_mode;
-        WINECON_SetEditionMode(data->console, cfg->edition_mode);
+        WINECON_SetEditionMode(data->hConIn, cfg->edition_mode);
     }
     /* we now need to gather all events we got from the operations above,
      * in order to get data correctly updated
@@ -530,9 +585,10 @@ static void WINECON_Delete(struct inner_data* data)
     if (!data) return;
 
     if (data->fnDeleteBackend)  data->fnDeleteBackend(data);
-    if (data->console)		CloseHandle(data->console);
+    if (data->hConIn)		CloseHandle(data->hConIn);
+    if (data->hConOut)		CloseHandle(data->hConOut);
+    if (data->hSynchro)		CloseHandle(data->hSynchro);
     if (data->hProcess)         CloseHandle(data->hProcess);
-    if (data->overlapped.hEvent) CloseHandle(data->overlapped.hEvent);
     HeapFree(GetProcessHeap(), 0, data->curcfg.registry);
     HeapFree(GetProcessHeap(), 0, data->cells);
     HeapFree(GetProcessHeap(), 0, data);
@@ -547,81 +603,40 @@ static void WINECON_Delete(struct inner_data* data)
  */
 static BOOL WINECON_GetServerConfig(struct inner_data* data)
 {
-    struct condrv_input_info input_info;
-    struct condrv_output_info output_info;
+    BOOL  ret;
     DWORD mode;
 
-    if (!DeviceIoControl(data->console, IOCTL_CONDRV_GET_INPUT_INFO, NULL, 0,
-                         &input_info, sizeof(input_info), NULL, NULL))
-        return FALSE;
-    data->curcfg.history_size  = input_info.history_size;
-    data->curcfg.history_nodup = input_info.history_mode;
-    data->curcfg.edition_mode  = input_info.edition_mode;
+    SERVER_START_REQ(get_console_input_info)
+    {
+        req->handle = wine_server_obj_handle( data->hConIn );
+        ret = !wine_server_call_err( req );
+        data->curcfg.history_size = reply->history_size;
+        data->curcfg.history_nodup = reply->history_mode;
+        data->curcfg.edition_mode = reply->edition_mode;
+    }
+    SERVER_END_REQ;
+    if (!ret) return FALSE;
 
-    GetConsoleMode(data->console, &mode);
+    GetConsoleMode(data->hConIn, &mode);
     data->curcfg.insert_mode = (mode & (ENABLE_INSERT_MODE|ENABLE_EXTENDED_FLAGS)) ==
                                        (ENABLE_INSERT_MODE|ENABLE_EXTENDED_FLAGS);
 
-    if (!DeviceIoControl(data->console, IOCTL_CONDRV_GET_OUTPUT_INFO, NULL, 0,
-                         &output_info, sizeof(output_info), NULL, NULL))
-        return FALSE;
-    data->curcfg.cursor_size = output_info.cursor_size;
-    data->curcfg.cursor_visible = output_info.cursor_visible;
-    data->curcfg.def_attr = output_info.attr;
-    data->curcfg.sb_width = output_info.width;
-    data->curcfg.sb_height = output_info.height;
-    data->curcfg.win_width = output_info.win_right - output_info.win_left + 1;
-    data->curcfg.win_height = output_info.win_bottom - output_info.win_top + 1;
-
-    WINECON_DumpConfig("first cfg: ", &data->curcfg);
-    return TRUE;
-}
-
-/******************************************************************
- *		WINECON_Spawn
- *
- * Spawn the child process when invoked with wineconsole foo bar
- */
-static BOOL WINECON_Spawn(struct inner_data* data, LPWSTR cmdLine, HANDLE con_in, HANDLE con_out)
-{
-    PROCESS_INFORMATION info;
-    STARTUPINFOW        startup;
-    BOOL                done;
-
-    /* we're in the case wineconsole <exe> <options>... spawn the new process */
-    memset(&startup, 0, sizeof(startup));
-    startup.cb          = sizeof(startup);
-    startup.dwFlags     = STARTF_USESTDHANDLES;
-
-    /* the attributes of wineconsole's handles are not adequate for inheritance, so
-     * get them with the correct attributes before process creation
-     */
-    if (!DuplicateHandle(GetCurrentProcess(), con_in,  GetCurrentProcess(),
-			 &startup.hStdInput, GENERIC_READ|GENERIC_WRITE|SYNCHRONIZE, TRUE, 0) ||
-	!DuplicateHandle(GetCurrentProcess(), con_out, GetCurrentProcess(),
-			 &startup.hStdOutput, GENERIC_READ|GENERIC_WRITE, TRUE, 0) ||
-	!DuplicateHandle(GetCurrentProcess(), con_out, GetCurrentProcess(),
-                         &startup.hStdError, GENERIC_READ|GENERIC_WRITE, TRUE, 0))
+    SERVER_START_REQ(get_console_output_info)
     {
-	WINE_ERR("Can't dup handles\n");
-	/* no need to delete handles, we're exiting the program anyway */
-	return FALSE;
-    }
-
-    done = CreateProcessW(NULL, cmdLine, NULL, NULL, TRUE, 0L, NULL, NULL, &startup, &info);
-    if (done)
-    {
-        data->hProcess = info.hProcess;
-        CloseHandle(info.hThread);
+        req->handle = wine_server_obj_handle( data->hConOut );
+        ret = !wine_server_call_err( req );
+        data->curcfg.cursor_size = reply->cursor_size;
+        data->curcfg.cursor_visible = reply->cursor_visible;
+        data->curcfg.def_attr = reply->attr;
+        data->curcfg.sb_width = reply->width;
+        data->curcfg.sb_height = reply->height;
+        data->curcfg.win_width = reply->win_right - reply->win_left + 1;
+        data->curcfg.win_height = reply->win_bottom - reply->win_top + 1;
     }
-    else printf_res(IDS_CMD_LAUNCH_FAILED, wine_dbgstr_w(cmdLine));
-
-    /* we no longer need the handles passed to the child for the console */
-    CloseHandle(startup.hStdInput);
-    CloseHandle(startup.hStdOutput);
-    CloseHandle(startup.hStdError);
+    SERVER_END_REQ;
+    WINECON_DumpConfig("first cfg: ", &data->curcfg);
 
-    return done;
+    return ret;
 }
 
 /******************************************************************
@@ -632,23 +647,12 @@ static BOOL WINECON_Spawn(struct inner_data* data, LPWSTR cmdLine, HANDLE con_in
  */
 static struct inner_data* WINECON_Init(HINSTANCE hInst, DWORD pid, LPCWSTR appname,
                                        enum init_return (*backend)(struct inner_data*),
-                                       INT nCmdShow, WCHAR *cmdline)
+                                       INT nCmdShow)
 {
-    struct condrv_input_info_params input_params;
-    OBJECT_ATTRIBUTES attr = {sizeof(attr)};
     struct inner_data*	data = NULL;
     DWORD		ret;
     struct config_data  cfg;
     STARTUPINFOW        si;
-    UNICODE_STRING string;
-    IO_STATUS_BLOCK io;
-    condrv_handle_t h;
-    HANDLE con_in;
-    HANDLE con_out;
-    NTSTATUS status;
-
-    static const WCHAR renderer_pathW[] = {'\\','D','e','v','i','c','e','\\','C','o','n','D','r','v',
-        '\\','R','e','n','d','e','r','e','r',0};
 
     data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data));
     if (!data) return 0;
@@ -674,8 +678,6 @@ static struct inner_data* WINECON_Init(HINSTANCE hInst, DWORD pid, LPCWSTR appna
         /* should always be defined */
     }
 
-    if (!(data->overlapped.hEvent = CreateEventW(NULL, TRUE, TRUE, NULL))) goto error;
-
     /* the handles here are created without the whistles and bells required by console
      * (mainly because wineconsole doesn't need it)
      * - they are not inheritable
@@ -689,36 +691,26 @@ static struct inner_data* WINECON_Init(HINSTANCE hInst, DWORD pid, LPCWSTR appna
         req->input_fd   = -1;
 
         ret = !wine_server_call_err( req );
-        con_in = wine_server_ptr_handle( reply->handle_in );
+        data->hConIn = wine_server_ptr_handle( reply->handle_in );
+        data->hSynchro = wine_server_ptr_handle( reply->event );
     }
     SERVER_END_REQ;
     if (!ret) goto error;
-    WINE_TRACE("using con_in %p, renderer %p\n", con_in, data->console);
-
-    RtlInitUnicodeString(&string, renderer_pathW);
-    attr.ObjectName = &string;
-    status = NtCreateFile(&data->console, FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_PROPERTIES
-                          | FILE_READ_PROPERTIES | SYNCHRONIZE, &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
-                          0, FILE_OPEN, FILE_NON_DIRECTORY_FILE,  NULL, 0);
-    if (status) goto error;
-
-    h = condrv_handle(con_in);
-    if (!DeviceIoControl(data->console, IOCTL_CONDRV_ATTACH_RENDERER, &h, sizeof(h), NULL, 0, NULL, NULL))
-        goto error;
+    WINE_TRACE("using hConIn %p, hSynchro event %p\n", data->hConIn, data->hSynchro);
 
     SERVER_START_REQ(create_console_output)
     {
-        req->handle_in  = wine_server_obj_handle( con_in );
+        req->handle_in  = wine_server_obj_handle( data->hConIn );
         req->access     = GENERIC_WRITE|GENERIC_READ;
         req->attributes = 0;
         req->share      = FILE_SHARE_READ|FILE_SHARE_WRITE;
         req->fd         = -1;
         ret = !wine_server_call_err( req );
-        con_out         = wine_server_ptr_handle( reply->handle_out );
+        data->hConOut   = wine_server_ptr_handle( reply->handle_out );
     }
     SERVER_END_REQ;
     if (!ret) goto error;
-    WINE_TRACE("using con_out %p\n", con_out);
+    WINE_TRACE("using hConOut %p\n", data->hConOut);
 
     /* filling data->curcfg from cfg */
     switch ((*backend)(data))
@@ -743,24 +735,19 @@ static struct inner_data* WINECON_Init(HINSTANCE hInst, DWORD pid, LPCWSTR appna
         WINECON_SetConfig(data, &cfg);
         data->curcfg.registry = cfg.registry;
         WINECON_DumpConfig("fint", &data->curcfg);
-
-        memset(&input_params, 0, sizeof(input_params));
-        input_params.mask = SET_CONSOLE_INPUT_INFO_WIN;
-        input_params.info.win = condrv_handle(data->hWnd);
-        ret = DeviceIoControl(data->console, IOCTL_CONDRV_SET_INPUT_INFO, &input_params, sizeof(input_params),
-                              NULL, 0, NULL, NULL);
-        if (!ret) goto error;
-
-        ret = DeviceIoControl(data->console, IOCTL_CONDRV_SET_TITLE, (void *)appname,
-                              lstrlenW(appname) * sizeof(WCHAR), NULL, 0, NULL, NULL);
+        SERVER_START_REQ( set_console_input_info )
+        {
+            req->handle = wine_server_obj_handle( data->hConIn );
+            req->win = wine_server_user_handle( data->hWnd );
+            req->mask = SET_CONSOLE_INPUT_INFO_TITLE |
+                        SET_CONSOLE_INPUT_INFO_WIN;
+            wine_server_add_data( req, appname, lstrlenW(appname) * sizeof(WCHAR) );
+            ret = !wine_server_call_err( req );
+        }
+        SERVER_END_REQ;
         if (!ret) goto error;
 
-        if (cmdline && !WINECON_Spawn(data, cmdline, con_in, con_out)) goto error;
-
-        CloseHandle(con_in);
-        CloseHandle(con_out);
         return data;
-
     case init_failed:
         break;
     }
@@ -772,6 +759,52 @@ static struct inner_data* WINECON_Init(HINSTANCE hInst, DWORD pid, LPCWSTR appna
     return NULL;
 }
 
+/******************************************************************
+ *		WINECON_Spawn
+ *
+ * Spawn the child process when invoked with wineconsole foo bar
+ */
+static int WINECON_Spawn(struct inner_data* data, LPWSTR cmdLine)
+{
+    PROCESS_INFORMATION info;
+    STARTUPINFOW        startup;
+    BOOL                done;
+
+    /* we're in the case wineconsole <exe> <options>... spawn the new process */
+    memset(&startup, 0, sizeof(startup));
+    startup.cb          = sizeof(startup);
+    startup.dwFlags     = STARTF_USESTDHANDLES;
+
+    /* the attributes of wineconsole's handles are not adequate for inheritance, so
+     * get them with the correct attributes before process creation
+     */
+    if (!DuplicateHandle(GetCurrentProcess(), data->hConIn,  GetCurrentProcess(),
+			 &startup.hStdInput, GENERIC_READ|GENERIC_WRITE|SYNCHRONIZE, TRUE, 0) ||
+	!DuplicateHandle(GetCurrentProcess(), data->hConOut, GetCurrentProcess(),
+			 &startup.hStdOutput, GENERIC_READ|GENERIC_WRITE, TRUE, 0) ||
+	!DuplicateHandle(GetCurrentProcess(), data->hConOut, GetCurrentProcess(),
+                         &startup.hStdError, GENERIC_READ|GENERIC_WRITE, TRUE, 0))
+    {
+	WINE_ERR("Can't dup handles\n");
+	/* no need to delete handles, we're exiting the program anyway */
+	return 1;
+    }
+
+    done = CreateProcessW(NULL, cmdLine, NULL, NULL, TRUE, 0L, NULL, NULL, &startup, &info);
+    if (done)
+    {
+        data->hProcess = info.hProcess;
+        CloseHandle(info.hThread);
+    }
+
+    /* we no longer need the handles passed to the child for the console */
+    CloseHandle(startup.hStdInput);
+    CloseHandle(startup.hStdOutput);
+    CloseHandle(startup.hStdError);
+
+    return !done;
+}
+
 struct wc_init {
     LPCSTR              ptr;
     enum {from_event, from_process_name} mode;
@@ -865,7 +898,7 @@ int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, INT nCmdSh
     {
     case from_event:
         /* case of wineconsole <evt>, signal process that created us that we're up and running */
-        if (!(data = WINECON_Init(hInst, 0, NULL, wci.backend, nCmdShow, NULL))) return 1;
+        if (!(data = WINECON_Init(hInst, 0, NULL, wci.backend, nCmdShow))) return 1;
         ret = !SetEvent(wci.event);
         if (ret != 0) WINE_ERR("SetEvent failed.\n");
         break;
@@ -882,9 +915,19 @@ int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, INT nCmdSh
 
             MultiByteToWideChar(CP_ACP, 0, wci.ptr, -1, buffer, len);
 
-            data = WINECON_Init(hInst, GetCurrentProcessId(), buffer, wci.backend, nCmdShow, buffer);
+            if (!(data = WINECON_Init(hInst, GetCurrentProcessId(), buffer, wci.backend, nCmdShow)))
+            {
+                HeapFree(GetProcessHeap(), 0, buffer);
+                return 1;
+            }
+            ret = WINECON_Spawn(data, buffer);
             HeapFree(GetProcessHeap(), 0, buffer);
-            if (!data) return 1;
+            if (ret != 0)
+            {
+                WINECON_Delete(data);
+                printf_res(IDS_CMD_LAUNCH_FAILED, wine_dbgstr_a(wci.ptr));
+                return ret;
+            }
         }
         break;
     default:
diff --git a/server/Makefile.in b/server/Makefile.in
index e90c5d1336..3f3761faab 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -33,6 +33,7 @@ C_SRCS = \
 	semaphore.c \
 	serial.c \
 	signal.c \
+	snapshot.c \
 	sock.c \
 	symlink.c \
 	thread.c \
diff --git a/server/console.c b/server/console.c
index 59a2794e01..302be6a1c1 100644
--- a/server/console.c
+++ b/server/console.c
@@ -38,7 +38,6 @@
 #include "unicode.h"
 #include "wincon.h"
 #include "winternl.h"
-#include "wine/condrv.h"
 
 struct screen_buffer;
 struct console_input_events;
@@ -71,14 +70,11 @@ struct console_input
     user_handle_t                win;           /* window handle if backend supports it */
     struct event                *event;         /* event to wait on for input queue */
     struct fd                   *fd;            /* for bare console, attached input fd */
-    struct async_queue           read_q;        /* read queue */
 };
 
 static void console_input_dump( struct object *obj, int verbose );
 static void console_input_destroy( struct object *obj );
 static struct fd *console_input_get_fd( struct object *obj );
-static struct object *console_input_open_file( struct object *obj, unsigned int access,
-                                               unsigned int sharing, unsigned int options );
 
 static const struct object_ops console_input_ops =
 {
@@ -97,45 +93,22 @@ static const struct object_ops console_input_ops =
     no_lookup_name,                   /* lookup_name */
     no_link_name,                     /* link_name */
     NULL,                             /* unlink_name */
-    console_input_open_file,          /* open_file */
+    no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
 
-static enum server_fd_type console_get_fd_type( struct fd *fd );
-static int console_input_ioctl( struct fd *fd, ioctl_code_t code, struct async *async );
-
-static const struct fd_ops console_input_fd_ops =
-{
-    default_fd_get_poll_events,   /* get_poll_events */
-    default_poll_event,           /* poll_event */
-    console_get_fd_type,          /* get_fd_type */
-    no_fd_read,                   /* read */
-    no_fd_write,                  /* write */
-    no_fd_flush,                  /* flush */
-    no_fd_get_file_info,          /* get_file_info */
-    no_fd_get_volume_info,        /* get_volume_info */
-    console_input_ioctl,          /* ioctl */
-    default_fd_queue_async,       /* queue_async */
-    default_fd_reselect_async     /* reselect_async */
-};
-
 static void console_input_events_dump( struct object *obj, int verbose );
 static void console_input_events_destroy( struct object *obj );
-static struct fd *console_input_events_get_fd( struct object *obj );
-static struct object *console_input_events_open_file( struct object *obj, unsigned int access,
-                                                      unsigned int sharing, unsigned int options );
+static int console_input_events_signaled( struct object *obj, struct wait_queue_entry *entry );
 
 struct console_input_events
 {
-    struct object                  obj;         /* object header */
-    struct fd                     *fd;          /* pseudo-fd for ioctls */
-    struct console_input          *console;     /* attached console */
-    int                            num_alloc;   /* number of allocated events */
-    int                            num_used;    /* number of actually used events */
-    struct condrv_renderer_event  *events;
-    struct async_queue             read_q;      /* read queue */
+    struct object         obj;         /* object header */
+    int			  num_alloc;   /* number of allocated events */
+    int 		  num_used;    /* number of actually used events */
+    struct console_renderer_event*	events;
 };
 
 static const struct object_ops console_input_events_ops =
@@ -145,39 +118,22 @@ static const struct object_ops console_input_events_ops =
     no_get_type,                      /* get_type */
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
-    NULL,                             /* signaled */
+    console_input_events_signaled,    /* signaled */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
-    console_input_events_get_fd,      /* get_fd */
+    no_get_fd,                        /* get_fd */
     default_fd_map_access,            /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
     no_lookup_name,                   /* lookup_name */
     no_link_name,                     /* link_name */
     NULL,                             /* unlink_name */
-    console_input_events_open_file,   /* open_file */
+    no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
     no_close_handle,                  /* close_handle */
     console_input_events_destroy      /* destroy */
 };
 
-static int console_input_events_ioctl( struct fd *fd, ioctl_code_t code, struct async *async );
-
-static const struct fd_ops console_input_events_fd_ops =
-{
-    default_fd_get_poll_events,   /* get_poll_events */
-    default_poll_event,           /* poll_event */
-    console_get_fd_type,          /* get_fd_type */
-    no_fd_read,                   /* read */
-    no_fd_write,                  /* write */
-    no_fd_flush,                  /* flush */
-    no_fd_get_file_info,          /* get_file_info */
-    no_fd_get_volume_info,        /* get_volume_info */
-    console_input_events_ioctl,   /* ioctl */
-    default_fd_queue_async,       /* queue_async */
-    default_fd_reselect_async     /* reselect_async */
-};
-
 struct font_info
 {
     short int width;
@@ -193,7 +149,7 @@ struct screen_buffer
     struct object         obj;           /* object header */
     struct list           entry;         /* entry in list of all screen buffers */
     struct console_input *input;         /* associated console input */
-    unsigned int          mode;          /* output mode */
+    int                   mode;          /* output mode */
     int                   cursor_size;   /* size of cursor (percentage filled) */
     int                   cursor_visible;/* cursor visibility flag */
     int                   cursor_x;      /* position of cursor */
@@ -215,8 +171,6 @@ struct screen_buffer
 static void screen_buffer_dump( struct object *obj, int verbose );
 static void screen_buffer_destroy( struct object *obj );
 static struct fd *screen_buffer_get_fd( struct object *obj );
-static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
-                                               unsigned int sharing, unsigned int options );
 
 static const struct object_ops screen_buffer_ops =
 {
@@ -235,15 +189,15 @@ static const struct object_ops screen_buffer_ops =
     no_lookup_name,                   /* lookup_name */
     no_link_name,                     /* link_name */
     NULL,                             /* unlink_name */
-    screen_buffer_open_file,          /* open_file */
+    no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
 
-static int screen_buffer_ioctl( struct fd *fd, ioctl_code_t code, struct async *async );
+static enum server_fd_type console_get_fd_type( struct fd *fd );
 
-static const struct fd_ops screen_buffer_fd_ops =
+static const struct fd_ops console_fd_ops =
 {
     default_fd_get_poll_events,   /* get_poll_events */
     default_poll_event,           /* poll_event */
@@ -253,40 +207,11 @@ static const struct fd_ops screen_buffer_fd_ops =
     no_fd_flush,                  /* flush */
     no_fd_get_file_info,          /* get_file_info */
     no_fd_get_volume_info,        /* get_volume_info */
-    screen_buffer_ioctl,          /* ioctl */
+    default_fd_ioctl,             /* ioctl */
     default_fd_queue_async,       /* queue_async */
     default_fd_reselect_async     /* reselect_async */
 };
 
-static struct object_type *console_device_get_type( struct object *obj );
-static void console_device_dump( struct object *obj, int verbose );
-static struct object *console_device_lookup_name( struct object *obj, struct unicode_str *name, unsigned int attr );
-static struct object *console_device_open_file( struct object *obj, unsigned int access,
-                                                unsigned int sharing, unsigned int options );
-
-static const struct object_ops console_device_ops =
-{
-    sizeof(struct object),            /* size */
-    console_device_dump,              /* dump */
-    console_device_get_type,          /* get_type */
-    no_add_queue,                     /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    no_satisfied,                     /* satisfied */
-    no_signal,                        /* signal */
-    no_get_fd,                        /* get_fd */
-    default_fd_map_access,            /* map_access */
-    default_get_sd,                   /* get_sd */
-    default_set_sd,                   /* set_sd */
-    console_device_lookup_name,       /* lookup_name */
-    directory_link_name,              /* link_name */
-    default_unlink_name,              /* unlink_name */
-    console_device_open_file,         /* open_file */
-    no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_close_handle,                  /* close_handle */
-    no_destroy                        /* destroy */
-};
-
 static struct list screen_buffer_list = LIST_INIT(screen_buffer_list);
 
 static const char_info_t empty_char_info = { ' ', 0x000f };  /* white on black space */
@@ -300,7 +225,10 @@ static struct fd *console_input_get_fd( struct object* obj )
 {
     struct console_input *console_input = (struct console_input*)obj;
     assert( obj->ops == &console_input_ops );
-    return (struct fd *)grab_object( console_input->fd );
+    if (console_input->fd)
+        return (struct fd*)grab_object( console_input->fd );
+    set_error( STATUS_OBJECT_TYPE_MISMATCH );
+    return NULL;
 }
 
 static enum server_fd_type console_get_fd_type( struct fd *fd )
@@ -322,61 +250,23 @@ static void console_input_events_destroy( struct object *obj )
 {
     struct console_input_events *evts = (struct console_input_events *)obj;
     assert( obj->ops == &console_input_events_ops );
-    if (evts->console) evts->console->evt = NULL;
-    free_async_queue( &evts->read_q );
-    if (evts->fd) release_object( evts->fd );
     free( evts->events );
 }
 
-static struct fd *console_input_events_get_fd( struct object* obj )
+/* the renderer events list is signaled when it's not empty */
+static int console_input_events_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
-    struct console_input_events *evts = (struct console_input_events*)obj;
+    struct console_input_events *evts = (struct console_input_events *)obj;
     assert( obj->ops == &console_input_events_ops );
-    return (struct fd*)grab_object( evts->fd );
-}
-
-static struct object *console_input_events_open_file( struct object *obj, unsigned int access,
-                                                      unsigned int sharing, unsigned int options )
-{
-    return grab_object( obj );
-}
-
-/* retrieves events from the console's renderer events list */
-static int get_renderer_events( struct console_input_events* evts, struct async *async )
-{
-    struct iosb *iosb = async_get_iosb( async );
-    data_size_t num;
-
-    num = min( iosb->out_size / sizeof(evts->events[0]), evts->num_used );
-    if (num && !(iosb->out_data = malloc( num * sizeof(evts->events[0] ))))
-    {
-        async_terminate( async, STATUS_NO_MEMORY );
-        release_object( iosb );
-        return 0;
-    }
-
-    iosb->status = STATUS_SUCCESS;
-    iosb->out_size = iosb->result = num * sizeof(evts->events[0]);
-    if (num) memcpy( iosb->out_data, evts->events, iosb->result );
-    release_object( iosb );
-    async_terminate( async, STATUS_ALERTED );
-
-    if (num && num < evts->num_used)
-    {
-        memmove( &evts->events[0], &evts->events[num],
-                 (evts->num_used - num) * sizeof(evts->events[0]) );
-    }
-    evts->num_used -= num;
-    return 1;
+    return (evts->num_used != 0);
 }
 
 /* add an event to the console's renderer events list */
 static void console_input_events_append( struct console_input* console,
-					 struct condrv_renderer_event* evt)
+					 struct console_renderer_event* evt)
 {
     struct console_input_events* evts;
     int collapsed = FALSE;
-    struct async *async;
 
     if (!(evts = console->evt)) return;
     /* to be done even when evt has been generated by the renderer ? */
@@ -384,7 +274,7 @@ static void console_input_events_append( struct console_input* console,
     /* try to collapse evt into current queue's events */
     if (evts->num_used)
     {
-        struct condrv_renderer_event* last = &evts->events[evts->num_used - 1];
+        struct console_renderer_event* last = &evts->events[evts->num_used - 1];
 
         if (last->event == CONSOLE_RENDERER_UPDATE_EVENT &&
             evt->event == CONSOLE_RENDERER_UPDATE_EVENT)
@@ -409,31 +299,35 @@ static void console_input_events_append( struct console_input* console,
         }
         evts->events[evts->num_used++] = *evt;
     }
-    while (evts->num_used && (async = find_pending_async( &evts->read_q )))
+    wake_up( &evts->obj, 0 );
+}
+
+/* retrieves events from the console's renderer events list */
+static void console_input_events_get( struct console_input_events* evts )
+{
+    data_size_t num = get_reply_max_size() / sizeof(evts->events[0]);
+
+    if (num > evts->num_used) num = evts->num_used;
+    set_reply_data( evts->events, num * sizeof(evts->events[0]) );
+    if (num < evts->num_used)
     {
-        get_renderer_events( evts, async );
-        release_object( async );
+        memmove( &evts->events[0], &evts->events[num],
+                 (evts->num_used - num) * sizeof(evts->events[0]) );
     }
+    evts->num_used -= num;
 }
 
-static struct object *create_console_input_events(void)
+static struct console_input_events *create_console_input_events(void)
 {
     struct console_input_events*	evt;
 
     if (!(evt = alloc_object( &console_input_events_ops ))) return NULL;
-    evt->console = NULL;
     evt->num_alloc = evt->num_used = 0;
     evt->events = NULL;
-    init_async_queue( &evt->read_q );
-    if (!(evt->fd = alloc_pseudo_fd( &console_input_events_fd_ops, &evt->obj, 0 )))
-    {
-        release_object( evt );
-        return NULL;
-    }
-    return &evt->obj;
+    return evt;
 }
 
-static struct object *create_console_input( int fd )
+static struct object *create_console_input( struct thread* renderer, int fd )
 {
     struct console_input *console_input;
 
@@ -442,7 +336,7 @@ static struct object *create_console_input( int fd )
         if (fd != -1) close( fd );
         return NULL;
     }
-    console_input->renderer      = NULL;
+    console_input->renderer      = renderer;
     console_input->mode          = ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT |
                                    ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT | ENABLE_INSERT_MODE |
                                    ENABLE_EXTENDED_FLAGS;
@@ -450,7 +344,7 @@ static struct object *create_console_input( int fd )
     console_input->active        = NULL;
     console_input->recnum        = 0;
     console_input->records       = NULL;
-    console_input->evt           = NULL;
+    console_input->evt           = renderer ? create_console_input_events() : NULL;
     console_input->title         = NULL;
     console_input->title_len     = 0;
     console_input->history_size  = 50;
@@ -463,9 +357,8 @@ static struct object *create_console_input( int fd )
     console_input->win           = 0;
     console_input->event         = create_event( NULL, NULL, 0, 1, 0, NULL );
     console_input->fd            = NULL;
-    init_async_queue( &console_input->read_q );
 
-    if (!console_input->history || !console_input->event)
+    if (!console_input->history || (renderer && !console_input->evt) || !console_input->event)
     {
         if (fd != -1) close( fd );
         console_input->history_size = 0;
@@ -474,27 +367,26 @@ static struct object *create_console_input( int fd )
     }
     if (fd != -1) /* bare console */
     {
-        console_input->fd = create_anonymous_fd( &console_input_fd_ops, fd, &console_input->obj,
-                                                 FILE_SYNCHRONOUS_IO_NONALERT );
-    }
-    else
-    {
-        console_input->fd = alloc_pseudo_fd( &console_input_fd_ops, &console_input->obj,
-                                             FILE_SYNCHRONOUS_IO_NONALERT );
-    }
-    if (!console_input->fd)
-    {
-        release_object( console_input );
-        return NULL;
+        if (!(console_input->fd = create_anonymous_fd( &console_fd_ops, fd, &console_input->obj,
+                                                       FILE_SYNCHRONOUS_IO_NONALERT )))
+        {
+            release_object( console_input );
+            return NULL;
+        }
+        allow_fd_caching( console_input->fd );
     }
-    allow_fd_caching( console_input->fd );
+
     return &console_input->obj;
 }
 
 static void generate_sb_initial_events( struct console_input *console_input )
 {
     struct screen_buffer *screen_buffer = console_input->active;
-    struct condrv_renderer_event evt;
+    struct console_renderer_event evt;
+
+    evt.event = CONSOLE_RENDERER_ACTIVE_SB_EVENT;
+    memset(&evt.u, 0, sizeof(evt.u));
+    console_input_events_append( console_input, &evt );
 
     evt.event = CONSOLE_RENDERER_SB_RESIZE_EVENT;
     evt.u.resize.width  = screen_buffer->width;
@@ -524,7 +416,7 @@ static void generate_sb_initial_events( struct console_input *console_input )
     console_input_events_append( console_input, &evt );
 }
 
-static struct object *create_console_output( struct console_input *console_input, int fd )
+static struct screen_buffer *create_console_output( struct console_input *console_input, int fd )
 {
     struct screen_buffer *screen_buffer;
     int	i;
@@ -560,18 +452,18 @@ static struct object *create_console_output( struct console_input *console_input
     memset( screen_buffer->color_map, 0, sizeof(screen_buffer->color_map) );
     list_add_head( &screen_buffer_list, &screen_buffer->entry );
 
-    if (fd != -1)
-        screen_buffer->fd = create_anonymous_fd( &screen_buffer_fd_ops, fd, &screen_buffer->obj,
-                                                 FILE_SYNCHRONOUS_IO_NONALERT );
+    if (fd == -1)
+        screen_buffer->fd = NULL;
     else
-        screen_buffer->fd = alloc_pseudo_fd( &screen_buffer_fd_ops, &screen_buffer->obj,
-                                             FILE_SYNCHRONOUS_IO_NONALERT );
-    if (!screen_buffer->fd)
     {
-        release_object( screen_buffer );
-        return NULL;
+        if (!(screen_buffer->fd = create_anonymous_fd( &console_fd_ops, fd, &screen_buffer->obj,
+                                                       FILE_SYNCHRONOUS_IO_NONALERT )))
+        {
+            release_object( screen_buffer );
+            return NULL;
+        }
+        allow_fd_caching(screen_buffer->fd);
     }
-    allow_fd_caching(screen_buffer->fd);
 
     if (!(screen_buffer->data = malloc( screen_buffer->width * screen_buffer->height *
                                         sizeof(*screen_buffer->data) )))
@@ -591,7 +483,7 @@ static struct object *create_console_output( struct console_input *console_input
 	console_input->active = (struct screen_buffer*)grab_object( screen_buffer );
         generate_sb_initial_events( console_input );
     }
-    return &screen_buffer->obj;
+    return screen_buffer;
 }
 
 /* free the console for this process */
@@ -605,7 +497,7 @@ int free_console( struct process *process )
     if (--console->num_proc == 0 && console->renderer)
     {
 	/* all processes have terminated... tell the renderer to terminate too */
-	struct condrv_renderer_event evt;
+	struct console_renderer_event evt;
 	evt.event = CONSOLE_RENDERER_EXIT_EVENT;
         memset(&evt.u, 0, sizeof(evt.u));
 	console_input_events_append( console, &evt );
@@ -620,8 +512,8 @@ int free_console( struct process *process )
  *	2/ parent is a renderer which launches process, and process should attach to the console
  *	   rendered by parent
  */
-obj_handle_t inherit_console( struct thread *parent_thread, struct process *parent, struct process *process,
-                              obj_handle_t hconin )
+void inherit_console( struct thread *parent_thread, struct process *parent, struct process *process,
+                      obj_handle_t hconin )
 {
     int done = 0;
 
@@ -652,10 +544,6 @@ obj_handle_t inherit_console( struct thread *parent_thread, struct process *pare
         process->console = (struct console_input *)grab_object( parent->console );
         process->console->num_proc++;
     }
-
-    if (!process->console) return 0;
-    return alloc_handle( process, process->console,
-                         SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, 0 );
 }
 
 struct thread *console_get_renderer( struct console_input *console )
@@ -726,53 +614,50 @@ static void propagate_console_signal( struct console_input *console,
     enum_processes(propagate_console_signal_cb, &csi);
 }
 
-/* retrieve a pointer to the console input records */
-static int read_console_input( struct console_input *console, struct async *async, int flush )
+static int get_console_mode( obj_handle_t handle )
 {
-    struct iosb *iosb = async_get_iosb( async );
-    data_size_t count;
+    struct object *obj;
+    int ret = 0;
 
-    count = min( iosb->out_size / sizeof(INPUT_RECORD), console->recnum );
-    if (count)
+    if ((obj = get_handle_obj( current->process, handle, FILE_READ_PROPERTIES, NULL )))
     {
-        if (!(iosb->out_data = malloc( count * sizeof(INPUT_RECORD) )))
+        if (obj->ops == &console_input_ops)
         {
-            set_error( STATUS_NO_MEMORY );
-            release_object( iosb );
-            return 0;
+            ret = ((struct console_input *)obj)->mode;
         }
-        iosb->out_size = iosb->result = count * sizeof(INPUT_RECORD);
-        memcpy( iosb->out_data, console->records, iosb->result );
-        iosb->status = STATUS_SUCCESS;
-        async_terminate( async, STATUS_ALERTED );
-    }
-    else
-    {
-        async_terminate( async, STATUS_SUCCESS );
-    }
-
-    release_object( iosb );
-
-    if (flush && count)
-    {
-        if (console->recnum > count)
+        else if (obj->ops == &screen_buffer_ops)
         {
-            INPUT_RECORD *new_rec;
-            memmove( console->records, console->records + count, (console->recnum - count) * sizeof(*console->records) );
-            console->recnum -= count;
-            new_rec = realloc( console->records, console->recnum * sizeof(*console->records) );
-            if (new_rec) console->records = new_rec;
+            ret = ((struct screen_buffer *)obj)->mode;
         }
         else
-        {
-            console->recnum = 0;
-            free( console->records );
-            console->records = NULL;
-            reset_event( console->event );
-        }
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+        release_object( obj );
     }
+    return ret;
+}
 
-    return 1;
+/* changes the mode of either a console input or a screen buffer */
+static int set_console_mode( obj_handle_t handle, int mode )
+{
+    struct object *obj;
+    int ret = 0;
+
+    if (!(obj = get_handle_obj( current->process, handle, FILE_WRITE_PROPERTIES, NULL )))
+        return 0;
+    if (obj->ops == &console_input_ops)
+    {
+	/* FIXME: if we remove the edit mode bits, we need (???) to clean up the history */
+        ((struct console_input *)obj)->mode = mode;
+        ret = 1;
+    }
+    else if (obj->ops == &screen_buffer_ops)
+    {
+        ((struct screen_buffer *)obj)->mode = mode;
+        ret = 1;
+    }
+    else set_error( STATUS_OBJECT_TYPE_MISMATCH );
+    release_object( obj );
+    return ret;
 }
 
 /* add input events to a console input queue */
@@ -780,14 +665,13 @@ static int write_console_input( struct console_input* console, int count,
                                 const INPUT_RECORD *records )
 {
     INPUT_RECORD *new_rec;
-    struct async *async;
 
-    if (!count) return 1;
+    if (!count) return 0;
     if (!(new_rec = realloc( console->records,
                              (console->recnum + count) * sizeof(INPUT_RECORD) )))
     {
         set_error( STATUS_NO_MEMORY );
-        return 0;
+        return -1;
     }
     console->records = new_rec;
     memcpy( new_rec + console->recnum, records, count * sizeof(INPUT_RECORD) );
@@ -815,14 +699,51 @@ static int write_console_input( struct console_input* console, int count,
             else i++;
         }
     }
+    if (!console->recnum && count) set_event( console->event );
     console->recnum += count;
-    while (console->recnum && (async = find_pending_async( &console->read_q )))
+    return count;
+}
+
+/* retrieve a pointer to the console input records */
+static int read_console_input( obj_handle_t handle, int count, int flush )
+{
+    struct console_input *console;
+
+    if (!(console = (struct console_input *)get_handle_obj( current->process, handle,
+                                                            FILE_READ_DATA, &console_input_ops )))
+        return -1;
+
+    if (!count)
     {
-        read_console_input( console, async, 1 );
-        release_object( async );
+        /* special case: do not retrieve anything, but return
+         * the total number of records available */
+        count = console->recnum;
     }
-    if (console->recnum) set_event( console->event );
-    return 1;
+    else
+    {
+        if (count > console->recnum) count = console->recnum;
+        set_reply_data( console->records, count * sizeof(INPUT_RECORD) );
+    }
+    if (flush)
+    {
+        int i;
+        for (i = count; i < console->recnum; i++)
+            console->records[i-count] = console->records[i];
+        if ((console->recnum -= count) > 0)
+        {
+            INPUT_RECORD *new_rec = realloc( console->records,
+                                             console->recnum * sizeof(INPUT_RECORD) );
+            if (new_rec) console->records = new_rec;
+        }
+        else
+        {
+            free( console->records );
+            console->records = NULL;
+            reset_event( console->event );
+        }
+    }
+    release_object( console );
+    return count;
 }
 
 /* set misc console input information */
@@ -830,16 +751,40 @@ static int set_console_input_info( const struct set_console_input_info_request *
 				   const WCHAR *title, data_size_t len )
 {
     struct console_input *console;
-    struct condrv_renderer_event evt;
+    struct console_renderer_event evt;
 
     if (!(console = console_input_get( req->handle, FILE_WRITE_PROPERTIES ))) goto error;
-    if (console_input_is_bare(console) && (req->mask & SET_CONSOLE_INPUT_INFO_WIN))
+    if (console_input_is_bare(console) &&
+        (req->mask & (SET_CONSOLE_INPUT_INFO_ACTIVE_SB|
+                      SET_CONSOLE_INPUT_INFO_WIN)))
     {
         set_error( STATUS_UNSUCCESSFUL );
         goto error;
     }
 
     memset(&evt.u, 0, sizeof(evt.u));
+    if (req->mask & SET_CONSOLE_INPUT_INFO_ACTIVE_SB)
+    {
+	struct screen_buffer *screen_buffer;
+
+	screen_buffer = (struct screen_buffer *)get_handle_obj( current->process, req->active_sb,
+								FILE_WRITE_PROPERTIES, &screen_buffer_ops );
+	if (!screen_buffer || screen_buffer->input != console)
+	{
+	    set_error( STATUS_INVALID_HANDLE );
+	    if (screen_buffer) release_object( screen_buffer );
+	    goto error;
+	}
+
+	if (screen_buffer != console->active)
+	{
+	    if (console->active) release_object( console->active );
+	    console->active = screen_buffer;
+	    generate_sb_initial_events( console );
+	}
+	else
+	    release_object( screen_buffer );
+    }
     if (req->mask & SET_CONSOLE_INPUT_INFO_TITLE)
     {
         WCHAR *new_title = NULL;
@@ -852,6 +797,42 @@ static int set_console_input_info( const struct set_console_input_info_request *
         evt.event = CONSOLE_RENDERER_TITLE_EVENT;
         console_input_events_append( console, &evt );
     }
+    if (req->mask & SET_CONSOLE_INPUT_INFO_HISTORY_MODE)
+    {
+	console->history_mode = req->history_mode;
+    }
+    if ((req->mask & SET_CONSOLE_INPUT_INFO_HISTORY_SIZE) &&
+	console->history_size != req->history_size)
+    {
+	struct history_line **mem = NULL;
+	int i, delta;
+
+	if (req->history_size)
+	{
+	    if (!(mem = mem_alloc( req->history_size * sizeof(*mem) ))) goto error;
+	    memset( mem, 0, req->history_size * sizeof(*mem) );
+	}
+
+	delta = (console->history_index > req->history_size) ?
+	    (console->history_index - req->history_size) : 0;
+
+	for (i = delta; i < console->history_index; i++)
+	{
+	    mem[i - delta] = console->history[i];
+	    console->history[i] = NULL;
+	}
+	console->history_index -= delta;
+
+	for (i = 0; i < console->history_size; i++)
+	    free( console->history[i] );
+	free( console->history );
+	console->history = mem;
+	console->history_size = req->history_size;
+    }
+    if (req->mask & SET_CONSOLE_INPUT_INFO_EDITION_MODE)
+    {
+        console->edition_mode = req->edition_mode;
+    }
     if (req->mask & SET_CONSOLE_INPUT_INFO_INPUT_CODEPAGE)
     {
         console->input_cp = req->input_cp;
@@ -860,6 +841,10 @@ static int set_console_input_info( const struct set_console_input_info_request *
     {
         console->output_cp = req->output_cp;
     }
+    if (req->mask & SET_CONSOLE_INPUT_INFO_WIN)
+    {
+        console->win = req->win;
+    }
     release_object( console );
     return 1;
  error:
@@ -919,180 +904,177 @@ static int change_screen_buffer_size( struct screen_buffer *screen_buffer,
     return 1;
 }
 
-static int set_output_info( struct screen_buffer *screen_buffer,
-                            const struct condrv_output_info_params *params, data_size_t extra_size )
+/* set misc screen buffer information */
+static int set_console_output_info( struct screen_buffer *screen_buffer,
+                                    const struct set_console_output_info_request *req )
 {
-    const struct condrv_output_info *info = &params->info;
-    struct condrv_renderer_event evt;
+    struct console_renderer_event evt;
+    data_size_t font_name_len, offset;
     WCHAR *font_name;
 
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_CURSOR_GEOM)
-    {
-        if (info->cursor_size < 1 || info->cursor_size > 100)
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        if (screen_buffer->cursor_size != info->cursor_size ||
-            screen_buffer->cursor_visible != info->cursor_visible)
-        {
-            screen_buffer->cursor_size    = info->cursor_size;
-            screen_buffer->cursor_visible = info->cursor_visible;
-            evt.event = CONSOLE_RENDERER_CURSOR_GEOM_EVENT;
-            memset( &evt.u, 0, sizeof(evt.u) );
-            evt.u.cursor_geom.size    = info->cursor_size;
-            evt.u.cursor_geom.visible = info->cursor_visible;
-            console_input_events_append( screen_buffer->input, &evt );
-        }
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_CURSOR_POS)
-    {
-        if (info->cursor_x < 0 || info->cursor_x >= screen_buffer->width ||
-            info->cursor_y < 0 || info->cursor_y >= screen_buffer->height)
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        if (screen_buffer->cursor_x != info->cursor_x || screen_buffer->cursor_y != info->cursor_y)
-        {
-            screen_buffer->cursor_x       = info->cursor_x;
-            screen_buffer->cursor_y       = info->cursor_y;
-            evt.event = CONSOLE_RENDERER_CURSOR_POS_EVENT;
-            memset( &evt.u, 0, sizeof(evt.u) );
-            evt.u.cursor_pos.x = info->cursor_x;
-            evt.u.cursor_pos.y = info->cursor_y;
-            console_input_events_append( screen_buffer->input, &evt );
-        }
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_SIZE)
+    memset(&evt.u, 0, sizeof(evt.u));
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_CURSOR_GEOM)
+    {
+	if (req->cursor_size < 1 || req->cursor_size > 100)
+	{
+	    set_error( STATUS_INVALID_PARAMETER );
+	    return 0;
+	}
+        if (screen_buffer->cursor_size != req->cursor_size ||
+	    screen_buffer->cursor_visible != req->cursor_visible)
+	{
+	    screen_buffer->cursor_size    = req->cursor_size;
+	    screen_buffer->cursor_visible = req->cursor_visible;
+	    evt.event = CONSOLE_RENDERER_CURSOR_GEOM_EVENT;
+	    evt.u.cursor_geom.size    = req->cursor_size;
+	    evt.u.cursor_geom.visible = req->cursor_visible;
+	    console_input_events_append( screen_buffer->input, &evt );
+	}
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_CURSOR_POS)
+    {
+	if (req->cursor_x < 0 || req->cursor_x >= screen_buffer->width ||
+	    req->cursor_y < 0 || req->cursor_y >= screen_buffer->height)
+	{
+	    set_error( STATUS_INVALID_PARAMETER );
+	    return 0;
+	}
+	if (screen_buffer->cursor_x != req->cursor_x || screen_buffer->cursor_y != req->cursor_y)
+	{
+	    screen_buffer->cursor_x       = req->cursor_x;
+	    screen_buffer->cursor_y       = req->cursor_y;
+	    evt.event = CONSOLE_RENDERER_CURSOR_POS_EVENT;
+	    evt.u.cursor_pos.x = req->cursor_x;
+	    evt.u.cursor_pos.y = req->cursor_y;
+	    console_input_events_append( screen_buffer->input, &evt );
+	}
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_SIZE)
     {
         unsigned cc;
 
         /* new screen-buffer cannot be smaller than actual window */
-        if (info->width < screen_buffer->win.right - screen_buffer->win.left + 1 ||
-            info->height < screen_buffer->win.bottom - screen_buffer->win.top + 1)
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
+	if (req->width < screen_buffer->win.right - screen_buffer->win.left + 1 ||
+            req->height < screen_buffer->win.bottom - screen_buffer->win.top + 1)
+	{
+	    set_error( STATUS_INVALID_PARAMETER );
+	    return 0;
+	}
         /* FIXME: there are also some basic minimum and max size to deal with */
-        if (!change_screen_buffer_size( screen_buffer, info->width, info->height )) return 0;
+        if (!change_screen_buffer_size( screen_buffer, req->width, req->height )) return 0;
 
-        evt.event = CONSOLE_RENDERER_SB_RESIZE_EVENT;
-        memset(  &evt.u, 0, sizeof(evt.u) );
-        evt.u.resize.width  = info->width;
-        evt.u.resize.height = info->height;
-        console_input_events_append( screen_buffer->input, &evt );
+	evt.event = CONSOLE_RENDERER_SB_RESIZE_EVENT;
+	evt.u.resize.width  = req->width;
+	evt.u.resize.height = req->height;
+	console_input_events_append( screen_buffer->input, &evt );
 
-        evt.event = CONSOLE_RENDERER_UPDATE_EVENT;
-        memset( &evt.u, 0, sizeof(evt.u) );
-        evt.u.update.top    = 0;
-        evt.u.update.bottom = screen_buffer->height - 1;
-        console_input_events_append( screen_buffer->input, &evt );
+	evt.event = CONSOLE_RENDERER_UPDATE_EVENT;
+	evt.u.update.top    = 0;
+	evt.u.update.bottom = screen_buffer->height - 1;
+	console_input_events_append( screen_buffer->input, &evt );
 
         /* scroll window to display sb */
-        if (screen_buffer->win.right >= info->width)
-        {
+        if (screen_buffer->win.right >= req->width)
+        {       
             screen_buffer->win.right -= screen_buffer->win.left;
             screen_buffer->win.left = 0;
         }
-        if (screen_buffer->win.bottom >= info->height)
-        {
+        if (screen_buffer->win.bottom >= req->height)
+        {       
             screen_buffer->win.bottom -= screen_buffer->win.top;
             screen_buffer->win.top = 0;
         }
         /* reset cursor if needed (normally, if cursor was outside of new sb, the
-         * window has been shifted so that the new position of the cursor will be
+         * window has been shifted so that the new position of the cursor will be 
          * visible */
         cc = 0;
-        if (screen_buffer->cursor_x >= info->width)
+        if (screen_buffer->cursor_x >= req->width)
         {
-            screen_buffer->cursor_x = info->width - 1;
+            screen_buffer->cursor_x = req->width - 1;
             cc++;
         }
-        if (screen_buffer->cursor_y >= info->height)
+        if (screen_buffer->cursor_y >= req->height)
         {
-            screen_buffer->cursor_y = info->height - 1;
+            screen_buffer->cursor_y = req->height - 1;
             cc++;
         }
         if (cc)
         {
             evt.event = CONSOLE_RENDERER_CURSOR_POS_EVENT;
-            memset( &evt.u, 0, sizeof(evt.u) );
-            evt.u.cursor_pos.x = info->cursor_x;
-            evt.u.cursor_pos.y = info->cursor_y;
+            evt.u.cursor_pos.x = req->cursor_x;
+            evt.u.cursor_pos.y = req->cursor_y;
             console_input_events_append( screen_buffer->input, &evt );
         }
 
-        if (screen_buffer == screen_buffer->input->active &&
-            screen_buffer->input->mode & ENABLE_WINDOW_INPUT)
-        {
-            INPUT_RECORD ir;
-            ir.EventType = WINDOW_BUFFER_SIZE_EVENT;
-            ir.Event.WindowBufferSizeEvent.dwSize.X = info->width;
-            ir.Event.WindowBufferSizeEvent.dwSize.Y = info->height;
-            write_console_input( screen_buffer->input, 1, &ir );
-        }
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_ATTR)
-    {
-        screen_buffer->attr = info->attr;
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR)
-    {
-        screen_buffer->popup_attr = info->popup_attr;
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW)
-    {
-        if (info->win_left < 0 || info->win_left > info->win_right ||
-            info->win_right >= screen_buffer->width ||
-            info->win_top < 0  || info->win_top > info->win_bottom ||
-            info->win_bottom >= screen_buffer->height)
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        if (screen_buffer->win.left != info->win_left || screen_buffer->win.top != info->win_top ||
-            screen_buffer->win.right != info->win_right || screen_buffer->win.bottom != info->win_bottom)
-        {
-            screen_buffer->win.left   = info->win_left;
-            screen_buffer->win.top    = info->win_top;
-            screen_buffer->win.right  = info->win_right;
-            screen_buffer->win.bottom = info->win_bottom;
-            evt.event = CONSOLE_RENDERER_DISPLAY_EVENT;
-            memset( &evt.u, 0, sizeof(evt.u) );
-            evt.u.display.left   = info->win_left;
-            evt.u.display.top    = info->win_top;
-            evt.u.display.width  = info->win_right - info->win_left + 1;
-            evt.u.display.height = info->win_bottom - info->win_top + 1;
-            console_input_events_append( screen_buffer->input, &evt );
-        }
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_MAX_SIZE)
-    {
-        screen_buffer->max_width  = info->max_width;
-        screen_buffer->max_height = info->max_height;
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_COLORTABLE)
-    {
-        memcpy( screen_buffer->color_map, info->color_map, sizeof(info->color_map) );
-    }
-    if (params->mask & SET_CONSOLE_OUTPUT_INFO_FONT)
-    {
-        screen_buffer->font.width  = info->font_width;
-        screen_buffer->font.height = info->font_height;
-        screen_buffer->font.weight = info->font_weight;
-        screen_buffer->font.pitch_family = info->font_pitch_family;
-        if (extra_size)
+	if (screen_buffer == screen_buffer->input->active &&
+	    screen_buffer->input->mode & ENABLE_WINDOW_INPUT)
+	{
+	    INPUT_RECORD	ir;
+	    ir.EventType = WINDOW_BUFFER_SIZE_EVENT;
+	    ir.Event.WindowBufferSizeEvent.dwSize.X = req->width;
+	    ir.Event.WindowBufferSizeEvent.dwSize.Y = req->height;
+	    write_console_input( screen_buffer->input, 1, &ir );
+	}
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_ATTR)
+    {
+	screen_buffer->attr = req->attr;
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR)
+    {
+        screen_buffer->popup_attr = req->popup_attr;
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW)
+    {
+	if (req->win_left < 0 || req->win_left > req->win_right ||
+	    req->win_right >= screen_buffer->width ||
+	    req->win_top < 0  || req->win_top > req->win_bottom ||
+	    req->win_bottom >= screen_buffer->height)
+	{
+	    set_error( STATUS_INVALID_PARAMETER );
+	    return 0;
+	}
+	if (screen_buffer->win.left != req->win_left || screen_buffer->win.top != req->win_top ||
+	    screen_buffer->win.right != req->win_right || screen_buffer->win.bottom != req->win_bottom)
+	{
+	    screen_buffer->win.left   = req->win_left;
+	    screen_buffer->win.top    = req->win_top;
+	    screen_buffer->win.right  = req->win_right;
+	    screen_buffer->win.bottom = req->win_bottom;
+	    evt.event = CONSOLE_RENDERER_DISPLAY_EVENT;
+	    evt.u.display.left   = req->win_left;
+	    evt.u.display.top    = req->win_top;
+	    evt.u.display.width  = req->win_right - req->win_left + 1;
+	    evt.u.display.height = req->win_bottom - req->win_top + 1;
+	    console_input_events_append( screen_buffer->input, &evt );
+	}
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_MAX_SIZE)
+    {
+	screen_buffer->max_width  = req->max_width;
+	screen_buffer->max_height = req->max_height;
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_COLORTABLE)
+    {
+        memcpy( screen_buffer->color_map, get_req_data(), min( get_req_data_size(), sizeof(screen_buffer->color_map) ));
+    }
+    if (req->mask & SET_CONSOLE_OUTPUT_INFO_FONT)
+    {
+        screen_buffer->font.width  = req->font_width;
+        screen_buffer->font.height = req->font_height;
+        screen_buffer->font.weight = req->font_weight;
+        screen_buffer->font.pitch_family = req->font_pitch_family;
+        offset = req->mask & SET_CONSOLE_OUTPUT_INFO_COLORTABLE ? sizeof(screen_buffer->color_map) : 0;
+        if (get_req_data_size() > offset)
         {
-            extra_size = extra_size / sizeof(WCHAR) * sizeof(WCHAR);
-            font_name = mem_alloc( extra_size );
+            font_name_len = (get_req_data_size() - offset) / sizeof(WCHAR) * sizeof(WCHAR);
+            font_name = mem_alloc( font_name_len );
             if (font_name)
             {
-                memcpy( font_name, info + 1, extra_size );
+                memcpy( font_name, (char *)get_req_data() + offset, font_name_len );
                 free( screen_buffer->font.face_name );
                 screen_buffer->font.face_name = font_name;
-                screen_buffer->font.face_len  = extra_size;
+                screen_buffer->font.face_len  = font_name_len;
             }
         }
     }
@@ -1178,9 +1160,11 @@ static void console_input_destroy( struct object *obj )
         if (curr->input == console_in) curr->input = NULL;
     }
 
-    free_async_queue( &console_in->read_q );
     if (console_in->evt)
-        console_in->evt->console = NULL;
+    {
+        release_object( console_in->evt );
+        console_in->evt = NULL;
+    }
     if (console_in->event)
         release_object( console_in->event );
     if (console_in->fd)
@@ -1191,12 +1175,6 @@ static void console_input_destroy( struct object *obj )
     free( console_in->history );
 }
 
-static struct object *console_input_open_file( struct object *obj, unsigned int access,
-                                               unsigned int sharing, unsigned int options )
-{
-    return grab_object( obj );
-}
-
 static void screen_buffer_dump( struct object *obj, int verbose )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
@@ -1232,12 +1210,6 @@ static void screen_buffer_destroy( struct object *obj )
     free( screen_buffer->font.face_name );
 }
 
-static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
-                                               unsigned int sharing, unsigned int options )
-{
-    return grab_object( obj );
-}
-
 static struct fd *screen_buffer_get_fd( struct object *obj )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer*)obj;
@@ -1248,149 +1220,66 @@ static struct fd *screen_buffer_get_fd( struct object *obj )
     return NULL;
 }
 
-/* read data from a screen buffer */
-static void read_console_output( struct screen_buffer *screen_buffer, unsigned int x, unsigned int y,
-                                 enum char_info_mode mode, unsigned int width )
+/* write data into a screen buffer */
+static int write_console_output( struct screen_buffer *screen_buffer, data_size_t size,
+                                 const void* data, enum char_info_mode mode,
+                                 int x, int y, int wrap )
 {
-    unsigned int i, count;
-    char_info_t *src;
+    unsigned int i;
+    char_info_t *end, *dest = screen_buffer->data + y * screen_buffer->width + x;
 
-    if (x >= screen_buffer->width || y >= screen_buffer->height)
-    {
-        if (width) set_error( STATUS_INVALID_PARAMETER );
-        return;
-    }
-    src = screen_buffer->data + y * screen_buffer->width + x;
+    if (y >= screen_buffer->height) return 0;
+
+    if (wrap)
+        end = screen_buffer->data + screen_buffer->height * screen_buffer->width;
+    else
+        end = screen_buffer->data + (y+1) * screen_buffer->width;
 
     switch(mode)
     {
     case CHAR_INFO_MODE_TEXT:
         {
-            WCHAR *data;
-            count = min( screen_buffer->data + screen_buffer->height * screen_buffer->width - src,
-                         get_reply_max_size() / sizeof(*data) );
-            if ((data = set_reply_data_size( count * sizeof(*data) )))
-            {
-                for (i = 0; i < count; i++) data[i] = src[i].ch;
-            }
+            const WCHAR *ptr = data;
+            for (i = 0; i < size/sizeof(*ptr) && dest < end; dest++, i++) dest->ch = ptr[i];
         }
         break;
     case CHAR_INFO_MODE_ATTR:
         {
-            unsigned short *data;
-            count = min( screen_buffer->data + screen_buffer->height * screen_buffer->width - src,
-                         get_reply_max_size() / sizeof(*data) );
-            if ((data = set_reply_data_size( count * sizeof(*data) )))
-            {
-                for (i = 0; i < count; i++) data[i] = src[i].attr;
-            }
+            const unsigned short *ptr = data;
+            for (i = 0; i < size/sizeof(*ptr) && dest < end; dest++, i++) dest->attr = ptr[i];
         }
         break;
     case CHAR_INFO_MODE_TEXTATTR:
         {
-            char_info_t *data;
-            SMALL_RECT *region;
-            if (!width || get_reply_max_size() < sizeof(*region))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return;
-            }
-            count  = min( (get_reply_max_size() - sizeof(*region)) / (width * sizeof(*data)), screen_buffer->height - y );
-            width  = min( width, screen_buffer->width - x );
-            if (!(region = set_reply_data_size( sizeof(*region) + width * count * sizeof(*data) ))) return;
-            region->Left   = x;
-            region->Top    = y;
-            region->Right  = x + width - 1;
-            region->Bottom = y + count - 1;
-            data = (char_info_t *)(region + 1);
-            for (i = 0; i < count; i++)
+            const char_info_t *ptr = data;
+            for (i = 0; i < size/sizeof(*ptr) && dest < end; dest++, i++) *dest = ptr[i];
+        }
+        break;
+    case CHAR_INFO_MODE_TEXTSTDATTR:
+        {
+            const WCHAR *ptr = data;
+            for (i = 0; i < size/sizeof(*ptr) && dest < end; dest++, i++)
             {
-                memcpy( &data[i * width], &src[i * screen_buffer->width], width * sizeof(*data) );
+                dest->ch   = ptr[i];
+                dest->attr = screen_buffer->attr;
             }
         }
         break;
     default:
         set_error( STATUS_INVALID_PARAMETER );
-        break;
-    }
-}
-
-/* write data into a screen buffer */
-static void write_console_output( struct screen_buffer *screen_buffer, const struct condrv_output_params *params,
-                                  data_size_t size )
-{
-    unsigned int i, entry_size, entry_cnt, x, y;
-    char_info_t *dest;
-    char *src;
-
-    entry_size = params->mode == CHAR_INFO_MODE_TEXTATTR ? sizeof(char_info_t) : sizeof(WCHAR);
-    if (size % entry_size)
-    {
-        set_error( STATUS_INVALID_PARAMETER );
-        return;
-    }
-    if (params->x >= screen_buffer->width) return;
-    entry_cnt = size / entry_size;
-
-    for (i = 0, src = (char *)(params + 1); i < entry_cnt; i++, src += entry_size)
-    {
-        if (params->width)
-        {
-            x = params->x + i % params->width;
-            y = params->y + i / params->width;
-            if (x >= screen_buffer->width) continue;
-        }
-        else
-        {
-            x = (params->x + i) % screen_buffer->width;
-            y = params->y + (params->x + i) / screen_buffer->width;
-        }
-        if (y >= screen_buffer->height) break;
-
-        dest = &screen_buffer->data[y * screen_buffer->width + x];
-        switch(params->mode)
-        {
-        case CHAR_INFO_MODE_TEXT:
-            dest->ch = *(const WCHAR *)src;
-            break;
-        case CHAR_INFO_MODE_ATTR:
-            dest->attr = *(const unsigned short *)src;
-            break;
-        case CHAR_INFO_MODE_TEXTATTR:
-            *dest = *(const char_info_t *)src;
-            break;
-        case CHAR_INFO_MODE_TEXTSTDATTR:
-            dest->ch   = *(const WCHAR *)src;
-            dest->attr = screen_buffer->attr;
-            break;
-        default:
-            set_error( STATUS_INVALID_PARAMETER );
-            return;
-        }
+        return 0;
     }
 
     if (i && screen_buffer == screen_buffer->input->active)
     {
-        struct condrv_renderer_event evt;
+        struct console_renderer_event evt;
         evt.event = CONSOLE_RENDERER_UPDATE_EVENT;
         memset(&evt.u, 0, sizeof(evt.u));
-        evt.u.update.top    = params->y;
-        evt.u.update.bottom = params->width
-            ? min( params->y + entry_cnt / params->width, screen_buffer->height ) - 1
-            : params->y + (params->x + i - 1) / screen_buffer->width;
+        evt.u.update.top    = y + x / screen_buffer->width;
+        evt.u.update.bottom = y + (x + i - 1) / screen_buffer->width;
         console_input_events_append( screen_buffer->input, &evt );
     }
-
-    if (get_reply_max_size() == sizeof(SMALL_RECT))
-    {
-        SMALL_RECT region;
-        region.Left   = params->x;
-        region.Top    = params->y;
-        region.Right  = min( params->x + params->width, screen_buffer->width ) - 1;
-        region.Bottom = min( params->y + entry_cnt / params->width, screen_buffer->height ) - 1;
-        set_reply_data( &region, sizeof(region) );
-    }
-    else set_reply_data( &i, sizeof(i) );
+    return i;
 }
 
 /* fill a screen buffer with uniform data */
@@ -1434,7 +1323,7 @@ static int fill_console_output( struct screen_buffer *screen_buffer, char_info_t
 
     if (count && screen_buffer == screen_buffer->input->active)
     {
-        struct condrv_renderer_event evt;
+        struct console_renderer_event evt;
         evt.event = CONSOLE_RENDERER_UPDATE_EVENT;
         memset(&evt.u, 0, sizeof(evt.u));
         evt.u.update.top    = y;
@@ -1444,593 +1333,120 @@ static int fill_console_output( struct screen_buffer *screen_buffer, char_info_t
     return i;
 }
 
-/* scroll parts of a screen buffer */
-static void scroll_console_output( struct screen_buffer *screen_buffer, int xsrc, int ysrc, int xdst, int ydst,
-                                   int w, int h, const rectangle_t *clip, char_info_t fill )
-{
-    struct condrv_renderer_event evt;
-    rectangle_t src, dst;
-    int x, y;
-
-    src.left   = max( xsrc, clip->left );
-    src.top    = max( ysrc, clip->top );
-    src.right  = min( xsrc + w - 1, clip->right );
-    src.bottom = min( ysrc + h - 1, clip->bottom );
-
-    dst.left   = xdst;
-    dst.top    = ydst;
-    dst.right  = xdst + w - 1;
-    dst.bottom = ydst + h - 1;
-
-    if (dst.left < clip->left)
-    {
-        xsrc += clip->left - dst.left;
-        w -= clip->left - dst.left;
-        dst.left = clip->left;
-    }
-    if (dst.top < clip->top)
-    {
-        ysrc += clip->top - dst.top;
-        h -= clip->top - dst.top;
-        dst.top = clip->top;
-    }
-    if (dst.right  > clip->right)  w -= dst.right  - clip->right;
-    if (dst.bottom > clip->bottom) h -= dst.bottom - clip->bottom;
-
-    if (w > 0 && h > 0)
-    {
-        if (ysrc < ydst)
-        {
-            for (y = h; y > 0; y--)
-            {
-                memcpy( &screen_buffer->data[(dst.top + y - 1) * screen_buffer->width + dst.left],
-                        &screen_buffer->data[(ysrc + y - 1) * screen_buffer->width + xsrc],
-                        w * sizeof(screen_buffer->data[0]) );
-            }
-        }
-        else
-        {
-            for (y = 0; y < h; y++)
-            {
-                /* we use memmove here because when psrc and pdst are the same,
-                 * copies are done on the same row, so the dst and src blocks
-                 * can overlap */
-                memmove( &screen_buffer->data[(dst.top + y) * screen_buffer->width + dst.left],
-                         &screen_buffer->data[(ysrc + y) * screen_buffer->width + xsrc],
-                         w * sizeof(screen_buffer->data[0]) );
-            }
-        }
-    }
-
-    for (y = src.top; y <= src.bottom; y++)
-    {
-        int left  = src.left;
-        int right = src.right;
-        if (dst.top <= y && y <= dst.bottom)
-        {
-            if (dst.left <= src.left) left  = max( left, dst.right + 1 );
-            if (dst.left >= src.left) right = min( right, dst.left - 1 );
-        }
-        for (x = left; x <= right; x++) screen_buffer->data[y * screen_buffer->width + x] = fill;
-    }
-
-    /* FIXME: this could be enhanced, by signalling scroll */
-    evt.event = CONSOLE_RENDERER_UPDATE_EVENT;
-    memset(&evt.u, 0, sizeof(evt.u));
-    evt.u.update.top    = min( src.top, dst.top );
-    evt.u.update.bottom = max( src.bottom, dst.bottom );
-    console_input_events_append( screen_buffer->input, &evt );
-}
-
-static int console_input_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
+/* read data from a screen buffer */
+static void read_console_output( struct screen_buffer *screen_buffer, int x, int y,
+                                 enum char_info_mode mode, int wrap )
 {
-    struct console_input *console = get_fd_user( fd );
-
-    switch (code)
-    {
-    case IOCTL_CONDRV_GET_MODE:
-        if (get_reply_max_size() != sizeof(console->mode))
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        return set_reply_data( &console->mode, sizeof(console->mode) ) != NULL;
-
-    case IOCTL_CONDRV_SET_MODE:
-        if (get_req_data_size() != sizeof(console->mode))
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        console->mode = *(unsigned int *)get_req_data();
-        return 1;
-
-    case IOCTL_CONDRV_READ_INPUT:
-        {
-            int blocking = 0;
-            if (get_reply_max_size() % sizeof(INPUT_RECORD))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            if (get_req_data_size())
-            {
-                if (get_req_data_size() != sizeof(int))
-                {
-                    set_error( STATUS_INVALID_PARAMETER );
-                    return 0;
-                }
-                blocking = *(int *)get_req_data();
-            }
-            set_error( STATUS_PENDING );
-            if (blocking && !console->recnum)
-            {
-                queue_async( &console->read_q, async );
-                return 1;
-            }
-            return read_console_input( console, async, 1 );
-        }
-
-    case IOCTL_CONDRV_WRITE_INPUT:
-        return write_console_input( console, get_req_data_size() / sizeof(INPUT_RECORD), get_req_data() );
-
-    case IOCTL_CONDRV_PEEK:
-        if (get_reply_max_size() % sizeof(INPUT_RECORD))
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        set_error( STATUS_PENDING );
-        return read_console_input( console, async, 0 );
-
-    case IOCTL_CONDRV_GET_INPUT_INFO:
-        {
-            struct condrv_input_info info;
-            if (get_reply_max_size() != sizeof(info))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            info.input_cp      = console->input_cp;
-            info.output_cp     = console->output_cp;
-            info.history_mode  = console->history_mode;
-            info.history_size  = console->history_size;
-            info.history_index = console->history_index;
-            info.edition_mode  = console->edition_mode;
-            info.input_count   = console->recnum;
-            info.win           = console->win;
-            return set_reply_data( &info, sizeof(info) ) != NULL;
-        }
-
-    case IOCTL_CONDRV_SET_INPUT_INFO:
-        {
-            const struct condrv_input_info_params *params = get_req_data();
-            if (get_req_data_size() != sizeof(*params))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            if (params->mask & SET_CONSOLE_INPUT_INFO_HISTORY_MODE)
-            {
-                console->history_mode = params->info.history_mode;
-            }
-            if ((params->mask & SET_CONSOLE_INPUT_INFO_HISTORY_SIZE) &&
-                console->history_size != params->info.history_size)
-            {
-                struct history_line **mem = NULL;
-                int i, delta;
-
-                if (params->info.history_size)
-                {
-                    if (!(mem = mem_alloc( params->info.history_size * sizeof(*mem) ))) return 0;
-                    memset( mem, 0, params->info.history_size * sizeof(*mem) );
-                }
-
-                delta = (console->history_index > params->info.history_size) ?
-                    (console->history_index - params->info.history_size) : 0;
-
-                for (i = delta; i < console->history_index; i++)
-                {
-                    mem[i - delta] = console->history[i];
-                    console->history[i] = NULL;
-                }
-                console->history_index -= delta;
-
-                for (i = 0; i < console->history_size; i++)
-                    free( console->history[i] );
-                free( console->history );
-                console->history = mem;
-                console->history_size = params->info.history_size;
-            }
-            if (params->mask & SET_CONSOLE_INPUT_INFO_EDITION_MODE)
-            {
-                console->edition_mode = params->info.edition_mode;
-            }
-            if (params->mask & SET_CONSOLE_INPUT_INFO_INPUT_CODEPAGE)
-            {
-                console->input_cp = params->info.input_cp;
-            }
-            if (params->mask & SET_CONSOLE_INPUT_INFO_OUTPUT_CODEPAGE)
-            {
-                console->output_cp = params->info.output_cp;
-            }
-            if (params->mask & SET_CONSOLE_INPUT_INFO_WIN)
-            {
-                console->win = params->info.win;
-            }
-            return 1;
-        }
-
-    case IOCTL_CONDRV_GET_TITLE:
-        if (!console->title_len) return 1;
-        return set_reply_data( console->title, min( console->title_len, get_reply_max_size() )) != NULL;
-
-    case IOCTL_CONDRV_SET_TITLE:
-        {
-            data_size_t len = get_req_data_size();
-            struct condrv_renderer_event evt;
-            WCHAR *title = NULL;
-
-            if (len % sizeof(WCHAR))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-
-            if (len && !(title = memdup( get_req_data(), len ))) return 0;
-            free( console->title );
-            console->title = title;
-            console->title_len = len;
-            evt.event = CONSOLE_RENDERER_TITLE_EVENT;
-            console_input_events_append( console, &evt );
-            return 1;
-        }
+    int i;
+    char_info_t *end, *src = screen_buffer->data + y * screen_buffer->width + x;
 
-    default:
-        set_error( STATUS_INVALID_HANDLE );
-        return 0;
-    }
-}
+    if (y >= screen_buffer->height) return;
 
-static int screen_buffer_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
-{
-    struct screen_buffer *screen_buffer = get_fd_user( fd );
+    if (wrap)
+        end = screen_buffer->data + screen_buffer->height * screen_buffer->width;
+    else
+        end = screen_buffer->data + (y+1) * screen_buffer->width;
 
-    switch (code)
+    switch(mode)
     {
-    case IOCTL_CONDRV_GET_MODE:
-        if (get_reply_max_size() != sizeof(screen_buffer->mode))
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        return set_reply_data( &screen_buffer->mode, sizeof(screen_buffer->mode) ) != NULL;
-
-    case IOCTL_CONDRV_SET_MODE:
-        if (get_req_data_size() != sizeof(screen_buffer->mode))
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        screen_buffer->mode = *(unsigned int *)get_req_data();
-        return 1;
-
-    case IOCTL_CONDRV_READ_OUTPUT:
-        {
-            const struct condrv_output_params *params = get_req_data();
-            if (get_req_data_size() != sizeof(*params))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            if (console_input_is_bare( screen_buffer->input ))
-            {
-                set_error( STATUS_OBJECT_TYPE_MISMATCH );
-                return 0;
-            }
-            read_console_output( screen_buffer, params->x, params->y, params->mode, params->width );
-            return !get_error();
-        }
-
-    case IOCTL_CONDRV_WRITE_OUTPUT:
-        if (get_req_data_size() < sizeof(struct condrv_output_params) ||
-            (get_reply_max_size() != sizeof(SMALL_RECT) && get_reply_max_size() != sizeof(unsigned int)))
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            return 0;
-        }
-        if (console_input_is_bare( screen_buffer->input ))
-        {
-            set_error( STATUS_OBJECT_TYPE_MISMATCH );
-            return 0;
-        }
-        write_console_output( screen_buffer, get_req_data(), get_req_data_size() - sizeof(struct condrv_output_params) );
-        return !get_error();
-
-    case IOCTL_CONDRV_GET_OUTPUT_INFO:
-        {
-            struct condrv_output_info *info;
-            data_size_t size;
-
-            size = min( sizeof(*info) + screen_buffer->font.face_len, get_reply_max_size() );
-            if (size < sizeof(*info))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            if (!(info = set_reply_data_size( size ))) return 0;
-
-            info->cursor_size       = screen_buffer->cursor_size;
-            info->cursor_visible    = screen_buffer->cursor_visible;
-            info->cursor_x          = screen_buffer->cursor_x;
-            info->cursor_y          = screen_buffer->cursor_y;
-            info->width             = screen_buffer->width;
-            info->height            = screen_buffer->height;
-            info->attr              = screen_buffer->attr;
-            info->popup_attr        = screen_buffer->popup_attr;
-            info->win_left          = screen_buffer->win.left;
-            info->win_top           = screen_buffer->win.top;
-            info->win_right         = screen_buffer->win.right;
-            info->win_bottom        = screen_buffer->win.bottom;
-            info->max_width         = screen_buffer->max_width;
-            info->max_height        = screen_buffer->max_height;
-            info->font_width        = screen_buffer->font.width;
-            info->font_height       = screen_buffer->font.height;
-            info->font_weight       = screen_buffer->font.weight;
-            info->font_pitch_family = screen_buffer->font.pitch_family;
-            memcpy( info->color_map, screen_buffer->color_map, sizeof(info->color_map) );
-            size -= sizeof(*info);
-            if (size) memcpy( info + 1, screen_buffer->font.face_name, size );
-            return 1;
-        }
-
-    case IOCTL_CONDRV_SET_OUTPUT_INFO:
-        {
-            const struct condrv_output_info_params *params = get_req_data();
-            if (get_req_data_size() < sizeof(*params))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            if (!screen_buffer->input)
-            {
-                set_error( STATUS_INVALID_HANDLE );
-                return 0;
-            }
-            return set_output_info( screen_buffer, params, get_req_data_size() - sizeof(*params) );
-        }
-
-    case IOCTL_CONDRV_ACTIVATE:
-        if (!screen_buffer->input)
-        {
-            set_error( STATUS_INVALID_HANDLE );
-            return 0;
-        }
-
-        if (screen_buffer != screen_buffer->input->active)
-        {
-            if (screen_buffer->input->active) release_object( screen_buffer->input->active );
-            screen_buffer->input->active = (struct screen_buffer *)grab_object( screen_buffer );
-            generate_sb_initial_events( screen_buffer->input );
-        }
-        return 1;
-
-    case IOCTL_CONDRV_FILL_OUTPUT:
+    case CHAR_INFO_MODE_TEXT:
         {
-            const struct condrv_fill_output_params *params = get_req_data();
-            char_info_t data;
-            DWORD written;
-            if (get_req_data_size() != sizeof(*params) ||
-                (get_reply_max_size() && get_reply_max_size() != sizeof(written)))
+            WCHAR *data;
+            int count = min( end - src, get_reply_max_size() / sizeof(*data) );
+            if ((data = set_reply_data_size( count * sizeof(*data) )))
             {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
+                for (i = 0; i < count; i++) data[i] = src[i].ch;
             }
-            data.ch   = params->ch;
-            data.attr = params->attr;
-            written = fill_console_output( screen_buffer, data, params->mode,
-                                           params->x, params->y, params->count, params->wrap );
-            if (written && get_reply_max_size() == sizeof(written))
-                set_reply_data( &written, sizeof(written) );
-            return !get_error();
         }
-
-    case IOCTL_CONDRV_SCROLL:
+        break;
+    case CHAR_INFO_MODE_ATTR:
         {
-            const struct condrv_scroll_params *params = get_req_data();
-            rectangle_t clip;
-            if (get_req_data_size() != sizeof(*params))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            if (console_input_is_bare( screen_buffer->input ) || !screen_buffer->input)
-            {
-                set_error( STATUS_OBJECT_TYPE_MISMATCH );
-                return 0;
-            }
-            clip.left   = max( params->clip.Left, 0 );
-            clip.top    = max( params->clip.Top,  0 );
-            clip.right  = min( params->clip.Right,  screen_buffer->width - 1 );
-            clip.bottom = min( params->clip.Bottom, screen_buffer->height - 1 );
-            if (clip.left > clip.right || clip.top > clip.bottom || params->scroll.Left < 0 || params->scroll.Top < 0 ||
-                params->scroll.Right >= screen_buffer->width || params->scroll.Bottom >= screen_buffer->height ||
-                params->scroll.Right < params->scroll.Left || params->scroll.Top > params->scroll.Bottom ||
-                params->origin.X < 0 || params->origin.X >= screen_buffer->width || params->origin.Y < 0 ||
-                params->origin.Y >= screen_buffer->height)
+            unsigned short *data;
+            int count = min( end - src, get_reply_max_size() / sizeof(*data) );
+            if ((data = set_reply_data_size( count * sizeof(*data) )))
             {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
+                for (i = 0; i < count; i++) data[i] = src[i].attr;
             }
-
-            scroll_console_output( screen_buffer, params->scroll.Left, params->scroll.Top, params->origin.X, params->origin.Y,
-                                   params->scroll.Right - params->scroll.Left + 1, params->scroll.Bottom - params->scroll.Top + 1,
-                                   &clip, params->fill );
-            return !get_error();
         }
-
-    default:
-        set_error( STATUS_INVALID_HANDLE );
-        return 0;
-    }
-}
-
-static int console_input_events_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
-{
-    struct console_input_events *evts = get_fd_user( fd );
-
-    switch (code)
-    {
-    case IOCTL_CONDRV_GET_RENDERER_EVENTS:
-        set_error( STATUS_PENDING );
-        if (evts->num_used) return get_renderer_events( evts, async );
-        queue_async( &evts->read_q, async );
-        return 1;
-
-    case IOCTL_CONDRV_ATTACH_RENDERER:
+        break;
+    case CHAR_INFO_MODE_TEXTATTR:
         {
-            struct console_input *console_input;
-            if (get_req_data_size() != sizeof(condrv_handle_t))
-            {
-                set_error( STATUS_INVALID_PARAMETER );
-                return 0;
-            }
-            console_input = (struct console_input *)get_handle_obj( current->process, *(condrv_handle_t *)get_req_data(),
-                                                                    0, &console_input_ops );
-            if (!console_input) return 0;
-
-            if (!console_input->evt && !evts->console)
+            char_info_t *data;
+            int count = min( end - src, get_reply_max_size() / sizeof(*data) );
+            if ((data = set_reply_data_size( count * sizeof(*data) )))
             {
-                console_input->evt = evts;
-                console_input->renderer = current;
-                evts->console = console_input;
+                for (i = 0; i < count; i++) data[i] = src[i];
             }
-            else set_error( STATUS_INVALID_HANDLE );
-
-            release_object( console_input );
-            return !get_error();
-        }
-
-    case IOCTL_CONDRV_SCROLL:
-    case IOCTL_CONDRV_SET_MODE:
-    case IOCTL_CONDRV_WRITE_OUTPUT:
-    case IOCTL_CONDRV_READ_OUTPUT:
-    case IOCTL_CONDRV_FILL_OUTPUT:
-    case IOCTL_CONDRV_GET_OUTPUT_INFO:
-    case IOCTL_CONDRV_SET_OUTPUT_INFO:
-        if (!evts->console || !evts->console->active)
-        {
-            set_error( STATUS_INVALID_HANDLE );
-            return 0;
         }
-        return screen_buffer_ioctl( evts->console->active->fd, code, async );
-
+        break;
     default:
-        if (!evts->console)
-        {
-            set_error( STATUS_INVALID_HANDLE );
-            return 0;
-        }
-        return console_input_ioctl( evts->console->fd, code, async );
+        set_error( STATUS_INVALID_PARAMETER );
+        break;
     }
 }
 
-static struct object_type *console_device_get_type( struct object *obj )
-{
-    static const WCHAR name[] = {'D','e','v','i','c','e'};
-    static const struct unicode_str str = { name, sizeof(name) };
-    return get_object_type( &str );
-}
-
-static void console_device_dump( struct object *obj, int verbose )
-{
-    fputs( "Console device\n", stderr );
-}
-
-static struct object *console_device_lookup_name( struct object *obj, struct unicode_str *name, unsigned int attr )
+/* scroll parts of a screen buffer */
+static void scroll_console_output( struct screen_buffer *screen_buffer, int xsrc, int ysrc, int xdst, int ydst,
+                                   int w, int h )
 {
-    static const WCHAR consoleW[]       = {'C','o','n','s','o','l','e'};
-    static const WCHAR current_inW[]    = {'C','u','r','r','e','n','t','I','n'};
-    static const WCHAR current_outW[]   = {'C','u','r','r','e','n','t','O','u','t'};
-    static const WCHAR rendererW[]      = {'R','e','n','d','e','r','e','r'};
-    static const WCHAR screen_bufferW[] = {'S','c','r','e','e','n','B','u','f','f','e','r'};
+    int				j;
+    char_info_t *psrc, *pdst;
+    struct console_renderer_event evt;
 
-    if (name->len == sizeof(current_inW) && !memcmp( name->str, current_inW, name->len ))
+    if (xsrc < 0 || ysrc < 0 || xdst < 0 || ydst < 0 ||
+	xsrc + w > screen_buffer->width  ||
+	xdst + w > screen_buffer->width  ||
+	ysrc + h > screen_buffer->height ||
+	ydst + h > screen_buffer->height ||
+	w == 0 || h == 0)
     {
-        if (!current->process->console)
-        {
-            set_error( STATUS_INVALID_HANDLE );
-            return NULL;
-        }
-        name->len = 0;
-        return grab_object( current->process->console );
-    }
-
-    if (name->len == sizeof(current_outW) && !memcmp( name->str, current_outW, name->len ))
-    {
-        if (!current->process->console || !current->process->console->active)
-        {
-            set_error( STATUS_INVALID_HANDLE );
-            return NULL;
-        }
-        name->len = 0;
-        return grab_object( current->process->console->active );
+	set_error( STATUS_INVALID_PARAMETER );
+	return;
     }
 
-    if (name->len == sizeof(consoleW) && !memcmp( name->str, consoleW, name->len ))
+    if (ysrc < ydst)
     {
-        name->len = 0;
-        return grab_object( obj );
-    }
+	psrc = &screen_buffer->data[(ysrc + h - 1) * screen_buffer->width + xsrc];
+	pdst = &screen_buffer->data[(ydst + h - 1) * screen_buffer->width + xdst];
 
-    if (name->len == sizeof(rendererW) && !memcmp( name->str, rendererW, name->len ))
-    {
-        name->len = 0;
-        return create_console_input_events();
+	for (j = h; j > 0; j--)
+	{
+	    memcpy(pdst, psrc, w * sizeof(*pdst) );
+	    pdst -= screen_buffer->width;
+	    psrc -= screen_buffer->width;
+	}
     }
-
-    if (name->len == sizeof(screen_bufferW) && !memcmp( name->str, screen_bufferW, name->len ))
+    else
     {
-        if (!current->process->console)
-        {
-            set_error( STATUS_INVALID_HANDLE );
-            return NULL;
-        }
-        name->len = 0;
-        return create_console_output( current->process->console, -1 );
-    }
+	psrc = &screen_buffer->data[ysrc * screen_buffer->width + xsrc];
+	pdst = &screen_buffer->data[ydst * screen_buffer->width + xdst];
 
-    return NULL;
-}
-
-static struct object *console_device_open_file( struct object *obj, unsigned int access,
-                                                unsigned int sharing, unsigned int options )
-{
-    int is_output;
-    access = default_fd_map_access( obj, access );
-    is_output = access & FILE_WRITE_DATA;
-    if (!current->process->console || (is_output && !current->process->console))
-    {
-        set_error( STATUS_INVALID_HANDLE );
-        return NULL;
-    }
-    if (is_output && (access & FILE_READ_DATA))
-    {
-        set_error( STATUS_INVALID_PARAMETER );
-        return NULL;
+	for (j = 0; j < h; j++)
+	{
+	    /* we use memmove here because when psrc and pdst are the same,
+	     * copies are done on the same row, so the dst and src blocks
+	     * can overlap */
+	    memmove( pdst, psrc, w * sizeof(*pdst) );
+	    pdst += screen_buffer->width;
+	    psrc += screen_buffer->width;
+	}
     }
-    return is_output ? grab_object( current->process->console->active ) : grab_object( current->process->console );
-}
 
-struct object *create_console_device( struct object *root, const struct unicode_str *name )
-{
-    return create_named_object( root, &console_device_ops, name, 0, NULL );
+    /* FIXME: this could be enhanced, by signalling scroll */
+    evt.event = CONSOLE_RENDERER_UPDATE_EVENT;
+    memset(&evt.u, 0, sizeof(evt.u));
+    evt.u.update.top    = min(ysrc, ydst);
+    evt.u.update.bottom = max(ysrc, ydst) + h - 1;
+    console_input_events_append( screen_buffer->input, &evt );
 }
 
 /* allocate a console for the renderer */
 DECL_HANDLER(alloc_console)
 {
+    obj_handle_t in = 0;
+    obj_handle_t evt = 0;
     struct process *process;
+    struct thread *renderer;
     struct console_input *console;
     int fd;
     int attach = 0;
@@ -2048,7 +1464,8 @@ DECL_HANDLER(alloc_console)
     switch (req->pid)
     {
     case 0:
-        /* console to be attached to parent process */
+        /* renderer is current, console to be attached to parent process */
+        renderer = current;
         if (!(process = get_process_from_id( current->process->parent_id )))
         {
             if (fd != -1) close( fd );
@@ -2058,13 +1475,15 @@ DECL_HANDLER(alloc_console)
         attach = 1;
         break;
     case 0xffffffff:
-        /* console to be attached to current process */
+        /* no renderer, console to be attached to current process */
+        renderer = NULL;
         process = current->process;
         grab_object( process );
         attach = 1;
         break;
     default:
-        /* console to be attached to req->pid */
+        /* renderer is current, console to be attached to req->pid */
+        renderer = current;
         if (!(process = get_process_from_id( req->pid )))
         {
             if (fd != -1) close( fd );
@@ -2076,17 +1495,31 @@ DECL_HANDLER(alloc_console)
     {
         if (fd != -1) close( fd );
         set_error( STATUS_ACCESS_DENIED );
+        goto the_end;
     }
-    else if ((console = (struct console_input*)create_console_input( fd )))
+
+    if ((console = (struct console_input*)create_console_input( renderer, fd )))
     {
-        if ((reply->handle_in = alloc_handle( current->process, console, req->access,
-                                              req->attributes )) && attach)
+        if ((in = alloc_handle( current->process, console, req->access, req->attributes )))
         {
-            process->console = (struct console_input*)grab_object( console );
-            console->num_proc++;
+            if (!console->evt ||
+                (evt = alloc_handle( current->process, console->evt, SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE, 0 )))
+            {
+                if (attach)
+                {
+                    process->console = (struct console_input*)grab_object( console );
+                    console->num_proc++;
+                }
+                reply->handle_in = in;
+                reply->event = evt;
+                release_object( console );
+                goto the_end;
+            }
+            close_handle( current->process, in );
         }
         release_object( console );
     }
+ the_end:
     release_object( process );
 }
 
@@ -2096,6 +1529,51 @@ DECL_HANDLER(free_console)
     free_console( current->process );
 }
 
+/* let the renderer peek the events it's waiting on */
+DECL_HANDLER(get_console_renderer_events)
+{
+    struct console_input_events *evt;
+
+    evt = (struct console_input_events *)get_handle_obj( current->process, req->handle,
+                                                         FILE_READ_PROPERTIES, &console_input_events_ops );
+    if (!evt) return;
+    console_input_events_get( evt );
+    release_object( evt );
+}
+
+/* open a handle to the process console */
+DECL_HANDLER(open_console)
+{
+    struct object      *obj = NULL;
+
+    reply->handle = 0;
+    if (!req->from)
+    {
+        if (current->process->console)
+            obj = grab_object( (struct object*)current->process->console );
+    }
+    else if (req->from == (obj_handle_t)1)
+    {
+        if (current->process->console && current->process->console->active)
+            obj = grab_object( (struct object*)current->process->console->active );
+    }
+    else if ((obj = get_handle_obj( current->process, req->from,
+                                    FILE_READ_PROPERTIES|FILE_WRITE_PROPERTIES, &console_input_ops )))
+    {
+        struct console_input *console = (struct console_input *)obj;
+        obj = (console->active) ? grab_object( console->active ) : NULL;
+        release_object( console );
+    }
+
+    /* FIXME: req->share is not used (as in screen buffer creation)  */
+    if (obj)
+    {
+        reply->handle = alloc_handle( current->process, obj, req->access, req->attributes );
+        release_object( obj );
+    }
+    else if (!get_error()) set_error( STATUS_ACCESS_DENIED );
+}
+
 /* attach to a other process's console */
 DECL_HANDLER(attach_console)
 {
@@ -2113,6 +1591,15 @@ DECL_HANDLER(attach_console)
 
     if (process->console && process->console->active)
     {
+        reply->std_in = alloc_handle( current->process, process->console, GENERIC_READ, 0 );
+        if (!reply->std_in) goto error;
+
+        reply->std_out = alloc_handle( current->process, process->console->active, GENERIC_WRITE, 0 );
+        if (!reply->std_out) goto error;
+
+        reply->std_err = alloc_handle( current->process, process->console->active, GENERIC_WRITE, 0 );
+        if (!reply->std_err) goto error;
+
         current->process->console = (struct console_input *)grab_object( process->console );
         current->process->console->num_proc++;
     }
@@ -2123,6 +1610,11 @@ DECL_HANDLER(attach_console)
 
     release_object( process );
     return;
+
+error:
+    if (reply->std_in) close_handle( current->process, reply->std_in );
+    if (reply->std_out) close_handle( current->process, reply->std_out );
+    release_object( process );
 }
 
 /* set info about a console input */
@@ -2131,6 +1623,57 @@ DECL_HANDLER(set_console_input_info)
     set_console_input_info( req, get_req_data(), get_req_data_size() );
 }
 
+/* get info about a console (output only) */
+DECL_HANDLER(get_console_input_info)
+{
+    struct console_input *console;
+
+    if (!(console = console_input_get( req->handle, FILE_READ_PROPERTIES ))) return;
+    if (console->title) set_reply_data( console->title, min( console->title_len, get_reply_max_size() ));
+    reply->history_mode  = console->history_mode;
+    reply->history_size  = console->history_size;
+    reply->history_index = console->history_index;
+    reply->edition_mode  = console->edition_mode;
+    reply->input_cp      = console->input_cp;
+    reply->output_cp     = console->output_cp;
+    reply->win           = console->win;
+
+    release_object( console );
+}
+
+/* get a console mode (input or output) */
+DECL_HANDLER(get_console_mode)
+{
+    reply->mode = get_console_mode( req->handle );
+}
+
+/* set a console mode (input or output) */
+DECL_HANDLER(set_console_mode)
+{
+    set_console_mode( req->handle, req->mode );
+}
+
+/* add input records to a console input queue */
+DECL_HANDLER(write_console_input)
+{
+    struct console_input *console;
+
+    reply->written = 0;
+    if (!(console = (struct console_input *)get_handle_obj( current->process, req->handle,
+                                                            FILE_WRITE_PROPERTIES, &console_input_ops )))
+        return;
+    reply->written = write_console_input( console, get_req_data_size() / sizeof(INPUT_RECORD),
+                                          get_req_data() );
+    release_object( console );
+}
+
+/* fetch input records from a console input queue */
+DECL_HANDLER(read_console_input)
+{
+    int count = get_reply_max_size() / sizeof(INPUT_RECORD);
+    reply->read = read_console_input( req->handle, count, req->flush );
+}
+
 /* appends a string to console's history */
 DECL_HANDLER(append_console_input_history)
 {
@@ -2154,9 +1697,9 @@ DECL_HANDLER(get_console_input_history)
 /* creates a screen buffer */
 DECL_HANDLER(create_console_output)
 {
-    struct console_input *console;
-    struct object        *screen_buffer;
-    int                   fd;
+    struct console_input*	console;
+    struct screen_buffer*	screen_buffer;
+    int                         fd;
 
     if (req->fd != -1)
     {
@@ -2191,6 +1734,145 @@ DECL_HANDLER(create_console_output)
     release_object( console );
 }
 
+/* set info about a console screen buffer */
+DECL_HANDLER(set_console_output_info)
+{
+    struct screen_buffer *screen_buffer;
+
+    if ((screen_buffer = (struct screen_buffer*)get_handle_obj( current->process, req->handle,
+                                                                FILE_WRITE_PROPERTIES, &screen_buffer_ops)))
+    {
+        set_console_output_info( screen_buffer, req );
+        release_object( screen_buffer );
+    }
+}
+
+/* get info about a console screen buffer */
+DECL_HANDLER(get_console_output_info)
+{
+    struct screen_buffer *screen_buffer;
+    void *data;
+    data_size_t total;
+
+    if ((screen_buffer = (struct screen_buffer *)get_handle_obj( current->process, req->handle,
+                                                                 FILE_READ_PROPERTIES, &screen_buffer_ops)))
+    {
+        reply->cursor_size    = screen_buffer->cursor_size;
+        reply->cursor_visible = screen_buffer->cursor_visible;
+        reply->cursor_x       = screen_buffer->cursor_x;
+        reply->cursor_y       = screen_buffer->cursor_y;
+        reply->width          = screen_buffer->width;
+        reply->height         = screen_buffer->height;
+        reply->attr           = screen_buffer->attr;
+        reply->popup_attr     = screen_buffer->popup_attr;
+        reply->win_left       = screen_buffer->win.left;
+        reply->win_top        = screen_buffer->win.top;
+        reply->win_right      = screen_buffer->win.right;
+        reply->win_bottom     = screen_buffer->win.bottom;
+        reply->max_width      = screen_buffer->max_width;
+        reply->max_height     = screen_buffer->max_height;
+        reply->font_width     = screen_buffer->font.width;
+        reply->font_height    = screen_buffer->font.height;
+        reply->font_weight    = screen_buffer->font.weight;
+        reply->font_pitch_family = screen_buffer->font.pitch_family;
+        total = min( sizeof(screen_buffer->color_map) + screen_buffer->font.face_len, get_reply_max_size() );
+        if (total)
+        {
+            data = set_reply_data_size( total );
+            memcpy( data, screen_buffer->color_map, min( total, sizeof(screen_buffer->color_map) ));
+            if (screen_buffer->font.face_len && total > sizeof(screen_buffer->color_map))
+            {
+                memcpy( (char *)data + sizeof(screen_buffer->color_map), screen_buffer->font.face_name,
+                        min( total - sizeof(screen_buffer->color_map), screen_buffer->font.face_len ));
+            }
+        }
+        release_object( screen_buffer );
+    }
+}
+
+/* read data (chars & attrs) from a screen buffer */
+DECL_HANDLER(read_console_output)
+{
+    struct screen_buffer *screen_buffer;
+
+    if ((screen_buffer = (struct screen_buffer*)get_handle_obj( current->process, req->handle,
+                                                                FILE_READ_DATA, &screen_buffer_ops )))
+    {
+        if (console_input_is_bare( screen_buffer->input ))
+        {
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+            release_object( screen_buffer );
+            return;
+        }
+        read_console_output( screen_buffer, req->x, req->y, req->mode, req->wrap );
+        reply->width  = screen_buffer->width;
+        reply->height = screen_buffer->height;
+        release_object( screen_buffer );
+    }
+}
+
+/* write data (char and/or attrs) to a screen buffer */
+DECL_HANDLER(write_console_output)
+{
+    struct screen_buffer *screen_buffer;
+
+    if ((screen_buffer = (struct screen_buffer*)get_handle_obj( current->process, req->handle,
+                                                                FILE_WRITE_DATA, &screen_buffer_ops)))
+    {
+        if (console_input_is_bare( screen_buffer->input ))
+        {
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+            release_object( screen_buffer );
+            return;
+        }
+        reply->written = write_console_output( screen_buffer, get_req_data_size(), get_req_data(),
+                                               req->mode, req->x, req->y, req->wrap );
+        reply->width  = screen_buffer->width;
+        reply->height = screen_buffer->height;
+        release_object( screen_buffer );
+    }
+}
+
+/* fill a screen buffer with constant data (chars and/or attributes) */
+DECL_HANDLER(fill_console_output)
+{
+    struct screen_buffer *screen_buffer;
+
+    if ((screen_buffer = (struct screen_buffer*)get_handle_obj( current->process, req->handle,
+                                                                FILE_WRITE_DATA, &screen_buffer_ops)))
+    {
+        if (console_input_is_bare( screen_buffer->input ))
+        {
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+            release_object( screen_buffer );
+            return;
+        }
+        reply->written = fill_console_output( screen_buffer, req->data, req->mode,
+                                              req->x, req->y, req->count, req->wrap );
+        release_object( screen_buffer );
+    }
+}
+
+/* move a rect of data in a screen buffer */
+DECL_HANDLER(move_console_output)
+{
+    struct screen_buffer *screen_buffer;
+
+    if ((screen_buffer = (struct screen_buffer*)get_handle_obj( current->process, req->handle,
+                                                                FILE_WRITE_DATA, &screen_buffer_ops)))
+    {
+        if (console_input_is_bare( screen_buffer->input ))
+        {
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+            release_object( screen_buffer );
+            return;
+        }
+        scroll_console_output( screen_buffer, req->x_src, req->y_src, req->x_dst, req->y_dst,
+                               req->w, req->h );
+        release_object( screen_buffer );
+    }
+}
+
 /* sends a signal to a console (process, group...) */
 DECL_HANDLER(send_console_signal)
 {
diff --git a/server/directory.c b/server/directory.c
index 198fc48ece..30cdd79b4a 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -347,35 +347,18 @@ void init_directories(void)
     static const WCHAR link_nulW[]    = {'N','U','L'};
     static const WCHAR link_pipeW[]   = {'P','I','P','E'};
     static const WCHAR link_mailslotW[] = {'M','A','I','L','S','L','O','T'};
-    static const WCHAR link_coninW[]  = {'C','O','N','I','N','$'};
-    static const WCHAR link_conoutW[] = {'C','O','N','O','U','T','$'};
-    static const WCHAR link_conW[]    = {'C','O','N'};
-    static const WCHAR link_currentinW[]  = {'\\','D','e','v','i','c','e','\\','C','o','n','D','r','v',
-        '\\','C','u','r','r','e','n','t','I','n'};
-    static const WCHAR link_currentoutW[] = {'\\','D','e','v','i','c','e','\\','C','o','n','D','r','v',
-        '\\','C','u','r','r','e','n','t','O','u','t'};
-    static const WCHAR link_consoleW[]    = {'\\','D','e','v','i','c','e','\\','C','o','n','D','r','v',
-        '\\','C','o','n','s','o','l','e'};
     static const struct unicode_str link_dosdev_str = {link_dosdevW, sizeof(link_dosdevW)};
     static const struct unicode_str link_global_str = {link_globalW, sizeof(link_globalW)};
     static const struct unicode_str link_nul_str    = {link_nulW, sizeof(link_nulW)};
     static const struct unicode_str link_pipe_str   = {link_pipeW, sizeof(link_pipeW)};
     static const struct unicode_str link_mailslot_str = {link_mailslotW, sizeof(link_mailslotW)};
-    static const struct unicode_str link_con_str      = {link_conW, sizeof(link_conW)};
-    static const struct unicode_str link_conin_str    = {link_coninW, sizeof(link_coninW)};
-    static const struct unicode_str link_conout_str   = {link_conoutW, sizeof(link_conoutW)};
-    static const struct unicode_str link_currentin_str = {link_currentinW, sizeof(link_currentinW)};
-    static const struct unicode_str link_currentout_str = {link_currentoutW, sizeof(link_currentoutW)};
-    static const struct unicode_str link_console_str  = {link_consoleW, sizeof(link_consoleW)};
 
     /* devices */
     static const WCHAR named_pipeW[] = {'N','a','m','e','d','P','i','p','e'};
     static const WCHAR mailslotW[] = {'M','a','i','l','S','l','o','t'};
-    static const WCHAR condrvW[] = {'C','o','n','D','r','v'};
     static const WCHAR nullW[] = {'N','u','l','l'};
     static const struct unicode_str named_pipe_str = {named_pipeW, sizeof(named_pipeW)};
     static const struct unicode_str mailslot_str = {mailslotW, sizeof(mailslotW)};
-    static const struct unicode_str condrv_str = {condrvW, sizeof(condrvW)};
     static const struct unicode_str null_str = {nullW, sizeof(nullW)};
 
     /* events */
@@ -397,14 +380,9 @@ void init_directories(void)
     };
     static const struct unicode_str keyed_event_crit_sect_str = {keyed_event_crit_sectW, sizeof(keyed_event_crit_sectW)};
 
-    /* mappings */
-    static const WCHAR user_dataW[] = {'_','_','w','i','n','e','_','u','s','e','r','_','s','h','a','r','e','d','_','d','a','t','a'};
-    static const struct unicode_str user_data_str = {user_dataW, sizeof(user_dataW)};
-
     struct directory *dir_driver, *dir_device, *dir_global, *dir_kernel;
     struct object *link_dosdev, *link_global, *link_nul, *link_pipe, *link_mailslot;
-    struct object *link_conin, *link_conout, *link_con;
-    struct object *named_pipe_device, *mailslot_device, *null_device, *user_data_mapping, *console_device;
+    struct object *named_pipe_device, *mailslot_device, *null_device;
     struct keyed_event *keyed_event;
     unsigned int i;
 
@@ -421,12 +399,10 @@ void init_directories(void)
     /* devices */
     named_pipe_device = create_named_pipe_device( &dir_device->obj, &named_pipe_str );
     mailslot_device   = create_mailslot_device( &dir_device->obj, &mailslot_str );
-    console_device    = create_console_device( &dir_device->obj, &condrv_str );
     null_device       = create_unix_device( &dir_device->obj, &null_str, "/dev/null" );
     make_object_static( named_pipe_device );
     make_object_static( mailslot_device );
     make_object_static( null_device );
-    make_object_static( console_device );
 
     /* sessions */
     create_session( 0 );
@@ -438,17 +414,11 @@ void init_directories(void)
     link_nul       = create_obj_symlink( &dir_global->obj, &link_nul_str, 0, null_device, NULL );
     link_pipe      = create_obj_symlink( &dir_global->obj, &link_pipe_str, 0, named_pipe_device, NULL );
     link_mailslot  = create_obj_symlink( &dir_global->obj, &link_mailslot_str, 0, mailslot_device, NULL );
-    link_conin     = create_symlink( &dir_global->obj, &link_conin_str, 0, &link_currentin_str, NULL );
-    link_conout    = create_symlink( &dir_global->obj, &link_conout_str, 0, &link_currentout_str, NULL );
-    link_con       = create_symlink( &dir_global->obj, &link_con_str, 0, &link_console_str, NULL );
     make_object_static( link_dosdev );
     make_object_static( link_global );
     make_object_static( link_nul );
     make_object_static( link_pipe );
     make_object_static( link_mailslot );
-    make_object_static( link_conin );
-    make_object_static( link_conout );
-    make_object_static( link_con );
 
     /* events */
     for (i = 0; i < ARRAY_SIZE( kernel_events ); i++)
@@ -459,10 +429,6 @@ void init_directories(void)
     keyed_event = create_keyed_event( &dir_kernel->obj, &keyed_event_crit_sect_str, 0, NULL );
     make_object_static( (struct object *)keyed_event );
 
-    /* user data mapping */
-    user_data_mapping = create_user_data_mapping( &dir_kernel->obj, &user_data_str, 0, NULL );
-    make_object_static( user_data_mapping );
-
     /* the objects hold references so we can release these directories */
     release_object( dir_global );
     release_object( dir_device );
@@ -534,6 +500,18 @@ DECL_HANDLER(get_directory_entry)
     }
 }
 
+/* unlink a named object */
+DECL_HANDLER(unlink_object)
+{
+    struct object *obj = get_handle_obj( current->process, req->handle, 0, NULL );
+
+    if (obj)
+    {
+        unlink_named_object( obj );
+        release_object( obj );
+    }
+}
+
 /* query object type name information */
 DECL_HANDLER(get_object_type)
 {
diff --git a/server/file.h b/server/file.h
index e8ace7f49e..45215c588d 100644
--- a/server/file.h
+++ b/server/file.h
@@ -167,19 +167,20 @@ extern int is_file_executable( const char *name );
 
 /* file mapping functions */
 
+extern struct mapping *get_mapping_obj( struct process *process, obj_handle_t handle,
+                                        unsigned int access );
 extern struct file *get_mapping_file( struct process *process, client_ptr_t base,
                                       unsigned int access, unsigned int sharing );
 extern const pe_image_info_t *get_mapping_image_info( struct process *process, client_ptr_t base );
 extern void free_mapped_views( struct process *process );
 extern int get_page_size(void);
-extern struct object *create_user_data_mapping( struct object *root, const struct unicode_str *name,
-                                                unsigned int attr, const struct security_descriptor *sd );
+
+extern void init_kusd_mapping( struct mapping *mapping );
 
 /* device functions */
 
 extern struct object *create_named_pipe_device( struct object *root, const struct unicode_str *name );
 extern struct object *create_mailslot_device( struct object *root, const struct unicode_str *name );
-extern struct object *create_console_device( struct object *root, const struct unicode_str *name );
 extern struct object *create_unix_device( struct object *root, const struct unicode_str *name,
                                           const char *unix_path );
 
diff --git a/server/handle.c b/server/handle.c
index 9ae99cd0c6..a2a8bb5479 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -833,17 +833,3 @@ DECL_HANDLER(get_system_handles)
         enum_processes( enum_handles, &info );
     }
 }
-
-DECL_HANDLER(make_temporary)
-{
-    struct object *obj;
-
-    if (!(obj = get_handle_obj( current->process, req->handle, 0, NULL ))) return;
-
-    if (obj->is_permanent)
-    {
-        make_object_temporary( obj );
-        release_object( obj );
-    }
-    release_object( obj );
-}
diff --git a/server/mailslot.c b/server/mailslot.c
index 58d650cbb2..781e6f3141 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -171,23 +171,19 @@ static const struct fd_ops mail_writer_fd_ops =
 struct mailslot_device
 {
     struct object       obj;         /* object header */
+    struct fd          *fd;          /* pseudo-fd for ioctls */
     struct namespace   *mailslots;   /* mailslot namespace */
 };
 
-struct mailslot_device_file
-{
-    struct object           obj;    /* object header */
-    struct fd              *fd;     /* pseudo-fd for ioctls */
-    struct mailslot_device *device; /* mailslot device */
-};
-
 static void mailslot_device_dump( struct object *obj, int verbose );
 static struct object_type *mailslot_device_get_type( struct object *obj );
+static struct fd *mailslot_device_get_fd( struct object *obj );
 static struct object *mailslot_device_lookup_name( struct object *obj, struct unicode_str *name,
                                                    unsigned int attr );
 static struct object *mailslot_device_open_file( struct object *obj, unsigned int access,
                                                  unsigned int sharing, unsigned int options );
 static void mailslot_device_destroy( struct object *obj );
+static enum server_fd_type mailslot_device_get_fd_type( struct fd *fd );
 
 static const struct object_ops mailslot_device_ops =
 {
@@ -199,7 +195,7 @@ static const struct object_ops mailslot_device_ops =
     NULL,                           /* signaled */
     no_satisfied,                   /* satisfied */
     no_signal,                      /* signal */
-    no_get_fd,                      /* get_fd */
+    mailslot_device_get_fd,         /* get_fd */
     no_map_access,                  /* map_access */
     default_get_sd,                 /* get_sd */
     default_set_sd,                 /* set_sd */
@@ -208,51 +204,23 @@ static const struct object_ops mailslot_device_ops =
     default_unlink_name,            /* unlink_name */
     mailslot_device_open_file,      /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
-    no_close_handle,                /* close_handle */
+    fd_close_handle,                /* close_handle */
     mailslot_device_destroy         /* destroy */
 };
 
-static void mailslot_device_file_dump( struct object *obj, int verbose );
-static struct fd *mailslot_device_file_get_fd( struct object *obj );
-static void mailslot_device_file_destroy( struct object *obj );
-static enum server_fd_type mailslot_device_file_get_fd_type( struct fd *fd );
-
-static const struct object_ops mailslot_device_file_ops =
-{
-    sizeof(struct mailslot_device_file),    /* size */
-    mailslot_device_file_dump,              /* dump */
-    file_get_type,                          /* get_type */
-    add_queue,                              /* add_queue */
-    remove_queue,                           /* remove_queue */
-    default_fd_signaled,                    /* signaled */
-    no_satisfied,                           /* satisfied */
-    no_signal,                              /* signal */
-    mailslot_device_file_get_fd,            /* get_fd */
-    default_fd_map_access,                  /* map_access */
-    default_get_sd,                         /* get_sd */
-    default_set_sd,                         /* set_sd */
-    no_lookup_name,                         /* lookup_name */
-    no_link_name,                           /* link_name */
-    NULL,                                   /* unlink_name */
-    no_open_file,                           /* open_file */
-    no_kernel_obj_list,                     /* get_kernel_obj_list */
-    fd_close_handle,                        /* close_handle */
-    mailslot_device_file_destroy            /* destroy */
-};
-
 static const struct fd_ops mailslot_device_fd_ops =
 {
-    default_fd_get_poll_events,         /* get_poll_events */
-    default_poll_event,                 /* poll_event */
-    mailslot_device_file_get_fd_type,   /* get_fd_type */
-    no_fd_read,                         /* read */
-    no_fd_write,                        /* write */
-    no_fd_flush,                        /* flush */
-    default_fd_get_file_info,           /* get_file_info */
-    no_fd_get_volume_info,              /* get_volume_info */
-    default_fd_ioctl,                   /* ioctl */
-    default_fd_queue_async,             /* queue_async */
-    default_fd_reselect_async           /* reselect_async */
+    default_fd_get_poll_events,     /* get_poll_events */
+    default_poll_event,             /* poll_event */
+    mailslot_device_get_fd_type,    /* get_fd_type */
+    no_fd_read,                     /* read */
+    no_fd_write,                    /* write */
+    no_fd_flush,                    /* flush */
+    default_fd_get_file_info,       /* get_file_info */
+    no_fd_get_volume_info,          /* get_volume_info */
+    default_fd_ioctl,               /* ioctl */
+    default_fd_queue_async,         /* queue_async */
+    default_fd_reselect_async       /* reselect_async */
 };
 
 static void mailslot_destroy( struct object *obj)
@@ -389,6 +357,12 @@ static struct object_type *mailslot_device_get_type( struct object *obj )
     return get_object_type( &str );
 }
 
+static struct fd *mailslot_device_get_fd( struct object *obj )
+{
+    struct mailslot_device *device = (struct mailslot_device *)obj;
+    return (struct fd *)grab_object( device->fd );
+}
+
 static struct object *mailslot_device_lookup_name( struct object *obj, struct unicode_str *name,
                                                    unsigned int attr )
 {
@@ -408,26 +382,22 @@ static struct object *mailslot_device_lookup_name( struct object *obj, struct un
 static struct object *mailslot_device_open_file( struct object *obj, unsigned int access,
                                                  unsigned int sharing, unsigned int options )
 {
-    struct mailslot_device_file *file;
-
-    if (!(file = alloc_object( &mailslot_device_file_ops ))) return NULL;
-    file->device = (struct mailslot_device *)grab_object( obj );
-    if (!(file->fd = alloc_pseudo_fd( &mailslot_device_fd_ops, obj, options )))
-    {
-        release_object( file );
-        return NULL;
-    }
-    allow_fd_caching( file->fd );
-    return &file->obj;
+    return grab_object( obj );
 }
 
 static void mailslot_device_destroy( struct object *obj )
 {
     struct mailslot_device *device = (struct mailslot_device*)obj;
     assert( obj->ops == &mailslot_device_ops );
+    if (device->fd) release_object( device->fd );
     free( device->mailslots );
 }
 
+static enum server_fd_type mailslot_device_get_fd_type( struct fd *fd )
+{
+    return FD_TYPE_DEVICE;
+}
+
 struct object *create_mailslot_device( struct object *root, const struct unicode_str *name )
 {
     struct mailslot_device *dev;
@@ -436,7 +406,8 @@ struct object *create_mailslot_device( struct object *root, const struct unicode
         get_error() != STATUS_OBJECT_NAME_EXISTS)
     {
         dev->mailslots = NULL;
-        if (!(dev->mailslots = create_namespace( 7 )))
+        if (!(dev->fd = alloc_pseudo_fd( &mailslot_device_fd_ops, &dev->obj, 0 )) ||
+            !(dev->mailslots = create_namespace( 7 )))
         {
             release_object( dev );
             dev = NULL;
@@ -445,32 +416,6 @@ struct object *create_mailslot_device( struct object *root, const struct unicode
     return &dev->obj;
 }
 
-static void mailslot_device_file_dump( struct object *obj, int verbose )
-{
-    struct mailslot_device_file *file = (struct mailslot_device_file *)obj;
-
-    fprintf( stderr, "File on mailslot device %p\n", file->device );
-}
-
-static struct fd *mailslot_device_file_get_fd( struct object *obj )
-{
-    struct mailslot_device_file *file = (struct mailslot_device_file *)obj;
-    return (struct fd *)grab_object( file->fd );
-}
-
-static void mailslot_device_file_destroy( struct object *obj )
-{
-    struct mailslot_device_file *file = (struct mailslot_device_file*)obj;
-    assert( obj->ops == &mailslot_device_file_ops );
-    if (file->fd) release_object( file->fd );
-    release_object( file->device );
-}
-
-static enum server_fd_type mailslot_device_file_get_fd_type( struct fd *fd )
-{
-    return FD_TYPE_DEVICE;
-}
-
 static struct mailslot *create_mailslot( struct object *root,
                                          const struct unicode_str *name, unsigned int attr,
                                          int max_msgsize, timeout_t read_timeout,
diff --git a/server/mapping.c b/server/mapping.c
index db0debe0af..2c34b8f3c8 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -782,10 +782,10 @@ static unsigned int get_mapping_flags( obj_handle_t handle, unsigned int flags )
 }
 
 
-static struct mapping *create_mapping( struct object *root, const struct unicode_str *name,
-                                       unsigned int attr, mem_size_t size, unsigned int flags,
-                                       obj_handle_t handle, unsigned int file_access,
-                                       const struct security_descriptor *sd )
+static struct object *create_mapping( struct object *root, const struct unicode_str *name,
+                                      unsigned int attr, mem_size_t size, unsigned int flags,
+                                      obj_handle_t handle, unsigned int file_access,
+                                      const struct security_descriptor *sd )
 {
     struct mapping *mapping;
     struct file *file;
@@ -798,7 +798,7 @@ static struct mapping *create_mapping( struct object *root, const struct unicode
     if (!(mapping = create_named_object( root, &mapping_ops, name, attr, sd )))
         return NULL;
     if (get_error() == STATUS_OBJECT_NAME_EXISTS)
-        return mapping;  /* Nothing else to do */
+        return &mapping->obj;  /* Nothing else to do */
 
     mapping->size        = size;
     mapping->fd          = NULL;
@@ -837,7 +837,7 @@ static struct mapping *create_mapping( struct object *root, const struct unicode
         if (flags & SEC_IMAGE)
         {
             unsigned int err = get_image_params( mapping, st.st_size, unix_fd );
-            if (!err) return mapping;
+            if (!err) return &mapping->obj;
             set_error( err );
             goto error;
         }
@@ -873,14 +873,14 @@ static struct mapping *create_mapping( struct object *root, const struct unicode
                                                  FILE_SYNCHRONOUS_IO_NONALERT ))) goto error;
         allow_fd_caching( mapping->fd );
     }
-    return mapping;
+    return &mapping->obj;
 
  error:
     release_object( mapping );
     return NULL;
 }
 
-static struct mapping *get_mapping_obj( struct process *process, obj_handle_t handle, unsigned int access )
+struct mapping *get_mapping_obj( struct process *process, obj_handle_t handle, unsigned int access )
 {
     return (struct mapping *)get_handle_obj( process, handle, access, &mapping_ops );
 }
@@ -955,43 +955,36 @@ int get_page_size(void)
     return page_mask + 1;
 }
 
-struct object *create_user_data_mapping( struct object *root, const struct unicode_str *name,
-                                        unsigned int attr, const struct security_descriptor *sd )
+void init_kusd_mapping( struct mapping *mapping )
 {
     void *ptr;
-    struct mapping *mapping;
 
-    if (!(mapping = create_mapping( root, name, OBJ_OPENIF, sizeof(KSHARED_USER_DATA),
-                                    SEC_COMMIT, 0, FILE_READ_DATA | FILE_WRITE_DATA, NULL ))) return NULL;
+    if (user_shared_data) return;
+    grab_object( mapping );
+    make_object_static( &mapping->obj );
     ptr = mmap( NULL, mapping->size, PROT_WRITE, MAP_SHARED, get_unix_fd( mapping->fd ), 0 );
-    if (ptr != MAP_FAILED)
-    {
-        user_shared_data = ptr;
-        user_shared_data->SystemCall = 1;
-    }
-    return &mapping->obj;
+    if (ptr != MAP_FAILED) user_shared_data = ptr;
 }
 
 /* create a file mapping */
 DECL_HANDLER(create_mapping)
 {
-    struct object *root;
-    struct mapping *mapping;
+    struct object *root, *obj;
     struct unicode_str name;
     const struct security_descriptor *sd;
     const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, &root );
 
     if (!objattr) return;
 
-    if ((mapping = create_mapping( root, &name, objattr->attributes, req->size, req->flags,
-                                   req->file_handle, req->file_access, sd )))
+    if ((obj = create_mapping( root, &name, objattr->attributes, req->size, req->flags,
+                               req->file_handle, req->file_access, sd )))
     {
         if (get_error() == STATUS_OBJECT_NAME_EXISTS)
-            reply->handle = alloc_handle( current->process, &mapping->obj, req->access, objattr->attributes );
+            reply->handle = alloc_handle( current->process, obj, req->access, objattr->attributes );
         else
-            reply->handle = alloc_handle_no_access_check( current->process, &mapping->obj,
+            reply->handle = alloc_handle_no_access_check( current->process, obj,
                                                           req->access, objattr->attributes );
-        release_object( mapping );
+        release_object( obj );
     }
 
     if (root) release_object( root );
@@ -1079,11 +1072,7 @@ DECL_HANDLER(map_view)
         view->fd        = !is_fd_removable( mapping->fd ) ? (struct fd *)grab_object( mapping->fd ) : NULL;
         view->committed = mapping->committed ? (struct ranges *)grab_object( mapping->committed ) : NULL;
         view->shared    = mapping->shared ? (struct shared_map *)grab_object( mapping->shared ) : NULL;
-        if (mapping->flags & SEC_IMAGE)
-        {
-            view->image = mapping->image;
-            if (view->base != mapping->image.base) set_error( STATUS_IMAGE_NOT_AT_BASE );
-        }
+        if (mapping->flags & SEC_IMAGE) view->image = mapping->image;
         list_add_tail( &current->process->views, &view->entry );
     }
 
diff --git a/server/named_pipe.c b/server/named_pipe.c
index b259abb8de..f97b141641 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -1138,17 +1138,6 @@ static int pipe_server_ioctl( struct fd *fd, ioctl_code_t code, struct async *as
         pipe_end_disconnect( &server->pipe_end, STATUS_PIPE_DISCONNECTED );
         return 1;
 
-    case FSCTL_PIPE_IMPERSONATE:
-        if (current->process->token) /* FIXME: use the client token */
-        {
-            struct token *token;
-            if (!(token = token_duplicate( current->process->token, 0, SecurityImpersonation, NULL )))
-                return 0;
-            if (current->token) release_object( current->token );
-            current->token = token;
-        }
-        return 1;
-
     default:
         return pipe_end_ioctl( &server->pipe_end, code, async );
     }
diff --git a/server/object.c b/server/object.c
index 8ec6609f69..dacfe1d71a 100644
--- a/server/object.c
+++ b/server/object.c
@@ -278,8 +278,7 @@ data_size_t get_path_element( const WCHAR *name, data_size_t len )
 }
 
 static struct object *create_object( struct object *parent, const struct object_ops *ops,
-                                     const struct unicode_str *name, unsigned int attributes,
-                                     const struct security_descriptor *sd )
+                                     const struct unicode_str *name, const struct security_descriptor *sd )
 {
     struct object *obj;
     struct object_name *name_ptr;
@@ -293,11 +292,6 @@ static struct object *create_object( struct object *parent, const struct object_
 
     name_ptr->obj = obj;
     obj->name = name_ptr;
-    if (attributes & OBJ_PERMANENT)
-    {
-        make_object_static( obj );
-        grab_object( obj );
-    }
     return obj;
 
 failed:
@@ -346,7 +340,7 @@ void *create_named_object( struct object *parent, const struct object_ops *ops,
         return obj;
     }
 
-    new_obj = create_object( obj, ops, &new_name, attributes, sd );
+    new_obj = create_object( obj, ops, &new_name, sd );
     release_object( obj );
     return new_obj;
 }
@@ -407,23 +401,12 @@ void unlink_named_object( struct object *obj )
 /* mark an object as being stored statically, i.e. only released at shutdown */
 void make_object_static( struct object *obj )
 {
-    obj->is_permanent = 1;
 #ifdef DEBUG_OBJECTS
     list_remove( &obj->obj_list );
     list_add_head( &static_object_list, &obj->obj_list );
 #endif
 }
 
-/* mark an object as no longer static */
-void make_object_temporary( struct object *obj )
-{
-    obj->is_permanent = 0;
-#ifdef DEBUG_OBJECTS
-    list_remove( &obj->obj_list );
-    list_add_head( &object_list, &obj->obj_list );
-#endif
-}
-
 /* grab an object (i.e. increment its refcount) and return the object */
 struct object *grab_object( void *ptr )
 {
diff --git a/server/object.h b/server/object.h
index 1f5c4a5f06..3144eb5667 100644
--- a/server/object.h
+++ b/server/object.h
@@ -105,7 +105,6 @@ struct object
     struct list               wait_queue;
     struct object_name       *name;
     struct security_descriptor *sd;
-    unsigned int              is_permanent:1;
 #ifdef DEBUG_OBJECTS
     struct list               obj_list;
 #endif
@@ -144,7 +143,6 @@ extern void *open_named_object( struct object *parent, const struct object_ops *
                                 const struct unicode_str *name, unsigned int attributes );
 extern void unlink_named_object( struct object *obj );
 extern void make_object_static( struct object *obj );
-extern void make_object_temporary( struct object *obj );
 extern struct namespace *create_namespace( unsigned int hash_size );
 extern void free_kernel_objects( struct object *obj );
 /* grab/release_object can take any pointer, but you better make sure */
@@ -246,9 +244,6 @@ extern void init_directories(void);
 extern struct object *create_obj_symlink( struct object *root, const struct unicode_str *name,
                                           unsigned int attr, struct object *target,
                                           const struct security_descriptor *sd );
-extern struct object *create_symlink( struct object *root, const struct unicode_str *name,
-                                      unsigned int attr, const struct unicode_str *target,
-                                      const struct security_descriptor *sd );
 
 /* global variables */
 
diff --git a/server/process.c b/server/process.c
index 61ba1549e9..ab3d448b00 100644
--- a/server/process.c
+++ b/server/process.c
@@ -22,7 +22,6 @@
 #include "wine/port.h"
 
 #include <assert.h>
-#include <errno.h>
 #include <limits.h>
 #include <signal.h>
 #include <string.h>
@@ -157,7 +156,6 @@ struct job
     struct object obj;             /* object header */
     struct list process_list;      /* list of all processes */
     int num_processes;             /* count of running processes */
-    int total_processes;           /* count of processes which have been assigned */
     unsigned int limit_flags;      /* limit flags */
     int terminating;               /* job is terminating */
     int signaled;                  /* job is signaled */
@@ -200,7 +198,6 @@ static struct job *create_job_object( struct object *root, const struct unicode_
             /* initialize it if it didn't already exist */
             list_init( &job->process_list );
             job->num_processes = 0;
-            job->total_processes = 0;
             job->limit_flags = 0;
             job->terminating = 0;
             job->signaled = 0;
@@ -243,7 +240,6 @@ static void add_job_process( struct job *job, struct process *process )
     process->job = (struct job *)grab_object( job );
     list_add_tail( &job->process_list, &process->job_entry );
     job->num_processes++;
-    job->total_processes++;
 
     add_job_completion( job, JOB_OBJECT_MSG_NEW_PROCESS, get_process_id(process) );
 }
@@ -1086,6 +1082,36 @@ int set_process_debug_flag( struct process *process, int flag )
     return write_process_memory( process, process->peb + 2, 1, &data );
 }
 
+/* take a snapshot of currently running processes */
+struct process_snapshot *process_snap( int *count )
+{
+    struct process_snapshot *snapshot, *ptr;
+    struct process *process;
+
+    if (!running_processes) return NULL;
+    if (!(snapshot = mem_alloc( sizeof(*snapshot) * running_processes )))
+        return NULL;
+    ptr = snapshot;
+    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
+    {
+        if (!process->running_threads) continue;
+        ptr->process  = process;
+        ptr->threads  = process->running_threads;
+        ptr->count    = process->obj.refcount;
+        ptr->priority = process->priority;
+        ptr->handles  = get_handle_table_count(process);
+        grab_object( process );
+        ptr++;
+    }
+
+    if (!(*count = ptr - snapshot))
+    {
+        free( snapshot );
+        snapshot = NULL;
+    }
+    return snapshot;
+}
+
 /* create a new process */
 DECL_HANDLER(new_process)
 {
@@ -1224,8 +1250,7 @@ DECL_HANDLER(new_process)
          * like if hConOut and hConIn are console handles, then they should be on the same
          * physical console
          */
-        info->data->console = inherit_console( parent_thread, parent,
-                                               process, req->inherit_all ? info->data->hstdin : 0 );
+        inherit_console( parent_thread, parent, process, req->inherit_all ? info->data->hstdin : 0 );
     }
 
     if (!req->inherit_all && !(req->create_flags & CREATE_NEW_CONSOLE))
@@ -1336,6 +1361,7 @@ DECL_HANDLER(init_process_done)
 {
     struct process_dll *dll;
     struct process *process = current->process;
+    struct mapping *mapping;
 
     if (is_process_init_done(process))
     {
@@ -1347,6 +1373,13 @@ DECL_HANDLER(init_process_done)
         set_error( STATUS_DLL_NOT_FOUND );
         return;
     }
+    if (!(mapping = get_mapping_obj( current->process, req->usd_handle, SECTION_MAP_WRITE )))
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return;
+    }
+    init_kusd_mapping( mapping );
+    release_object( mapping );
 
     /* main exe is the first in the dll list */
     list_remove( &dll->entry );
@@ -1702,18 +1735,6 @@ DECL_HANDLER(process_in_job)
     release_object( process );
 }
 
-/* retrieve information about a job */
-DECL_HANDLER(get_job_info)
-{
-    struct job *job = get_job_obj( current->process, req->handle, JOB_OBJECT_QUERY );
-
-    if (!job) return;
-
-    reply->total_processes = job->total_processes;
-    reply->active_processes = job->num_processes;
-    release_object( job );
-}
-
 /* terminate all processes associated with the job */
 DECL_HANDLER(terminate_job)
 {
@@ -1791,72 +1812,3 @@ DECL_HANDLER(resume_process)
         release_object( process );
     }
 }
-
-/* Get a list of processes and threads currently running */
-DECL_HANDLER(list_processes)
-{
-    struct process *process;
-    struct thread *thread;
-    unsigned int pos = 0;
-    char *buffer;
-
-    reply->process_count = 0;
-    reply->info_size = 0;
-
-    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
-    {
-        struct process_dll *exe = get_process_exe_module( process );
-        reply->info_size = (reply->info_size + 7) & ~7;
-        reply->info_size += sizeof(struct process_info);
-        if (exe) reply->info_size += exe->namelen;
-        reply->info_size = (reply->info_size + 7) & ~7;
-        reply->info_size += process->running_threads * sizeof(struct thread_info);
-        reply->process_count++;
-    }
-
-    if (reply->info_size > get_reply_max_size())
-    {
-        set_error( STATUS_INFO_LENGTH_MISMATCH );
-        return;
-    }
-
-    if (!(buffer = set_reply_data_size( reply->info_size ))) return;
-
-    memset( buffer, 0, reply->info_size );
-    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
-    {
-        struct process_info *process_info;
-        struct process_dll *exe = get_process_exe_module( process );
-
-        pos = (pos + 7) & ~7;
-        process_info = (struct process_info *)(buffer + pos);
-        process_info->start_time = process->start_time;
-        process_info->name_len = exe ? exe->namelen : 0;
-        process_info->thread_count = process->running_threads;
-        process_info->priority = process->priority;
-        process_info->pid = process->id;
-        process_info->parent_pid = process->parent_id;
-        process_info->handle_count = get_handle_table_count(process);
-        process_info->unix_pid = process->unix_pid;
-        pos += sizeof(*process_info);
-
-        if (exe)
-        {
-            memcpy( buffer + pos, exe->filename, exe->namelen );
-            pos += exe->namelen;
-        }
-
-        pos = (pos + 7) & ~7;
-        LIST_FOR_EACH_ENTRY( thread, &process->thread_list, struct thread, proc_entry )
-        {
-            struct thread_info *thread_info = (struct thread_info *)(buffer + pos);
-
-            thread_info->start_time = thread->creation_time;
-            thread_info->tid = thread->id;
-            thread_info->base_priority = thread->priority;
-            thread_info->current_priority = thread->priority; /* FIXME */
-            thread_info->unix_tid = thread->unix_tid;
-            pos += sizeof(*thread_info);
-        }
-    }
-}
diff --git a/server/process.h b/server/process.h
index 3944a67d57..5b83e111a6 100644
--- a/server/process.h
+++ b/server/process.h
@@ -100,6 +100,15 @@ struct process
     struct list          kernel_object;   /* list of kernel object pointers */
 };
 
+struct process_snapshot
+{
+    struct process *process;  /* process ptr */
+    int             count;    /* process refcount */
+    int             threads;  /* number of threads */
+    int             priority; /* priority class */
+    int             handles;  /* number of handles */
+};
+
 #define CPU_FLAG(cpu) (1 << (cpu))
 #define CPU_64BIT_MASK (CPU_FLAG(CPU_x86_64) | CPU_FLAG(CPU_ARM64))
 
@@ -128,11 +137,12 @@ extern void kill_process( struct process *process, int violent_death );
 extern void kill_console_processes( struct thread *renderer, int exit_code );
 extern void kill_debugged_processes( struct thread *debugger, int exit_code );
 extern void detach_debugged_processes( struct thread *debugger );
+extern struct process_snapshot *process_snap( int *count );
 extern void enum_processes( int (*cb)(struct process*, void*), void *user);
 
 /* console functions */
-extern obj_handle_t inherit_console( struct thread *parent_thread, struct process *parent,
-                                     struct process *process, obj_handle_t hconin );
+extern void inherit_console( struct thread *parent_thread, struct process *parent,
+                             struct process *process, obj_handle_t hconin );
 extern int free_console( struct process *process );
 extern struct thread *console_get_renderer( struct console_input *console );
 
diff --git a/server/protocol.def b/server/protocol.def
index 123f629a48..600113ff02 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -368,6 +368,13 @@ typedef union
     struct winevent_msg_data winevent;
 } message_data_t;
 
+/* structure for console char/attribute info */
+typedef struct
+{
+    WCHAR          ch;
+    unsigned short attr;
+} char_info_t;
+
 /* structure returned in filesystem events */
 struct filesystem_event
 {
@@ -502,7 +509,7 @@ typedef union
         unsigned int     op_type;      /* type of operation */
         client_ptr_t     addr;         /* requested address */
         mem_size_t       size;         /* allocation size */
-        mem_size_t       zero_bits;    /* number of zero high bits */
+        unsigned int     zero_bits_64; /* number of zero high bits */
         unsigned int     prot;         /* memory protection flags */
     } virtual_alloc;
     struct
@@ -553,9 +560,9 @@ typedef union
         client_ptr_t     addr;         /* requested address */
         mem_size_t       size;         /* allocation size */
         file_pos_t       offset;       /* file offset */
-        mem_size_t       zero_bits;    /* number of zero high bits */
         unsigned int     alloc_type;   /* allocation type */
-        unsigned int     prot;         /* memory protection flags */
+        unsigned short   zero_bits_64; /* number of zero high bits */
+        unsigned short   prot;         /* memory protection flags */
     } map_view;
     struct
     {
@@ -566,7 +573,7 @@ typedef union
     struct
     {
         enum apc_type    type;      /* APC_CREATE_THREAD */
-        unsigned int     flags;     /* creation flags */
+        int              suspend;   /* suspended thread? */
         client_ptr_t     func;      /* void (__stdcall *func)(void*);  start function */
         client_ptr_t     arg;       /* argument for start function */
         mem_size_t       reserve;   /* reserve size for thread stack */
@@ -654,9 +661,7 @@ typedef union
     {
         enum apc_type    type;      /* APC_CREATE_THREAD */
         unsigned int     status;    /* status returned by call */
-        process_id_t     pid;       /* process id */
         thread_id_t      tid;       /* thread id */
-        client_ptr_t     teb;       /* thread teb (in process address space) */
         obj_handle_t     handle;    /* handle to new thread */
     } create_thread;
     struct
@@ -849,6 +854,7 @@ struct rawinput_device
     mod_handle_t module;       /* main module base address */
     client_ptr_t ldt_copy;     /* address of LDT copy (in thread address space) */
     client_ptr_t entry;        /* process entry point */
+    obj_handle_t usd_handle;   /* USD mapping handle */
 @REPLY
     int          suspend;      /* is process suspended? */
 @END
@@ -939,7 +945,7 @@ struct rawinput_device
 /* Retrieve information about a thread */
 @REQ(get_thread_info)
     obj_handle_t handle;        /* thread handle */
-    unsigned int access;        /* required access rights */
+    thread_id_t  tid_in;        /* thread id (optional) */
 @REPLY
     process_id_t pid;           /* server process id */
     thread_id_t  tid;           /* server thread id */
@@ -950,7 +956,6 @@ struct rawinput_device
     int          priority;      /* thread priority level */
     int          last;          /* last thread in process */
     int          suspend_count; /* thread suspend count */
-    int          dbg_hidden;    /* thread hidden from debugger */
     data_size_t  desc_len;      /* description length in bytes */
     VARARG(desc,unicode_str);   /* description string */
 @END
@@ -962,8 +967,6 @@ struct rawinput_device
 @REPLY
     timeout_t    creation_time; /* thread creation time */
     timeout_t    exit_time;     /* thread exit time */
-    int          unix_pid;      /* thread native pid */
-    int          unix_tid;      /* thread native pid */
 @END
 
 
@@ -982,7 +985,6 @@ struct rawinput_device
 #define SET_THREAD_INFO_TOKEN       0x04
 #define SET_THREAD_INFO_ENTRYPOINT  0x08
 #define SET_THREAD_INFO_DESCRIPTION 0x10
-#define SET_THREAD_INFO_DBG_HIDDEN  0x20
 
 
 /* Retrieve information about a module */
@@ -1080,12 +1082,6 @@ struct rawinput_device
 #define DUP_HANDLE_MAKE_GLOBAL   0x80000000  /* Not a Windows flag */
 
 
-/* Make an object temporary */
-@REQ(make_temporary)
-    obj_handle_t handle;       /* handle to the object */
-@END
-
-
 /* Open a handle to a process */
 @REQ(open_process)
     process_id_t pid;          /* process id to open */
@@ -1464,6 +1460,7 @@ enum server_fd_type
     int          input_fd;      /* if pid=-1 (bare console to current process), fd for input */
 @REPLY
     obj_handle_t handle_in;     /* handle to console input */
+    obj_handle_t event;         /* handle to renderer events change notification */
 @END
 
 
@@ -1472,9 +1469,77 @@ enum server_fd_type
 @END
 
 
+#define CONSOLE_RENDERER_NONE_EVENT        0x00
+#define CONSOLE_RENDERER_TITLE_EVENT       0x01
+#define CONSOLE_RENDERER_ACTIVE_SB_EVENT   0x02
+#define CONSOLE_RENDERER_SB_RESIZE_EVENT   0x03
+#define CONSOLE_RENDERER_UPDATE_EVENT      0x04
+#define CONSOLE_RENDERER_CURSOR_POS_EVENT  0x05
+#define CONSOLE_RENDERER_CURSOR_GEOM_EVENT 0x06
+#define CONSOLE_RENDERER_DISPLAY_EVENT     0x07
+#define CONSOLE_RENDERER_EXIT_EVENT        0x08
+struct console_renderer_event
+{
+    short event;
+    union
+    {
+        struct
+        {
+            short top;
+            short bottom;
+        } update;
+        struct
+        {
+            short width;
+            short height;
+        } resize;
+        struct
+        {
+            short x;
+            short y;
+        } cursor_pos;
+        struct
+        {
+            short visible;
+            short size;
+        } cursor_geom;
+        struct
+        {
+            short left;
+            short top;
+            short width;
+            short height;
+        } display;
+    } u;
+};
+
+/* retrieve console events for the renderer */
+@REQ(get_console_renderer_events)
+    obj_handle_t handle;        /* handle to console input events */
+@REPLY
+    VARARG(data,bytes);         /* the various console_renderer_events */
+@END
+
+
+/* Open a handle to the process console */
+@REQ(open_console)
+    obj_handle_t from;          /* 0 (resp 1) input (resp output) of current process console */
+                                /* otherwise console_in handle to get active screen buffer? */
+    unsigned int access;        /* wanted access rights */
+    unsigned int attributes;    /* object attributes */
+    int          share;         /* share mask (only for output handles) */
+@REPLY
+    obj_handle_t handle;        /* handle to the console */
+@END
+
+
 /* Attach to a other process's console */
 @REQ(attach_console)
     process_id_t pid;           /* pid of attached console process */
+@REPLY
+    obj_handle_t std_in;        /* attached stdin */
+    obj_handle_t std_out;       /* attached stdout */
+    obj_handle_t std_err;       /* attached stderr */
 @END
 
 
@@ -1485,6 +1550,20 @@ enum server_fd_type
     obj_handle_t event;
 @END
 
+/* Get a console mode (input or output) */
+@REQ(get_console_mode)
+    obj_handle_t handle;        /* handle to the console */
+@REPLY
+    int          mode;          /* console mode */
+@END
+
+
+/* Set a console mode (input or output) */
+@REQ(set_console_mode)
+    obj_handle_t handle;        /* handle to the console */
+    int          mode;          /* console mode */
+@END
+
 
 /* Set info about a console (input only) */
 @REQ(set_console_input_info)
@@ -1499,6 +1578,7 @@ enum server_fd_type
     user_handle_t win;           /* console window if backend supports it */
     VARARG(title,unicode_str);   /* console title */
 @END
+#define SET_CONSOLE_INPUT_INFO_ACTIVE_SB        0x01
 #define SET_CONSOLE_INPUT_INFO_TITLE            0x02
 #define SET_CONSOLE_INPUT_INFO_HISTORY_MODE     0x04
 #define SET_CONSOLE_INPUT_INFO_HISTORY_SIZE     0x08
@@ -1508,6 +1588,21 @@ enum server_fd_type
 #define SET_CONSOLE_INPUT_INFO_WIN              0x80
 
 
+/* Get info about a console (input only) */
+@REQ(get_console_input_info)
+    obj_handle_t  handle;         /* handle to console input, or 0 for process' console */
+@REPLY
+    int           history_mode;   /* whether we duplicate lines in history */
+    int           history_size;   /* number of lines in history */
+    int           history_index;  /* number of used lines in history */
+    int           edition_mode;   /* index to the edition mode flavors */
+    int           input_cp;       /* console input codepage */
+    int           output_cp;      /* console output codepage */
+    user_handle_t win;            /* console window if backend supports it */
+    VARARG(title,unicode_str);    /* console title */
+@END
+
+
 /* appends a string to console's history */
 @REQ(append_console_input_history)
     obj_handle_t handle;        /* handle to console input, or 0 for process' console */
@@ -1537,6 +1632,149 @@ enum server_fd_type
 @END
 
 
+/* Set info about a console (output only) */
+@REQ(set_console_output_info)
+    obj_handle_t handle;        /* handle to the console */
+    int          mask;          /* setting mask (see below) */
+    short int    cursor_size;   /* size of cursor (percentage filled) */
+    short int    cursor_visible;/* cursor visibility flag */
+    short int    cursor_x;      /* position of cursor (x, y) */
+    short int    cursor_y;
+    short int    width;         /* width of the screen buffer */
+    short int    height;        /* height of the screen buffer */
+    short int    attr;          /* default fill attributes (screen colors) */
+    short int    popup_attr;    /* pop-up color attributes */
+    short int    win_left;      /* window actually displayed by renderer */
+    short int    win_top;       /* the rect area is expressed within the */
+    short int    win_right;     /* boundaries of the screen buffer */
+    short int    win_bottom;
+    short int    max_width;     /* maximum size (width x height) for the window */
+    short int    max_height;
+    short int    font_width;    /* font size (width x height) */
+    short int    font_height;
+    short int    font_weight;   /* font weight */
+    short int    font_pitch_family; /* font pitch & family */
+    VARARG(colors,uints,64);    /* color table */
+    VARARG(face_name,unicode_str);  /* font face name */
+@END
+#define SET_CONSOLE_OUTPUT_INFO_CURSOR_GEOM     0x0001
+#define SET_CONSOLE_OUTPUT_INFO_CURSOR_POS      0x0002
+#define SET_CONSOLE_OUTPUT_INFO_SIZE            0x0004
+#define SET_CONSOLE_OUTPUT_INFO_ATTR            0x0008
+#define SET_CONSOLE_OUTPUT_INFO_DISPLAY_WINDOW  0x0010
+#define SET_CONSOLE_OUTPUT_INFO_MAX_SIZE        0x0020
+#define SET_CONSOLE_OUTPUT_INFO_FONT            0x0040
+#define SET_CONSOLE_OUTPUT_INFO_COLORTABLE      0x0080
+#define SET_CONSOLE_OUTPUT_INFO_POPUP_ATTR      0x0100
+
+
+/* Get info about a console (output only) */
+@REQ(get_console_output_info)
+    obj_handle_t handle;        /* handle to the console */
+@REPLY
+    short int    cursor_size;   /* size of cursor (percentage filled) */
+    short int    cursor_visible;/* cursor visibility flag */
+    short int    cursor_x;      /* position of cursor (x, y) */
+    short int    cursor_y;
+    short int    width;         /* width of the screen buffer */
+    short int    height;        /* height of the screen buffer */
+    short int    attr;          /* default fill attributes (screen colors) */
+    short int    popup_attr;    /* pop-up color attributes */
+    short int    win_left;      /* window actually displayed by renderer */
+    short int    win_top;       /* the rect area is expressed within the */
+    short int    win_right;     /* boundaries of the screen buffer */
+    short int    win_bottom;
+    short int    max_width;     /* maximum size (width x height) for the window */
+    short int    max_height;
+    short int    font_width;    /* font size (width x height) */
+    short int    font_height;
+    short int    font_weight;   /* font weight */
+    short int    font_pitch_family; /* font pitch & family */
+    VARARG(colors,uints,64);    /* color table */
+    VARARG(face_name,unicode_str);  /* font face name */
+@END
+
+/* Add input records to a console input queue */
+@REQ(write_console_input)
+    obj_handle_t handle;        /* handle to the console input */
+    VARARG(rec,input_records);  /* input records */
+@REPLY
+    int          written;       /* number of records written */
+@END
+
+
+/* Fetch input records from a console input queue */
+@REQ(read_console_input)
+    obj_handle_t handle;        /* handle to the console input */
+    int          flush;         /* flush the retrieved records from the queue? */
+@REPLY
+    int          read;          /* number of records read */
+    VARARG(rec,input_records);  /* input records */
+@END
+
+
+/* write data (chars and/or attributes) in a screen buffer */
+@REQ(write_console_output)
+    obj_handle_t handle;        /* handle to the console output */
+    int          x;             /* position where to start writing */
+    int          y;
+    int          mode;          /* char info (see below) */
+    int          wrap;          /* wrap around at end of line? */
+    VARARG(data,bytes);         /* info to write */
+@REPLY
+    int          written;       /* number of char infos actually written */
+    int          width;         /* width of screen buffer */
+    int          height;        /* height of screen buffer */
+@END
+enum char_info_mode
+{
+    CHAR_INFO_MODE_TEXT,        /* characters only */
+    CHAR_INFO_MODE_ATTR,        /* attributes only */
+    CHAR_INFO_MODE_TEXTATTR,    /* both characters and attributes */
+    CHAR_INFO_MODE_TEXTSTDATTR  /* characters but use standard attributes */
+};
+
+
+/* fill a screen buffer with constant data (chars and/or attributes) */
+@REQ(fill_console_output)
+    obj_handle_t handle;        /* handle to the console output */
+    int          x;             /* position where to start writing */
+    int          y;
+    int          mode;          /* char info mode */
+    int          count;         /* number to write */
+    int          wrap;          /* wrap around at end of line? */
+    char_info_t  data;          /* data to write */
+@REPLY
+    int          written;       /* number of char infos actually written */
+@END
+
+
+/* read data (chars and/or attributes) from a screen buffer */
+@REQ(read_console_output)
+    obj_handle_t handle;        /* handle to the console output */
+    int          x;             /* position (x,y) where to start reading */
+    int          y;
+    int          mode;          /* char info mode */
+    int          wrap;          /* wrap around at end of line? */
+@REPLY
+    int          width;         /* width of screen buffer */
+    int          height;        /* height of screen buffer */
+    VARARG(data,bytes);
+@END
+
+
+/* move a rect (of data) in screen buffer content */
+@REQ(move_console_output)
+    obj_handle_t handle;        /* handle to the console output */
+    short int    x_src;         /* position (x, y) of rect to start moving from */
+    short int    y_src;
+    short int    x_dst;         /* position (x, y) of rect to move to */
+    short int    y_dst;
+    short int    w;             /* size of the rect (width, height) to move */
+    short int    h;
+@END
+
+
 /* Sends a signal to a process group */
 @REQ(send_console_signal)
     int          signal;        /* the signal to send */
@@ -1637,36 +1875,43 @@ enum server_fd_type
 @END
 
 
-struct thread_info
-{
-    timeout_t       start_time;
-    thread_id_t     tid;
-    int             base_priority;
-    int             current_priority;
-    int             unix_tid;
-};
+#define SNAP_PROCESS    0x00000001
+#define SNAP_THREAD     0x00000002
+/* Create a snapshot */
+@REQ(create_snapshot)
+    unsigned int attributes;    /* object attributes */
+    unsigned int flags;         /* snapshot flags (SNAP_*) */
+@REPLY
+    obj_handle_t handle;        /* handle to the snapshot */
+@END
+
+
+/* Get the next process from a snapshot */
+@REQ(next_process)
+    obj_handle_t handle;        /* handle to the snapshot */
+    int          reset;         /* reset snapshot position? */
+@REPLY
+    int          count;         /* process usage count */
+    process_id_t pid;           /* process id */
+    process_id_t ppid;          /* parent process id */
+    int          threads;       /* number of threads */
+    int          priority;      /* process priority */
+    int          handles;       /* number of handles */
+    int          unix_pid;      /* Unix pid */
+    VARARG(filename,unicode_str); /* file name of main exe */
+@END
 
-struct process_info
-{
-    timeout_t       start_time;
-    data_size_t     name_len;
-    int             thread_count;
-    int             priority;
-    process_id_t    pid;
-    process_id_t    parent_pid;
-    int             handle_count;
-    int             unix_pid;
-    int             __pad;
-    /* VARARG(name,unicode_str,name_len); */
-    /* VARARG(threads,struct thread_info,thread_count); */
-};
 
-/* Get a list of processes and threads currently running */
-@REQ(list_processes)
+/* Get the next thread from a snapshot */
+@REQ(next_thread)
+    obj_handle_t handle;        /* handle to the snapshot */
+    int          reset;         /* reset snapshot position? */
 @REPLY
-    data_size_t     info_size;
-    int             process_count;
-    VARARG(data,process_info,info_size);
+    int          count;         /* thread usage count */
+    process_id_t pid;           /* process id */
+    thread_id_t  tid;           /* thread id */
+    int          base_pri;      /* base priority */
+    int          delta_pri;     /* delta priority */
 @END
 
 
@@ -2124,9 +2369,10 @@ enum message_type
 @END
 
 
-/* Accept and remove the current hardware message */
+/* Accept the current hardware message */
 @REQ(accept_hardware_message)
     unsigned int    hw_id;     /* id of the hardware message */
+    int             remove;    /* should we remove the message? */
 @END
 
 
@@ -3362,6 +3608,12 @@ struct handle_info
 @END
 
 
+/* Unlink a named object */
+@REQ(unlink_object)
+    obj_handle_t   handle;        /* handle to the object */
+@END
+
+
 /* Query the impersonation level of an impersonation token */
 @REQ(get_token_impersonation_level)
     obj_handle_t   handle;        /* handle to the object */
@@ -3628,27 +3880,11 @@ struct handle_info
 #define SET_CURSOR_NOCLIP 0x10
 
 
-/* Batch read rawinput message data */
-@REQ(get_rawinput_buffer)
-    data_size_t rawinput_size; /* size of RAWINPUT structure */
-    data_size_t buffer_size;   /* size of output buffer */
-@REPLY
-    data_size_t next_size; /* minimum size to get next message data */
-    unsigned int count;
-    VARARG(data,bytes);
-@END
-
 /* Modify the list of registered rawinput devices */
 @REQ(update_rawinput_devices)
     VARARG(devices,rawinput_devices);
 @END
 
-/* Retrieve the list of registered rawinput devices */
-@REQ(get_rawinput_devices)
-@REPLY
-    unsigned int device_count;
-    VARARG(devices,rawinput_devices);
-@END
 
 /* Create a new job object */
 @REQ(create_job)
@@ -3699,15 +3935,6 @@ struct handle_info
 @END
 
 
-/* Retrieve information about a job */
-@REQ(get_job_info)
-    obj_handle_t handle;          /* handle to the job */
-@REPLY
-    int total_processes;          /* total count of processes */
-    int active_processes;         /* count of running processes */
-@END
-
-
 /* Terminate all processes associated with the job  */
 @REQ(terminate_job)
     obj_handle_t handle;          /* handle to the job */
diff --git a/server/queue.c b/server/queue.c
index c101601605..c3925dd664 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1384,11 +1384,11 @@ static void update_desktop_mouse_state( struct desktop *desktop, unsigned int fl
 }
 
 /* release the hardware message currently being processed by the given thread */
-static void release_hardware_message( struct msg_queue *queue, unsigned int hw_id )
+static void release_hardware_message( struct msg_queue *queue, unsigned int hw_id,
+                                      int remove )
 {
     struct thread_input *input = queue->input;
-    struct message *msg, *other;
-    int clr_bit;
+    struct message *msg;
 
     LIST_FOR_EACH_ENTRY( msg, &input->msg_list, struct message, entry )
     {
@@ -1397,20 +1397,26 @@ static void release_hardware_message( struct msg_queue *queue, unsigned int hw_i
     if (&msg->entry == &input->msg_list) return;  /* not found */
 
     /* clear the queue bit for that message */
-    clr_bit = get_hardware_msg_bit( msg );
-    LIST_FOR_EACH_ENTRY( other, &input->msg_list, struct message, entry )
+    if (remove)
     {
-        if (other != msg && get_hardware_msg_bit( other ) == clr_bit)
+        struct message *other;
+        int clr_bit;
+
+        clr_bit = get_hardware_msg_bit( msg );
+        LIST_FOR_EACH_ENTRY( other, &input->msg_list, struct message, entry )
         {
-            clr_bit = 0;
-            break;
+            if (other != msg && get_hardware_msg_bit( other ) == clr_bit)
+            {
+                clr_bit = 0;
+                break;
+            }
         }
-    }
-    if (clr_bit) clear_queue_bits( queue, clr_bit );
+        if (clr_bit) clear_queue_bits( queue, clr_bit );
 
-    update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
-    list_remove( &msg->entry );
-    free_message( msg );
+        update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+        list_remove( &msg->entry );
+        free_message( msg );
+    }
 }
 
 static int queue_hotkey_message( struct desktop *desktop, struct message *msg )
@@ -2074,7 +2080,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
         data->hw_id = msg->unique_id;
         set_reply_data( msg->data, msg->data_size );
         if (msg->msg == WM_INPUT && (flags & PM_REMOVE))
-            release_hardware_message( current->queue, data->hw_id );
+            release_hardware_message( current->queue, data->hw_id, 1 );
         return 1;
     }
     /* nothing found, clear the hardware queue bits */
@@ -2600,7 +2606,7 @@ DECL_HANDLER(reply_message)
 DECL_HANDLER(accept_hardware_message)
 {
     if (current->queue)
-        release_hardware_message( current->queue, req->hw_id );
+        release_hardware_message( current->queue, req->hw_id, req->remove );
     else
         set_error( STATUS_ACCESS_DENIED );
 }
@@ -3220,46 +3226,6 @@ DECL_HANDLER(set_cursor)
     reply->last_change = input->desktop->cursor.last_change;
 }
 
-DECL_HANDLER(get_rawinput_buffer)
-{
-    struct thread_input *input = current->queue->input;
-    data_size_t size = 0, next_size = 0;
-    struct list *ptr;
-    char *buf, *cur;
-    int count = 0;
-
-    if (!req->buffer_size) buf = NULL;
-    else if (!(buf = mem_alloc( get_reply_max_size() )))
-        return;
-
-    cur = buf;
-    ptr = list_head( &input->msg_list );
-    while (ptr)
-    {
-        struct message *msg = LIST_ENTRY( ptr, struct message, entry );
-        struct hardware_msg_data *data = msg->data;
-
-        ptr = list_next( &input->msg_list, ptr );
-        if (msg->msg != WM_INPUT) continue;
-
-        next_size = req->rawinput_size;
-        if (size + next_size > req->buffer_size) break;
-        if (cur + sizeof(*data) > buf + get_reply_max_size()) break;
-
-        memcpy(cur, data, sizeof(*data));
-        list_remove( &msg->entry );
-        free_message( msg );
-
-        size += next_size;
-        cur += sizeof(*data);
-        count++;
-    }
-
-    reply->next_size = next_size;
-    reply->count = count;
-    set_reply_data_ptr( buf, cur - buf );
-}
-
 DECL_HANDLER(update_rawinput_devices)
 {
     const struct rawinput_device *devices = get_req_data();
@@ -3277,24 +3243,3 @@ DECL_HANDLER(update_rawinput_devices)
     e = find_rawinput_device( 1, 6 );
     current->process->rawinput_kbd   = e ? &e->device : NULL;
 }
-
-DECL_HANDLER(get_rawinput_devices)
-{
-    struct rawinput_device_entry *e;
-    struct rawinput_device *devices;
-    unsigned int i = 0, device_count = list_count( &current->process->rawinput_devices );
-    unsigned int size = device_count * sizeof(*devices);
-
-    reply->device_count = device_count;
-
-    /* no buffer provided, nothing else to do */
-    if (!get_reply_max_size()) return;
-
-    if (size > get_reply_max_size())
-        set_error( STATUS_BUFFER_TOO_SMALL );
-    else if ((devices = set_reply_data_size( size )))
-    {
-        LIST_FOR_EACH_ENTRY( e, &current->process->rawinput_devices, struct rawinput_device_entry, entry )
-            devices[i++] = e->device;
-    }
-}
diff --git a/server/request.h b/server/request.h
index 4dff87e8b9..4a65296eb5 100644
--- a/server/request.h
+++ b/server/request.h
@@ -144,7 +144,6 @@ DECL_HANDLER(get_apc_result);
 DECL_HANDLER(close_handle);
 DECL_HANDLER(set_handle_info);
 DECL_HANDLER(dup_handle);
-DECL_HANDLER(make_temporary);
 DECL_HANDLER(open_process);
 DECL_HANDLER(open_thread);
 DECL_HANDLER(select);
@@ -183,12 +182,25 @@ DECL_HANDLER(enable_socket_event);
 DECL_HANDLER(set_socket_deferred);
 DECL_HANDLER(alloc_console);
 DECL_HANDLER(free_console);
+DECL_HANDLER(get_console_renderer_events);
+DECL_HANDLER(open_console);
 DECL_HANDLER(attach_console);
 DECL_HANDLER(get_console_wait_event);
+DECL_HANDLER(get_console_mode);
+DECL_HANDLER(set_console_mode);
 DECL_HANDLER(set_console_input_info);
+DECL_HANDLER(get_console_input_info);
 DECL_HANDLER(append_console_input_history);
 DECL_HANDLER(get_console_input_history);
 DECL_HANDLER(create_console_output);
+DECL_HANDLER(set_console_output_info);
+DECL_HANDLER(get_console_output_info);
+DECL_HANDLER(write_console_input);
+DECL_HANDLER(read_console_input);
+DECL_HANDLER(write_console_output);
+DECL_HANDLER(fill_console_output);
+DECL_HANDLER(read_console_output);
+DECL_HANDLER(move_console_output);
 DECL_HANDLER(send_console_signal);
 DECL_HANDLER(read_directory_changes);
 DECL_HANDLER(read_change);
@@ -200,7 +212,9 @@ DECL_HANDLER(unmap_view);
 DECL_HANDLER(get_mapping_committed_range);
 DECL_HANDLER(add_mapping_committed_range);
 DECL_HANDLER(is_same_mapping);
-DECL_HANDLER(list_processes);
+DECL_HANDLER(create_snapshot);
+DECL_HANDLER(next_process);
+DECL_HANDLER(next_thread);
 DECL_HANDLER(wait_debug_event);
 DECL_HANDLER(queue_exception_event);
 DECL_HANDLER(get_exception_status);
@@ -361,6 +375,7 @@ DECL_HANDLER(open_symlink);
 DECL_HANDLER(query_symlink);
 DECL_HANDLER(get_object_info);
 DECL_HANDLER(get_object_type);
+DECL_HANDLER(unlink_object);
 DECL_HANDLER(get_token_impersonation_level);
 DECL_HANDLER(allocate_locally_unique_id);
 DECL_HANDLER(create_device_manager);
@@ -389,16 +404,13 @@ DECL_HANDLER(set_window_layered_info);
 DECL_HANDLER(alloc_user_handle);
 DECL_HANDLER(free_user_handle);
 DECL_HANDLER(set_cursor);
-DECL_HANDLER(get_rawinput_buffer);
 DECL_HANDLER(update_rawinput_devices);
-DECL_HANDLER(get_rawinput_devices);
 DECL_HANDLER(create_job);
 DECL_HANDLER(open_job);
 DECL_HANDLER(assign_job);
 DECL_HANDLER(process_in_job);
 DECL_HANDLER(set_job_limits);
 DECL_HANDLER(set_job_completion_port);
-DECL_HANDLER(get_job_info);
 DECL_HANDLER(terminate_job);
 DECL_HANDLER(suspend_process);
 DECL_HANDLER(resume_process);
@@ -433,7 +445,6 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_close_handle,
     (req_handler)req_set_handle_info,
     (req_handler)req_dup_handle,
-    (req_handler)req_make_temporary,
     (req_handler)req_open_process,
     (req_handler)req_open_thread,
     (req_handler)req_select,
@@ -472,12 +483,25 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_set_socket_deferred,
     (req_handler)req_alloc_console,
     (req_handler)req_free_console,
+    (req_handler)req_get_console_renderer_events,
+    (req_handler)req_open_console,
     (req_handler)req_attach_console,
     (req_handler)req_get_console_wait_event,
+    (req_handler)req_get_console_mode,
+    (req_handler)req_set_console_mode,
     (req_handler)req_set_console_input_info,
+    (req_handler)req_get_console_input_info,
     (req_handler)req_append_console_input_history,
     (req_handler)req_get_console_input_history,
     (req_handler)req_create_console_output,
+    (req_handler)req_set_console_output_info,
+    (req_handler)req_get_console_output_info,
+    (req_handler)req_write_console_input,
+    (req_handler)req_read_console_input,
+    (req_handler)req_write_console_output,
+    (req_handler)req_fill_console_output,
+    (req_handler)req_read_console_output,
+    (req_handler)req_move_console_output,
     (req_handler)req_send_console_signal,
     (req_handler)req_read_directory_changes,
     (req_handler)req_read_change,
@@ -489,7 +513,9 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_get_mapping_committed_range,
     (req_handler)req_add_mapping_committed_range,
     (req_handler)req_is_same_mapping,
-    (req_handler)req_list_processes,
+    (req_handler)req_create_snapshot,
+    (req_handler)req_next_process,
+    (req_handler)req_next_thread,
     (req_handler)req_wait_debug_event,
     (req_handler)req_queue_exception_event,
     (req_handler)req_get_exception_status,
@@ -650,6 +676,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_query_symlink,
     (req_handler)req_get_object_info,
     (req_handler)req_get_object_type,
+    (req_handler)req_unlink_object,
     (req_handler)req_get_token_impersonation_level,
     (req_handler)req_allocate_locally_unique_id,
     (req_handler)req_create_device_manager,
@@ -678,16 +705,13 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_alloc_user_handle,
     (req_handler)req_free_user_handle,
     (req_handler)req_set_cursor,
-    (req_handler)req_get_rawinput_buffer,
     (req_handler)req_update_rawinput_devices,
-    (req_handler)req_get_rawinput_devices,
     (req_handler)req_create_job,
     (req_handler)req_open_job,
     (req_handler)req_assign_job,
     (req_handler)req_process_in_job,
     (req_handler)req_set_job_limits,
     (req_handler)req_set_job_completion_port,
-    (req_handler)req_get_job_info,
     (req_handler)req_terminate_job,
     (req_handler)req_suspend_process,
     (req_handler)req_resume_process,
@@ -695,12 +719,13 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
 
 C_ASSERT( sizeof(abstime_t) == 8 );
 C_ASSERT( sizeof(affinity_t) == 8 );
-C_ASSERT( sizeof(apc_call_t) == 48 );
+C_ASSERT( sizeof(apc_call_t) == 40 );
 C_ASSERT( sizeof(apc_param_t) == 8 );
 C_ASSERT( sizeof(apc_result_t) == 40 );
 C_ASSERT( sizeof(async_data_t) == 40 );
 C_ASSERT( sizeof(atom_t) == 4 );
 C_ASSERT( sizeof(char) == 1 );
+C_ASSERT( sizeof(char_info_t) == 4 );
 C_ASSERT( sizeof(client_cpu_t) == 4 );
 C_ASSERT( sizeof(client_ptr_t) == 8 );
 C_ASSERT( sizeof(data_size_t) == 4 );
@@ -759,7 +784,8 @@ C_ASSERT( FIELD_OFFSET(struct init_process_done_request, gui) == 12 );
 C_ASSERT( FIELD_OFFSET(struct init_process_done_request, module) == 16 );
 C_ASSERT( FIELD_OFFSET(struct init_process_done_request, ldt_copy) == 24 );
 C_ASSERT( FIELD_OFFSET(struct init_process_done_request, entry) == 32 );
-C_ASSERT( sizeof(struct init_process_done_request) == 40 );
+C_ASSERT( FIELD_OFFSET(struct init_process_done_request, usd_handle) == 40 );
+C_ASSERT( sizeof(struct init_process_done_request) == 48 );
 C_ASSERT( FIELD_OFFSET(struct init_process_done_reply, suspend) == 8 );
 C_ASSERT( sizeof(struct init_process_done_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct init_thread_request, unix_pid) == 12 );
@@ -818,7 +844,7 @@ C_ASSERT( FIELD_OFFSET(struct set_process_info_request, priority) == 20 );
 C_ASSERT( FIELD_OFFSET(struct set_process_info_request, affinity) == 24 );
 C_ASSERT( sizeof(struct set_process_info_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_request, handle) == 12 );
-C_ASSERT( FIELD_OFFSET(struct get_thread_info_request, access) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_thread_info_request, tid_in) == 16 );
 C_ASSERT( sizeof(struct get_thread_info_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, pid) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, tid) == 12 );
@@ -829,16 +855,13 @@ C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, exit_code) == 40 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, priority) == 44 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, last) == 48 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, suspend_count) == 52 );
-C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, dbg_hidden) == 56 );
-C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, desc_len) == 60 );
+C_ASSERT( FIELD_OFFSET(struct get_thread_info_reply, desc_len) == 56 );
 C_ASSERT( sizeof(struct get_thread_info_reply) == 64 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_times_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_thread_times_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, creation_time) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, exit_time) == 16 );
-C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, unix_pid) == 24 );
-C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, unix_tid) == 28 );
-C_ASSERT( sizeof(struct get_thread_times_reply) == 32 );
+C_ASSERT( sizeof(struct get_thread_times_reply) == 24 );
 C_ASSERT( FIELD_OFFSET(struct set_thread_info_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_thread_info_request, mask) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_thread_info_request, priority) == 20 );
@@ -869,7 +892,7 @@ C_ASSERT( FIELD_OFFSET(struct unload_dll_request, base) == 16 );
 C_ASSERT( sizeof(struct unload_dll_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct queue_apc_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct queue_apc_request, call) == 16 );
-C_ASSERT( sizeof(struct queue_apc_request) == 64 );
+C_ASSERT( sizeof(struct queue_apc_request) == 56 );
 C_ASSERT( FIELD_OFFSET(struct queue_apc_reply, handle) == 8 );
 C_ASSERT( FIELD_OFFSET(struct queue_apc_reply, self) == 12 );
 C_ASSERT( sizeof(struct queue_apc_reply) == 16 );
@@ -896,8 +919,6 @@ C_ASSERT( FIELD_OFFSET(struct dup_handle_reply, handle) == 8 );
 C_ASSERT( FIELD_OFFSET(struct dup_handle_reply, self) == 12 );
 C_ASSERT( FIELD_OFFSET(struct dup_handle_reply, closed) == 16 );
 C_ASSERT( sizeof(struct dup_handle_reply) == 24 );
-C_ASSERT( FIELD_OFFSET(struct make_temporary_request, handle) == 12 );
-C_ASSERT( sizeof(struct make_temporary_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct open_process_request, pid) == 12 );
 C_ASSERT( FIELD_OFFSET(struct open_process_request, access) == 16 );
 C_ASSERT( FIELD_OFFSET(struct open_process_request, attributes) == 20 );
@@ -917,8 +938,8 @@ C_ASSERT( FIELD_OFFSET(struct select_request, size) == 32 );
 C_ASSERT( FIELD_OFFSET(struct select_request, prev_apc) == 36 );
 C_ASSERT( sizeof(struct select_request) == 40 );
 C_ASSERT( FIELD_OFFSET(struct select_reply, call) == 8 );
-C_ASSERT( FIELD_OFFSET(struct select_reply, apc_handle) == 56 );
-C_ASSERT( sizeof(struct select_reply) == 64 );
+C_ASSERT( FIELD_OFFSET(struct select_reply, apc_handle) == 48 );
+C_ASSERT( sizeof(struct select_reply) == 56 );
 C_ASSERT( FIELD_OFFSET(struct create_event_request, access) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_event_request, manual_reset) == 16 );
 C_ASSERT( FIELD_OFFSET(struct create_event_request, initial_state) == 20 );
@@ -1108,14 +1129,36 @@ C_ASSERT( FIELD_OFFSET(struct alloc_console_request, pid) == 20 );
 C_ASSERT( FIELD_OFFSET(struct alloc_console_request, input_fd) == 24 );
 C_ASSERT( sizeof(struct alloc_console_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct alloc_console_reply, handle_in) == 8 );
+C_ASSERT( FIELD_OFFSET(struct alloc_console_reply, event) == 12 );
 C_ASSERT( sizeof(struct alloc_console_reply) == 16 );
 C_ASSERT( sizeof(struct free_console_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_console_renderer_events_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_console_renderer_events_request) == 16 );
+C_ASSERT( sizeof(struct get_console_renderer_events_reply) == 8 );
+C_ASSERT( FIELD_OFFSET(struct open_console_request, from) == 12 );
+C_ASSERT( FIELD_OFFSET(struct open_console_request, access) == 16 );
+C_ASSERT( FIELD_OFFSET(struct open_console_request, attributes) == 20 );
+C_ASSERT( FIELD_OFFSET(struct open_console_request, share) == 24 );
+C_ASSERT( sizeof(struct open_console_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct open_console_reply, handle) == 8 );
+C_ASSERT( sizeof(struct open_console_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct attach_console_request, pid) == 12 );
 C_ASSERT( sizeof(struct attach_console_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct attach_console_reply, std_in) == 8 );
+C_ASSERT( FIELD_OFFSET(struct attach_console_reply, std_out) == 12 );
+C_ASSERT( FIELD_OFFSET(struct attach_console_reply, std_err) == 16 );
+C_ASSERT( sizeof(struct attach_console_reply) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_console_wait_event_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_console_wait_event_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_console_wait_event_reply, event) == 8 );
 C_ASSERT( sizeof(struct get_console_wait_event_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_console_mode_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_console_mode_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_console_mode_reply, mode) == 8 );
+C_ASSERT( sizeof(struct get_console_mode_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct set_console_mode_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct set_console_mode_request, mode) == 16 );
+C_ASSERT( sizeof(struct set_console_mode_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct set_console_input_info_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_console_input_info_request, mask) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_console_input_info_request, active_sb) == 20 );
@@ -1126,6 +1169,16 @@ C_ASSERT( FIELD_OFFSET(struct set_console_input_info_request, input_cp) == 36 );
 C_ASSERT( FIELD_OFFSET(struct set_console_input_info_request, output_cp) == 40 );
 C_ASSERT( FIELD_OFFSET(struct set_console_input_info_request, win) == 44 );
 C_ASSERT( sizeof(struct set_console_input_info_request) == 48 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_console_input_info_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_reply, history_mode) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_reply, history_size) == 12 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_reply, history_index) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_reply, edition_mode) == 20 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_reply, input_cp) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_reply, output_cp) == 28 );
+C_ASSERT( FIELD_OFFSET(struct get_console_input_info_reply, win) == 32 );
+C_ASSERT( sizeof(struct get_console_input_info_reply) == 40 );
 C_ASSERT( FIELD_OFFSET(struct append_console_input_history_request, handle) == 12 );
 C_ASSERT( sizeof(struct append_console_input_history_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_console_input_history_request, handle) == 12 );
@@ -1141,6 +1194,94 @@ C_ASSERT( FIELD_OFFSET(struct create_console_output_request, fd) == 28 );
 C_ASSERT( sizeof(struct create_console_output_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct create_console_output_reply, handle_out) == 8 );
 C_ASSERT( sizeof(struct create_console_output_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, mask) == 16 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, cursor_size) == 20 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, cursor_visible) == 22 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, cursor_x) == 24 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, cursor_y) == 26 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, width) == 28 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, height) == 30 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, attr) == 32 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, popup_attr) == 34 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, win_left) == 36 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, win_top) == 38 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, win_right) == 40 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, win_bottom) == 42 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, max_width) == 44 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, max_height) == 46 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, font_width) == 48 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, font_height) == 50 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, font_weight) == 52 );
+C_ASSERT( FIELD_OFFSET(struct set_console_output_info_request, font_pitch_family) == 54 );
+C_ASSERT( sizeof(struct set_console_output_info_request) == 56 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_console_output_info_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, cursor_size) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, cursor_visible) == 10 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, cursor_x) == 12 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, cursor_y) == 14 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, width) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, height) == 18 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, attr) == 20 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, popup_attr) == 22 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, win_left) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, win_top) == 26 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, win_right) == 28 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, win_bottom) == 30 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, max_width) == 32 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, max_height) == 34 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, font_width) == 36 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, font_height) == 38 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, font_weight) == 40 );
+C_ASSERT( FIELD_OFFSET(struct get_console_output_info_reply, font_pitch_family) == 42 );
+C_ASSERT( sizeof(struct get_console_output_info_reply) == 48 );
+C_ASSERT( FIELD_OFFSET(struct write_console_input_request, handle) == 12 );
+C_ASSERT( sizeof(struct write_console_input_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct write_console_input_reply, written) == 8 );
+C_ASSERT( sizeof(struct write_console_input_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct read_console_input_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct read_console_input_request, flush) == 16 );
+C_ASSERT( sizeof(struct read_console_input_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct read_console_input_reply, read) == 8 );
+C_ASSERT( sizeof(struct read_console_input_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_request, x) == 16 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_request, y) == 20 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_request, mode) == 24 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_request, wrap) == 28 );
+C_ASSERT( sizeof(struct write_console_output_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_reply, written) == 8 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_reply, width) == 12 );
+C_ASSERT( FIELD_OFFSET(struct write_console_output_reply, height) == 16 );
+C_ASSERT( sizeof(struct write_console_output_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_request, x) == 16 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_request, y) == 20 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_request, mode) == 24 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_request, count) == 28 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_request, wrap) == 32 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_request, data) == 36 );
+C_ASSERT( sizeof(struct fill_console_output_request) == 40 );
+C_ASSERT( FIELD_OFFSET(struct fill_console_output_reply, written) == 8 );
+C_ASSERT( sizeof(struct fill_console_output_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct read_console_output_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct read_console_output_request, x) == 16 );
+C_ASSERT( FIELD_OFFSET(struct read_console_output_request, y) == 20 );
+C_ASSERT( FIELD_OFFSET(struct read_console_output_request, mode) == 24 );
+C_ASSERT( FIELD_OFFSET(struct read_console_output_request, wrap) == 28 );
+C_ASSERT( sizeof(struct read_console_output_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct read_console_output_reply, width) == 8 );
+C_ASSERT( FIELD_OFFSET(struct read_console_output_reply, height) == 12 );
+C_ASSERT( sizeof(struct read_console_output_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct move_console_output_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct move_console_output_request, x_src) == 16 );
+C_ASSERT( FIELD_OFFSET(struct move_console_output_request, y_src) == 18 );
+C_ASSERT( FIELD_OFFSET(struct move_console_output_request, x_dst) == 20 );
+C_ASSERT( FIELD_OFFSET(struct move_console_output_request, y_dst) == 22 );
+C_ASSERT( FIELD_OFFSET(struct move_console_output_request, w) == 24 );
+C_ASSERT( FIELD_OFFSET(struct move_console_output_request, h) == 26 );
+C_ASSERT( sizeof(struct move_console_output_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct send_console_signal_request, signal) == 12 );
 C_ASSERT( FIELD_OFFSET(struct send_console_signal_request, group_id) == 16 );
 C_ASSERT( sizeof(struct send_console_signal_request) == 24 );
@@ -1194,10 +1335,31 @@ C_ASSERT( sizeof(struct add_mapping_committed_range_request) == 40 );
 C_ASSERT( FIELD_OFFSET(struct is_same_mapping_request, base1) == 16 );
 C_ASSERT( FIELD_OFFSET(struct is_same_mapping_request, base2) == 24 );
 C_ASSERT( sizeof(struct is_same_mapping_request) == 32 );
-C_ASSERT( sizeof(struct list_processes_request) == 16 );
-C_ASSERT( FIELD_OFFSET(struct list_processes_reply, info_size) == 8 );
-C_ASSERT( FIELD_OFFSET(struct list_processes_reply, process_count) == 12 );
-C_ASSERT( sizeof(struct list_processes_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct create_snapshot_request, attributes) == 12 );
+C_ASSERT( FIELD_OFFSET(struct create_snapshot_request, flags) == 16 );
+C_ASSERT( sizeof(struct create_snapshot_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct create_snapshot_reply, handle) == 8 );
+C_ASSERT( sizeof(struct create_snapshot_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct next_process_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct next_process_request, reset) == 16 );
+C_ASSERT( sizeof(struct next_process_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct next_process_reply, count) == 8 );
+C_ASSERT( FIELD_OFFSET(struct next_process_reply, pid) == 12 );
+C_ASSERT( FIELD_OFFSET(struct next_process_reply, ppid) == 16 );
+C_ASSERT( FIELD_OFFSET(struct next_process_reply, threads) == 20 );
+C_ASSERT( FIELD_OFFSET(struct next_process_reply, priority) == 24 );
+C_ASSERT( FIELD_OFFSET(struct next_process_reply, handles) == 28 );
+C_ASSERT( FIELD_OFFSET(struct next_process_reply, unix_pid) == 32 );
+C_ASSERT( sizeof(struct next_process_reply) == 40 );
+C_ASSERT( FIELD_OFFSET(struct next_thread_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct next_thread_request, reset) == 16 );
+C_ASSERT( sizeof(struct next_thread_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct next_thread_reply, count) == 8 );
+C_ASSERT( FIELD_OFFSET(struct next_thread_reply, pid) == 12 );
+C_ASSERT( FIELD_OFFSET(struct next_thread_reply, tid) == 16 );
+C_ASSERT( FIELD_OFFSET(struct next_thread_reply, base_pri) == 20 );
+C_ASSERT( FIELD_OFFSET(struct next_thread_reply, delta_pri) == 24 );
+C_ASSERT( sizeof(struct next_thread_reply) == 32 );
 C_ASSERT( FIELD_OFFSET(struct wait_debug_event_request, get_handle) == 12 );
 C_ASSERT( sizeof(struct wait_debug_event_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct wait_debug_event_reply, pid) == 8 );
@@ -1431,7 +1593,8 @@ C_ASSERT( FIELD_OFFSET(struct reply_message_request, remove) == 12 );
 C_ASSERT( FIELD_OFFSET(struct reply_message_request, result) == 16 );
 C_ASSERT( sizeof(struct reply_message_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct accept_hardware_message_request, hw_id) == 12 );
-C_ASSERT( sizeof(struct accept_hardware_message_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct accept_hardware_message_request, remove) == 16 );
+C_ASSERT( sizeof(struct accept_hardware_message_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_message_reply_request, cancel) == 12 );
 C_ASSERT( sizeof(struct get_message_reply_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_message_reply_reply, result) == 8 );
@@ -2103,6 +2266,8 @@ C_ASSERT( FIELD_OFFSET(struct get_object_type_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_object_type_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_object_type_reply, total) == 8 );
 C_ASSERT( sizeof(struct get_object_type_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct unlink_object_request, handle) == 12 );
+C_ASSERT( sizeof(struct unlink_object_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_token_impersonation_level_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_token_impersonation_level_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_token_impersonation_level_reply, impersonation_level) == 8 );
@@ -2248,16 +2413,7 @@ C_ASSERT( FIELD_OFFSET(struct set_cursor_reply, new_y) == 28 );
 C_ASSERT( FIELD_OFFSET(struct set_cursor_reply, new_clip) == 32 );
 C_ASSERT( FIELD_OFFSET(struct set_cursor_reply, last_change) == 48 );
 C_ASSERT( sizeof(struct set_cursor_reply) == 56 );
-C_ASSERT( FIELD_OFFSET(struct get_rawinput_buffer_request, rawinput_size) == 12 );
-C_ASSERT( FIELD_OFFSET(struct get_rawinput_buffer_request, buffer_size) == 16 );
-C_ASSERT( sizeof(struct get_rawinput_buffer_request) == 24 );
-C_ASSERT( FIELD_OFFSET(struct get_rawinput_buffer_reply, next_size) == 8 );
-C_ASSERT( FIELD_OFFSET(struct get_rawinput_buffer_reply, count) == 12 );
-C_ASSERT( sizeof(struct get_rawinput_buffer_reply) == 16 );
 C_ASSERT( sizeof(struct update_rawinput_devices_request) == 16 );
-C_ASSERT( sizeof(struct get_rawinput_devices_request) == 16 );
-C_ASSERT( FIELD_OFFSET(struct get_rawinput_devices_reply, device_count) == 8 );
-C_ASSERT( sizeof(struct get_rawinput_devices_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct create_job_request, access) == 12 );
 C_ASSERT( sizeof(struct create_job_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct create_job_reply, handle) == 8 );
@@ -2281,11 +2437,6 @@ C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, job) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, port) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, key) == 24 );
 C_ASSERT( sizeof(struct set_job_completion_port_request) == 32 );
-C_ASSERT( FIELD_OFFSET(struct get_job_info_request, handle) == 12 );
-C_ASSERT( sizeof(struct get_job_info_request) == 16 );
-C_ASSERT( FIELD_OFFSET(struct get_job_info_reply, total_processes) == 8 );
-C_ASSERT( FIELD_OFFSET(struct get_job_info_reply, active_processes) == 12 );
-C_ASSERT( sizeof(struct get_job_info_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, status) == 16 );
 C_ASSERT( sizeof(struct terminate_job_request) == 24 );
diff --git a/server/snapshot.c b/server/snapshot.c
new file mode 100644
index 0000000000..a0f2ea17a3
--- /dev/null
+++ b/server/snapshot.c
@@ -0,0 +1,222 @@
+/*
+ * Server-side snapshots
+ *
+ * Copyright (C) 1999 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ * FIXME: heap snapshots not implemented
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "handle.h"
+#include "process.h"
+#include "thread.h"
+#include "request.h"
+
+
+struct snapshot
+{
+    struct object             obj;           /* object header */
+    struct process_snapshot  *processes;     /* processes snapshot */
+    int                       process_count; /* count of processes */
+    int                       process_pos;   /* current position in proc snapshot */
+    struct thread_snapshot   *threads;       /* threads snapshot */
+    int                       thread_count;  /* count of threads */
+    int                       thread_pos;    /* current position in thread snapshot */
+};
+
+static void snapshot_dump( struct object *obj, int verbose );
+static void snapshot_destroy( struct object *obj );
+
+static const struct object_ops snapshot_ops =
+{
+    sizeof(struct snapshot),      /* size */
+    snapshot_dump,                /* dump */
+    no_get_type,                  /* get_type */
+    no_add_queue,                 /* add_queue */
+    NULL,                         /* remove_queue */
+    NULL,                         /* signaled */
+    NULL,                         /* satisfied */
+    no_signal,                    /* signal */
+    no_get_fd,                    /* get_fd */
+    no_map_access,                /* map_access */
+    default_get_sd,               /* get_sd */
+    default_set_sd,               /* set_sd */
+    no_lookup_name,               /* lookup_name */
+    no_link_name,                 /* link_name */
+    NULL,                         /* unlink_name */
+    no_open_file,                 /* open_file */
+    no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_close_handle,              /* close_handle */
+    snapshot_destroy              /* destroy */
+};
+
+
+/* create a new snapshot */
+static struct snapshot *create_snapshot( unsigned int flags )
+{
+    struct snapshot *snapshot;
+
+    if (!(snapshot = alloc_object( &snapshot_ops ))) return NULL;
+
+    snapshot->process_pos = 0;
+    snapshot->process_count = 0;
+    if (flags & SNAP_PROCESS)
+        snapshot->processes = process_snap( &snapshot->process_count );
+
+    snapshot->thread_pos = 0;
+    snapshot->thread_count = 0;
+    if (flags & SNAP_THREAD)
+        snapshot->threads = thread_snap( &snapshot->thread_count );
+
+    return snapshot;
+}
+
+/* get the next process in the snapshot */
+static int snapshot_next_process( struct snapshot *snapshot, struct next_process_reply *reply )
+{
+    struct process_snapshot *ptr;
+    struct process_dll *exe_module;
+
+    if (!snapshot->process_count)
+    {
+        set_error( STATUS_INVALID_PARAMETER );  /* FIXME */
+        return 0;
+    }
+    if (snapshot->process_pos >= snapshot->process_count)
+    {
+        set_error( STATUS_NO_MORE_FILES );
+        return 0;
+    }
+    ptr = &snapshot->processes[snapshot->process_pos++];
+    reply->count    = ptr->count;
+    reply->pid      = get_process_id( ptr->process );
+    reply->ppid     = ptr->process->parent_id;
+    reply->threads  = ptr->threads;
+    reply->priority = ptr->priority;
+    reply->handles  = ptr->handles;
+    reply->unix_pid = ptr->process->unix_pid;
+    if ((exe_module = get_process_exe_module( ptr->process )) && exe_module->filename)
+    {
+        data_size_t len = min( exe_module->namelen, get_reply_max_size() );
+        set_reply_data( exe_module->filename, len );
+    }
+    return 1;
+}
+
+/* get the next thread in the snapshot */
+static int snapshot_next_thread( struct snapshot *snapshot, struct next_thread_reply *reply )
+{
+    struct thread_snapshot *ptr;
+
+    if (!snapshot->thread_count)
+    {
+        set_error( STATUS_INVALID_PARAMETER );  /* FIXME */
+        return 0;
+    }
+    if (snapshot->thread_pos >= snapshot->thread_count)
+    {
+        set_error( STATUS_NO_MORE_FILES );
+        return 0;
+    }
+    ptr = &snapshot->threads[snapshot->thread_pos++];
+    reply->count     = ptr->count;
+    reply->pid       = get_process_id( ptr->thread->process );
+    reply->tid       = get_thread_id( ptr->thread );
+    reply->base_pri  = ptr->priority;
+    reply->delta_pri = 0;  /* FIXME */
+    return 1;
+}
+
+static void snapshot_dump( struct object *obj, int verbose )
+{
+    struct snapshot *snapshot = (struct snapshot *)obj;
+    assert( obj->ops == &snapshot_ops );
+    fprintf( stderr, "Snapshot: %d procs %d threads\n",
+             snapshot->process_count, snapshot->thread_count );
+}
+
+static void snapshot_destroy( struct object *obj )
+{
+    int i;
+    struct snapshot *snapshot = (struct snapshot *)obj;
+    assert( obj->ops == &snapshot_ops );
+    if (snapshot->process_count)
+    {
+        for (i = 0; i < snapshot->process_count; i++)
+            release_object( snapshot->processes[i].process );
+        free( snapshot->processes );
+    }
+    if (snapshot->thread_count)
+    {
+        for (i = 0; i < snapshot->thread_count; i++)
+            release_object( snapshot->threads[i].thread );
+        free( snapshot->threads );
+    }
+}
+
+/* create a snapshot */
+DECL_HANDLER(create_snapshot)
+{
+    struct snapshot *snapshot;
+
+    reply->handle = 0;
+    if ((snapshot = create_snapshot( req->flags )))
+    {
+        reply->handle = alloc_handle( current->process, snapshot, 0, req->attributes );
+        release_object( snapshot );
+    }
+}
+
+/* get the next process from a snapshot */
+DECL_HANDLER(next_process)
+{
+    struct snapshot *snapshot;
+
+    if ((snapshot = (struct snapshot *)get_handle_obj( current->process, req->handle,
+                                                       0, &snapshot_ops )))
+    {
+        if (req->reset) snapshot->process_pos = 0;
+        snapshot_next_process( snapshot, reply );
+        release_object( snapshot );
+    }
+}
+
+/* get the next thread from a snapshot */
+DECL_HANDLER(next_thread)
+{
+    struct snapshot *snapshot;
+
+    if ((snapshot = (struct snapshot *)get_handle_obj( current->process, req->handle,
+                                                       0, &snapshot_ops )))
+    {
+        if (req->reset) snapshot->thread_pos = 0;
+        snapshot_next_thread( snapshot, reply );
+        release_object( snapshot );
+    }
+}
diff --git a/server/symlink.c b/server/symlink.c
index 7a2f8642d5..e5ee09f015 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -134,9 +134,9 @@ static void symlink_destroy( struct object *obj )
     free( symlink->target );
 }
 
-struct object *create_symlink( struct object *root, const struct unicode_str *name,
-                               unsigned int attr, const struct unicode_str *target,
-                               const struct security_descriptor *sd )
+static struct symlink *create_symlink( struct object *root, const struct unicode_str *name,
+                                       unsigned int attr, const struct unicode_str *target,
+                                       const struct security_descriptor *sd )
 {
     struct symlink *symlink;
 
@@ -145,14 +145,20 @@ struct object *create_symlink( struct object *root, const struct unicode_str *na
         set_error( STATUS_INVALID_PARAMETER );
         return NULL;
     }
-    if (!(symlink = create_named_object( root, &symlink_ops, name, attr, sd ))) return NULL;
-    if (get_error() != STATUS_OBJECT_NAME_EXISTS && !(symlink->target = memdup( target->str, target->len )))
+    if ((symlink = create_named_object( root, &symlink_ops, name, attr, sd )) &&
+        (get_error() != STATUS_OBJECT_NAME_EXISTS))
     {
-        release_object( symlink );
-        return NULL;
+        if ((symlink->target = memdup( target->str, target->len )))
+        {
+            symlink->len = target->len;
+        }
+        else
+        {
+            release_object( symlink );
+            symlink = NULL;
+        }
     }
-    symlink->len = target->len;
-    return &symlink->obj;
+    return symlink;
 }
 
 /* create a symlink pointing to an existing object */
@@ -184,7 +190,7 @@ struct object *create_obj_symlink( struct object *root, const struct unicode_str
 /* create a symbolic link object */
 DECL_HANDLER(create_symlink)
 {
-    struct object *symlink;
+    struct symlink *symlink;
     struct unicode_str name, target;
     struct object *root;
     const struct security_descriptor *sd;
diff --git a/server/thread.c b/server/thread.c
index 9b14174578..f8c8443ba0 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -234,7 +234,6 @@ static inline void init_thread_structure( struct thread *thread )
     thread->exit_code       = 0;
     thread->priority        = 0;
     thread->suspend         = 0;
-    thread->dbg_hidden      = 0;
     thread->desktop_users   = 0;
     thread->token           = NULL;
     thread->desc            = NULL;
@@ -625,8 +624,6 @@ static void set_thread_info( struct thread *thread,
         security_set_thread_token( thread, req->token );
     if (req->mask & SET_THREAD_INFO_ENTRYPOINT)
         thread->entry_point = req->entry_point;
-    if (req->mask & SET_THREAD_INFO_DBG_HIDDEN)
-        thread->dbg_hidden = 1;
     if (req->mask & SET_THREAD_INFO_DESCRIPTION)
     {
         WCHAR *desc;
@@ -1299,6 +1296,30 @@ static unsigned int get_context_system_regs( enum cpu_type cpu )
     return 0;
 }
 
+/* take a snapshot of currently running threads */
+struct thread_snapshot *thread_snap( int *count )
+{
+    struct thread_snapshot *snapshot, *ptr;
+    struct thread *thread;
+    int total = 0;
+
+    LIST_FOR_EACH_ENTRY( thread, &thread_list, struct thread, entry )
+        if (thread->state != TERMINATED) total++;
+    if (!total || !(snapshot = mem_alloc( sizeof(*snapshot) * total ))) return NULL;
+    ptr = snapshot;
+    LIST_FOR_EACH_ENTRY( thread, &thread_list, struct thread, entry )
+    {
+        if (thread->state == TERMINATED) continue;
+        ptr->thread   = thread;
+        ptr->count    = thread->obj.refcount;
+        ptr->priority = thread->priority;
+        grab_object( thread );
+        ptr++;
+    }
+    *count = total;
+    return snapshot;
+}
+
 /* gets the current impersonation token */
 struct token *thread_get_impersonation_token( struct thread *thread )
 {
@@ -1494,10 +1515,11 @@ DECL_HANDLER(open_thread)
 DECL_HANDLER(get_thread_info)
 {
     struct thread *thread;
-    unsigned int access = req->access & (THREAD_QUERY_INFORMATION | THREAD_QUERY_LIMITED_INFORMATION);
+    obj_handle_t handle = req->handle;
+
+    if (!handle) thread = get_thread_from_id( req->tid_in );
+    else thread = get_thread_from_handle( req->handle, THREAD_QUERY_LIMITED_INFORMATION );
 
-    if (!access) access = THREAD_QUERY_LIMITED_INFORMATION;
-    thread = get_thread_from_handle( req->handle, access );
     if (thread)
     {
         reply->pid            = get_process_id( thread->process );
@@ -1509,7 +1531,6 @@ DECL_HANDLER(get_thread_info)
         reply->affinity       = thread->affinity;
         reply->last           = thread->process->running_threads == 1;
         reply->suspend_count  = thread->suspend;
-        reply->dbg_hidden     = thread->dbg_hidden;
         reply->desc_len       = thread->desc_len;
 
         if (thread->desc && get_reply_max_size())
@@ -1529,12 +1550,10 @@ DECL_HANDLER(get_thread_times)
 {
     struct thread *thread;
 
-    if ((thread = get_thread_from_handle( req->handle, THREAD_QUERY_LIMITED_INFORMATION )))
+    if ((thread = get_thread_from_handle( req->handle, THREAD_QUERY_INFORMATION )))
     {
         reply->creation_time  = thread->creation_time;
         reply->exit_time      = thread->exit_time;
-        reply->unix_pid       = thread->unix_pid;
-        reply->unix_tid       = thread->unix_tid;
 
         release_object( thread );
     }
diff --git a/server/thread.h b/server/thread.h
index 650bc44628..5d12d24dd8 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -82,7 +82,6 @@ struct thread
     affinity_t             affinity;      /* affinity mask */
     int                    priority;      /* priority level */
     int                    suspend;       /* suspend count */
-    int                    dbg_hidden;    /* hidden from debugger */
     obj_handle_t           desktop;       /* desktop handle */
     int                    desktop_users; /* number of objects using the thread desktop */
     timeout_t              creation_time; /* Thread creation time */
@@ -93,6 +92,13 @@ struct thread
     WCHAR                 *desc;          /* thread description string */
 };
 
+struct thread_snapshot
+{
+    struct thread  *thread;    /* thread ptr */
+    int             count;     /* thread refcount */
+    int             priority;  /* priority class */
+};
+
 extern struct thread *current;
 
 /* thread functions */
@@ -118,6 +124,7 @@ extern int thread_queue_apc( struct process *process, struct thread *thread, str
 extern void thread_cancel_apc( struct thread *thread, struct object *owner, enum apc_type type );
 extern int thread_add_inflight_fd( struct thread *thread, int client, int server );
 extern int thread_get_inflight_fd( struct thread *thread, int client );
+extern struct thread_snapshot *thread_snap( int *count );
 extern struct token *thread_get_impersonation_token( struct thread *thread );
 extern int set_thread_affinity( struct thread *thread, affinity_t affinity );
 extern int is_cpu_supported( enum cpu_type cpu );
diff --git a/server/trace.c b/server/trace.c
index a276f54212..1f0e71f1b6 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -38,7 +38,6 @@
 #include "winternl.h"
 #include "winuser.h"
 #include "winioctl.h"
-#include "wine/condrv.h"
 #include "ddk/wdm.h"
 #include "ddk/ntddser.h"
 #define USE_WS_PREFIX
@@ -109,26 +108,18 @@ static void dump_rectangle( const char *prefix, const rectangle_t *rect )
              rect->left, rect->top, rect->right, rect->bottom );
 }
 
+static void dump_char_info( const char *prefix, const char_info_t *info )
+{
+    fprintf( stderr, "%s{'", prefix );
+    dump_strW( &info->ch, sizeof(info->ch), stderr, "\'\'" );
+    fprintf( stderr, "',%04x}", info->attr );
+}
+
 static void dump_ioctl_code( const char *prefix, const ioctl_code_t *code )
 {
     switch(*code)
     {
 #define CASE(c) case c: fprintf( stderr, "%s%s", prefix, #c ); break
-        CASE(IOCTL_CONDRV_ACTIVATE);
-        CASE(IOCTL_CONDRV_ATTACH_RENDERER);
-        CASE(IOCTL_CONDRV_FILL_OUTPUT);
-        CASE(IOCTL_CONDRV_GET_INPUT_INFO);
-        CASE(IOCTL_CONDRV_GET_MODE);
-        CASE(IOCTL_CONDRV_GET_OUTPUT_INFO);
-        CASE(IOCTL_CONDRV_GET_RENDERER_EVENTS);
-        CASE(IOCTL_CONDRV_GET_TITLE);
-        CASE(IOCTL_CONDRV_PEEK);
-        CASE(IOCTL_CONDRV_READ_INPUT);
-        CASE(IOCTL_CONDRV_READ_OUTPUT);
-        CASE(IOCTL_CONDRV_SET_MODE);
-        CASE(IOCTL_CONDRV_SET_OUTPUT_INFO);
-        CASE(IOCTL_CONDRV_WRITE_INPUT);
-        CASE(IOCTL_CONDRV_WRITE_OUTPUT);
         CASE(FSCTL_DISMOUNT_VOLUME);
         CASE(FSCTL_PIPE_DISCONNECT);
         CASE(FSCTL_PIPE_LISTEN);
@@ -186,8 +177,9 @@ static void dump_apc_call( const char *prefix, const apc_call_t *call )
     case APC_VIRTUAL_ALLOC:
         dump_uint64( "APC_VIRTUAL_ALLOC,addr==", &call->virtual_alloc.addr );
         dump_uint64( ",size=", &call->virtual_alloc.size );
-        dump_uint64( ",zero_bits=", &call->virtual_alloc.zero_bits );
-        fprintf( stderr, ",op_type=%x,prot=%x", call->virtual_alloc.op_type, call->virtual_alloc.prot );
+        fprintf( stderr, ",zero_bits_64=%u,op_type=%x,prot=%x",
+                 call->virtual_alloc.zero_bits_64, call->virtual_alloc.op_type,
+                 call->virtual_alloc.prot );
         break;
     case APC_VIRTUAL_FREE:
         dump_uint64( "APC_VIRTUAL_FREE,addr=", &call->virtual_free.addr );
@@ -219,8 +211,8 @@ static void dump_apc_call( const char *prefix, const apc_call_t *call )
         dump_uint64( ",addr=", &call->map_view.addr );
         dump_uint64( ",size=", &call->map_view.size );
         dump_uint64( ",offset=", &call->map_view.offset );
-        dump_uint64( ",zero_bits=", &call->map_view.zero_bits );
-        fprintf( stderr, ",alloc_type=%x,prot=%x", call->map_view.alloc_type, call->map_view.prot );
+        fprintf( stderr, ",zero_bits_64=%u,alloc_type=%x,prot=%x",
+                 call->map_view.zero_bits_64, call->map_view.alloc_type, call->map_view.prot );
         break;
     case APC_UNMAP_VIEW:
         dump_uint64( "APC_UNMAP_VIEW,addr=", &call->unmap_view.addr );
@@ -230,7 +222,7 @@ static void dump_apc_call( const char *prefix, const apc_call_t *call )
         dump_uint64( ",arg=", &call->create_thread.arg );
         dump_uint64( ",reserve=", &call->create_thread.reserve );
         dump_uint64( ",commit=", &call->create_thread.commit );
-        fprintf( stderr, ",flags=%x", call->create_thread.flags );
+        fprintf( stderr, ",suspend=%u", call->create_thread.suspend );
         break;
     case APC_BREAK_PROCESS:
         fprintf( stderr, "APC_BREAK_PROCESS" );
@@ -311,9 +303,9 @@ static void dump_apc_result( const char *prefix, const apc_result_t *result )
                  get_status_name( result->unmap_view.status ) );
         break;
     case APC_CREATE_THREAD:
-        fprintf( stderr, "APC_CREATE_THREAD,status=%s,pid=%04x,tid=%04x,handle=%04x",
+        fprintf( stderr, "APC_CREATE_THREAD,status=%s,tid=%04x,handle=%04x",
                  get_status_name( result->create_thread.status ),
-                 result->create_thread.pid, result->create_thread.tid, result->create_thread.handle );
+                 result->create_thread.tid, result->create_thread.handle );
         break;
     case APC_BREAK_PROCESS:
         fprintf( stderr, "APC_BREAK_PROCESS,status=%s", get_status_name( result->break_process.status ) );
@@ -868,6 +860,22 @@ static void dump_varargs_startup_info( const char *prefix, data_size_t size )
     remove_data( size );
 }
 
+static void dump_varargs_input_records( const char *prefix, data_size_t size )
+{
+    const INPUT_RECORD *rec = cur_data;
+    data_size_t len = size / sizeof(*rec);
+
+    fprintf( stderr,"%s{", prefix );
+    while (len > 0)
+    {
+        fprintf( stderr, "{%04x,...}", rec->EventType );
+        rec++;
+        if (--len) fputc( ',', stderr );
+    }
+    fputc( '}', stderr );
+    remove_data( size );
+}
+
 static void dump_varargs_rectangles( const char *prefix, data_size_t size )
 {
     const rectangle_t *rect = cur_data;
@@ -1108,46 +1116,6 @@ static void dump_varargs_token_groups( const char *prefix, data_size_t size )
     fputc( '}', stderr );
 }
 
-static void dump_varargs_process_info( const char *prefix, data_size_t size )
-{
-    data_size_t pos = 0;
-    unsigned int i;
-
-    fprintf( stderr,"%s{", prefix );
-
-    while (size - pos >= sizeof(struct process_info))
-    {
-        const struct process_info *process;
-        pos = (pos + 7) & ~7;
-        process = (const struct process_info *)((const char *)cur_data + pos);
-        if (size - pos < sizeof(*process)) break;
-        if (pos) fputc( ',', stderr );
-        dump_timeout( "{start_time=", &process->start_time );
-        fprintf( stderr, ",thread_count=%u,priority=%d,pid=%04x,parent_pid=%04x,handle_count=%u,unix_pid=%d,",
-                 process->thread_count, process->priority, process->pid,
-                 process->parent_pid, process->handle_count, process->unix_pid );
-        pos += sizeof(*process);
-
-        pos = dump_inline_unicode_string( "name=L\"", pos, process->name_len, size );
-
-        pos = (pos + 7) & ~7;
-        fprintf( stderr, "\",threads={" );
-        for (i = 0; i < process->thread_count; i++)
-        {
-            const struct thread_info *thread = (const struct thread_info *)((const char *)cur_data + pos);
-            if (size - pos < sizeof(*thread)) break;
-            if (i) fputc( ',', stderr );
-            dump_timeout( "{start_time=", &thread->start_time );
-            fprintf( stderr, ",tid=%04x,base_priority=%d,current_priority=%d,unix_tid=%d}",
-                     thread->tid, thread->base_priority, thread->current_priority, thread->unix_tid );
-            pos += sizeof(*thread);
-        }
-        fprintf( stderr, "}}" );
-    }
-    fputc( '}', stderr );
-    remove_data( size );
-}
-
 static void dump_varargs_object_attributes( const char *prefix, data_size_t size )
 {
     const struct object_attributes *objattr = cur_data;
@@ -1349,6 +1317,7 @@ static void dump_init_process_done_request( const struct init_process_done_reque
     dump_uint64( ", module=", &req->module );
     dump_uint64( ", ldt_copy=", &req->ldt_copy );
     dump_uint64( ", entry=", &req->entry );
+    fprintf( stderr, ", usd_handle=%04x", req->usd_handle );
 }
 
 static void dump_init_process_done_reply( const struct init_process_done_reply *req )
@@ -1448,7 +1417,7 @@ static void dump_set_process_info_request( const struct set_process_info_request
 static void dump_get_thread_info_request( const struct get_thread_info_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
-    fprintf( stderr, ", access=%08x", req->access );
+    fprintf( stderr, ", tid_in=%04x", req->tid_in );
 }
 
 static void dump_get_thread_info_reply( const struct get_thread_info_reply *req )
@@ -1462,7 +1431,6 @@ static void dump_get_thread_info_reply( const struct get_thread_info_reply *req
     fprintf( stderr, ", priority=%d", req->priority );
     fprintf( stderr, ", last=%d", req->last );
     fprintf( stderr, ", suspend_count=%d", req->suspend_count );
-    fprintf( stderr, ", dbg_hidden=%d", req->dbg_hidden );
     fprintf( stderr, ", desc_len=%u", req->desc_len );
     dump_varargs_unicode_str( ", desc=", cur_size );
 }
@@ -1476,8 +1444,6 @@ static void dump_get_thread_times_reply( const struct get_thread_times_reply *re
 {
     dump_timeout( " creation_time=", &req->creation_time );
     dump_timeout( ", exit_time=", &req->exit_time );
-    fprintf( stderr, ", unix_pid=%d", req->unix_pid );
-    fprintf( stderr, ", unix_tid=%d", req->unix_tid );
 }
 
 static void dump_set_thread_info_request( const struct set_thread_info_request *req )
@@ -1594,11 +1560,6 @@ static void dump_dup_handle_reply( const struct dup_handle_reply *req )
     fprintf( stderr, ", closed=%d", req->closed );
 }
 
-static void dump_make_temporary_request( const struct make_temporary_request *req )
-{
-    fprintf( stderr, " handle=%04x", req->handle );
-}
-
 static void dump_open_process_request( const struct open_process_request *req )
 {
     fprintf( stderr, " pid=%04x", req->pid );
@@ -2035,17 +1996,48 @@ static void dump_alloc_console_request( const struct alloc_console_request *req
 static void dump_alloc_console_reply( const struct alloc_console_reply *req )
 {
     fprintf( stderr, " handle_in=%04x", req->handle_in );
+    fprintf( stderr, ", event=%04x", req->event );
 }
 
 static void dump_free_console_request( const struct free_console_request *req )
 {
 }
 
+static void dump_get_console_renderer_events_request( const struct get_console_renderer_events_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_console_renderer_events_reply( const struct get_console_renderer_events_reply *req )
+{
+    dump_varargs_bytes( " data=", cur_size );
+}
+
+static void dump_open_console_request( const struct open_console_request *req )
+{
+    fprintf( stderr, " from=%04x", req->from );
+    fprintf( stderr, ", access=%08x", req->access );
+    fprintf( stderr, ", attributes=%08x", req->attributes );
+    fprintf( stderr, ", share=%d", req->share );
+}
+
+static void dump_open_console_reply( const struct open_console_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
 static void dump_attach_console_request( const struct attach_console_request *req )
 {
     fprintf( stderr, " pid=%04x", req->pid );
 }
 
+static void dump_attach_console_reply( const struct attach_console_reply *req )
+{
+    fprintf( stderr, " std_in=%04x", req->std_in );
+    fprintf( stderr, ", std_out=%04x", req->std_out );
+    fprintf( stderr, ", std_err=%04x", req->std_err );
+}
+
 static void dump_get_console_wait_event_request( const struct get_console_wait_event_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -2056,6 +2048,22 @@ static void dump_get_console_wait_event_reply( const struct get_console_wait_eve
     fprintf( stderr, " event=%04x", req->event );
 }
 
+static void dump_get_console_mode_request( const struct get_console_mode_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_console_mode_reply( const struct get_console_mode_reply *req )
+{
+    fprintf( stderr, " mode=%d", req->mode );
+}
+
+static void dump_set_console_mode_request( const struct set_console_mode_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", mode=%d", req->mode );
+}
+
 static void dump_set_console_input_info_request( const struct set_console_input_info_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -2070,6 +2078,23 @@ static void dump_set_console_input_info_request( const struct set_console_input_
     dump_varargs_unicode_str( ", title=", cur_size );
 }
 
+static void dump_get_console_input_info_request( const struct get_console_input_info_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_console_input_info_reply( const struct get_console_input_info_reply *req )
+{
+    fprintf( stderr, " history_mode=%d", req->history_mode );
+    fprintf( stderr, ", history_size=%d", req->history_size );
+    fprintf( stderr, ", history_index=%d", req->history_index );
+    fprintf( stderr, ", edition_mode=%d", req->edition_mode );
+    fprintf( stderr, ", input_cp=%d", req->input_cp );
+    fprintf( stderr, ", output_cp=%d", req->output_cp );
+    fprintf( stderr, ", win=%08x", req->win );
+    dump_varargs_unicode_str( ", title=", cur_size );
+}
+
 static void dump_append_console_input_history_request( const struct append_console_input_history_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -2102,6 +2127,144 @@ static void dump_create_console_output_reply( const struct create_console_output
     fprintf( stderr, " handle_out=%04x", req->handle_out );
 }
 
+static void dump_set_console_output_info_request( const struct set_console_output_info_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", mask=%d", req->mask );
+    fprintf( stderr, ", cursor_size=%d", req->cursor_size );
+    fprintf( stderr, ", cursor_visible=%d", req->cursor_visible );
+    fprintf( stderr, ", cursor_x=%d", req->cursor_x );
+    fprintf( stderr, ", cursor_y=%d", req->cursor_y );
+    fprintf( stderr, ", width=%d", req->width );
+    fprintf( stderr, ", height=%d", req->height );
+    fprintf( stderr, ", attr=%d", req->attr );
+    fprintf( stderr, ", popup_attr=%d", req->popup_attr );
+    fprintf( stderr, ", win_left=%d", req->win_left );
+    fprintf( stderr, ", win_top=%d", req->win_top );
+    fprintf( stderr, ", win_right=%d", req->win_right );
+    fprintf( stderr, ", win_bottom=%d", req->win_bottom );
+    fprintf( stderr, ", max_width=%d", req->max_width );
+    fprintf( stderr, ", max_height=%d", req->max_height );
+    fprintf( stderr, ", font_width=%d", req->font_width );
+    fprintf( stderr, ", font_height=%d", req->font_height );
+    fprintf( stderr, ", font_weight=%d", req->font_weight );
+    fprintf( stderr, ", font_pitch_family=%d", req->font_pitch_family );
+    dump_varargs_uints( ", colors=", min(cur_size,64) );
+    dump_varargs_unicode_str( ", face_name=", cur_size );
+}
+
+static void dump_get_console_output_info_request( const struct get_console_output_info_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_console_output_info_reply( const struct get_console_output_info_reply *req )
+{
+    fprintf( stderr, " cursor_size=%d", req->cursor_size );
+    fprintf( stderr, ", cursor_visible=%d", req->cursor_visible );
+    fprintf( stderr, ", cursor_x=%d", req->cursor_x );
+    fprintf( stderr, ", cursor_y=%d", req->cursor_y );
+    fprintf( stderr, ", width=%d", req->width );
+    fprintf( stderr, ", height=%d", req->height );
+    fprintf( stderr, ", attr=%d", req->attr );
+    fprintf( stderr, ", popup_attr=%d", req->popup_attr );
+    fprintf( stderr, ", win_left=%d", req->win_left );
+    fprintf( stderr, ", win_top=%d", req->win_top );
+    fprintf( stderr, ", win_right=%d", req->win_right );
+    fprintf( stderr, ", win_bottom=%d", req->win_bottom );
+    fprintf( stderr, ", max_width=%d", req->max_width );
+    fprintf( stderr, ", max_height=%d", req->max_height );
+    fprintf( stderr, ", font_width=%d", req->font_width );
+    fprintf( stderr, ", font_height=%d", req->font_height );
+    fprintf( stderr, ", font_weight=%d", req->font_weight );
+    fprintf( stderr, ", font_pitch_family=%d", req->font_pitch_family );
+    dump_varargs_uints( ", colors=", min(cur_size,64) );
+    dump_varargs_unicode_str( ", face_name=", cur_size );
+}
+
+static void dump_write_console_input_request( const struct write_console_input_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    dump_varargs_input_records( ", rec=", cur_size );
+}
+
+static void dump_write_console_input_reply( const struct write_console_input_reply *req )
+{
+    fprintf( stderr, " written=%d", req->written );
+}
+
+static void dump_read_console_input_request( const struct read_console_input_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", flush=%d", req->flush );
+}
+
+static void dump_read_console_input_reply( const struct read_console_input_reply *req )
+{
+    fprintf( stderr, " read=%d", req->read );
+    dump_varargs_input_records( ", rec=", cur_size );
+}
+
+static void dump_write_console_output_request( const struct write_console_output_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", x=%d", req->x );
+    fprintf( stderr, ", y=%d", req->y );
+    fprintf( stderr, ", mode=%d", req->mode );
+    fprintf( stderr, ", wrap=%d", req->wrap );
+    dump_varargs_bytes( ", data=", cur_size );
+}
+
+static void dump_write_console_output_reply( const struct write_console_output_reply *req )
+{
+    fprintf( stderr, " written=%d", req->written );
+    fprintf( stderr, ", width=%d", req->width );
+    fprintf( stderr, ", height=%d", req->height );
+}
+
+static void dump_fill_console_output_request( const struct fill_console_output_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", x=%d", req->x );
+    fprintf( stderr, ", y=%d", req->y );
+    fprintf( stderr, ", mode=%d", req->mode );
+    fprintf( stderr, ", count=%d", req->count );
+    fprintf( stderr, ", wrap=%d", req->wrap );
+    dump_char_info( ", data=", &req->data );
+}
+
+static void dump_fill_console_output_reply( const struct fill_console_output_reply *req )
+{
+    fprintf( stderr, " written=%d", req->written );
+}
+
+static void dump_read_console_output_request( const struct read_console_output_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", x=%d", req->x );
+    fprintf( stderr, ", y=%d", req->y );
+    fprintf( stderr, ", mode=%d", req->mode );
+    fprintf( stderr, ", wrap=%d", req->wrap );
+}
+
+static void dump_read_console_output_reply( const struct read_console_output_reply *req )
+{
+    fprintf( stderr, " width=%d", req->width );
+    fprintf( stderr, ", height=%d", req->height );
+    dump_varargs_bytes( ", data=", cur_size );
+}
+
+static void dump_move_console_output_request( const struct move_console_output_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", x_src=%d", req->x_src );
+    fprintf( stderr, ", y_src=%d", req->y_src );
+    fprintf( stderr, ", x_dst=%d", req->x_dst );
+    fprintf( stderr, ", y_dst=%d", req->y_dst );
+    fprintf( stderr, ", w=%d", req->w );
+    fprintf( stderr, ", h=%d", req->h );
+}
+
 static void dump_send_console_signal_request( const struct send_console_signal_request *req )
 {
     fprintf( stderr, " signal=%d", req->signal );
@@ -2207,15 +2370,48 @@ static void dump_is_same_mapping_request( const struct is_same_mapping_request *
     dump_uint64( ", base2=", &req->base2 );
 }
 
-static void dump_list_processes_request( const struct list_processes_request *req )
+static void dump_create_snapshot_request( const struct create_snapshot_request *req )
 {
+    fprintf( stderr, " attributes=%08x", req->attributes );
+    fprintf( stderr, ", flags=%08x", req->flags );
 }
 
-static void dump_list_processes_reply( const struct list_processes_reply *req )
+static void dump_create_snapshot_reply( const struct create_snapshot_reply *req )
 {
-    fprintf( stderr, " info_size=%u", req->info_size );
-    fprintf( stderr, ", process_count=%d", req->process_count );
-    dump_varargs_process_info( ", data=", min(cur_size,req->info_size) );
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_next_process_request( const struct next_process_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", reset=%d", req->reset );
+}
+
+static void dump_next_process_reply( const struct next_process_reply *req )
+{
+    fprintf( stderr, " count=%d", req->count );
+    fprintf( stderr, ", pid=%04x", req->pid );
+    fprintf( stderr, ", ppid=%04x", req->ppid );
+    fprintf( stderr, ", threads=%d", req->threads );
+    fprintf( stderr, ", priority=%d", req->priority );
+    fprintf( stderr, ", handles=%d", req->handles );
+    fprintf( stderr, ", unix_pid=%d", req->unix_pid );
+    dump_varargs_unicode_str( ", filename=", cur_size );
+}
+
+static void dump_next_thread_request( const struct next_thread_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", reset=%d", req->reset );
+}
+
+static void dump_next_thread_reply( const struct next_thread_reply *req )
+{
+    fprintf( stderr, " count=%d", req->count );
+    fprintf( stderr, ", pid=%04x", req->pid );
+    fprintf( stderr, ", tid=%04x", req->tid );
+    fprintf( stderr, ", base_pri=%d", req->base_pri );
+    fprintf( stderr, ", delta_pri=%d", req->delta_pri );
 }
 
 static void dump_wait_debug_event_request( const struct wait_debug_event_request *req )
@@ -2697,6 +2893,7 @@ static void dump_reply_message_request( const struct reply_message_request *req
 static void dump_accept_hardware_message_request( const struct accept_hardware_message_request *req )
 {
     fprintf( stderr, " hw_id=%08x", req->hw_id );
+    fprintf( stderr, ", remove=%d", req->remove );
 }
 
 static void dump_get_message_reply_request( const struct get_message_reply_request *req )
@@ -4045,6 +4242,11 @@ static void dump_get_object_type_reply( const struct get_object_type_reply *req
     dump_varargs_unicode_str( ", type=", cur_size );
 }
 
+static void dump_unlink_object_request( const struct unlink_object_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
 static void dump_get_token_impersonation_level_request( const struct get_token_impersonation_level_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -4324,34 +4526,11 @@ static void dump_set_cursor_reply( const struct set_cursor_reply *req )
     fprintf( stderr, ", last_change=%08x", req->last_change );
 }
 
-static void dump_get_rawinput_buffer_request( const struct get_rawinput_buffer_request *req )
-{
-    fprintf( stderr, " rawinput_size=%u", req->rawinput_size );
-    fprintf( stderr, ", buffer_size=%u", req->buffer_size );
-}
-
-static void dump_get_rawinput_buffer_reply( const struct get_rawinput_buffer_reply *req )
-{
-    fprintf( stderr, " next_size=%u", req->next_size );
-    fprintf( stderr, ", count=%08x", req->count );
-    dump_varargs_bytes( ", data=", cur_size );
-}
-
 static void dump_update_rawinput_devices_request( const struct update_rawinput_devices_request *req )
 {
     dump_varargs_rawinput_devices( " devices=", cur_size );
 }
 
-static void dump_get_rawinput_devices_request( const struct get_rawinput_devices_request *req )
-{
-}
-
-static void dump_get_rawinput_devices_reply( const struct get_rawinput_devices_reply *req )
-{
-    fprintf( stderr, " device_count=%08x", req->device_count );
-    dump_varargs_rawinput_devices( ", devices=", cur_size );
-}
-
 static void dump_create_job_request( const struct create_job_request *req )
 {
     fprintf( stderr, " access=%08x", req->access );
@@ -4401,17 +4580,6 @@ static void dump_set_job_completion_port_request( const struct set_job_completio
     dump_uint64( ", key=", &req->key );
 }
 
-static void dump_get_job_info_request( const struct get_job_info_request *req )
-{
-    fprintf( stderr, " handle=%04x", req->handle );
-}
-
-static void dump_get_job_info_reply( const struct get_job_info_reply *req )
-{
-    fprintf( stderr, " total_processes=%d", req->total_processes );
-    fprintf( stderr, ", active_processes=%d", req->active_processes );
-}
-
 static void dump_terminate_job_request( const struct terminate_job_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -4454,7 +4622,6 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_close_handle_request,
     (dump_func)dump_set_handle_info_request,
     (dump_func)dump_dup_handle_request,
-    (dump_func)dump_make_temporary_request,
     (dump_func)dump_open_process_request,
     (dump_func)dump_open_thread_request,
     (dump_func)dump_select_request,
@@ -4493,12 +4660,25 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_set_socket_deferred_request,
     (dump_func)dump_alloc_console_request,
     (dump_func)dump_free_console_request,
+    (dump_func)dump_get_console_renderer_events_request,
+    (dump_func)dump_open_console_request,
     (dump_func)dump_attach_console_request,
     (dump_func)dump_get_console_wait_event_request,
+    (dump_func)dump_get_console_mode_request,
+    (dump_func)dump_set_console_mode_request,
     (dump_func)dump_set_console_input_info_request,
+    (dump_func)dump_get_console_input_info_request,
     (dump_func)dump_append_console_input_history_request,
     (dump_func)dump_get_console_input_history_request,
     (dump_func)dump_create_console_output_request,
+    (dump_func)dump_set_console_output_info_request,
+    (dump_func)dump_get_console_output_info_request,
+    (dump_func)dump_write_console_input_request,
+    (dump_func)dump_read_console_input_request,
+    (dump_func)dump_write_console_output_request,
+    (dump_func)dump_fill_console_output_request,
+    (dump_func)dump_read_console_output_request,
+    (dump_func)dump_move_console_output_request,
     (dump_func)dump_send_console_signal_request,
     (dump_func)dump_read_directory_changes_request,
     (dump_func)dump_read_change_request,
@@ -4510,7 +4690,9 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_get_mapping_committed_range_request,
     (dump_func)dump_add_mapping_committed_range_request,
     (dump_func)dump_is_same_mapping_request,
-    (dump_func)dump_list_processes_request,
+    (dump_func)dump_create_snapshot_request,
+    (dump_func)dump_next_process_request,
+    (dump_func)dump_next_thread_request,
     (dump_func)dump_wait_debug_event_request,
     (dump_func)dump_queue_exception_event_request,
     (dump_func)dump_get_exception_status_request,
@@ -4671,6 +4853,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_query_symlink_request,
     (dump_func)dump_get_object_info_request,
     (dump_func)dump_get_object_type_request,
+    (dump_func)dump_unlink_object_request,
     (dump_func)dump_get_token_impersonation_level_request,
     (dump_func)dump_allocate_locally_unique_id_request,
     (dump_func)dump_create_device_manager_request,
@@ -4699,16 +4882,13 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_alloc_user_handle_request,
     (dump_func)dump_free_user_handle_request,
     (dump_func)dump_set_cursor_request,
-    (dump_func)dump_get_rawinput_buffer_request,
     (dump_func)dump_update_rawinput_devices_request,
-    (dump_func)dump_get_rawinput_devices_request,
     (dump_func)dump_create_job_request,
     (dump_func)dump_open_job_request,
     (dump_func)dump_assign_job_request,
     (dump_func)dump_process_in_job_request,
     (dump_func)dump_set_job_limits_request,
     (dump_func)dump_set_job_completion_port_request,
-    (dump_func)dump_get_job_info_request,
     (dump_func)dump_terminate_job_request,
     (dump_func)dump_suspend_process_request,
     (dump_func)dump_resume_process_request,
@@ -4740,7 +4920,6 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     (dump_func)dump_set_handle_info_reply,
     (dump_func)dump_dup_handle_reply,
-    NULL,
     (dump_func)dump_open_process_reply,
     (dump_func)dump_open_thread_reply,
     (dump_func)dump_select_reply,
@@ -4779,13 +4958,26 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     (dump_func)dump_alloc_console_reply,
     NULL,
-    NULL,
+    (dump_func)dump_get_console_renderer_events_reply,
+    (dump_func)dump_open_console_reply,
+    (dump_func)dump_attach_console_reply,
     (dump_func)dump_get_console_wait_event_reply,
+    (dump_func)dump_get_console_mode_reply,
+    NULL,
     NULL,
+    (dump_func)dump_get_console_input_info_reply,
     NULL,
     (dump_func)dump_get_console_input_history_reply,
     (dump_func)dump_create_console_output_reply,
     NULL,
+    (dump_func)dump_get_console_output_info_reply,
+    (dump_func)dump_write_console_input_reply,
+    (dump_func)dump_read_console_input_reply,
+    (dump_func)dump_write_console_output_reply,
+    (dump_func)dump_fill_console_output_reply,
+    (dump_func)dump_read_console_output_reply,
+    NULL,
+    NULL,
     NULL,
     (dump_func)dump_read_change_reply,
     (dump_func)dump_create_mapping_reply,
@@ -4796,7 +4988,9 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_get_mapping_committed_range_reply,
     NULL,
     NULL,
-    (dump_func)dump_list_processes_reply,
+    (dump_func)dump_create_snapshot_reply,
+    (dump_func)dump_next_process_reply,
+    (dump_func)dump_next_thread_reply,
     (dump_func)dump_wait_debug_event_reply,
     (dump_func)dump_queue_exception_event_reply,
     NULL,
@@ -4957,6 +5151,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_query_symlink_reply,
     (dump_func)dump_get_object_info_reply,
     (dump_func)dump_get_object_type_reply,
+    NULL,
     (dump_func)dump_get_token_impersonation_level_reply,
     (dump_func)dump_allocate_locally_unique_id_reply,
     (dump_func)dump_create_device_manager_reply,
@@ -4985,16 +5180,13 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_alloc_user_handle_reply,
     NULL,
     (dump_func)dump_set_cursor_reply,
-    (dump_func)dump_get_rawinput_buffer_reply,
     NULL,
-    (dump_func)dump_get_rawinput_devices_reply,
     (dump_func)dump_create_job_reply,
     (dump_func)dump_open_job_reply,
     NULL,
     NULL,
     NULL,
     NULL,
-    (dump_func)dump_get_job_info_reply,
     NULL,
     NULL,
     NULL,
@@ -5026,7 +5218,6 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "close_handle",
     "set_handle_info",
     "dup_handle",
-    "make_temporary",
     "open_process",
     "open_thread",
     "select",
@@ -5065,12 +5256,25 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "set_socket_deferred",
     "alloc_console",
     "free_console",
+    "get_console_renderer_events",
+    "open_console",
     "attach_console",
     "get_console_wait_event",
+    "get_console_mode",
+    "set_console_mode",
     "set_console_input_info",
+    "get_console_input_info",
     "append_console_input_history",
     "get_console_input_history",
     "create_console_output",
+    "set_console_output_info",
+    "get_console_output_info",
+    "write_console_input",
+    "read_console_input",
+    "write_console_output",
+    "fill_console_output",
+    "read_console_output",
+    "move_console_output",
     "send_console_signal",
     "read_directory_changes",
     "read_change",
@@ -5082,7 +5286,9 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "get_mapping_committed_range",
     "add_mapping_committed_range",
     "is_same_mapping",
-    "list_processes",
+    "create_snapshot",
+    "next_process",
+    "next_thread",
     "wait_debug_event",
     "queue_exception_event",
     "get_exception_status",
@@ -5243,6 +5449,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "query_symlink",
     "get_object_info",
     "get_object_type",
+    "unlink_object",
     "get_token_impersonation_level",
     "allocate_locally_unique_id",
     "create_device_manager",
@@ -5271,16 +5478,13 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "alloc_user_handle",
     "free_user_handle",
     "set_cursor",
-    "get_rawinput_buffer",
     "update_rawinput_devices",
-    "get_rawinput_devices",
     "create_job",
     "open_job",
     "assign_job",
     "process_in_job",
     "set_job_limits",
     "set_job_completion_port",
-    "get_job_info",
     "terminate_job",
     "suspend_process",
     "resume_process",
@@ -5335,7 +5539,6 @@ static const struct
     { "HANDLE_NOT_CLOSABLE",         STATUS_HANDLE_NOT_CLOSABLE },
     { "HOST_UNREACHABLE",            STATUS_HOST_UNREACHABLE },
     { "ILLEGAL_FUNCTION",            STATUS_ILLEGAL_FUNCTION },
-    { "IMAGE_NOT_AT_BASE",           STATUS_IMAGE_NOT_AT_BASE },
     { "INFO_LENGTH_MISMATCH",        STATUS_INFO_LENGTH_MISMATCH },
     { "INSTANCE_NOT_AVAILABLE",      STATUS_INSTANCE_NOT_AVAILABLE },
     { "INSUFFICIENT_RESOURCES",      STATUS_INSUFFICIENT_RESOURCES },
@@ -5376,6 +5579,7 @@ static const struct
     { "NO_IMPERSONATION_TOKEN",      STATUS_NO_IMPERSONATION_TOKEN },
     { "NO_MEMORY",                   STATUS_NO_MEMORY },
     { "NO_MORE_ENTRIES",             STATUS_NO_MORE_ENTRIES },
+    { "NO_MORE_FILES",               STATUS_NO_MORE_FILES },
     { "NO_SUCH_DEVICE",              STATUS_NO_SUCH_DEVICE },
     { "NO_SUCH_FILE",                STATUS_NO_SUCH_FILE },
     { "NO_TOKEN",                    STATUS_NO_TOKEN },
diff --git a/tools/make_requests b/tools/make_requests
index cd3405e47d..7251cd86fc 100755
--- a/tools/make_requests
+++ b/tools/make_requests
@@ -45,7 +45,8 @@ my %formats =
     "timeout_t"     => [  8,   8,  "&dump_timeout" ],
     "abstime_t"     => [  8,   8,  "&dump_abstime" ],
     "rectangle_t"   => [  16,  4,  "&dump_rectangle" ],
-    "apc_call_t"    => [  48,  8,  "&dump_apc_call" ],
+    "char_info_t"   => [  4,   2,  "&dump_char_info" ],
+    "apc_call_t"    => [  40,  8,  "&dump_apc_call" ],
     "apc_result_t"  => [  40,  8,  "&dump_apc_result" ],
     "async_data_t"  => [  40,  8,  "&dump_async_data" ],
     "irp_params_t"  => [  32,  8,  "&dump_irp_params" ],
diff --git a/tools/makedep.c b/tools/makedep.c
index 825458156f..bdeae8f65a 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -3349,7 +3349,6 @@ static void output_module( struct makefile *make )
         strarray_add( &make->all_targets, unix_lib );
         add_install_rule( make, make->module, unix_lib, strmake( "p$(dlldir)/%s", unix_lib ));
         output( "%s:", unix_lib );
-        if (spec_file) output_filename( spec_file );
         output_filenames_obj_dir( make, make->unixobj_files );
         output_filenames( unix_deps );
         output_filename( tools_path( make, "winebuild" ));
@@ -3358,7 +3357,6 @@ static void output_module( struct makefile *make )
         output_winegcc_command( make, 0 );
         output_filename( "-munix" );
         output_filename( "-shared" );
-        if (spec_file) output_filename( spec_file );
         if (strarray_exists( &make->extradllflags, "-nodefaultlibs" )) output_filename( "-nodefaultlibs" );
         output_filenames_obj_dir( make, make->unixobj_files );
         output_filenames( unix_libs );
diff --git a/tools/winebuild/build.h b/tools/winebuild/build.h
index e1d2e5edf8..d0fc3dca1b 100644
--- a/tools/winebuild/build.h
+++ b/tools/winebuild/build.h
@@ -175,10 +175,9 @@ struct strarray
 #define FLAG_REGISTER  0x0010  /* use register calling convention */
 #define FLAG_PRIVATE   0x0020  /* function is private (cannot be imported) */
 #define FLAG_ORDINAL   0x0040  /* function should be imported by ordinal */
-#define FLAG_THISCALL  0x0080  /* function uses thiscall calling convention */
-#define FLAG_FASTCALL  0x0100  /* function uses fastcall calling convention */
-#define FLAG_SYSCALL   0x0200  /* function is a system call */
-#define FLAG_IMPORT    0x0400  /* export is imported from another module */
+#define FLAG_THISCALL  0x0080  /* use thiscall calling convention */
+#define FLAG_FASTCALL  0x0100  /* use fastcall calling convention */
+#define FLAG_IMPORT    0x0200  /* export is imported from another module */
 
 #define FLAG_FORWARD   0x1000  /* function is a forwarded name */
 #define FLAG_EXT_LINK  0x2000  /* function links to an external symbol */
@@ -276,7 +275,6 @@ extern void free_dll_spec( DLLSPEC *spec );
 extern char *make_c_identifier( const char *str );
 extern const char *get_stub_name( const ORDDEF *odp, const DLLSPEC *spec );
 extern const char *get_link_name( const ORDDEF *odp );
-extern int sort_func_list( ORDDEF **list, int count, int (*compare)(const void *, const void *) );
 extern int get_cpu_from_name( const char *name );
 extern unsigned int get_alignment(unsigned int align);
 extern unsigned int get_page_size(void);
@@ -304,7 +302,6 @@ extern int has_imports(void);
 extern void output_get_pc_thunk(void);
 extern void output_module( DLLSPEC *spec );
 extern void output_stubs( DLLSPEC *spec );
-extern void output_syscalls( DLLSPEC *spec );
 extern void output_imports( DLLSPEC *spec );
 extern void output_static_lib( DLLSPEC *spec, char **argv );
 extern void output_exports( DLLSPEC *spec );
diff --git a/tools/winebuild/import.c b/tools/winebuild/import.c
index da9ad62022..5cf22b7639 100644
--- a/tools/winebuild/import.c
+++ b/tools/winebuild/import.c
@@ -460,9 +460,6 @@ static void add_undef_import( const char *name, int is_ordinal )
 static int has_stubs( const DLLSPEC *spec )
 {
     int i;
-
-    if (unix_lib) return 0;
-
     for (i = 0; i < spec->nb_entry_points; i++)
     {
         ORDDEF *odp = &spec->entry_points[i];
@@ -507,8 +504,6 @@ static void check_undefined_forwards( DLLSPEC *spec )
     char *link_name, *api_name, *dll_name, *p;
     int i;
 
-    if (unix_lib) return;
-
     for (i = 0; i < spec->nb_entry_points; i++)
     {
         ORDDEF *odp = &spec->entry_points[i];
@@ -539,14 +534,11 @@ static void check_undefined_exports( DLLSPEC *spec )
 {
     int i;
 
-    if (unix_lib) return;
-
     for (i = 0; i < spec->nb_entry_points; i++)
     {
         ORDDEF *odp = &spec->entry_points[i];
         if (odp->type == TYPE_STUB || odp->type == TYPE_ABS || odp->type == TYPE_VARIABLE) continue;
         if (odp->flags & FLAG_FORWARD) continue;
-        if (odp->flags & FLAG_SYSCALL) continue;
         if (find_name( odp->link_name, &undef_symbols ))
         {
             switch(odp->type)
@@ -564,7 +556,6 @@ static void check_undefined_exports( DLLSPEC *spec )
                             spec->src_name, odp->lineno, odp->link_name );
                 break;
             default:
-                if (!strcmp( odp->link_name, "__wine_syscall_dispatcher" )) break;
                 error( "%s:%d: external symbol '%s' is not a function\n",
                        spec->src_name, odp->lineno, odp->link_name );
                 break;
@@ -580,8 +571,6 @@ static char *create_undef_symbols_file( DLLSPEC *spec )
     int i;
     unsigned int j;
 
-    if (unix_lib) return NULL;
-
     as_file = open_temp_output_file( ".s" );
     output( "\t.data\n" );
 
@@ -590,7 +579,6 @@ static char *create_undef_symbols_file( DLLSPEC *spec )
         ORDDEF *odp = &spec->entry_points[i];
         if (odp->type == TYPE_STUB || odp->type == TYPE_ABS || odp->type == TYPE_VARIABLE) continue;
         if (odp->flags & FLAG_FORWARD) continue;
-        if (odp->flags & FLAG_SYSCALL) continue;
         output( "\t%s %s\n", get_asm_ptr_keyword(), asm_name( get_link_name( odp )));
     }
     for (j = 0; j < extra_ld_symbols.count; j++)
@@ -1404,371 +1392,6 @@ void output_stubs( DLLSPEC *spec )
     }
 }
 
-static int cmp_link_name( const void *e1, const void *e2 )
-{
-    const ORDDEF *odp1 = *(const ORDDEF * const *)e1;
-    const ORDDEF *odp2 = *(const ORDDEF * const *)e2;
-
-    return strcmp( odp1->link_name, odp2->link_name );
-}
-
-
-/* output the functions for system calls */
-void output_syscalls( DLLSPEC *spec )
-{
-    const unsigned int invalid_param = 0xc000000d; /* STATUS_INVALID_PARAMETER */
-    int i, count;
-    ORDDEF **syscalls = NULL;
-
-    for (i = count = 0; i < spec->nb_entry_points; i++)
-    {
-        ORDDEF *odp = &spec->entry_points[i];
-        if (!(odp->flags & FLAG_SYSCALL)) continue;
-        if (!syscalls) syscalls = xmalloc( (spec->nb_entry_points - i) * sizeof(*syscalls) );
-        syscalls[count++] = odp;
-    }
-    if (!count) return;
-    count = sort_func_list( syscalls, count, cmp_link_name );
-
-    output( "\n/* system calls */\n\n" );
-    output( "\t.text\n" );
-
-    if (unix_lib)
-    {
-        output( "\t.align %d\n", get_alignment(4) );
-        output( "\t%s\n", func_declaration("__wine_syscall_dispatcher") );
-        output( "%s\n", asm_globl("__wine_syscall_dispatcher") );
-        output_cfi( ".cfi_startproc" );
-        switch (target_cpu)
-        {
-        case CPU_x86:
-            output( "\tpushl %%ebp\n" );
-            output_cfi( ".cfi_adjust_cfa_offset 4\n" );
-            output_cfi( ".cfi_rel_offset %%ebp,0\n" );
-            output( "\tmovl %%esp,%%ebp\n" );
-            output_cfi( ".cfi_def_cfa_register %%ebp\n" );
-            output( "\tpushl %%ebx\n" );
-            output_cfi( ".cfi_rel_offset %%ebx,-4\n" );
-            output( "\tpushl %%esi\n" );
-            output_cfi( ".cfi_rel_offset %%esi,-8\n" );
-            output( "\tpushl %%edi\n" );
-            output_cfi( ".cfi_rel_offset %%edi,-12\n" );
-            output( "\tpushl %%fs:0x1f8\n" );  /* x86_thread_data()->syscall_frame */
-            output( "\tmovl %%esp,%%fs:0x1f8\n" );
-            output( "\tcmpl $%u,%%eax\n", count );
-            output( "\tjae 3f\n" );
-            if (UsePIC)
-            {
-                output( "\tmovl %%eax,%%edx\n" );
-                output( "\tcall %s\n", asm_name("__wine_spec_get_pc_thunk_eax") );
-                output( "1:\tmovzbl .Lsyscall_args-1b(%%eax,%%edx,1),%%ecx\n" );
-                needs_get_pc_thunk = 1;
-            }
-            else output( "\tmovzbl .Lsyscall_args(%%eax),%%ecx\n" );
-            output( "\tsubl %%ecx,%%esp\n" );
-            output( "\tshrl $2,%%ecx\n" );
-            output( "\tleal 12(%%ebp),%%esi\n" );
-            output( "\tandl $~15,%%esp\n" );
-            output( "\tmovl %%esp,%%edi\n" );
-            output( "\tcld\n" );
-            output( "\trep; movsl\n" );
-            if (UsePIC)
-                output( "\tcall *.Lsyscall_table-1b(%%eax,%%edx,4)\n" );
-            else
-                output( "\tcall *.Lsyscall_table(,%%eax,4)\n" );
-            output( "\tleal -16(%%ebp),%%esp\n" );
-            output( "2:\tpopl %%fs:0x1f8\n" );
-            output( "\tpopl %%edi\n" );
-            output_cfi( ".cfi_same_value %%edi\n" );
-            output( "\tpopl %%esi\n" );
-            output_cfi( ".cfi_same_value %%esi\n" );
-            output( "\tpopl %%ebx\n" );
-            output_cfi( ".cfi_same_value %%ebx\n" );
-            output( "\tpopl %%ebp\n" );
-            output_cfi( ".cfi_def_cfa %%esp,4\n" );
-            output_cfi( ".cfi_same_value %%ebp\n" );
-            output( "\tret\n" );
-            output( "3:\tmovl $0x%x,%%eax\n", invalid_param );
-            output( "\tjmp 2b\n" );
-            break;
-        case CPU_x86_64:
-            output( "\tpushq %%rbp\n" );
-            output_cfi( ".cfi_adjust_cfa_offset 8" );
-            output_cfi( ".cfi_rel_offset %%rbp,0" );
-            output( "\tmovq %%rsp,%%rbp\n" );
-            output_cfi( ".cfi_def_cfa_register %%rbp" );
-            output( "\tleaq -0xe8(%%rbp),%%rsp\n" );
-            output( "\tmovq %%gs:0x30,%%rcx\n" );
-            output( "\tpushq 0x328(%%rcx)\n" );  /* amd64_thread_data()->syscall_frame */
-            output( "\tmovq %%rsp,0x328(%%rcx)\n" );
-            output( "\tmovdqu %%xmm6,-0xe0(%%rbp)\n" );
-            output( "\tmovdqu %%xmm7,-0xd0(%%rbp)\n" );
-            output( "\tmovdqu %%xmm8,-0xc0(%%rbp)\n" );
-            output( "\tmovdqu %%xmm9,-0xb0(%%rbp)\n" );
-            output( "\tmovdqu %%xmm10,-0xa0(%%rbp)\n" );
-            output( "\tmovdqu %%xmm11,-0x90(%%rbp)\n" );
-            output( "\tmovdqu %%xmm12,-0x80(%%rbp)\n" );
-            output( "\tmovdqu %%xmm13,-0x70(%%rbp)\n" );
-            output( "\tmovdqu %%xmm14,-0x60(%%rbp)\n" );
-            output( "\tmovdqu %%xmm15,-0x50(%%rbp)\n" );
-            output( "\tstmxcsr -0x40(%%rbp)\n" );
-            output( "\tmovq %%r12,-0x38(%%rbp)\n" );
-            output( "\tmovq %%r13,-0x30(%%rbp)\n" );
-            output( "\tmovq %%r14,-0x28(%%rbp)\n" );
-            output( "\tmovq %%r15,-0x20(%%rbp)\n" );
-            output( "\tmovq %%rdi,-0x18(%%rbp)\n" );
-            output_cfi( ".cfi_rel_offset %%rdi,-24" );
-            output( "\tmovq %%rsi,-0x10(%%rbp)\n" );
-            output_cfi( ".cfi_rel_offset %%rsi,-16" );
-            output( "\tmovq %%rbx,-0x08(%%rbp)\n" );
-            output_cfi( ".cfi_rel_offset %%rbx,-8" );
-            /* Legends of Runeterra hooks the first system call return instruction, and
-             * depends on us returning to it. Adjust the return address accordingly. */
-            output( "\tsubq $0xb,0x8(%%rbp)\n" );
-            output( "\tcmpq $%u,%%rax\n", count );
-            output( "\tjae 4f\n" );
-            output( "\tleaq .Lsyscall_args(%%rip),%%rcx\n" );
-            output( "\tmovzbl (%%rcx,%%rax),%%ecx\n" );
-            output( "\tsubq $0x20,%%rcx\n" );
-            output( "\tja 1f\n" );
-            output( "\tandq $~15,%%rsp\n\t" );
-            output( "\tjmp 2f\n" );
-            output( "1:\tsubq %%rcx,%%rsp\n" );
-            output( "\tshrq $3,%%rcx\n" );
-            output( "\tleaq 0x38(%%rbp),%%rsi\n" );
-            output( "\tandq $~15,%%rsp\n\t" );
-            output( "\tmovq %%rsp,%%rdi\n" );
-            output( "\tcld\n" );
-            output( "\trep; movsq\n" );
-            output( "2:\tmovq %%r10,%%rcx\n" );
-            output( "\tsubq $0x20,%%rsp\n" );
-            output( "\tleaq .Lsyscall_table(%%rip),%%r10\n" );
-            output( "\tcallq *(%%r10,%%rax,8)\n" );
-            output( "3:\tpushq -0xf0(%%rbp)\n" );
-            output( "\tmovq %%gs:0x30,%%rcx\n" );
-            output( "\tpopq 0x328(%%rcx)\n" );  /* prev frame */
-            output( "\tmovq -0x18(%%rbp),%%rdi\n" );
-            output_cfi( ".cfi_same_value %%rdi" );
-            output( "\tmovq -0x10(%%rbp),%%rsi\n" );
-            output_cfi( ".cfi_same_value %%rsi" );
-            output( "\tmovq -0x8(%%rbp),%%rbx\n" );
-            output_cfi( ".cfi_same_value %%rbx" );
-            output_cfi( ".cfi_def_cfa_register %%rsp" );
-            output( "\tleave\n" );
-            output_cfi( ".cfi_adjust_cfa_offset -8" );
-            output_cfi( ".cfi_same_value %%rbp" );
-            output( "\tret\n" );
-            output( "4:\tmovl $0x%x,%%eax\n", invalid_param );
-            output( "\tjmp 3b\n" );
-            break;
-        case CPU_ARM:
-            output( "\tpush {r5-r11,lr}\n" );
-            output( "\tadd r6, sp, #40\n" );  /* stack parameters */
-            output( "\tldr r5, 8f\n" );
-            output( "\tcmp r4, r5\n" );
-            output( "\tbcs 5f\n" );
-            output( "\tsub sp, sp, #8\n" );
-            output( "\tpush {r0-r3}\n" );
-            output( "\tbl %s\n", asm_name("NtCurrentTeb") );
-            output( "\tadd r7, r0, #0x1d8\n" );  /* arm_thread_data()->syscall_frame */
-            output( "\tpop {r0-r3}\n" );
-            output( "\tldr r8, [r7]\n" );
-            output( "\tstr r8, [sp]\n" );  /* prev frame */
-            output( "\tstr sp, [r7]\n" );  /* syscall frame */
-            output( "\tmrs ip, CPSR\n" );
-            output( "\tstr ip, [sp, #4]\n" );
-            output( "\tldr r5, 7f\n");
-            output( "\tadd r5, pc\n");
-            output( "\tldrb r5, [r5, r4]\n" );  /* syscall args */
-            output( "1:\tsubs r5, #16\n" );   /* first 4 args are in registers */
-            output( "\tble 3f\n" );
-            output( "\tsub sp, r5\n" );
-            output( "\tand sp, #~7\n" );
-            output( "2:\tsubs r5, r5, #4\n" );
-            output( "\tldr ip, [r6, r5]\n" );
-            output( "\tstr ip, [sp, r5]\n" );
-            output( "\tbgt 2b\n" );
-            output( "3:\tldr r5, 6f\n");
-            output( "\tadd r5, pc\n");
-            output( "\tldr ip, [r5, r4, lsl #2]\n");  /* syscall table */
-            output( "4:\tblx ip\n");
-            output( "\tstr r8, [r7]\n" );  /* prev frame */
-            output( "\tsub sp, r6, #40\n" );
-            output( "\tpop {r5-r11,pc}\n" );
-            output( "5:\tldr r0, 9f\n" );
-            output( "\tpop {r5-r11,pc}\n" );
-            output( "6:\t.long .Lsyscall_table-4b\n" );
-            output( "7:\t.long .Lsyscall_args-1b\n" );
-            output( "8:\t.long %u\n", count );
-            output( "9:\t.long 0x%x\n", invalid_param );
-            break;
-        case CPU_ARM64:
-            output( "\tcmp x8, %u\n", count );
-            output( "\tbcs 3f\n" );
-            output( "\tstp x29, x30, [sp,#-176]!\n" );
-            output( "\tmov x29, sp\n" );
-            output( "\tstp x27, x28, [sp, #160]\n" );
-            output( "\tstp x25, x26, [sp, #144]\n" );
-            output( "\tstp x23, x24, [sp, #128]\n" );
-            output( "\tstp x21, x22, [sp, #112]\n" );
-            output( "\tstp x19, x20, [sp, #96]\n" );
-            output( "\tstr x8, [sp, #80]\n" );
-            output( "\tstp x6, x7, [sp, #64]\n" );
-            output( "\tstp x4, x5, [sp, #48]\n" );
-            output( "\tstp x2, x3, [sp, #32]\n" );
-            output( "\tstp x0, x1, [sp, #16]\n" );
-            output( "\tbl %s\n", asm_name("NtCurrentTeb") );
-            output( "\tadd x19, x0, #0x2f8\n" );  /* arm64_thread_data()->syscall_frame */
-            output( "\tldp x0, x1, [sp, #16]\n" );
-            output( "\tldp x2, x3, [sp, #32]\n" );
-            output( "\tldp x4, x5, [sp, #48]\n" );
-            output( "\tldp x6, x7, [sp, #64]\n" );
-            output( "\tldr x8, [sp, #80]\n" );
-            output( "\tldr x20, [x19]\n" );  /* prev frame */
-            output( "\tstr x20, [sp, #88]\n" );
-            output( "\tstr x29, [x19]\n" );  /* syscall frame */
-            output( "\tadrp x16, .Lsyscall_args\n" );
-            output( "\tadd x16, x16, #:lo12:.Lsyscall_args\n" );
-            output( "\tldrb w9, [x16, x8]\n" );
-            output( "\tsubs x9, x9, #64\n" );
-            output( "\tbls 2f\n" );
-            output( "\tadd x11, x29, #192\n" );
-            output( "\tsub sp, sp, x9\n" );
-            output( "\ttbz x9, #3, 1f\n" );
-            output( "\tsub SP, SP, #8\n" );
-            output( "1:\tsub x9, x9, #8\n" );
-            output( "\tldr x10, [x11, x9]\n" );
-            output( "\tstr x10, [sp, x9]\n" );
-            output( "\tcbnz x9, 1b\n" );
-            output( "2:\tadrp x16, .Lsyscall_table\n" );
-            output( "\tadd x16, x16, #:lo12:.Lsyscall_table\n" );
-            output( "\tldr x16, [x16, x8, lsl 3]\n" );
-            output( "\tblr x16\n" );
-            output( "\tmov sp, x29\n" );
-            output( "\tstr x20, [x19]\n" );  /* prev frame */
-            output( "\tldp x19, x20, [sp, #96]\n" );
-            output( "\tldp x21, x22, [sp, #112]\n" );
-            output( "\tldp x23, x24, [sp, #128]\n" );
-            output( "\tldp x25, x26, [sp, #144]\n" );
-            output( "\tldp x27, x28, [sp, #160]\n" );
-            output( "\tldp x29, x30, [sp], #176\n" );
-            output( "\tret\n" );
-            output( "3:\tmov x0, #0x%x\n", invalid_param & 0xffff0000 );
-            output( "\tmovk x0, #0x%x\n", invalid_param & 0x0000ffff );
-            output( "\tret\n" );
-            break;
-        default:
-            assert(0);
-        }
-        output_cfi( ".cfi_endproc" );
-        output_function_size( "__wine_syscall_dispatcher" );
-
-        output( "\t.data\n" );
-        output( "\t.align %d\n", get_alignment( get_ptr_size() ) );
-        output( ".Lsyscall_table:\n" );
-        for (i = 0; i < count; i++)
-            output( "\t%s %s\n", get_asm_ptr_keyword(), asm_name( get_link_name( syscalls[i] )));
-        output( ".Lsyscall_args:\n" );
-        for (i = 0; i < count; i++)
-            output( "\t.byte %u\n", get_args_size( syscalls[i] ));
-        return;
-    }
-
-    for (i = 0; i < count; i++)
-    {
-        ORDDEF *odp = syscalls[i];
-        const char *name = get_link_name(odp);
-        output( "\t.align %d\n", get_alignment(16) );
-        output( "\t%s\n", func_declaration(name) );
-        output( "%s\n", asm_globl(name) );
-        output_cfi( ".cfi_startproc" );
-        switch (target_cpu)
-        {
-        case CPU_x86:
-            if (UsePIC)
-            {
-                output( "\tcall %s\n", asm_name("__wine_spec_get_pc_thunk_eax") );
-                output( "1:\tmovl %s-1b(%%eax),%%edx\n", asm_name("__wine_syscall_dispatcher") );
-                output( "\tmovl $%u,%%eax\n", i );
-                needs_get_pc_thunk = 1;
-            }
-            else
-            {
-                output( "\tmovl $%u,%%eax\n", i );
-                output( "\tmovl $%s,%%edx\n", asm_name("__wine_syscall") );
-            }
-            output( "\tcall *%%edx\n" );
-            output( "\tret $%u\n", get_args_size( odp ));
-            break;
-        case CPU_x86_64:
-            /* Chromium depends on syscall thunks having the same form as on
-             * Windows. For 64-bit systems the only viable form we can emulate is
-             * having an int $0x2e fallback. Since actually using an interrupt is
-             * expensive, and since for some reason Chromium doesn't actually
-             * validate that instruction, we can just put a jmp there instead. */
-            output( "\t.byte 0x4c,0x8b,0xd1\n" ); /* movq %rcx,%r10 */
-            output( "\t.byte 0xb8\n" );           /* movl $i,%eax */
-            output( "\t.long %u\n", i );
-            output( "\t.byte 0xf6,0x04,0x25,0x08,0x03,0xfe,0x7f,0x01\n" ); /* testb $1,0x7ffe0308 */
-            output( "\t.byte 0x75,0x03\n" );      /* jne 1f */
-            output( "\t.byte 0x0f,0x05\n" );      /* syscall */
-            output( "\t.byte 0xc3\n" );           /* ret */
-            output( "\tjmp 1f\n" );
-            output( "\t.byte 0xc3\n" );           /* ret */
-            if (target_platform == PLATFORM_WINDOWS)
-            {
-                output( "1:\t.byte 0xff,0x14,0x25\n" ); /* 2: callq *(__wine_syscall_dispatcher) */
-                output( "\t.long __wine_syscall_dispatcher\n" );
-            }
-            else
-            {
-                output( "\tnop\n" );
-                output( "1:\tcallq *%s(%%rip)\n", asm_name("__wine_syscall_dispatcher") );
-            }
-            output( "\tret\n" );
-            break;
-        case CPU_ARM:
-            output( "\tpush {r4,lr}\n" );
-            output( "\tldr r4, 3f\n");
-            output( "\tldr ip, 2f\n");
-            output( "\tadd ip, pc\n");
-            output( "\tldr ip, [ip]\n");
-            output( "1:\tblx ip\n");
-            output( "\tpop {r4,pc}\n" );
-            output( "2:\t.long %s-1b\n", asm_name("__wine_syscall_dispatcher") );
-            output( "3:\t.long %u\n", i );
-            break;
-        case CPU_ARM64:
-            output( "\tstp x29, x30, [sp,#-16]!\n" );
-            output( "\tmov x8, #%u\n", i );
-            output( "\tadrp x16, %s\n", asm_name("__wine_syscall_dispatcher") );
-            output( "\tldr x16, [x16, #:lo12:%s]\n", asm_name("__wine_syscall_dispatcher") );
-            output( "\tblr x16\n");
-            output( "\tldp x29, x30, [sp], #16\n" );
-            output( "\tret\n" );
-            break;
-        default:
-            assert(0);
-        }
-        output_cfi( ".cfi_endproc" );
-        output_function_size( name );
-    }
-
-    if (target_cpu == CPU_x86 && !UsePIC)
-    {
-        output( "\t.align %d\n", get_alignment(16) );
-        output( "\t%s\n", func_declaration("__wine_syscall") );
-        output( "%s:\n", asm_name("__wine_syscall") );
-        output( "\tjmp *(%s)\n", asm_name("__wine_syscall_dispatcher") );
-        output_function_size( "__wine_syscall" );
-    }
-    output( "\t.data\n" );
-    output( "\t.align %d\n", get_alignment( get_ptr_size() ) );
-    output( "%s\n", asm_globl("__wine_syscall_dispatcher") );
-    output( "\t%s 0\n", get_asm_ptr_keyword() );
-}
-
-
 /* output the import and delayed import tables of a Win32 module */
 void output_imports( DLLSPEC *spec )
 {
diff --git a/tools/winebuild/parser.c b/tools/winebuild/parser.c
index 54fffd8a1b..f44eb9c26d 100644
--- a/tools/winebuild/parser.c
+++ b/tools/winebuild/parser.c
@@ -70,7 +70,6 @@ static const char * const FlagNames[] =
     "ordinal",     /* FLAG_ORDINAL */
     "thiscall",    /* FLAG_THISCALL */
     "fastcall",    /* FLAG_FASTCALL */
-    "syscall",     /* FLAG_SYSCALL */
     "import",      /* FLAG_IMPORT */
     NULL
 };
@@ -321,14 +320,6 @@ static int parse_spec_arguments( ORDDEF *odp, DLLSPEC *spec, int optional )
             return 0;
         }
     }
-    if (odp->flags & FLAG_SYSCALL)
-    {
-        if (odp->type != TYPE_STDCALL)
-        {
-            error( "A syscall function must use the stdcall convention\n" );
-            return 0;
-        }
-    }
     return 1;
 }
 
diff --git a/tools/winebuild/spec16.c b/tools/winebuild/spec16.c
index daa9c63a8c..a52c03aaa6 100644
--- a/tools/winebuild/spec16.c
+++ b/tools/winebuild/spec16.c
@@ -495,6 +495,27 @@ static int relay_type_compare( const void *e1, const void *e2 )
 }
 
 
+/*******************************************************************
+ *         sort_func_list
+ *
+ * Sort a list of functions, removing duplicates.
+ */
+static int sort_func_list( ORDDEF **list, int count,
+                           int (*compare)(const void *, const void *) )
+{
+    int i, j;
+
+    if (!count) return 0;
+    qsort( list, count, sizeof(*list), compare );
+
+    for (i = j = 0; i < count; i++)
+    {
+        if (compare( &list[j], &list[i] )) list[++j] = list[i];
+    }
+    return j + 1;
+}
+
+
 /*******************************************************************
  *         output_module16
  *
diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
index c85249b2a9..5f74d2f29b 100644
--- a/tools/winebuild/spec32.c
+++ b/tools/winebuild/spec32.c
@@ -96,13 +96,6 @@ static int has_relays( DLLSPEC *spec )
     return 0;
 }
 
-static int get_exports_count( DLLSPEC *spec )
-{
-    if (unix_lib) return 0;
-    if (spec->base > spec->limit) return 0;
-    return spec->limit - spec->base + 1;
-}
-
 static int cmp_func_args( const void *p1, const void *p2 )
 {
     const ORDDEF *odp1 = *(const ORDDEF **)p1;
@@ -391,7 +384,7 @@ void output_exports( DLLSPEC *spec )
     int i, fwd_size = 0;
     int needs_imports = 0;
     int needs_relay = has_relays( spec );
-    int nr_exports = get_exports_count( spec );
+    int nr_exports = spec->base <= spec->limit ? spec->limit - spec->base + 1 : 0;
     const char *func_ptr = (target_platform == PLATFORM_WINDOWS) ? ".rva" : get_asm_ptr_keyword();
     const char *name;
 
@@ -711,7 +704,7 @@ void output_module( DLLSPEC *spec )
     output( "\t.long 0\n" );              /* LoaderFlags */
     output( "\t.long 16\n" );             /* NumberOfRvaAndSizes */
 
-    if (get_exports_count( spec ))
+    if (spec->base <= spec->limit)
         data_dirs[0] = ".L__wine_spec_exports";   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] */
     if (has_imports())
         data_dirs[1] = ".L__wine_spec_imports";   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT] */
@@ -739,7 +732,6 @@ void output_spec32_file( DLLSPEC *spec )
     output_stubs( spec );
     output_exports( spec );
     output_imports( spec );
-    output_syscalls( spec );
     if (needs_get_pc_thunk) output_get_pc_thunk();
     output_resources( spec );
     output_gnu_stack_note();
diff --git a/tools/winebuild/utils.c b/tools/winebuild/utils.c
index 07ef2ed298..2a1fc96092 100644
--- a/tools/winebuild/utils.c
+++ b/tools/winebuild/utils.c
@@ -960,22 +960,6 @@ const char *get_link_name( const ORDDEF *odp )
     return ret;
 }
 
-/*******************************************************************
- *         sort_func_list
- *
- * Sort a list of functions, removing duplicates.
- */
-int sort_func_list( ORDDEF **list, int count, int (*compare)(const void *, const void *) )
-{
-    int i, j;
-
-    if (!count) return 0;
-    qsort( list, count, sizeof(*list), compare );
-    for (i = j = 0; i < count; i++) if (compare( &list[j], &list[i] )) list[++j] = list[i];
-    return j + 1;
-}
-
-
 /* parse a cpu name and return the corresponding value */
 int get_cpu_from_name( const char *name )
 {
diff --git a/tools/winebuild/winebuild.man.in b/tools/winebuild/winebuild.man.in
index c1de885dac..109f3824f1 100644
--- a/tools/winebuild/winebuild.man.in
+++ b/tools/winebuild/winebuild.man.in
@@ -338,12 +338,6 @@ The function uses the
 calling convention (first two parameters in %ecx/%edx registers on
 i386).
 .TP
-.B -syscall
-The function is an NT system call. A system call thunk will be
-generated, and the actual function will be called by the
-\fI__wine_syscall_dispatcher\fR function that will be generated on the
-Unix library side.
-.TP
 .B -import
 The function is imported from another module. This can be used instead
 of a
